(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

This AB provides a list for the administration of the movement-locks. 
Instanced in ABControl.

Actions modifying the lock list(aAdd, aRemove) must only be executed from EV_Task_3 so they can not interrupt each other.
Also this code modifying the list can takes a long time (e.g. handling evLockUnlockGroup)
and might be interrupted by a new task cycle where ABControl.paMoveControl executed in TaskInject
calls ABLockList.aCheck() and might access half added locklist entries.
Because of this the bUsed flag needs to be set last when all other data is already set.
*)

IMPORT_OVER_LISTFILE
 SET_ALARM
, ASSERT
, GET_ALARM_NAME
, cLockListSize
, cMoveAll
, tyLockList
, tevAlarmConfirm
, tsDeviceId
, tsTraceLevel
, FBDebugTrace
, tMoveIdent
, tsLockEntry
, tsAlarm
, tevAlarmConfirmData

END_IMPORT

ALGORITHM_BLOCK ABLockList #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_DeviceId : tsDeviceId;
 sv_TraceLevel : tsTraceLevel;
END_VAR

SYSTEM_OBJECT
 erLockListSizeExeeded : ALARM;
 EV_Task_3 : TASK;
 evAlarmConfirm : tevAlarmConfirm;
 erComponentLocked : ALARM;
 erAssert : ALARM;
END_OBJECT

VAR_EXTERNAL
 g_LockList : tyLockList;
END_VAR

VAR
 fbDebugTrace : FBDebugTrace;
END_VAR

ALGORITHM aSetAlarm


VAR_INPUT
 i : DINT;
 MoveId : tMoveIdent;
END_VAR

VAR
 b : BOOL;
 SubID4 : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT g_LockList.lockList[i].bAlarmSet THEN
   //alarm not already set
   b := ASSERT(g_LockList.lockList[i].entry.Alarm.AlarmId <> EMPTY, erAssert);
      
   //set alarm from entry in list
   IF g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked THEN
      //display the requested MoveId if default alarm is used
      SubID4 := MoveId;
   ELSE
      SubID4 := g_LockList.lockList[i].entry.Alarm.SubId[4];
   END_IF;
   
   IF sv_TraceLevel.bLockUnlock THEN
      fbDebugTrace(CONCAT('ABLockList-aSetAlarm setting ',
                           GET_ALARM_NAME(g_LockList.lockList[i].entry.Alarm.AlarmId), ' ',
                           DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[1]), ' ',
                           DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[2]), ' ',
                           DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[3]), ' ',
                           DINT_TO_STRING(SubID4)));
   END_IF;
   
   SET_ALARM(Name   := g_LockList.lockList[i].entry.Alarm.AlarmId,
               SubID1 := g_LockList.lockList[i].entry.Alarm.SubId[1],
               SubID2 := g_LockList.lockList[i].entry.Alarm.SubId[2],
               SubID3 := g_LockList.lockList[i].entry.Alarm.SubId[3],
               SubID4 := SubID4,
               Param1 := g_LockList.lockList[i].entry.Alarm.Param1,
               Param2 := g_LockList.lockList[i].entry.Alarm.Param2);
   g_LockList.lockList[i].bAlarmSet := TRUE;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
If a Movement is locked, a entry is added to the locklist by this algo.
If the parameter Entry.Alarm is empty, a standard alarm  is added (eg. "Mold1 locked by Ejector1).
*)

ALGORITHM aAdd


VAR_INPUT
 Entry : tsLockEntry (* Data of the movement which is locked *);
 bDisable : BOOL;
 bSetAlarmImmediately : BOOL;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 Alarm : tsAlarm;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Add lock-entry to the locklist
IF g_LockList.iElementsUsed >= cLockListSize THEN
   //cLockListSize exeeded
   SET_ALARM(Name := erLockListSizeExeeded,
             SubID1 := cLockListSize);
   RETURN;
END_IF;

IF Entry.Alarm.AlarmId = EMPTY THEN
   //replace empty alarms by erComponentLocked
   Alarm.AlarmId  := erComponentLocked;
   Alarm.SubId[1] := sv_DeviceId.CompId;
   Alarm.SubId[2] := sv_DeviceId.IndexId;
   Alarm.SubId[3] := Entry.DeviceIdSender.CompId;
   Alarm.SubId[4] := 0; //according MoveId is used later in aSetAlarm
   Alarm.Param1   := DINT_TO_STRING(Entry.DeviceIdSender.IndexId);
   Alarm.Param2   := '';
ELSE
   Alarm := Entry.Alarm;
END_IF;

FOR i := 1 TO cLockListSize DO
   
   // searching if the entry already exists
   IF g_LockList.lockList[i].bUsed THEN 
      
      IF g_LockList.lockList[i].entry.DeviceIdSender = Entry.DeviceIdSender AND
         g_LockList.lockList[i].entry.MoveDir = Entry.MoveDir AND
         g_LockList.lockList[i].entry.MoveId =  Entry.MoveId  THEN
         //movement exists in list

         IF Entry.bStopDevice THEN
            // overwrite bStopDevice flag
            g_LockList.lockList[i].entry.bStopDevice := TRUE;
            g_LockList.iListChanged := g_LockList.iListChanged + 1; 
         END_IF;
         
         //copy / update ignore flag
         g_LockList.lockList[i].bDisabled := bDisable;
                  
         //compare each element instead of the whole structure
         //because of CR_0049647 (Strings in a STRUCT are compared with %MemoryCompare instead of %StringCompare)
         IF g_LockList.lockList[i].entry.Alarm.AlarmId = Alarm.AlarmId AND
            g_LockList.lockList[i].entry.Alarm.SubId = Alarm.SubId AND
            g_LockList.lockList[i].entry.Alarm.Param1 = Alarm.Param1 AND
            g_LockList.lockList[i].entry.Alarm.Param2 = Alarm.Param2 THEN
            //sender, movement and alarm is equal -> already added
            EXIT;
         END_IF;
      END_IF;
   ELSE
      //entry not found, adding
      g_LockList.iElementsUsed := g_LockList.iElementsUsed + 1;
      g_LockList.lockList[i].entry := Entry;
      g_LockList.lockList[i].entry.Alarm := Alarm; //replace by correct alarm
      
      //add ignore flag
      g_LockList.lockList[i].bDisabled := bDisable;
      
      //mark the new lock list entry as used
      //this must only happen after the entry was fully filled.
      g_LockList.lockList[i].bUsed := TRUE;

      //set alarm if immediately flag is set and
      //according entry is not disabled
      IF bSetAlarmImmediately AND NOT g_LockList.lockList[i].bDisabled THEN
         aSetAlarm(i, Entry.MoveId);
      END_IF;
      
      // signal if list has changed, to save performance when calling aCheck cyclically
      g_LockList.iListChanged := g_LockList.iListChanged + 1;
      EXIT;
   END_IF;
END_FOR;



;#END_EDIT_BLOCK END_ALGORITHM

(*
Removes the entry of the movement which is unlocked from the list,
and resets the lock-alarm if it is set.
*)

ALGORITHM aRemove


VAR_INPUT
 Entry : tsLockEntry;
END_VAR

VAR_TEMP
 i : DINT;
 ii : DINT;
END_VAR

VAR
 bSameAlarm : BOOL;
 sSubID4 : STRING(10);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Remove lock-entry from the locklist
FOR i := 1 TO cLockListSize DO
   
   // searching for the entry
   IF g_LockList.lockList[i].bUsed THEN 
      
      //compare each element because of CR_0049647 (problem with compare of strings in structures)
      bSameAlarm := (g_LockList.lockList[i].entry.Alarm.AlarmId = Entry.Alarm.AlarmId AND
                     g_LockList.lockList[i].entry.Alarm.SubId = Entry.Alarm.SubId AND
                     g_LockList.lockList[i].entry.Alarm.Param1 = Entry.Alarm.Param1 AND
                     g_LockList.lockList[i].entry.Alarm.Param2 = Entry.Alarm.Param2);
      
      IF g_LockList.lockList[i].entry.DeviceIdSender = Entry.DeviceIdSender AND
         g_LockList.lockList[i].entry.MoveDir = Entry.MoveDir AND
         g_LockList.lockList[i].entry.MoveId =  Entry.MoveId  AND
         (bSameAlarm OR (Entry.Alarm.AlarmId = EMPTY AND g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked)) THEN
         //entry found
         
         IF g_LockList.lockList[i].bAlarmSet THEN
            IF g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked THEN
               sSubID4 := 'ANY';
            ELSE
               sSubID4 := DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[4]); 
            END_IF;
            
            IF sv_TraceLevel.bLockUnlock THEN
               fbDebugTrace(CONCAT('ABLockList-aRemove resetting ',
                                   GET_ALARM_NAME(g_LockList.lockList[i].entry.Alarm.AlarmId), ' ',
                                   DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[1]), ' ',
                                   DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[2]), ' ',
                                   DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[3]), ' ',
                                   sSubID4));
            END_IF;

            IF g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked THEN
               RESET_ALARM(Name := g_LockList.lockList[i].entry.Alarm.AlarmId,
                           SubID1 := g_LockList.lockList[i].entry.Alarm.SubId[1],
                           SubID2 := g_LockList.lockList[i].entry.Alarm.SubId[2],
                           SubID3 := g_LockList.lockList[i].entry.Alarm.SubId[3],
                           SubID4 := ANY);
            ELSE
               RESET_ALARM(Name := g_LockList.lockList[i].entry.Alarm.AlarmId,
                           SubID1 := g_LockList.lockList[i].entry.Alarm.SubId[1],
                           SubID2 := g_LockList.lockList[i].entry.Alarm.SubId[2],
                           SubID3 := g_LockList.lockList[i].entry.Alarm.SubId[3],
                           SubID4 := g_LockList.lockList[i].entry.Alarm.SubId[4]);
            END_IF;
            g_LockList.lockList[i].bAlarmSet := FALSE;
         END_IF;
         
         //reorganize list 
         FOR ii := i+1 TO cLockListSize DO
            IF g_LockList.lockList[ii].bUsed THEN
               // overwrite last element with the actual one
               g_LockList.lockList[ii-1] := g_LockList.lockList[ii];                
            ELSE 
               g_LockList.lockList[ii-1].bUsed := FALSE;
               g_LockList.lockList[ii-1].bAlarmSet := FALSE;
               g_LockList.lockList[ii-1].bDisabled := FALSE;
               EXIT;
            END_IF;   
         END_FOR;
         g_LockList.iElementsUsed := g_LockList.iElementsUsed - 1;

         // signal if list has changed, to save performance when calling aCheck cyclically
         g_LockList.iListChanged := g_LockList.iListChanged + 1;
         EXIT;
      END_IF;
   ELSE
      //entry not found
      EXIT;
   END_IF;
END_FOR;



;#END_EDIT_BLOCK END_ALGORITHM

(*
Checking locklist if a specified movement is locked. If the movement is locked, the alarm is set.
*)

ALGORITHM aCheck


VAR_INPUT
 MoveDir : tMoveIdent;
 MoveId : tMoveIdent;
END_VAR

VAR_OUTPUT
 bLocked : BOOL;
 bAbort : BOOL;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 MoveDirOld : tMoveIdent;
 MoveIdOld : tMoveIdent;
 bFound : BOOL;
 iListChangeCntOld : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Check if lock-entry exists, set alarm

IF   (g_LockList.iListChanged <> iListChangeCntOld) 
    OR (MoveDir <> MoveDirOld) 
    OR (MoveId <> MoveIdOld) THEN
   

   iListChangeCntOld := g_LockList.iListChanged;
   // remember the parameters to be able to notice a change, to save performance (cyclic call of aCheck)
   MoveDirOld := MoveDir;
   MoveIdOld:= MoveId; 
   bFound := FALSE;
   FOR i := 1 TO cLockListSize DO
      // searching for the entry
      IF g_LockList.lockList[i].bUsed THEN 
         
         IF (g_LockList.lockList[i].entry.MoveDir = MoveDir OR g_LockList.lockList[i].entry.MoveDir = cMoveAll) AND
            (g_LockList.lockList[i].entry.MoveId =  MoveId  OR g_LockList.lockList[i].entry.MoveId =  cMoveAll) AND
            NOT g_LockList.lockList[i].bDisabled THEN
             //entry found and disabled flag not set
            
            bFound := TRUE;
            bLocked := TRUE;            
            bAbort := g_LockList.lockList[i].entry.bStopDevice; //TRUE: active movement will be completely stopped
                                                       //FALSE: movement will be set to resume-state and reactivated after unlock
            aSetAlarm(i, MoveId);            
         END_IF;
      ELSE
         EXIT;
      END_IF;
   END_FOR;
END_IF;

IF NOT bFound THEN
   bLocked := FALSE;
   bAbort := FALSE;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
This algo reacts on the alarmconfirm-button and resets every active lock-alarm.
*)

EVENT_ALGORITHM evaAlarmConfirm ON EV_Task_3 WITH evAlarmConfirm


VAR_INPUT
 evAlarmConfirmData : tevAlarmConfirmData;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 sSubID4 : STRING(10);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
//reset every active alarm if confirm-button is pressed
FOR i := 1 TO g_LockList.iElementsUsed DO
    IF g_LockList.lockList[i].bAlarmSet THEN
        IF g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked THEN
           sSubID4 := 'ANY';
        ELSE
           sSubID4 := DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[4]); 
        END_IF;
       
        IF sv_TraceLevel.bLockUnlock THEN
            fbDebugTrace(CONCAT('ABLockList-evaAlarmConfirm resetting ',
                                GET_ALARM_NAME(g_LockList.lockList[i].entry.Alarm.AlarmId), ' ',
                                DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[1]), ' ',
                                DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[2]), ' ',
                                DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[3]), ' ',
                                sSubID4));
        END_IF;
        
        IF g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked THEN
           RESET_ALARM(Name := g_LockList.lockList[i].entry.Alarm.AlarmId,
                       SubID1 := g_LockList.lockList[i].entry.Alarm.SubId[1],
                       SubID2 := g_LockList.lockList[i].entry.Alarm.SubId[2],
                       SubID3 := g_LockList.lockList[i].entry.Alarm.SubId[3],
                       SubID4 := ANY);
        ELSE
           RESET_ALARM(Name := g_LockList.lockList[i].entry.Alarm.AlarmId,
                       SubID1 := g_LockList.lockList[i].entry.Alarm.SubId[1],
                       SubID2 := g_LockList.lockList[i].entry.Alarm.SubId[2],
                       SubID3 := g_LockList.lockList[i].entry.Alarm.SubId[3],
                       SubID4 := g_LockList.lockList[i].entry.Alarm.SubId[4]);
        END_IF;
        g_LockList.lockList[i].bAlarmSet := FALSE;
        g_LockList.iListChanged := g_LockList.iListChanged + 1;
    END_IF;
END_FOR;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aUpdateLockDisable


VAR_INPUT
 Entry : tsLockEntry;
 bDisable : BOOL;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 bSameAlarm : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//update ignore - flag
FOR i := 1 TO cLockListSize DO
   
   // searching for the entry
   IF g_LockList.lockList[i].bUsed THEN 
      
      //compare each element because of CR_0049647 (problem with compare of strings in structures)
      bSameAlarm := (g_LockList.lockList[i].entry.Alarm.AlarmId = Entry.Alarm.AlarmId AND
                     g_LockList.lockList[i].entry.Alarm.SubId = Entry.Alarm.SubId AND
                     g_LockList.lockList[i].entry.Alarm.Param1 = Entry.Alarm.Param1 AND
                     g_LockList.lockList[i].entry.Alarm.Param2 = Entry.Alarm.Param2);
      
      IF g_LockList.lockList[i].entry.DeviceIdSender = Entry.DeviceIdSender AND
         g_LockList.lockList[i].entry.MoveDir = Entry.MoveDir AND
         g_LockList.lockList[i].entry.MoveId =  Entry.MoveId  AND
         (bSameAlarm OR (Entry.Alarm.AlarmId = EMPTY AND g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked)) THEN
         
         //entry found -> update ignore flag
         g_LockList.lockList[i].bDisabled := bDisable;
         
         // signal if list has changed, to save performance when calling aCheck cyclically
         g_LockList.iListChanged := g_LockList.iListChanged + 1;
         EXIT;
      END_IF;
   ELSE
      //entry not found
      EXIT;
   END_IF;
END_FOR;


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 97 @Pou 25 
@@@BEG_Comment@@@
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

This AB provides a list for the administration of the movement-locks. 
Instanced in ABControl.

Actions modifying the lock list(aAdd, aRemove) must only be executed from EV_Task_3 so they can not interrupt each other.
Also this code modifying the list can takes a long time (e.g. handling evLockUnlockGroup)
and might be interrupted by a new task cycle where ABControl.paMoveControl executed in TaskInject
calls ABLockList.aCheck() and might access half added locklist entries.
Because of this the bUsed flag needs to be set last when all other data is already set.
@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
3 
@Var @RT(9)SET_ALARM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)ASSERT @RT(0) @T @T @DERIVED 0 @F @RT(8)FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)GET_ALARM_NAME @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
2 
@Var @RT(13)cLockListSize @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)80 @RT(20)size of the locklist 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveAll @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(13)cMaxMoveIdent @RT(32)all movements (for evLockUnlock) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(10)ABLockList @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
9 
@Var @RT(10)g_LockList @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tyLockList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(21)erLockListSizeExeeded @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)EV_Task_3 @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(14)evAlarmConfirm @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(15)tevAlarmConfirm @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(17)erComponentLocked @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(8)erAssert @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(11)sv_DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_TraceLevel @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsTraceLevel @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)fbDebugTrace @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBDebugTrace @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

6 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(9)aSetAlarm @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
4 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)SubID4 @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)MoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aAdd @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(5)Entry @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tsLockEntry @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(36)Data of the movement which is locked @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(5)Alarm @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(7)tsAlarm @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)bDisable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)bSetAlarmImmediately @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(7)aRemove @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(5)Entry @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tsLockEntry @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(2)ii @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(10)bSameAlarm @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)sSubID4 @RT(0) @T @F @DT @RT(10)STRING(10) @RT(0) @T @T @STRING 0 @F @RT(2)10 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(6)aCheck @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
9 
@Var @RT(7)MoveDir @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)MoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)bLocked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(6)bAbort @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(10)MoveDirOld @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)MoveIdOld @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)bFound @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)iListChangeCntOld @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(15)evaAlarmConfirm @STRUCTURED_TEXT 
@RT(0) @RT(14)evAlarmConfirm @RT(9)EV_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(18)evAlarmConfirmData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tevAlarmConfirmData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(7)sSubID4 @RT(0) @T @F @DT @RT(10)STRING(10) @RT(0) @T @T @STRING 0 @F @RT(2)10 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(18)aUpdateLockDisable @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
4 
@Var @RT(5)Entry @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tsLockEntry @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)bDisable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(10)bSameAlarm @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(36)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT g_LockList.lockList[i].bAlarmSet THEN
   //alarm not already set
   b := ASSERT(g_LockList.lockList[i].entry.Alarm.AlarmId <> EMPTY, erAssert);
      
   //set alarm from entry in list
   IF g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked THEN
      //display the requested MoveId if default alarm is used
      SubID4 := MoveId;
   ELSE
      SubID4 := g_LockList.lockList[i].entry.Alarm.SubId[4];
   END_IF;
   
   IF sv_TraceLevel.bLockUnlock THEN
      fbDebugTrace(CONCAT('ABLockList-aSetAlarm setting ',
                           GET_ALARM_NAME(g_LockList.lockList[i].entry.Alarm.AlarmId), ' ',
                           DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[1]), ' ',
                           DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[2]), ' ',
                           DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[3]), ' ',
                           DINT_TO_STRING(SubID4)));
   END_IF;
   
   SET_ALARM(Name   := g_LockList.lockList[i].entry.Alarm.AlarmId,
               SubID1 := g_LockList.lockList[i].entry.Alarm.SubId[1],
               SubID2 := g_LockList.lockList[i].entry.Alarm.SubId[2],
               SubID3 := g_LockList.lockList[i].entry.Alarm.SubId[3],
               SubID4 := SubID4,
               Param1 := g_LockList.lockList[i].entry.Alarm.Param1,
               Param2 := g_LockList.lockList[i].entry.Alarm.Param2);
   g_LockList.lockList[i].bAlarmSet := TRUE;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(81)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Add lock-entry to the locklist
IF g_LockList.iElementsUsed >= cLockListSize THEN
   //cLockListSize exeeded
   SET_ALARM(Name := erLockListSizeExeeded,
             SubID1 := cLockListSize);
   RETURN;
END_IF;

IF Entry.Alarm.AlarmId = EMPTY THEN
   //replace empty alarms by erComponentLocked
   Alarm.AlarmId  := erComponentLocked;
   Alarm.SubId[1] := sv_DeviceId.CompId;
   Alarm.SubId[2] := sv_DeviceId.IndexId;
   Alarm.SubId[3] := Entry.DeviceIdSender.CompId;
   Alarm.SubId[4] := 0; //according MoveId is used later in aSetAlarm
   Alarm.Param1   := DINT_TO_STRING(Entry.DeviceIdSender.IndexId);
   Alarm.Param2   := '';
ELSE
   Alarm := Entry.Alarm;
END_IF;

FOR i := 1 TO cLockListSize DO
   
   // searching if the entry already exists
   IF g_LockList.lockList[i].bUsed THEN 
      
      IF g_LockList.lockList[i].entry.DeviceIdSender = Entry.DeviceIdSender AND
         g_LockList.lockList[i].entry.MoveDir = Entry.MoveDir AND
         g_LockList.lockList[i].entry.MoveId =  Entry.MoveId  THEN
         //movement exists in list

         IF Entry.bStopDevice THEN
            // overwrite bStopDevice flag
            g_LockList.lockList[i].entry.bStopDevice := TRUE;
            g_LockList.iListChanged := g_LockList.iListChanged + 1; 
         END_IF;
         
         //copy / update ignore flag
         g_LockList.lockList[i].bDisabled := bDisable;
                  
         //compare each element instead of the whole structure
         //because of CR_0049647 (Strings in a STRUCT are compared with %MemoryCompare instead of %StringCompare)
         IF g_LockList.lockList[i].entry.Alarm.AlarmId = Alarm.AlarmId AND
            g_LockList.lockList[i].entry.Alarm.SubId = Alarm.SubId AND
            g_LockList.lockList[i].entry.Alarm.Param1 = Alarm.Param1 AND
            g_LockList.lockList[i].entry.Alarm.Param2 = Alarm.Param2 THEN
            //sender, movement and alarm is equal -> already added
            EXIT;
         END_IF;
      END_IF;
   ELSE
      //entry not found, adding
      g_LockList.iElementsUsed := g_LockList.iElementsUsed + 1;
      g_LockList.lockList[i].entry := Entry;
      g_LockList.lockList[i].entry.Alarm := Alarm; //replace by correct alarm
      
      //add ignore flag
      g_LockList.lockList[i].bDisabled := bDisable;
      
      //mark the new lock list entry as used
      //this must only happen after the entry was fully filled.
      g_LockList.lockList[i].bUsed := TRUE;

      //set alarm if immediately flag is set and
      //according entry is not disabled
      IF bSetAlarmImmediately AND NOT g_LockList.lockList[i].bDisabled THEN
         aSetAlarm(i, Entry.MoveId);
      END_IF;
      
      // signal if list has changed, to save performance when calling aCheck cyclically
      g_LockList.iListChanged := g_LockList.iListChanged + 1;
      EXIT;
   END_IF;
END_FOR;


@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
If a Movement is locked, a entry is added to the locklist by this algo.
If the parameter Entry.Alarm is empty, a standard alarm  is added (eg. "Mold1 locked by Ejector1).
@@@END_Comment@@@ 

@BEG_Body 
@TL(80)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Remove lock-entry from the locklist
FOR i := 1 TO cLockListSize DO
   
   // searching for the entry
   IF g_LockList.lockList[i].bUsed THEN 
      
      //compare each element because of CR_0049647 (problem with compare of strings in structures)
      bSameAlarm := (g_LockList.lockList[i].entry.Alarm.AlarmId = Entry.Alarm.AlarmId AND
                     g_LockList.lockList[i].entry.Alarm.SubId = Entry.Alarm.SubId AND
                     g_LockList.lockList[i].entry.Alarm.Param1 = Entry.Alarm.Param1 AND
                     g_LockList.lockList[i].entry.Alarm.Param2 = Entry.Alarm.Param2);
      
      IF g_LockList.lockList[i].entry.DeviceIdSender = Entry.DeviceIdSender AND
         g_LockList.lockList[i].entry.MoveDir = Entry.MoveDir AND
         g_LockList.lockList[i].entry.MoveId =  Entry.MoveId  AND
         (bSameAlarm OR (Entry.Alarm.AlarmId = EMPTY AND g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked)) THEN
         //entry found
         
         IF g_LockList.lockList[i].bAlarmSet THEN
            IF g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked THEN
               sSubID4 := 'ANY';
            ELSE
               sSubID4 := DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[4]); 
            END_IF;
            
            IF sv_TraceLevel.bLockUnlock THEN
               fbDebugTrace(CONCAT('ABLockList-aRemove resetting ',
                                   GET_ALARM_NAME(g_LockList.lockList[i].entry.Alarm.AlarmId), ' ',
                                   DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[1]), ' ',
                                   DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[2]), ' ',
                                   DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[3]), ' ',
                                   sSubID4));
            END_IF;

            IF g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked THEN
               RESET_ALARM(Name := g_LockList.lockList[i].entry.Alarm.AlarmId,
                           SubID1 := g_LockList.lockList[i].entry.Alarm.SubId[1],
                           SubID2 := g_LockList.lockList[i].entry.Alarm.SubId[2],
                           SubID3 := g_LockList.lockList[i].entry.Alarm.SubId[3],
                           SubID4 := ANY);
            ELSE
               RESET_ALARM(Name := g_LockList.lockList[i].entry.Alarm.AlarmId,
                           SubID1 := g_LockList.lockList[i].entry.Alarm.SubId[1],
                           SubID2 := g_LockList.lockList[i].entry.Alarm.SubId[2],
                           SubID3 := g_LockList.lockList[i].entry.Alarm.SubId[3],
                           SubID4 := g_LockList.lockList[i].entry.Alarm.SubId[4]);
            END_IF;
            g_LockList.lockList[i].bAlarmSet := FALSE;
         END_IF;
         
         //reorganize list 
         FOR ii := i+1 TO cLockListSize DO
            IF g_LockList.lockList[ii].bUsed THEN
               // overwrite last element with the actual one
               g_LockList.lockList[ii-1] := g_LockList.lockList[ii];                
            ELSE 
               g_LockList.lockList[ii-1].bUsed := FALSE;
               g_LockList.lockList[ii-1].bAlarmSet := FALSE;
               g_LockList.lockList[ii-1].bDisabled := FALSE;
               EXIT;
            END_IF;   
         END_FOR;
         g_LockList.iElementsUsed := g_LockList.iElementsUsed - 1;

         // signal if list has changed, to save performance when calling aCheck cyclically
         g_LockList.iListChanged := g_LockList.iListChanged + 1;
         EXIT;
      END_IF;
   ELSE
      //entry not found
      EXIT;
   END_IF;
END_FOR;


@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
Removes the entry of the movement which is unlocked from the list,
and resets the lock-alarm if it is set.
@@@END_Comment@@@ 

@BEG_Body 
@TL(43)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Check if lock-entry exists, set alarm

IF   (g_LockList.iListChanged <> iListChangeCntOld) 
    OR (MoveDir <> MoveDirOld) 
    OR (MoveId <> MoveIdOld) THEN
   

   iListChangeCntOld := g_LockList.iListChanged;
   // remember the parameters to be able to notice a change, to save performance (cyclic call of aCheck)
   MoveDirOld := MoveDir;
   MoveIdOld:= MoveId; 
   bFound := FALSE;
   FOR i := 1 TO cLockListSize DO
      // searching for the entry
      IF g_LockList.lockList[i].bUsed THEN 
         
         IF (g_LockList.lockList[i].entry.MoveDir = MoveDir OR g_LockList.lockList[i].entry.MoveDir = cMoveAll) AND
            (g_LockList.lockList[i].entry.MoveId =  MoveId  OR g_LockList.lockList[i].entry.MoveId =  cMoveAll) AND
            NOT g_LockList.lockList[i].bDisabled THEN
             //entry found and disabled flag not set
            
            bFound := TRUE;
            bLocked := TRUE;            
            bAbort := g_LockList.lockList[i].entry.bStopDevice; //TRUE: active movement will be completely stopped
                                                       //FALSE: movement will be set to resume-state and reactivated after unlock
            aSetAlarm(i, MoveId);            
         END_IF;
      ELSE
         EXIT;
      END_IF;
   END_FOR;
END_IF;

IF NOT bFound THEN
   bLocked := FALSE;
   bAbort := FALSE;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
Checking locklist if a specified movement is locked. If the movement is locked, the alarm is set.
@@@END_Comment@@@ 

@BEG_Body 
@TL(41)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
//reset every active alarm if confirm-button is pressed
FOR i := 1 TO g_LockList.iElementsUsed DO
    IF g_LockList.lockList[i].bAlarmSet THEN
        IF g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked THEN
           sSubID4 := 'ANY';
        ELSE
           sSubID4 := DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[4]); 
        END_IF;
       
        IF sv_TraceLevel.bLockUnlock THEN
            fbDebugTrace(CONCAT('ABLockList-evaAlarmConfirm resetting ',
                                GET_ALARM_NAME(g_LockList.lockList[i].entry.Alarm.AlarmId), ' ',
                                DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[1]), ' ',
                                DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[2]), ' ',
                                DINT_TO_STRING(g_LockList.lockList[i].entry.Alarm.SubId[3]), ' ',
                                sSubID4));
        END_IF;
        
        IF g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked THEN
           RESET_ALARM(Name := g_LockList.lockList[i].entry.Alarm.AlarmId,
                       SubID1 := g_LockList.lockList[i].entry.Alarm.SubId[1],
                       SubID2 := g_LockList.lockList[i].entry.Alarm.SubId[2],
                       SubID3 := g_LockList.lockList[i].entry.Alarm.SubId[3],
                       SubID4 := ANY);
        ELSE
           RESET_ALARM(Name := g_LockList.lockList[i].entry.Alarm.AlarmId,
                       SubID1 := g_LockList.lockList[i].entry.Alarm.SubId[1],
                       SubID2 := g_LockList.lockList[i].entry.Alarm.SubId[2],
                       SubID3 := g_LockList.lockList[i].entry.Alarm.SubId[3],
                       SubID4 := g_LockList.lockList[i].entry.Alarm.SubId[4]);
        END_IF;
        g_LockList.lockList[i].bAlarmSet := FALSE;
        g_LockList.iListChanged := g_LockList.iListChanged + 1;
    END_IF;
END_FOR;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
This algo reacts on the alarmconfirm-button and resets every active lock-alarm.
@@@END_Comment@@@ 

@BEG_Body 
@TL(35)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//update ignore - flag
FOR i := 1 TO cLockListSize DO
   
   // searching for the entry
   IF g_LockList.lockList[i].bUsed THEN 
      
      //compare each element because of CR_0049647 (problem with compare of strings in structures)
      bSameAlarm := (g_LockList.lockList[i].entry.Alarm.AlarmId = Entry.Alarm.AlarmId AND
                     g_LockList.lockList[i].entry.Alarm.SubId = Entry.Alarm.SubId AND
                     g_LockList.lockList[i].entry.Alarm.Param1 = Entry.Alarm.Param1 AND
                     g_LockList.lockList[i].entry.Alarm.Param2 = Entry.Alarm.Param2);
      
      IF g_LockList.lockList[i].entry.DeviceIdSender = Entry.DeviceIdSender AND
         g_LockList.lockList[i].entry.MoveDir = Entry.MoveDir AND
         g_LockList.lockList[i].entry.MoveId =  Entry.MoveId  AND
         (bSameAlarm OR (Entry.Alarm.AlarmId = EMPTY AND g_LockList.lockList[i].entry.Alarm.AlarmId = erComponentLocked)) THEN
         
         //entry found -> update ignore flag
         g_LockList.lockList[i].bDisabled := bDisable;
         
         // signal if list has changed, to save performance when calling aCheck cyclically
         g_LockList.iListChanged := g_LockList.iListChanged + 1;
         EXIT;
      END_IF;
   ELSE
      //entry not found
      EXIT;
   END_IF;
END_FOR;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
