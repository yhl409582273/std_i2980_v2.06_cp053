(*
/*-------------------------------------------------------------------------
 *                   (c) 2015 by KEBA AG
 *                            Linz/AUSTRIA
 *                         All rights reserved
 *--------------------------------------------------------------------------*/
Implementation of limitation of output with maximum speed,limit position and 
maxramp to limit position.

Limitation can be done in both directions (increasing/decreasing position).
*)

IMPORT_OVER_LISTFILE
 KCTRL_YXGen_RampType_Sin
, cInvalidVelocityParams
, cCycleTimeError
, KCTRL_YXGen_RampType_Square
, KCTRL_Ret_OK
, cNoValidParams
, cCyclicCalculationError
, cInvalidMovementLimits
, KCTRL_YXGen_LightA
, KCTRL_YXGenParam
, KCTRL_YXGen_Accelerations

END_IMPORT

ALGORITHM_BLOCK ABEnvelop #DUMMY_EDIT_BLOCK

VAR
 mdCycleTime : TIME;
 mrMaxVelocity : REAL;
 mrMaxVelocityFwd : REAL;
 mrMaxVelocityBwd : REAL;
 mrMaxAcceleration : REAL;
 mrLimitPosition : REAL (* position where the limitation ends(after this 0 is allowed) *);
 mrMaxPosition : REAL (* position where the limitation ends(after this 0 is allowed) *);
 mrMinPosition : REAL (* position where the limitation ends(after this 0 is allowed) *);
 mrStartLimitingPosition : REAL (* position where the limitation starts(before this maximum velocity is allowed) *);
 mrStartLimitingPositionFwd : REAL (* position where the limitation forward starts(before this maximum velocity is allowed) *);
 mrStartLimitingPositionBwd : REAL (* position where the limitation backward starts(before this maximum velocity is allowed) *);
 mbLimitRisingPos : BOOL (* TRUE: limitation happens when position value increases FALSE: limitation happens when position value decreases *);
 mbParamOK : BOOL;
 mbParamDualOK : BOOL;
 abKCTRL_YXGen : KCTRL_YXGen_LightA;
 abKCTRL_YXGenFwd : KCTRL_YXGen_LightA;
 abKCTRL_YXGenBwd : KCTRL_YXGen_LightA;
END_VAR

ALGORITHM aPar


VAR_INPUT
 rMaxVelocity : REAL (* max. velocity anywhere *);
 rMaxAcceleration : REAL (* max. acceleration for ramp down at end *);
 rLimitPosition : REAL (* limit position. after this position 0 velocity is output, before this position the output ramps down *);
 bLimitRisingPos : BOOL (* TRUE: limitation happens when position value increases FALSE: limitation happens when position value decreases *);
 bRampTypeSquare : BOOL (* TRUE: use square ramps FALSE: use sin ramps *);
 dDeadTime : TIME (* dead time *);
 dCycleTime : TIME (* cycle time of the task calling aRun *);
END_VAR

VAR_OUTPUT
 bError : BOOL (* error during param *);
 iErrorInfo : DINT (* additional error info *);
END_VAR

VAR
 YXGenParam : KCTRL_YXGenParam := (Mode:=(RampType:=KCTRL_YXGen_RampType_Sin),ProfilePoints:=(uNoOfPoints:=2));
 YXGenAccelerations : KCTRL_YXGen_Accelerations;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
bError := FALSE;
iErrorInfo := 0;
mbParamOK := FALSE;

mdCycleTime := dCycleTime;
mrMaxVelocity := rMaxVelocity;
mrMaxAcceleration := rMaxAcceleration;
mrLimitPosition := rLimitPosition;
mbLimitRisingPos := bLimitRisingPos;

IF (mrMaxAcceleration <= 0.0) OR (mrMaxVelocity <= 0.0) THEN
    bError := TRUE;
    iErrorInfo := cInvalidVelocityParams;
    RETURN;
ELSIF (mdCycleTime <= T#0s) THEN
    bError := TRUE;
    iErrorInfo := cCycleTimeError;
    RETURN;
END_IF;

IF (mbLimitRisingPos) THEN
   mrStartLimitingPosition := mrLimitPosition - 0.5 * mrMaxVelocity * mrMaxVelocity / mrMaxAcceleration;    
ELSE
   mrStartLimitingPosition := mrLimitPosition + 0.5 * mrMaxVelocity * mrMaxVelocity / mrMaxAcceleration;
END_IF;

IF bRampTypeSquare THEN
   YXGenParam.Mode.RampType := KCTRL_YXGen_RampType_Square;
ELSE
   YXGenParam.Mode.RampType := KCTRL_YXGen_RampType_Sin;
END_IF;
YXGenParam.ProfilePoints.Point[1].rX := mrStartLimitingPosition;
YXGenParam.ProfilePoints.Point[1].rY := mrMaxVelocity;
YXGenParam.ProfilePoints.Point[2].rX := mrLimitPosition;
YXGenParam.ProfilePoints.Point[2].rY := 0.0;

abKCTRL_YXGen.Par(dCycleTime := mdCycleTime,
                  Param := YXGenParam);
abKCTRL_YXGen.ParDeadTime(dDeadTime := dDeadTime);

YXGenAccelerations.rStart := mrMaxAcceleration;
YXGenAccelerations.rStop := mrMaxAcceleration;
YXGenAccelerations.rSoft := mrMaxAcceleration;
abKCTRL_YXGen.ParAccelerations(Accelerations := YXGenAccelerations);

abKCTRL_YXGen.Init(rX0 := mrStartLimitingPosition,
                   rY0 := mrMaxVelocity); 

IF (abKCTRL_YXGen.Par.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGen.ParDeadTime.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGen.ParAccelerations.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGen.Init.initStatus <> KCTRL_Ret_OK) THEN
   bError := TRUE;
   iErrorInfo := cInvalidVelocityParams;
   RETURN;
END_IF;

// parametrization finished with valid parameters
mbParamOK := TRUE;



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aRun


VAR_INPUT
 bStart : BOOL R_EDGE (* start of movement *);
 bStop : BOOL (* stop movement *);
 rActPosition : REAL (* actual position *);
END_VAR

VAR_OUTPUT
 rLimitVelocity : REAL (* maximum output velocity *);
 bError : BOOL (* error during param *);
 iErrorInfo : DINT (* additional error info *);
END_VAR

VAR
 bInit : BOOL (* it is necessary to call abKCTRL_YXGen.Init *);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
IF NOT mbParamOK THEN
   // settings not initialized
   bError := TRUE;
   iErrorInfo := cNoValidParams;
   rLimitVelocity := 0.0;
   RETURN;
END_IF;

IF bStart THEN
   abKCTRL_YXGen.Init(rX0 := mrStartLimitingPosition,
                      rY0 := mrMaxVelocity);
   IF (abKCTRL_YXGen.Init.initStatus <> KCTRL_Ret_OK) THEN
      bError := TRUE;
      iErrorInfo := cInvalidVelocityParams;
      rLimitVelocity := 0.0;
      RETURN;
   END_IF;    
END_IF;

IF ((mbLimitRisingPos AND (rActPosition < mrStartLimitingPosition)) OR
    ((NOT mbLimitRisingPos) AND (rActPosition > mrStartLimitingPosition))) AND
   (NOT bStop) THEN
   // We are before the start of the limitation -> allow full output
   // We do not need to ask the YX generator for this
   rLimitVelocity := mrMaxVelocity;
   bInit := TRUE; 
ELSE
   // We are in the zone where limiting occurs
   IF (bInit) THEN
      abKCTRL_YXGen.Init(rX0 := mrStartLimitingPosition,
                         rY0 := mrMaxVelocity);
      IF (abKCTRL_YXGen.Init.initStatus <> KCTRL_Ret_OK) THEN
            bError := TRUE;
            iErrorInfo := cInvalidVelocityParams;
            rLimitVelocity := 0.0;
            RETURN;
      END_IF;
      bInit := FALSE;
   END_IF;

   abKCTRL_YXGen.Calculate(rX := rActPosition,
                           bSoftStop := bStop);
   IF (abKCTRL_YXGen.Calculate.calcStatus <> KCTRL_Ret_OK) THEN
      bError := TRUE;
      iErrorInfo := cCyclicCalculationError;
      rLimitVelocity := 0.0;
      RETURN;
   END_IF;
   rLimitVelocity := abKCTRL_YXGen.Calculate.rY;
END_IF;

bError := FALSE;
iErrorInfo := 0;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aParDual


VAR_INPUT
 rMaxVelocityFwd : REAL (* max. velocity move increasing position, > 0.0 *);
 rMaxVelocityBwd : REAL (* max. velocity  move decreasing position, > 0.0 *);
 rMaxAcceleration : REAL (* max. acceleration for ramp down at end, > 0.0 *);
 rLimitMinPosition : REAL (* min. position limit, at lower position velocity output bwd is 0 *);
 rLimitMaxPosition : REAL (* max. position limit, at higher position velocity output fwd is 0 *);
 bRampTypeSquare : BOOL (* TRUE: use square ramps FALSE: use sin ramps *);
 dDeadTime : TIME (* dead time *);
 dCycleTime : TIME (* cycle time of the task calling aRun *);
END_VAR

VAR_OUTPUT
 bError : BOOL (* error during param *);
 iErrorInfo : DINT (* additional error info *);
END_VAR

VAR
 YXGenParamFwd : KCTRL_YXGenParam := (Mode:=(RampType:=KCTRL_YXGen_RampType_Sin),ProfilePoints:=(uNoOfPoints:=2));
 YXGenParamBwd : KCTRL_YXGenParam := (Mode:=(RampType:=KCTRL_YXGen_RampType_Sin),ProfilePoints:=(uNoOfPoints:=2));
 YXGenAccelerations : KCTRL_YXGen_Accelerations;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
bError := FALSE;
iErrorInfo := 0;
mbParamDualOK := FALSE;

mdCycleTime := dCycleTime;
mrMaxVelocityFwd := rMaxVelocityFwd;
mrMaxVelocityBwd := rMaxVelocityBwd;
mrMaxAcceleration := rMaxAcceleration;
mrMaxPosition := rLimitMaxPosition;
mrMinPosition := rLimitMinPosition;

IF (mrMaxAcceleration <= 0.0) OR 
   (mrMaxVelocityFwd <= 0.0) OR 
   (mrMaxVelocityBwd <= 0.0) THEN
    bError := TRUE;
    iErrorInfo := cInvalidVelocityParams;
    RETURN;
ELSIF (mdCycleTime <= T#0s) THEN
    bError := TRUE;
    iErrorInfo := cCycleTimeError;
    RETURN;
ELSIF (mrMaxPosition  < mrMinPosition) THEN
    bError := TRUE;
    iErrorInfo := cInvalidMovementLimits;
    RETURN;
END_IF;

mrStartLimitingPositionFwd := mrMaxPosition - 0.5 * mrMaxVelocityFwd * mrMaxVelocityFwd / mrMaxAcceleration;    
mrStartLimitingPositionBwd := mrMinPosition + 0.5 * mrMaxVelocityBwd * mrMaxVelocityBwd / mrMaxAcceleration;

IF bRampTypeSquare THEN
   YXGenParamFwd.Mode.RampType := KCTRL_YXGen_RampType_Square;
   YXGenParamBwd.Mode.RampType := KCTRL_YXGen_RampType_Square;
ELSE
   YXGenParamFwd.Mode.RampType := KCTRL_YXGen_RampType_Sin;
   YXGenParamBwd.Mode.RampType := KCTRL_YXGen_RampType_Sin;
END_IF;
YXGenParamFwd.ProfilePoints.Point[1].rX := mrStartLimitingPositionFwd;
YXGenParamFwd.ProfilePoints.Point[1].rY := mrMaxVelocityFwd;
YXGenParamFwd.ProfilePoints.Point[2].rX := mrMaxPosition;
YXGenParamFwd.ProfilePoints.Point[2].rY := 0.0;

YXGenParamBwd.ProfilePoints.Point[1].rX := mrStartLimitingPositionBwd;
YXGenParamBwd.ProfilePoints.Point[1].rY := mrMaxVelocityBwd;
YXGenParamBwd.ProfilePoints.Point[2].rX := mrMinPosition;
YXGenParamBwd.ProfilePoints.Point[2].rY := 0.0;

abKCTRL_YXGenFwd.Par(dCycleTime := mdCycleTime,
                     Param := YXGenParamFwd);
abKCTRL_YXGenFwd.ParDeadTime(dDeadTime := dDeadTime);

abKCTRL_YXGenBwd.Par(dCycleTime := mdCycleTime,
                     Param := YXGenParamBwd);
abKCTRL_YXGenBwd.ParDeadTime(dDeadTime := dDeadTime);


YXGenAccelerations.rStart := 1.0e6;
YXGenAccelerations.rStop := mrMaxAcceleration;
YXGenAccelerations.rSoft := mrMaxAcceleration;
abKCTRL_YXGenFwd.ParAccelerations(Accelerations := YXGenAccelerations);
abKCTRL_YXGenBwd.ParAccelerations(Accelerations := YXGenAccelerations);

abKCTRL_YXGenFwd.Init(rX0 := mrStartLimitingPositionFwd,
                      rY0 := mrMaxVelocityFwd); 
abKCTRL_YXGenBwd.Init(rX0 := mrStartLimitingPositionBwd,
                      rY0 := mrMaxVelocityBwd); 
IF (abKCTRL_YXGenFwd.Par.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenFwd.ParDeadTime.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenFwd.ParAccelerations.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenFwd.Init.initStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenBwd.Par.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenBwd.ParDeadTime.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenBwd.ParAccelerations.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenBwd.Init.initStatus <> KCTRL_Ret_OK) THEN
   bError := TRUE;
   iErrorInfo := cInvalidVelocityParams;
END_IF;

// parametrization finished with valid parameters
mbParamDualOK := TRUE;



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aRunDual


VAR_INPUT
 bStart : BOOL R_EDGE (* start of movement *);
 bStop : BOOL (* stop movement *);
 rActPosition : REAL (* actual position *);
END_VAR

VAR_OUTPUT
 rLimitVelocityFwd : REAL (* maximum output velocity increasing position, >= 0.0 *);
 rLimitVelocityBwd : REAL (* maximum output velocity decreasing position, >= 0.0 *);
 bError : BOOL (* error during param *);
 iErrorInfo : DINT (* additional error info *);
END_VAR

VAR
 bInitFwd : BOOL (* it is necessary to call abKCTRL_YXGen.Init *);
 bInitBwd : BOOL (* it is necessary to call abKCTRL_YXGen.Init *);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
IF NOT mbParamDualOK THEN
   // settings not initialized
   bError := TRUE;
   iErrorInfo := cNoValidParams;
   rLimitVelocityFwd := 0.0;
   rLimitVelocityBwd := 0.0;
   RETURN;
END_IF;

IF bStart THEN
   abKCTRL_YXGenFwd.Init(rX0 := mrStartLimitingPositionFwd,
                         rY0 := 0.0);
   abKCTRL_YXGenFwd.Calculate(rX := rActPosition);

   abKCTRL_YXGenBwd.Init(rX0 := mrStartLimitingPositionBwd,
                         rY0 := 0.0);
   abKCTRL_YXGenBwd.Calculate(rX := rActPosition);
   
   IF (abKCTRL_YXGenFwd.Init.initStatus <> KCTRL_Ret_OK) OR
      (abKCTRL_YXGenBwd.Init.initStatus <> KCTRL_Ret_OK) OR
      (abKCTRL_YXGenFwd.Calculate.calcStatus <> KCTRL_Ret_OK) OR
      (abKCTRL_YXGenBwd.Calculate.calcStatus <> KCTRL_Ret_OK) THEN
      bError := TRUE;
      iErrorInfo := cInvalidVelocityParams;
      rLimitVelocityFwd := 0.0;
      rLimitVelocityBwd := 0.0;
      RETURN;
   END_IF;    
END_IF;

// calc fwd limit
IF (rActPosition < mrStartLimitingPositionFwd) AND (NOT bStop) THEN
   // we are before the start of the limitation -> allow full output
   // we do not need to ask the YX generator for this
   rLimitVelocityFwd := mrMaxVelocityFwd;
   bInitFwd := TRUE; 
ELSE
   // We are in the zone where limiting occurs
   IF (bInitFwd) THEN
      abKCTRL_YXGenFwd.Init(rX0 := mrStartLimitingPositionFwd,
                            rY0 := mrMaxVelocityFwd);
      IF (abKCTRL_YXGenFwd.Init.initStatus <> KCTRL_Ret_OK) THEN
            bError := TRUE;
            iErrorInfo := cInvalidVelocityParams;
            rLimitVelocityFwd := 0.0;
            rLimitVelocityBwd := 0.0;
            RETURN;
      END_IF;
      bInitFwd := FALSE;
   END_IF;

   abKCTRL_YXGenFwd.Calculate(rX := rActPosition,
                              bSoftStop := bStop);
   IF (abKCTRL_YXGenFwd.Calculate.calcStatus <> KCTRL_Ret_OK) THEN
      bError := TRUE;
      iErrorInfo := cCyclicCalculationError;
      rLimitVelocityFwd := 0.0;
      rLimitVelocityBwd := 0.0;
      RETURN;
   END_IF;
   rLimitVelocityFwd := abKCTRL_YXGenFwd.Calculate.rY;
END_IF;

// calc bwd limit
IF (rActPosition > mrStartLimitingPositionBwd) AND (NOT bStop) THEN
   // we are before the start of the limitation -> allow full output
   // we do not need to ask the YX generator for this
   rLimitVelocityBwd := mrMaxVelocityBwd;
   bInitBwd := TRUE; 
ELSE
   // We are in the zone where limiting occurs
   IF (bInitBwd) THEN
      abKCTRL_YXGenBwd.Init(rX0 := mrStartLimitingPositionBwd,
                         rY0 := mrMaxVelocityBwd);
      IF (abKCTRL_YXGenBwd.Init.initStatus <> KCTRL_Ret_OK) THEN
            bError := TRUE;
            iErrorInfo := cInvalidVelocityParams;
            rLimitVelocityFwd := 0.0;
            rLimitVelocityBwd := 0.0;
            RETURN;
      END_IF;
      bInitBwd := FALSE;
   END_IF;

   abKCTRL_YXGenBwd.Calculate(rX := rActPosition,
                              bSoftStop := bStop);
   IF (abKCTRL_YXGenBwd.Calculate.calcStatus <> KCTRL_Ret_OK) THEN
      bError := TRUE;
      iErrorInfo := cCyclicCalculationError;
      rLimitVelocityFwd := 0.0;
      rLimitVelocityBwd := 0.0;
      RETURN;
   END_IF;
   rLimitVelocityBwd := abKCTRL_YXGenBwd.Calculate.rY;
END_IF;


bError := FALSE;
iErrorInfo := 0;


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 144 @Pou 25 
@@@BEG_Comment@@@
/*-------------------------------------------------------------------------
 *                   (c) 2015 by KEBA AG
 *                            Linz/AUSTRIA
 *                         All rights reserved
 *--------------------------------------------------------------------------*/
Implementation of limitation of output with maximum speed,limit position and 
maxramp to limit position.

Limitation can be done in both directions (increasing/decreasing position).
@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
0 
@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
8 
@Var @RT(24)KCTRL_YXGen_RampType_Sin @RT(0) @T @T @DERIVED 0 @F @RT(20)KCTRL_YXGen_RampType @F 
@T 
@BEG_Attrib 
0 @RT(1)2 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(22)cInvalidVelocityParams @RT(0) @T @F @DT @RT(0) @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)cCycleTimeError @RT(0) @T @F @DT @RT(0) @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(27)KCTRL_YXGen_RampType_Square @RT(0) @T @T @DERIVED 0 @F @RT(20)KCTRL_YXGen_RampType @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)KCTRL_Ret_OK @RT(0) @T @T @DERIVED 0 @F @RT(9)KCTRL_Ret @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)cNoValidParams @RT(0) @T @F @DT @RT(0) @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(23)cCyclicCalculationError @RT(0) @T @F @DT @RT(0) @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(22)cInvalidMovementLimits @RT(0) @T @F @DT @RT(0) @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(9)ABEnvelop @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
17 
@Var @RT(11)mdCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrMaxVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mrMaxVelocityFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mrMaxVelocityBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mrMaxAcceleration @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mrLimitPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(59)position where the limitation ends(after this 0 is allowed) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrMaxPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(59)position where the limitation ends(after this 0 is allowed) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrMinPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(59)position where the limitation ends(after this 0 is allowed) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(23)mrStartLimitingPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(77)position where the limitation starts(before this maximum velocity is allowed) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(26)mrStartLimitingPositionFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(85)position where the limitation forward starts(before this maximum velocity is allowed) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(26)mrStartLimitingPositionBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(86)position where the limitation backward starts(before this maximum velocity is allowed) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mbLimitRisingPos @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(110)TRUE: limitation happens when position value increases FALSE: limitation happens when position value decreases @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)mbParamOK @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mbParamDualOK @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)abKCTRL_YXGen @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)KCTRL_YXGen_LightA @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abKCTRL_YXGenFwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)KCTRL_YXGen_LightA @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abKCTRL_YXGenBwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)KCTRL_YXGen_LightA @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

4 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aPar @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
11 
@Var @RT(12)rMaxVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(22)max. velocity anywhere @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)rMaxAcceleration @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(38)max. acceleration for ramp down at end @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)rLimitPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(100)limit position. after this position 0 velocity is output, before this position the output ramps down @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)bLimitRisingPos @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(110)TRUE: limitation happens when position value increases FALSE: limitation happens when position value decreases @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)bRampTypeSquare @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(43)TRUE: use square ramps FALSE: use sin ramps @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)dDeadTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(9)dead time @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)dCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)cycle time of the task calling aRun @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)error during param @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(21)additional error info @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)YXGenParam @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KCTRL_YXGenParam @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(76)(Mode:=(RampType:=KCTRL_YXGen_RampType_Sin),ProfilePoints:=(uNoOfPoints:=2)) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)YXGenAccelerations @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(25)KCTRL_YXGen_Accelerations @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aRun @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
7 
@Var @RT(6)bStart @RT(0) @T @F @DT @RT(11)BOOL R_EDGE @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(17)start of movement @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(5)bStop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(13)stop movement @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)rActPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(15)actual position @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)rLimitVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(23)maximum output velocity @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)error during param @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(21)additional error info @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(5)bInit @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(42)it is necessary to call abKCTRL_YXGen.Init @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(8)aParDual @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
13 
@Var @RT(15)rMaxVelocityFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(45)max. velocity move increasing position, > 0.0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)rMaxVelocityBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(46)max. velocity  move decreasing position, > 0.0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)rMaxAcceleration @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(45)max. acceleration for ramp down at end, > 0.0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)rLimitMinPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(63)min. position limit, at lower position velocity output bwd is 0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)rLimitMaxPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(64)max. position limit, at higher position velocity output fwd is 0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)bRampTypeSquare @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(43)TRUE: use square ramps FALSE: use sin ramps @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)dDeadTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(9)dead time @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)dCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)cycle time of the task calling aRun @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)error during param @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(21)additional error info @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(13)YXGenParamFwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KCTRL_YXGenParam @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(76)(Mode:=(RampType:=KCTRL_YXGen_RampType_Sin),ProfilePoints:=(uNoOfPoints:=2)) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)YXGenParamBwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KCTRL_YXGenParam @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(76)(Mode:=(RampType:=KCTRL_YXGen_RampType_Sin),ProfilePoints:=(uNoOfPoints:=2)) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)YXGenAccelerations @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(25)KCTRL_YXGen_Accelerations @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(8)aRunDual @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
9 
@Var @RT(6)bStart @RT(0) @T @F @DT @RT(11)BOOL R_EDGE @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(17)start of movement @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(5)bStop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(13)stop movement @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)rActPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(15)actual position @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)rLimitVelocityFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(51)maximum output velocity increasing position, >= 0.0 @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(17)rLimitVelocityBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(51)maximum output velocity decreasing position, >= 0.0 @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)error during param @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(21)additional error info @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(8)bInitFwd @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(42)it is necessary to call abKCTRL_YXGen.Init @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)bInitBwd @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(42)it is necessary to call abKCTRL_YXGen.Init @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(65)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
bError := FALSE;
iErrorInfo := 0;
mbParamOK := FALSE;

mdCycleTime := dCycleTime;
mrMaxVelocity := rMaxVelocity;
mrMaxAcceleration := rMaxAcceleration;
mrLimitPosition := rLimitPosition;
mbLimitRisingPos := bLimitRisingPos;

IF (mrMaxAcceleration <= 0.0) OR (mrMaxVelocity <= 0.0) THEN
    bError := TRUE;
    iErrorInfo := cInvalidVelocityParams;
    RETURN;
ELSIF (mdCycleTime <= T#0s) THEN
    bError := TRUE;
    iErrorInfo := cCycleTimeError;
    RETURN;
END_IF;

IF (mbLimitRisingPos) THEN
   mrStartLimitingPosition := mrLimitPosition - 0.5 * mrMaxVelocity * mrMaxVelocity / mrMaxAcceleration;    
ELSE
   mrStartLimitingPosition := mrLimitPosition + 0.5 * mrMaxVelocity * mrMaxVelocity / mrMaxAcceleration;
END_IF;

IF bRampTypeSquare THEN
   YXGenParam.Mode.RampType := KCTRL_YXGen_RampType_Square;
ELSE
   YXGenParam.Mode.RampType := KCTRL_YXGen_RampType_Sin;
END_IF;
YXGenParam.ProfilePoints.Point[1].rX := mrStartLimitingPosition;
YXGenParam.ProfilePoints.Point[1].rY := mrMaxVelocity;
YXGenParam.ProfilePoints.Point[2].rX := mrLimitPosition;
YXGenParam.ProfilePoints.Point[2].rY := 0.0;

abKCTRL_YXGen.Par(dCycleTime := mdCycleTime,
                  Param := YXGenParam);
abKCTRL_YXGen.ParDeadTime(dDeadTime := dDeadTime);

YXGenAccelerations.rStart := mrMaxAcceleration;
YXGenAccelerations.rStop := mrMaxAcceleration;
YXGenAccelerations.rSoft := mrMaxAcceleration;
abKCTRL_YXGen.ParAccelerations(Accelerations := YXGenAccelerations);

abKCTRL_YXGen.Init(rX0 := mrStartLimitingPosition,
                   rY0 := mrMaxVelocity); 

IF (abKCTRL_YXGen.Par.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGen.ParDeadTime.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGen.ParAccelerations.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGen.Init.initStatus <> KCTRL_Ret_OK) THEN
   bError := TRUE;
   iErrorInfo := cInvalidVelocityParams;
   RETURN;
END_IF;

// parametrization finished with valid parameters
mbParamOK := TRUE;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(58)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
IF NOT mbParamOK THEN
   // settings not initialized
   bError := TRUE;
   iErrorInfo := cNoValidParams;
   rLimitVelocity := 0.0;
   RETURN;
END_IF;

IF bStart THEN
   abKCTRL_YXGen.Init(rX0 := mrStartLimitingPosition,
                      rY0 := mrMaxVelocity);
   IF (abKCTRL_YXGen.Init.initStatus <> KCTRL_Ret_OK) THEN
      bError := TRUE;
      iErrorInfo := cInvalidVelocityParams;
      rLimitVelocity := 0.0;
      RETURN;
   END_IF;    
END_IF;

IF ((mbLimitRisingPos AND (rActPosition < mrStartLimitingPosition)) OR
    ((NOT mbLimitRisingPos) AND (rActPosition > mrStartLimitingPosition))) AND
   (NOT bStop) THEN
   // We are before the start of the limitation -> allow full output
   // We do not need to ask the YX generator for this
   rLimitVelocity := mrMaxVelocity;
   bInit := TRUE; 
ELSE
   // We are in the zone where limiting occurs
   IF (bInit) THEN
      abKCTRL_YXGen.Init(rX0 := mrStartLimitingPosition,
                         rY0 := mrMaxVelocity);
      IF (abKCTRL_YXGen.Init.initStatus <> KCTRL_Ret_OK) THEN
            bError := TRUE;
            iErrorInfo := cInvalidVelocityParams;
            rLimitVelocity := 0.0;
            RETURN;
      END_IF;
      bInit := FALSE;
   END_IF;

   abKCTRL_YXGen.Calculate(rX := rActPosition,
                           bSoftStop := bStop);
   IF (abKCTRL_YXGen.Calculate.calcStatus <> KCTRL_Ret_OK) THEN
      bError := TRUE;
      iErrorInfo := cCyclicCalculationError;
      rLimitVelocity := 0.0;
      RETURN;
   END_IF;
   rLimitVelocity := abKCTRL_YXGen.Calculate.rY;
END_IF;

bError := FALSE;
iErrorInfo := 0;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(86)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
bError := FALSE;
iErrorInfo := 0;
mbParamDualOK := FALSE;

mdCycleTime := dCycleTime;
mrMaxVelocityFwd := rMaxVelocityFwd;
mrMaxVelocityBwd := rMaxVelocityBwd;
mrMaxAcceleration := rMaxAcceleration;
mrMaxPosition := rLimitMaxPosition;
mrMinPosition := rLimitMinPosition;

IF (mrMaxAcceleration <= 0.0) OR 
   (mrMaxVelocityFwd <= 0.0) OR 
   (mrMaxVelocityBwd <= 0.0) THEN
    bError := TRUE;
    iErrorInfo := cInvalidVelocityParams;
    RETURN;
ELSIF (mdCycleTime <= T#0s) THEN
    bError := TRUE;
    iErrorInfo := cCycleTimeError;
    RETURN;
ELSIF (mrMaxPosition  < mrMinPosition) THEN
    bError := TRUE;
    iErrorInfo := cInvalidMovementLimits;
    RETURN;
END_IF;

mrStartLimitingPositionFwd := mrMaxPosition - 0.5 * mrMaxVelocityFwd * mrMaxVelocityFwd / mrMaxAcceleration;    
mrStartLimitingPositionBwd := mrMinPosition + 0.5 * mrMaxVelocityBwd * mrMaxVelocityBwd / mrMaxAcceleration;

IF bRampTypeSquare THEN
   YXGenParamFwd.Mode.RampType := KCTRL_YXGen_RampType_Square;
   YXGenParamBwd.Mode.RampType := KCTRL_YXGen_RampType_Square;
ELSE
   YXGenParamFwd.Mode.RampType := KCTRL_YXGen_RampType_Sin;
   YXGenParamBwd.Mode.RampType := KCTRL_YXGen_RampType_Sin;
END_IF;
YXGenParamFwd.ProfilePoints.Point[1].rX := mrStartLimitingPositionFwd;
YXGenParamFwd.ProfilePoints.Point[1].rY := mrMaxVelocityFwd;
YXGenParamFwd.ProfilePoints.Point[2].rX := mrMaxPosition;
YXGenParamFwd.ProfilePoints.Point[2].rY := 0.0;

YXGenParamBwd.ProfilePoints.Point[1].rX := mrStartLimitingPositionBwd;
YXGenParamBwd.ProfilePoints.Point[1].rY := mrMaxVelocityBwd;
YXGenParamBwd.ProfilePoints.Point[2].rX := mrMinPosition;
YXGenParamBwd.ProfilePoints.Point[2].rY := 0.0;

abKCTRL_YXGenFwd.Par(dCycleTime := mdCycleTime,
                     Param := YXGenParamFwd);
abKCTRL_YXGenFwd.ParDeadTime(dDeadTime := dDeadTime);

abKCTRL_YXGenBwd.Par(dCycleTime := mdCycleTime,
                     Param := YXGenParamBwd);
abKCTRL_YXGenBwd.ParDeadTime(dDeadTime := dDeadTime);


YXGenAccelerations.rStart := 1.0e6;
YXGenAccelerations.rStop := mrMaxAcceleration;
YXGenAccelerations.rSoft := mrMaxAcceleration;
abKCTRL_YXGenFwd.ParAccelerations(Accelerations := YXGenAccelerations);
abKCTRL_YXGenBwd.ParAccelerations(Accelerations := YXGenAccelerations);

abKCTRL_YXGenFwd.Init(rX0 := mrStartLimitingPositionFwd,
                      rY0 := mrMaxVelocityFwd); 
abKCTRL_YXGenBwd.Init(rX0 := mrStartLimitingPositionBwd,
                      rY0 := mrMaxVelocityBwd); 
IF (abKCTRL_YXGenFwd.Par.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenFwd.ParDeadTime.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenFwd.ParAccelerations.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenFwd.Init.initStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenBwd.Par.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenBwd.ParDeadTime.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenBwd.ParAccelerations.parStatus <> KCTRL_Ret_OK) OR
   (abKCTRL_YXGenBwd.Init.initStatus <> KCTRL_Ret_OK) THEN
   bError := TRUE;
   iErrorInfo := cInvalidVelocityParams;
END_IF;

// parametrization finished with valid parameters
mbParamDualOK := TRUE;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(104)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
IF NOT mbParamDualOK THEN
   // settings not initialized
   bError := TRUE;
   iErrorInfo := cNoValidParams;
   rLimitVelocityFwd := 0.0;
   rLimitVelocityBwd := 0.0;
   RETURN;
END_IF;

IF bStart THEN
   abKCTRL_YXGenFwd.Init(rX0 := mrStartLimitingPositionFwd,
                         rY0 := 0.0);
   abKCTRL_YXGenFwd.Calculate(rX := rActPosition);

   abKCTRL_YXGenBwd.Init(rX0 := mrStartLimitingPositionBwd,
                         rY0 := 0.0);
   abKCTRL_YXGenBwd.Calculate(rX := rActPosition);
   
   IF (abKCTRL_YXGenFwd.Init.initStatus <> KCTRL_Ret_OK) OR
      (abKCTRL_YXGenBwd.Init.initStatus <> KCTRL_Ret_OK) OR
      (abKCTRL_YXGenFwd.Calculate.calcStatus <> KCTRL_Ret_OK) OR
      (abKCTRL_YXGenBwd.Calculate.calcStatus <> KCTRL_Ret_OK) THEN
      bError := TRUE;
      iErrorInfo := cInvalidVelocityParams;
      rLimitVelocityFwd := 0.0;
      rLimitVelocityBwd := 0.0;
      RETURN;
   END_IF;    
END_IF;

// calc fwd limit
IF (rActPosition < mrStartLimitingPositionFwd) AND (NOT bStop) THEN
   // we are before the start of the limitation -> allow full output
   // we do not need to ask the YX generator for this
   rLimitVelocityFwd := mrMaxVelocityFwd;
   bInitFwd := TRUE; 
ELSE
   // We are in the zone where limiting occurs
   IF (bInitFwd) THEN
      abKCTRL_YXGenFwd.Init(rX0 := mrStartLimitingPositionFwd,
                            rY0 := mrMaxVelocityFwd);
      IF (abKCTRL_YXGenFwd.Init.initStatus <> KCTRL_Ret_OK) THEN
            bError := TRUE;
            iErrorInfo := cInvalidVelocityParams;
            rLimitVelocityFwd := 0.0;
            rLimitVelocityBwd := 0.0;
            RETURN;
      END_IF;
      bInitFwd := FALSE;
   END_IF;

   abKCTRL_YXGenFwd.Calculate(rX := rActPosition,
                              bSoftStop := bStop);
   IF (abKCTRL_YXGenFwd.Calculate.calcStatus <> KCTRL_Ret_OK) THEN
      bError := TRUE;
      iErrorInfo := cCyclicCalculationError;
      rLimitVelocityFwd := 0.0;
      rLimitVelocityBwd := 0.0;
      RETURN;
   END_IF;
   rLimitVelocityFwd := abKCTRL_YXGenFwd.Calculate.rY;
END_IF;

// calc bwd limit
IF (rActPosition > mrStartLimitingPositionBwd) AND (NOT bStop) THEN
   // we are before the start of the limitation -> allow full output
   // we do not need to ask the YX generator for this
   rLimitVelocityBwd := mrMaxVelocityBwd;
   bInitBwd := TRUE; 
ELSE
   // We are in the zone where limiting occurs
   IF (bInitBwd) THEN
      abKCTRL_YXGenBwd.Init(rX0 := mrStartLimitingPositionBwd,
                         rY0 := mrMaxVelocityBwd);
      IF (abKCTRL_YXGenBwd.Init.initStatus <> KCTRL_Ret_OK) THEN
            bError := TRUE;
            iErrorInfo := cInvalidVelocityParams;
            rLimitVelocityFwd := 0.0;
            rLimitVelocityBwd := 0.0;
            RETURN;
      END_IF;
      bInitBwd := FALSE;
   END_IF;

   abKCTRL_YXGenBwd.Calculate(rX := rActPosition,
                              bSoftStop := bStop);
   IF (abKCTRL_YXGenBwd.Calculate.calcStatus <> KCTRL_Ret_OK) THEN
      bError := TRUE;
      iErrorInfo := cCyclicCalculationError;
      rLimitVelocityFwd := 0.0;
      rLimitVelocityBwd := 0.0;
      RETURN;
   END_IF;
   rLimitVelocityBwd := abKCTRL_YXGenBwd.Calculate.rY;
END_IF;


bError := FALSE;
iErrorInfo := 0;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
