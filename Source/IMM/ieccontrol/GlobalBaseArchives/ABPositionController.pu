IMPORT_OVER_LISTFILE
 GET_TASK_INTERVAL
, nAnaOutputModeFast
, nAnaOutputModeMid
, KCTRL_Ret_OK
, nSetup
, cMoveNone
, KCTRL_PIDT1
, KCTRL_PIDT1_Param
, ABLintabApply
, tsControlParameters
, tnAnaOutputMode
, ABOutputRequest
, tpMoveData
, tnOperationMode
, KAPPL_LintabData
, ABLockList
, TON

END_IMPORT

ALGORITHM_BLOCK ABPositionController #DUMMY_EDIT_BLOCK

SYSTEM_OBJECT
 TaskAnalog : TASK;
 TaskInject : TASK;
 PU_Task_7 : TASK;
END_OBJECT

VAR
 abKCTRL_PIDT1 : KCTRL_PIDT1;
 abPIDT1_Param : KCTRL_PIDT1_Param;
 abLintabApplyVel : ABLintabApply;
 mbInputsLinked : BOOL := FALSE;
 mpActPosition : REFTO REAL;
 mbActPositionLinked : BOOL;
 mpSetPosition : REFTO REAL;
 mbSetPositionLinked : BOOL;
 mpForce : REFTO REAL;
 mbForceLinked : BOOL;
 mpSetVelocity : REFTO REAL;
 mbSetVelLinked : BOOL;
 mpSetForce : REFTO REAL;
 mbSetForceLinked : BOOL;
 mpPositionControlParam : REFTO tsControlParameters;
 mbPositionControlParamLinked : BOOL;
 mpbDeviceReady : REFTO BOOL;
 mbDeviceReadyLinked : BOOL;
 rMaxLimit : REAL := 1.0e3;
 mdCycleTime : TIME;
 bEnable : BOOL;
 mbFastOutput : BOOL;
 bStart : BOOL;
 bStop : BOOL;
 bReParam : BOOL;
 AnaOutputMode : tnAnaOutputMode;
 abOutputRequest : ABOutputRequest;
 mpMoveCtrlData : REFTO tpMoveData;
 mMoveCtrlData : tpMoveData;
 mbMoveCtrlDataLinked : BOOL;
 mpOperationMode : REFTO tnOperationMode;
 mbOperationModeLinked : BOOL;
 mpLintabOutV : REFTO KAPPL_LintabData;
 mbLintabOutVLinked : BOOL;
 abLockList : ABLockList;
 StopMovementTimer : TON;
 mpdMaxMoveTime : REFTO TIME;
 mbMaxMoveTimeLinked : BOOL;
 mdMaxMoveTime : TIME;
 mbPositionCtrlStarted : BOOL := FALSE;
 mbUseMoveCtrlData : BOOL;
 mpPositionTolerance : REFTO REAL;
 mbPositionToleranceLinked : BOOL;
 mpMaxPositionTolerance : REFTO REAL;
 mbMaxPositionToleranceLinked : BOOL;
END_VAR

ALGORITHM aInit


VAR_INPUT
 pActPosition : REFTO REAL (* REFTO act position of movement *);
 pSetPosition : REFTO REAL (* REFTO set position to control *);
 pForce : REFTO REAL (* REFTO set pressure or set torque during position control *);
 pSetVelocity : REFTO REAL (* REFTO set pressure or set torque during position control *);
 pSetForce : REFTO REAL (* REFTO set pressure or set torque during position control *);
 pPositionControlParam : REFTO tsControlParameters (* REFTO set pressure or set torque during position control *);
 pMoveCtrlData : REFTO tpMoveData;
 pOperationMode : REFTO tnOperationMode;
 pbDeviceReady : REFTO BOOL;
 pLintabOutV : REFTO KAPPL_LintabData;
 pdMaxMoveTime : REFTO TIME;
 bFastOutput : BOOL;
 bIgnoreMoveCtrlData : BOOL;
 pPositionTolerance : REFTO REAL;
 pMaxPositionTolerance : REFTO REAL;
END_VAR

VAR_OUTPUT
 bError : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
bError := FALSE;
 
IF CHECK_REF(pActPosition^) THEN
   mbActPositionLinked := TRUE;
   mpActPosition := pActPosition; 
ELSE
   mbActPositionLinked := FALSE; 
END_IF;
IF CHECK_REF(pSetPosition^) THEN
   mbSetPositionLinked := TRUE;
   mpSetPosition := pSetPosition; 
ELSE
   mbSetPositionLinked := FALSE; 
END_IF;    
IF CHECK_REF(pForce^) THEN
   mbForceLinked := TRUE;
   mpForce := pForce; 
ELSE
   mbForceLinked := FALSE; 
END_IF;
IF CHECK_REF(pSetVelocity^) THEN
   mbSetVelLinked := TRUE;
   mpSetVelocity := pSetVelocity; 
ELSE
   mbSetVelLinked := FALSE; 
END_IF;
IF CHECK_REF(pSetForce^) THEN
   mbSetForceLinked := TRUE;
   mpSetForce := pSetForce; 
ELSE
   mbSetForceLinked := FALSE; 
END_IF;
IF CHECK_REF(pPositionControlParam^) THEN
   mbPositionControlParamLinked := TRUE;
   mpPositionControlParam := pPositionControlParam; 
ELSE
   mbPositionControlParamLinked := FALSE; 
END_IF;
IF NOT bIgnoreMoveCtrlData THEN
   IF CHECK_REF(pMoveCtrlData^) THEN
      mbMoveCtrlDataLinked := TRUE;
      mpMoveCtrlData := pMoveCtrlData; 
       
   ELSE
      mbMoveCtrlDataLinked := FALSE; 
   END_IF;
   mbUseMoveCtrlData := TRUE; 
ELSE    
   mbMoveCtrlDataLinked := FALSE; 
   mbUseMoveCtrlData := FALSE;
END_IF;
IF CHECK_REF(pOperationMode^) THEN
   mbOperationModeLinked := TRUE;
   mpOperationMode := pOperationMode; 
ELSE
   mbOperationModeLinked := FALSE; 
END_IF;
IF CHECK_REF(pOperationMode^) THEN
   mbDeviceReadyLinked := TRUE;
   mpbDeviceReady := pbDeviceReady; 
ELSE
   mbDeviceReadyLinked := FALSE; 
END_IF;

IF CHECK_REF(pLintabOutV^) THEN
   mbLintabOutVLinked := TRUE;
   mpLintabOutV := pLintabOutV; 
ELSE
   mbLintabOutVLinked := FALSE; 
END_IF;

IF CHECK_REF(pdMaxMoveTime^) THEN
   mbMaxMoveTimeLinked := TRUE;
   mpdMaxMoveTime := pdMaxMoveTime; 
ELSE
   mbMaxMoveTimeLinked := FALSE; 
END_IF;

mbInputsLinked := (mbActPositionLinked AND mbSetPositionLinked AND 
                   (mbForceLinked OR NOT mbForceLinked) AND mbSetVelLinked AND 
                   mbPositionControlParamLinked AND 
                  (mbMoveCtrlDataLinked OR NOT mbUseMoveCtrlData) AND
                   mbOperationModeLinked AND mbDeviceReadyLinked);
bError := bError OR (NOT mbInputsLinked);

mbFastOutput := bFastOutput;
IF mbFastOutput THEN
   mdCycleTime := GET_TASK_INTERVAL(TaskInject);
   AnaOutputMode := nAnaOutputModeFast;
ELSE
   mdCycleTime := GET_TASK_INTERVAL(TaskAnalog);
   AnaOutputMode := nAnaOutputModeMid;
END_IF;    

IF CHECK_REF(pPositionTolerance^) THEN
   mbPositionToleranceLinked := TRUE;
   mpPositionTolerance := pPositionTolerance; 
ELSE
   mbPositionToleranceLinked := FALSE; 
END_IF;

IF CHECK_REF(pMaxPositionTolerance^) THEN
   mbMaxPositionToleranceLinked := TRUE;
   mpMaxPositionTolerance := pMaxPositionTolerance; 
ELSE
   mbMaxPositionToleranceLinked := FALSE; 
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aRun


VAR_INPUT
 bStart : BOOL R_EDGE;
 bStop : BOOL;
 bReParam : BOOL;
END_VAR

VAR_OUTPUT
 bReady : BOOL;
 bError : BOOL;
 iErrorID : DINT;
END_VAR

VAR
 rPosTolerance : REAL;
 rMaxOutput : REAL;
 rMinOutput : REAL;
 rMinLimit : REAL := -1.0e3;
 rControlValue : REAL;
 rActVal : REAL;
 rSetVal : REAL;
 rTolerance : REAL := 0.01;
 rMaxPosTolerance : REAL := 1.0e35;
END_VAR
#BEGIN_EDIT_BLOCK
bError := FALSE;
IF CHECK_REF(mpMoveCtrlData^^) THEN
   abLockList.aCheck(MoveDir:=mpMoveCtrlData^^.MoveDir,
                     MoveId:=mpMoveCtrlData^^.MoveId);
END_IF;
IF abLockList.aCheck.bLocked OR (NOT mpPositionControlParam^.bUsePIDControl) THEN
   bEnable := FALSE;
   bReady := TRUE; 
   mpSetVelocity^ := 0.0;
   IF mbSetForceLinked THEN
      mpSetForce^ := mpForce^;
   END_IF;    
   RETURN;
END_IF;
IF bReParam THEN
   abPIDT1_Param.rKR := mpPositionControlParam^.rP;
   abPIDT1_Param.dTN := mpPositionControlParam^.dTN; 
   abPIDT1_Param.dTV := mpPositionControlParam^.dTV; 
    
   IF mbPositionToleranceLinked AND mpPositionTolerance^ > rTolerance THEN
      rPosTolerance := mpPositionTolerance^; 
   ELSE     
      rPosTolerance := rTolerance;
   END_IF; 
   IF mbMaxPositionToleranceLinked AND mpMaxPositionTolerance^ > 0.0 THEN
      rMaxPosTolerance := mpMaxPositionTolerance^; 
   ELSE
       rMaxPosTolerance := 1.0e35;
   END_IF; 
    
   IF rMaxLimit <= rMinLimit THEN
      bError := bError OR TRUE;
      rMaxOutput := 0.0;
      rMinOutput := 0.0;           
   ELSE
      rMaxOutput := rMaxLimit;
      rMinOutput := rMinLimit;    
   END_IF;
   abPIDT1_Param.rUMax := rMaxOutput; 
   abPIDT1_Param.rUMin := rMinOutput; 
   abKCTRL_PIDT1.Par(dCycleTime:=mdCycleTime, Param:=abPIDT1_Param);
   IF abKCTRL_PIDT1.Par.parStatus <> KCTRL_Ret_OK THEN
      bError := TRUE;
   END_IF;
   IF mbLintabOutVLinked THEN
      abLintabApplyVel.aInit(pLintab:=mpLintabOutV,
                             bLinearExtrapolation:=TRUE); 
   END_IF; 
END_IF;
IF bStart THEN
   abKCTRL_PIDT1.Init(rActVal:=0.0,
                      rSetVal:=0.0,
                      rOpenLoopSetVal:=0.0,
                      rOutVal:=0.0);
   bEnable := mpPositionControlParam^.bUsePIDControl;
   bReady := FALSE;
   iErrorID := 0;
   IF mbMaxMoveTimeLinked THEN
       mdMaxMoveTime := mpdMaxMoveTime^;
   ELSE
       mdMaxMoveTime := T#0s;
   END_IF;
   StopMovementTimer(IN:=FALSE, PT:=mdMaxMoveTime); 
END_IF;
IF mdMaxMoveTime > T#0s THEN
   StopMovementTimer(IN:=TRUE);
   IF StopMovementTimer.Q THEN
      bEnable := FALSE;
      bReady := TRUE; 
   END_IF; 
END_IF;
IF bStop THEN
   bEnable := FALSE;
   bReady := TRUE; 
END_IF;
rActVal := mpActPosition^; 
rSetVal := mpSetPosition^; 
IF (ABS(rSetVal - rActVal) > rPosTolerance) AND
   (ABS(rSetVal - rActVal) < rMaxPosTolerance) AND (NOT bReady) THEN
   abKCTRL_PIDT1.Calculate(rActVal:=rActVal,
                           rSetVal:=rSetVal,
                           bEnable:=bEnable);
   IF abKCTRL_PIDT1.Calculate.calcStatus <> KCTRL_Ret_OK THEN
      bError := TRUE;
      rControlValue := 0.0; 
   ELSE   
      IF abKCTRL_PIDT1.Calculate.rOutVal > rMaxOutput THEN
         rControlValue := rMaxOutput;
      ELSIF abKCTRL_PIDT1.Calculate.rOutVal < rMinOutput THEN
         rControlValue := rMinOutput;
      ELSE    
         rControlValue := abKCTRL_PIDT1.Calculate.rOutVal;
      END_IF;
      IF mbLintabOutVLinked THEN
         abLintabApplyVel.aCalc(rX:=rControlValue);
         rControlValue := abLintabApplyVel.aCalc.rY;
      END_IF; 
   END_IF; 
ELSE
   // reset controller stop movement
   abKCTRL_PIDT1.Init(rActVal:=0.0,rSetVal:=0.0,rOpenLoopSetVal:=0.0,rOutVal:=0.0);
   rControlValue := 0.0; 
END_IF;
mpSetVelocity^ := rControlValue;
IF mbSetForceLinked THEN
   mpSetForce^ := mpForce^;
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paRunMid ON TaskAnalog

#BEGIN_EDIT_BLOCK
aRun(bStart:=bStart,
     bStop:=bStop,
     bReParam:=bReParam);
IF aRun.bError OR aRun.bReady THEN
   bStop := TRUE; 
   abOutputRequest.aRelease(pMoveData := mMoveCtrlData);
   mbPositionCtrlStarted := FALSE; 
  STOP_PROCESS_ALGORITHM();
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paRunFast ON TaskInject

#BEGIN_EDIT_BLOCK
aRun(bStart:=bStart,
     bStop:=bStop,
     bReParam:=bReParam);
IF aRun.bError OR aRun.bReady THEN
   bStop := TRUE; 
   abOutputRequest.aRelease(pMoveData := mMoveCtrlData);
   mbPositionCtrlStarted := FALSE; 
   STOP_PROCESS_ALGORITHM();
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pStartControl ON PU_Task_7 WITH mpbDeviceReady^

#BEGIN_EDIT_BLOCK
IF NOT mbInputsLinked THEN
    mbPositionCtrlStarted := FALSE; 
    RETURN;
END_IF;
IF mpbDeviceReady^ AND mpOperationMode^ > nSetup THEN
    IF NOT mpPositionControlParam^.bUsePIDControl THEN
       mbPositionCtrlStarted := FALSE; 
       RETURN;
    END_IF;
    IF aInit.bError THEN
       bStart := FALSE;
       bStop := TRUE;
       mbPositionCtrlStarted := FALSE; 
       RETURN; 
    END_IF;
    bStop := FALSE;
    bReParam := TRUE; // ToDo: PostUpdateAlgo if parameter changed
    aRun(bStart:=FALSE,
         bStop:=bStop,
         bReParam:=bReParam);
         bReParam := FALSE;
         bStart := TRUE;
         bStop := FALSE;
   IF mbUseMoveCtrlData THEN
      IF CHECK_REF(mpMoveCtrlData^^) THEN
         IF mpMoveCtrlData^^.MoveId > cMoveNone THEN
            IF mbFastOutput THEN
               START_PROCESS_ALGORITHM(paRunFast);
            ELSE
               START_PROCESS_ALGORITHM(paRunMid);
            END_IF;
            mMoveCtrlData := mpMoveCtrlData^;
            abOutputRequest.aRequest(pMoveData := mMoveCtrlData,
                                  AnaOutputMode := AnaOutputMode);
            mbPositionCtrlStarted := TRUE; 
         END_IF;
      END_IF;
   ELSE
     IF mbFastOutput THEN
        START_PROCESS_ALGORITHM(paRunFast);
     ELSE
        START_PROCESS_ALGORITHM(paRunMid);
     END_IF;
     mbPositionCtrlStarted := TRUE; 
   END_IF;
ELSE
   bStart := FALSE;
   bStop := TRUE;
   IF aInit.bError THEN
      RETURN; 
   END_IF;
   IF mbFastOutput THEN
      STOP_PROCESS_ALGORITHM(paRunFast);
   ELSE
      STOP_PROCESS_ALGORITHM(paRunMid);
   END_IF;
   IF mbUseMoveCtrlData AND CHECK_REF(mpMoveCtrlData^^) THEN
      IF CHECK_REF(mMoveCtrlData^) AND mbPositionCtrlStarted THEN
         abOutputRequest.aRelease(pMoveData := mMoveCtrlData);
         mbPositionCtrlStarted := FALSE; 
      END_IF;
   END_IF;   
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pStopControl ON PU_Task_7 WITH mpOperationMode^

#BEGIN_EDIT_BLOCK
IF mpOperationMode^ = nSetup THEN
   bStart := FALSE;
   bStop := TRUE;
   IF aInit.bError THEN
      RETURN; 
   END_IF;
   IF mbFastOutput THEN
      STOP_PROCESS_ALGORITHM(paRunFast);
   ELSE
      STOP_PROCESS_ALGORITHM(paRunMid);
   END_IF;
   IF mbUseMoveCtrlData AND CHECK_REF(mpMoveCtrlData^^) THEN
      IF CHECK_REF(mMoveCtrlData^) AND mbPositionCtrlStarted THEN
         abOutputRequest.aRelease(pMoveData := mMoveCtrlData);
         mbPositionCtrlStarted := FALSE;
      END_IF;
   END_IF;   
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aCheckReleased


VAR_OUTPUT
 bReady : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
bReady := NOT mbPositionCtrlStarted;


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 127 @Pou 25 
@@@BEG_Comment@@@

@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
1 
@Var @RT(17)GET_TASK_INTERVAL @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
5 
@Var @RT(18)nAnaOutputModeFast @RT(0) @T @T @DERIVED 0 @F @RT(15)tnAnaOutputMode @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)nAnaOutputModeMid @RT(0) @T @T @DERIVED 0 @F @RT(15)tnAnaOutputMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)KCTRL_Ret_OK @RT(0) @T @T @DERIVED 0 @F @RT(9)KCTRL_Ret @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)nSetup @RT(0) @T @T @DERIVED 0 @F @RT(15)tnOperationMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(36)Setup mode only for service engineer 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)cMoveNone @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(13)cMinMoveIdent @RT(4)None 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(20)ABPositionController @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
48 
@Var @RT(10)TaskAnalog @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)TaskInject @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)PU_Task_7 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(13)abKCTRL_PIDT1 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KCTRL_PIDT1 @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)abPIDT1_Param @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)KCTRL_PIDT1_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abLintabApplyVel @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mbInputsLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)FALSE @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mpActPosition @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mbActPositionLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mpSetPosition @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mbSetPositionLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)mpForce @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mbForceLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mpSetVelocity @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mbSetVelLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)mpSetForce @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mbSetForceLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mpPositionControlParam @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(19)tsControlParameters @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(28)mbPositionControlParamLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mpbDeviceReady @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mbDeviceReadyLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)rMaxLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)1.0e3 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)mdCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)bEnable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mbFastOutput @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)bStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)bStop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)bReParam @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)AnaOutputMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnAnaOutputMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)abOutputRequest @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)ABOutputRequest @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mpMoveCtrlData @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(10)tpMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mMoveCtrlData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tpMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)mbMoveCtrlDataLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mpOperationMode @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(15)tnOperationMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)mbOperationModeLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mpLintabOutV @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mbLintabOutVLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)abLockList @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)ABLockList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)StopMovementTimer @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)TON @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mpdMaxMoveTime @RT(0) @T @T @REFTO 0 @T @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mbMaxMoveTimeLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mdMaxMoveTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)mbPositionCtrlStarted @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)FALSE @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mbUseMoveCtrlData @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mpPositionTolerance @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(25)mbPositionToleranceLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mpMaxPositionTolerance @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(28)mbMaxPositionToleranceLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

7 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(5)aInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
16 
@Var @RT(12)pActPosition @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(30)REFTO act position of movement @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)pSetPosition @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(29)REFTO set position to control @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)pForce @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(56)REFTO set pressure or set torque during position control @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)pSetVelocity @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(56)REFTO set pressure or set torque during position control @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)pSetForce @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(56)REFTO set pressure or set torque during position control @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(21)pPositionControlParam @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(19)tsControlParameters @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(56)REFTO set pressure or set torque during position control @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)pMoveCtrlData @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(10)tpMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)pOperationMode @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(15)tnOperationMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)pbDeviceReady @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)pLintabOutV @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)pdMaxMoveTime @RT(0) @T @T @REFTO 0 @T @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)bFastOutput @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)bIgnoreMoveCtrlData @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)pPositionTolerance @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(21)pMaxPositionTolerance @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aRun @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
15 
@Var @RT(6)bStart @RT(0) @T @F @DT @RT(11)BOOL R_EDGE @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(5)bStop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)bReParam @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)bReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(8)iErrorID @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(13)rPosTolerance @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rMaxOutput @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rMinOutput @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)rMinLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(6)-1.0e3 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)rControlValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)rActVal @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)rSetVal @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rTolerance @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)0.01 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)rMaxPosTolerance @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(6)1.0e35 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(8)paRunMid @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(10)TaskAnalog @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(9)paRunFast @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(10)TaskInject @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(13)pStartControl @STRUCTURED_TEXT 
@RT(0) @RT(15)mpbDeviceReady^ @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(12)pStopControl @STRUCTURED_TEXT 
@RT(0) @RT(16)mpOperationMode^ @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(14)aCheckReleased @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(6)bReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(109)
bError := FALSE;
 
IF CHECK_REF(pActPosition^) THEN
   mbActPositionLinked := TRUE;
   mpActPosition := pActPosition; 
ELSE
   mbActPositionLinked := FALSE; 
END_IF;
IF CHECK_REF(pSetPosition^) THEN
   mbSetPositionLinked := TRUE;
   mpSetPosition := pSetPosition; 
ELSE
   mbSetPositionLinked := FALSE; 
END_IF;    
IF CHECK_REF(pForce^) THEN
   mbForceLinked := TRUE;
   mpForce := pForce; 
ELSE
   mbForceLinked := FALSE; 
END_IF;
IF CHECK_REF(pSetVelocity^) THEN
   mbSetVelLinked := TRUE;
   mpSetVelocity := pSetVelocity; 
ELSE
   mbSetVelLinked := FALSE; 
END_IF;
IF CHECK_REF(pSetForce^) THEN
   mbSetForceLinked := TRUE;
   mpSetForce := pSetForce; 
ELSE
   mbSetForceLinked := FALSE; 
END_IF;
IF CHECK_REF(pPositionControlParam^) THEN
   mbPositionControlParamLinked := TRUE;
   mpPositionControlParam := pPositionControlParam; 
ELSE
   mbPositionControlParamLinked := FALSE; 
END_IF;
IF NOT bIgnoreMoveCtrlData THEN
   IF CHECK_REF(pMoveCtrlData^) THEN
      mbMoveCtrlDataLinked := TRUE;
      mpMoveCtrlData := pMoveCtrlData; 
       
   ELSE
      mbMoveCtrlDataLinked := FALSE; 
   END_IF;
   mbUseMoveCtrlData := TRUE; 
ELSE    
   mbMoveCtrlDataLinked := FALSE; 
   mbUseMoveCtrlData := FALSE;
END_IF;
IF CHECK_REF(pOperationMode^) THEN
   mbOperationModeLinked := TRUE;
   mpOperationMode := pOperationMode; 
ELSE
   mbOperationModeLinked := FALSE; 
END_IF;
IF CHECK_REF(pOperationMode^) THEN
   mbDeviceReadyLinked := TRUE;
   mpbDeviceReady := pbDeviceReady; 
ELSE
   mbDeviceReadyLinked := FALSE; 
END_IF;

IF CHECK_REF(pLintabOutV^) THEN
   mbLintabOutVLinked := TRUE;
   mpLintabOutV := pLintabOutV; 
ELSE
   mbLintabOutVLinked := FALSE; 
END_IF;

IF CHECK_REF(pdMaxMoveTime^) THEN
   mbMaxMoveTimeLinked := TRUE;
   mpdMaxMoveTime := pdMaxMoveTime; 
ELSE
   mbMaxMoveTimeLinked := FALSE; 
END_IF;

mbInputsLinked := (mbActPositionLinked AND mbSetPositionLinked AND 
                   (mbForceLinked OR NOT mbForceLinked) AND mbSetVelLinked AND 
                   mbPositionControlParamLinked AND 
                  (mbMoveCtrlDataLinked OR NOT mbUseMoveCtrlData) AND
                   mbOperationModeLinked AND mbDeviceReadyLinked);
bError := bError OR (NOT mbInputsLinked);

mbFastOutput := bFastOutput;
IF mbFastOutput THEN
   mdCycleTime := GET_TASK_INTERVAL(TaskInject);
   AnaOutputMode := nAnaOutputModeFast;
ELSE
   mdCycleTime := GET_TASK_INTERVAL(TaskAnalog);
   AnaOutputMode := nAnaOutputModeMid;
END_IF;    

IF CHECK_REF(pPositionTolerance^) THEN
   mbPositionToleranceLinked := TRUE;
   mpPositionTolerance := pPositionTolerance; 
ELSE
   mbPositionToleranceLinked := FALSE; 
END_IF;

IF CHECK_REF(pMaxPositionTolerance^) THEN
   mbMaxPositionToleranceLinked := TRUE;
   mpMaxPositionTolerance := pMaxPositionTolerance; 
ELSE
   mbMaxPositionToleranceLinked := FALSE; 
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(109)
bError := FALSE;
IF CHECK_REF(mpMoveCtrlData^^) THEN
   abLockList.aCheck(MoveDir:=mpMoveCtrlData^^.MoveDir,
                     MoveId:=mpMoveCtrlData^^.MoveId);
END_IF;
IF abLockList.aCheck.bLocked OR (NOT mpPositionControlParam^.bUsePIDControl) THEN
   bEnable := FALSE;
   bReady := TRUE; 
   mpSetVelocity^ := 0.0;
   IF mbSetForceLinked THEN
      mpSetForce^ := mpForce^;
   END_IF;    
   RETURN;
END_IF;
IF bReParam THEN
   abPIDT1_Param.rKR := mpPositionControlParam^.rP;
   abPIDT1_Param.dTN := mpPositionControlParam^.dTN; 
   abPIDT1_Param.dTV := mpPositionControlParam^.dTV; 
    
   IF mbPositionToleranceLinked AND mpPositionTolerance^ > rTolerance THEN
      rPosTolerance := mpPositionTolerance^; 
   ELSE     
      rPosTolerance := rTolerance;
   END_IF; 
   IF mbMaxPositionToleranceLinked AND mpMaxPositionTolerance^ > 0.0 THEN
      rMaxPosTolerance := mpMaxPositionTolerance^; 
   ELSE
       rMaxPosTolerance := 1.0e35;
   END_IF; 
    
   IF rMaxLimit <= rMinLimit THEN
      bError := bError OR TRUE;
      rMaxOutput := 0.0;
      rMinOutput := 0.0;           
   ELSE
      rMaxOutput := rMaxLimit;
      rMinOutput := rMinLimit;    
   END_IF;
   abPIDT1_Param.rUMax := rMaxOutput; 
   abPIDT1_Param.rUMin := rMinOutput; 
   abKCTRL_PIDT1.Par(dCycleTime:=mdCycleTime, Param:=abPIDT1_Param);
   IF abKCTRL_PIDT1.Par.parStatus <> KCTRL_Ret_OK THEN
      bError := TRUE;
   END_IF;
   IF mbLintabOutVLinked THEN
      abLintabApplyVel.aInit(pLintab:=mpLintabOutV,
                             bLinearExtrapolation:=TRUE); 
   END_IF; 
END_IF;
IF bStart THEN
   abKCTRL_PIDT1.Init(rActVal:=0.0,
                      rSetVal:=0.0,
                      rOpenLoopSetVal:=0.0,
                      rOutVal:=0.0);
   bEnable := mpPositionControlParam^.bUsePIDControl;
   bReady := FALSE;
   iErrorID := 0;
   IF mbMaxMoveTimeLinked THEN
       mdMaxMoveTime := mpdMaxMoveTime^;
   ELSE
       mdMaxMoveTime := T#0s;
   END_IF;
   StopMovementTimer(IN:=FALSE, PT:=mdMaxMoveTime); 
END_IF;
IF mdMaxMoveTime > T#0s THEN
   StopMovementTimer(IN:=TRUE);
   IF StopMovementTimer.Q THEN
      bEnable := FALSE;
      bReady := TRUE; 
   END_IF; 
END_IF;
IF bStop THEN
   bEnable := FALSE;
   bReady := TRUE; 
END_IF;
rActVal := mpActPosition^; 
rSetVal := mpSetPosition^; 
IF (ABS(rSetVal - rActVal) > rPosTolerance) AND
   (ABS(rSetVal - rActVal) < rMaxPosTolerance) AND (NOT bReady) THEN
   abKCTRL_PIDT1.Calculate(rActVal:=rActVal,
                           rSetVal:=rSetVal,
                           bEnable:=bEnable);
   IF abKCTRL_PIDT1.Calculate.calcStatus <> KCTRL_Ret_OK THEN
      bError := TRUE;
      rControlValue := 0.0; 
   ELSE   
      IF abKCTRL_PIDT1.Calculate.rOutVal > rMaxOutput THEN
         rControlValue := rMaxOutput;
      ELSIF abKCTRL_PIDT1.Calculate.rOutVal < rMinOutput THEN
         rControlValue := rMinOutput;
      ELSE    
         rControlValue := abKCTRL_PIDT1.Calculate.rOutVal;
      END_IF;
      IF mbLintabOutVLinked THEN
         abLintabApplyVel.aCalc(rX:=rControlValue);
         rControlValue := abLintabApplyVel.aCalc.rY;
      END_IF; 
   END_IF; 
ELSE
   // reset controller stop movement
   abKCTRL_PIDT1.Init(rActVal:=0.0,rSetVal:=0.0,rOpenLoopSetVal:=0.0,rOutVal:=0.0);
   rControlValue := 0.0; 
END_IF;
mpSetVelocity^ := rControlValue;
IF mbSetForceLinked THEN
   mpSetForce^ := mpForce^;
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(10)
aRun(bStart:=bStart,
     bStop:=bStop,
     bReParam:=bReParam);
IF aRun.bError OR aRun.bReady THEN
   bStop := TRUE; 
   abOutputRequest.aRelease(pMoveData := mMoveCtrlData);
   mbPositionCtrlStarted := FALSE; 
  STOP_PROCESS_ALGORITHM();
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(10)
aRun(bStart:=bStart,
     bStop:=bStop,
     bReParam:=bReParam);
IF aRun.bError OR aRun.bReady THEN
   bStop := TRUE; 
   abOutputRequest.aRelease(pMoveData := mMoveCtrlData);
   mbPositionCtrlStarted := FALSE; 
   STOP_PROCESS_ALGORITHM();
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(64)
IF NOT mbInputsLinked THEN
    mbPositionCtrlStarted := FALSE; 
    RETURN;
END_IF;
IF mpbDeviceReady^ AND mpOperationMode^ > nSetup THEN
    IF NOT mpPositionControlParam^.bUsePIDControl THEN
       mbPositionCtrlStarted := FALSE; 
       RETURN;
    END_IF;
    IF aInit.bError THEN
       bStart := FALSE;
       bStop := TRUE;
       mbPositionCtrlStarted := FALSE; 
       RETURN; 
    END_IF;
    bStop := FALSE;
    bReParam := TRUE; // ToDo: PostUpdateAlgo if parameter changed
    aRun(bStart:=FALSE,
         bStop:=bStop,
         bReParam:=bReParam);
         bReParam := FALSE;
         bStart := TRUE;
         bStop := FALSE;
   IF mbUseMoveCtrlData THEN
      IF CHECK_REF(mpMoveCtrlData^^) THEN
         IF mpMoveCtrlData^^.MoveId > cMoveNone THEN
            IF mbFastOutput THEN
               START_PROCESS_ALGORITHM(paRunFast);
            ELSE
               START_PROCESS_ALGORITHM(paRunMid);
            END_IF;
            mMoveCtrlData := mpMoveCtrlData^;
            abOutputRequest.aRequest(pMoveData := mMoveCtrlData,
                                  AnaOutputMode := AnaOutputMode);
            mbPositionCtrlStarted := TRUE; 
         END_IF;
      END_IF;
   ELSE
     IF mbFastOutput THEN
        START_PROCESS_ALGORITHM(paRunFast);
     ELSE
        START_PROCESS_ALGORITHM(paRunMid);
     END_IF;
     mbPositionCtrlStarted := TRUE; 
   END_IF;
ELSE
   bStart := FALSE;
   bStop := TRUE;
   IF aInit.bError THEN
      RETURN; 
   END_IF;
   IF mbFastOutput THEN
      STOP_PROCESS_ALGORITHM(paRunFast);
   ELSE
      STOP_PROCESS_ALGORITHM(paRunMid);
   END_IF;
   IF mbUseMoveCtrlData AND CHECK_REF(mpMoveCtrlData^^) THEN
      IF CHECK_REF(mMoveCtrlData^) AND mbPositionCtrlStarted THEN
         abOutputRequest.aRelease(pMoveData := mMoveCtrlData);
         mbPositionCtrlStarted := FALSE; 
      END_IF;
   END_IF;   
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(19)
IF mpOperationMode^ = nSetup THEN
   bStart := FALSE;
   bStop := TRUE;
   IF aInit.bError THEN
      RETURN; 
   END_IF;
   IF mbFastOutput THEN
      STOP_PROCESS_ALGORITHM(paRunFast);
   ELSE
      STOP_PROCESS_ALGORITHM(paRunMid);
   END_IF;
   IF mbUseMoveCtrlData AND CHECK_REF(mpMoveCtrlData^^) THEN
      IF CHECK_REF(mMoveCtrlData^) AND mbPositionCtrlStarted THEN
         abOutputRequest.aRelease(pMoveData := mMoveCtrlData);
         mbPositionCtrlStarted := FALSE;
      END_IF;
   END_IF;   
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(2)
bReady := NOT mbPositionCtrlStarted;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
