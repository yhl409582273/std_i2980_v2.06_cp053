(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

This AB is used for measuring of analog inputs.
It includes the following funcionalities:
- converting an analog input to a measure value by using a linearization table 
- automatic reparam after a change in lintab
- automatic detection of analog inut errors
- velocity measurement by using a filter
- fast and slow measuring


@FunctionID: S_KPIEC_ALASENS_01

*)

IMPORT_OVER_LISTFILE
 SET_ALARM
, RESET_ALARM
, GET_TASK_INTERVAL
, GET_SYNC_REFTO
, FGetHWPath
, GET_MY_FU_NAME
, KSWO_AddVariable
, cMeasureReductionFactor
, cApplPlasticsWrongLintabParams
, KCTRL_Ret_OK
, cApplPlasticsWrongPT1Params
, cApplPlasticsPT1CalcFailed
, cPointsLastAIValue
, KSYS_Status_OK
, tsDeviceId
, KAPPL_LintabData
, KAPPL_Plastics_Measure
, R_TRIG
, tsDerivationEstimateParam
, ABDerivationEstimator
, tyLintabPoints
, F_TRIG
, KCTRL_PTN
, KCTRL_PTN_Param
, tyLastAIValueArray
, KSYS_Status
, KSWO_Status

END_IMPORT

ALGORITHM_BLOCK ABMeasureAI #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_DeviceId : tsDeviceId;
 sv_bInitDone : BOOL;
END_VAR

SYSTEM_OBJECT
 PU_Task_7 : TASK;
 TaskInject : TASK;
 TaskMid : TASK;
 erAnalogInput : ALARM;
 erAnalogSensor : ALARM;
 erInvalidLintabReference : ALARM;
 erInvalidEndpointReference : ALARM;
 erInvalidStatReference : ALARM;
 erAnalogMeasure : ALARM;
END_OBJECT

VAR
 mpLintab : REFTO KAPPL_LintabData;
 mbReParam : BOOL;
 mpbRawValue_stat : REFTO BOOL;
 mbSensorError : BOOL;
 msRawValue : STRING(64);
 mbValidStatFlag : BOOL;
 mpRawValue : REFTO REAL;
 fbMeasure : KAPPL_Plastics_Measure;
 mbValidLintabReference : BOOL (* info if lintab reference is valid *);
 mbValidEndpointReference : BOOL (* info if endpoint reference is valid *);
 mdFilterTime : TIME (* filter time for velocity measurement *);
 mpVelFilterTime : REFTO TIME;
 mbMonEnable : BOOL := FALSE (* enable monitoring for rValue *);
 mrMonLowLimit : REAL (* lower limit for monitoring *);
 mbMonLimitation : BOOL (* use limitation, set values to lower limit  *);
 mrMonFailureFactor : REAL (* define the area without setting alarm *);
 mrMonLowFailureLimit : REAL (* lowest value without alarm *);
 mbReParamLight : BOOL;
 mbRun : BOOL;
 fbRTrigMeasureError : R_TRIG;
 miCount : DINT (* Idle: counts up to cMeasureReductionFactor-1, NOT Idle: always 0 *);
 InstanceId : INT;
 mpDerivationEstimateParam : REFTO tsDerivationEstimateParam;
 mDerivationEstimateParam : tsDerivationEstimateParam;
 mbDerivationEstimatorInitDone : BOOL;
 mrActPosition : REAL;
 mrActPositionEstimate : REAL;
 mrActVelocity : REAL;
 mrActVelocityFilt : REAL;
 mrActVelocityEstimate : REAL;
 abDerivationEstimator : ABDerivationEstimator;
 msHWPath : STRING(255);
 mbCheckLowerLimit : BOOL;
 mdT1Position : TIME;
 mT1PositionUsed : BOOL;
 mpPosFilterTime : REFTO TIME;
 mpLintabPointArray : REFTO tyLintabPoints;
 mpiUsedLintabPoints : REFTO UDINT;
 mbOpenArray : BOOL (* is set to TRUE if an open array of lintab points is used *);
 miMaxLintabSize : UDINT;
END_VAR

(*
Following functions are realized in this algorithm:

1) fast and slow measuring by using the given lintab
2) errorhandling

This is a light version of algorithm aRun, because it is without the measuring of the velocity.
This algorithm has to be used for measure pressure or pure position. So you can save performance.  
*)

ALGORITHM aRunLight


VAR_INPUT
 bIdle : BOOL (* if TRUE measurement is done with reduced cycle time *);
END_VAR

VAR_OUTPUT
 rValue : REAL (* result of measuring (e.g. position) *);
 bSensorError : BOOL (* sensor error *);
 bMeasureError : BOOL (* measure error *);
 iErrorInfo : DINT (* additional erro info *);
END_VAR

VAR_TEMP
 i : UDINT;
END_VAR

VAR
 bLintabAlarmSet : BOOL;
 bEndpointAlarmSet : BOOL;
 bStatAlarmSet : BOOL;
 bInitDone : BOOL;
 bAnalogSensorError : BOOL;
 fbFTrigSensorError : F_TRIG;
 fbRTrigSensorError : R_TRIG;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//don´t do measurement if references are not valid
IF NOT mbValidLintabReference OR NOT mbValidEndpointReference OR NOT mbValidStatFlag THEN
    
    IF NOT mbValidLintabReference AND NOT bLintabAlarmSet THEN
        SET_ALARM(Name := erInvalidLintabReference,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId);
        bLintabAlarmSet := TRUE;
    END_IF;
    
    IF NOT mbValidEndpointReference AND NOT bEndpointAlarmSet THEN
        SET_ALARM(Name := erInvalidEndpointReference,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId,
              Param1 := msRawValue);
        bEndpointAlarmSet := TRUE;
    END_IF;
    
    IF NOT mbValidStatFlag AND NOT bStatAlarmSet THEN
        SET_ALARM(Name := erInvalidStatReference,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                Param1 := msRawValue);
        bStatAlarmSet := TRUE;
    END_IF;
    mbRun := FALSE;
    RETURN;        
END_IF;


IF NOT bInitDone OR mbReParamLight THEN
    //reparam measure block
    IF mbOpenArray THEN
       FOR i := 1 TO miMaxLintabSize DO
          fbMeasure.Lintab.LintabPoints.Point[i].rX := mpLintabPointArray^[i].rX;
          fbMeasure.Lintab.LintabPoints.Point[i].rY := mpLintabPointArray^[i].rY;
       END_FOR;
       fbMeasure.Lintab.LintabPoints.uNoOfPoints := MIN(mpiUsedLintabPoints^, miMaxLintabSize);
    ELSE
       fbMeasure.Lintab := mpLintab^;
    END_IF;
       
    fbMeasure(LintabUsed := TRUE,
              ReParam := TRUE,
              T1 := mdT1Position,
              T1Used := mT1PositionUsed);
    
    mbReParamLight := FALSE;
    bInitDone := TRUE;
END_IF;


//do fast measurement only if movement is active
//if movement is not active then measurement should be done every cMeasureReduction - cycle 
IF NOT bIdle OR miCount = (cMeasureReductionFactor - 1) THEN
    IF NOT mbSensorError THEN
        fbMeasure(RawValue := mpRawValue^,
                  ReParam := FALSE,
                  OutputValue => rValue,
                  Error => bMeasureError,
                  ErrorInfo => iErrorInfo);
        // Allow only Analog Input values >= mrMonLowLimit. Set values to zero in small area 
        // [mrMonLowFailureLimit mrMonLowLimit]
        // and set error, if the value is smaller than mrMonLowFailureLimit 
        IF mbMonEnable THEN
            IF mbCheckLowerLimit THEN
               bAnalogSensorError := FALSE;
               IF rValue < mrMonLowFailureLimit THEN
                  bAnalogSensorError := TRUE;
                  iErrorInfo := cApplPlasticsWrongLintabParams;
               END_IF;
            END_IF;
            
            IF mbMonLimitation THEN
                rValue := MAX(rValue, mrMonLowLimit);
            END_IF;
        END_IF;       
    END_IF;
    miCount := 0;
ELSE
    //increase counter
    miCount := miCount + 1;
END_IF;
//cyclic part
bSensorError := mbSensorError;

//set alarm if error occurs during measure
fbRTrigMeasureError(CLK := bMeasureError);
IF fbRTrigMeasureError.Q THEN
    SET_ALARM(Name := erAnalogMeasure,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId,
              SubID3 := iErrorInfo);
END_IF;

// Set alarm, if value not allowed
IF mbMonEnable AND mbCheckLowerLimit THEN
    //set alarm if error occurs during measure
    fbRTrigSensorError(CLK := bAnalogSensorError);
    IF fbRTrigSensorError.Q THEN
        SET_ALARM(Name := erAnalogSensor,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                Param1 := msRawValue);
    END_IF;
    // Reset alarm after measured value is greater than limit,
    // user reset still neccessary
    fbFTrigSensorError(CLK := bAnalogSensorError);
    IF fbFTrigSensorError.Q THEN
        RESET_ALARM(Name := erAnalogSensor,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId);
    END_IF;
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

(*
Following functions are realized in this algorithm:

1) fast and slow measuring by using the given lintab
2) velocity measuring
3) errorhandling
*)

ALGORITHM aRun


VAR_INPUT
 bIdle : BOOL (* if TRUE measurement is done with reduced cycle time *);
 bIgnoreStandDetection : BOOL (* if TRUE standstill detection is deactivated *);
END_VAR

VAR_OUTPUT
 rValue : REAL (* result of measuring (e.g. position) *);
 rVelocity : REAL (* change of the measure result per time (e.g. mm/s)(always positive) *);
 rVelocitySign : REAL (* change of the measure result per time with sign *);
 rValueEstimate : REAL (* approximation of measured value with taylor series *);
 rDiffValueEstimate : REAL (* estimation of derivation of measured value with respect to time (drValue/dt) *);
 rDDiffValueEstimate : REAL (* estimation of second derivation of measured value with respect to time (d2rValue/dt2) *);
 bSensorError : BOOL (* sensor error *);
 bMeasureError : BOOL (* measure error *);
 iErrorInfo : DINT (* additional erro info *);
END_VAR

VAR_TEMP
 uCounter : DINT;
END_VAR

VAR
 bInitDone : BOOL;
 dCycleTime : TIME;
 rCycleTime : REAL (* cycletime of this Task in seconds *);
 rOldValue : REAL (* result of measuring from the last call of this block *);
 abKCTRL_PTn : KCTRL_PTN;
 ptnParams : KCTRL_PTN_Param;
 rVelocityNotFiltered : REAL;
 rDelta : REAL;
 bAiIsConstant : BOOL;
 rMeanAIValue : REAL := 0.0;
 uMeanAIValuesCounter : DINT := 1;
 rMinDelta : REAL := 9999.0;
 tyLastAIValues : tyLastAIValueArray;
 bInitIdle : BOOL;
 bInitNotIdle : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
mbRun := TRUE;
aRunLight(bIdle := bIdle,
          rValue => rValue, 
          bSensorError => bSensorError, 
          bMeasureError => bMeasureError, 
          iErrorInfo => iErrorInfo);
// Part for calculating differential quotient (e.g. velocity)
IF mbRun THEN
    IF NOT bInitDone OR mbReParam THEN
        IF NOT bInitDone THEN
            //get cycle time
            dCycleTime :=  GET_TASK_INTERVAL();
            rCycleTime := (LINT_TO_REAL(TIME_TO_LINT(dCycleTime))) / 1000000.0;
        END_IF;
        
        //filter initialization
        // Test shows good results by using
        // 12.5 Hz and order 2
        ptnParams.uN := 2;
        ptnParams.rK := 1.0;
        ptnParams.dT1 := mdFilterTime;
        ptnParams.dT2 := mdFilterTime;
        abKCTRL_PTn.Par(dCycleTime := dCycleTime,
                        Param := ptnParams);
        IF (abKCTRL_PTn.Par.parStatus <> KCTRL_Ret_OK) THEN
            bMeasureError := TRUE;
            iErrorInfo := cApplPlasticsWrongPT1Params;
            SET_ALARM(Name := erAnalogMeasure,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                SubID3 := iErrorInfo);
        ELSE
            bMeasureError := FALSE;
        END_IF;
        abKCTRL_PTn.Init(rOutVal := 0.0);      
    
        // init derivation estimator
        IF mDerivationEstimateParam.bUseDerivationEstimator THEN
            mbDerivationEstimatorInitDone := FALSE;
            mDerivationEstimateParam.dMeasCycleTime := dCycleTime;
            START_PROCESS_ALGORITHM(paInitDerivationEstimator);
        END_IF; 
    
        rValueEstimate := 0.0;
        rDiffValueEstimate := 0.0;
        rDDiffValueEstimate := 0.0;
    
        rOldValue := rValue;
        mbReParam := FALSE;
        bInitDone := TRUE;
    END_IF;
    
    
   //do fast measurement only if movement is active
   //if movement is not active then measurement should be done every cMeasureReduction - cycle 
   IF (NOT bIdle OR miCount = 0) AND NOT mbSensorError THEN
       
      //velocity measurement (without abs-function)
      IF bIdle THEN
         IF (NOT bInitIdle) THEN
            bInitIdle := TRUE;
            bInitNotIdle := FALSE;
            abKCTRL_PTn.Par(dCycleTime := MULTIME(dCycleTime, cMeasureReductionFactor));
            abKCTRL_PTn.Init(rOutVal := abKCTRL_PTn.Calculate.rOutVal);
         END_IF;            
         rVelocityNotFiltered := (rValue - rOldValue) / (rCycleTime * DINT_TO_REAL(cMeasureReductionFactor));         
      ELSE
         IF (NOT bInitNotIdle) THEN
            bInitIdle := FALSE;
            bInitNotIdle := TRUE;
            abKCTRL_PTn.Par(dCycleTime := dCycleTime);
            abKCTRL_PTn.Init(rOutVal := abKCTRL_PTn.Calculate.rOutVal);
         END_IF;            
         rVelocityNotFiltered := (rValue - rOldValue) / rCycleTime;
      END_IF;
      //use a filter for velocity measurement
      abKCTRL_PTn.Calculate(rInVal := rVelocityNotFiltered);
      IF (abKCTRL_PTn.Calculate.calcStatus <> KCTRL_Ret_OK) THEN
         bMeasureError := TRUE;
         iErrorInfo := cApplPlasticsPT1CalcFailed;
      ELSE
         rVelocity := abKCTRL_PTn.Calculate.rOutVal;              
             
         // standstill-detection
         // Set velocity to zero if Analog Input is not changing
         // Take more than two points, otherwise a small velocity (e.g. < 6.5% v_max) 
         // would also be set to zero all time of injection process            
             
         // find difference of 1 bit resolution 
         rDelta := ABS(rValue - rOldValue);
         IF (rDelta < rMinDelta) AND (rDelta > 0.0) THEN
            rMinDelta := rDelta;  
         END_IF;     
         // cyclic saving of screw position  
         // cPointsLastAIValue = 5 shows good results by tests
         IF uMeanAIValuesCounter >= cPointsLastAIValue THEN
            uMeanAIValuesCounter := 1;
         ELSE
            uMeanAIValuesCounter := uMeanAIValuesCounter + 1;
         END_IF;          
             
         // Calculating Mean Value in every step new,
         // because by subtracting old value and adding new value
         // there will be numerical noise after few minutes
         tyLastAIValues[uMeanAIValuesCounter] := rValue;
         rMeanAIValue := 0.0;
         FOR uCounter := 1 TO cPointsLastAIValue DO
            rMeanAIValue := rMeanAIValue + tyLastAIValues[uCounter];
         END_FOR;
         rMeanAIValue := rMeanAIValue / DINT_TO_REAL(cPointsLastAIValue);
               
         bAiIsConstant := TRUE; 
         // Start standstill detection only if filtered velocity < v_min_Timediff
         IF (ABS(rVelocity) > (rMinDelta / rCycleTime)) THEN
            bAiIsConstant := bAiIsConstant AND FALSE;
         END_IF;
         FOR uCounter := 1 TO cPointsLastAIValue DO
            IF (ABS(tyLastAIValues[uCounter] - rMeanAIValue) >= rMinDelta ) THEN
               bAiIsConstant := bAiIsConstant AND FALSE;
            END_IF;
         END_FOR; 
            IF bAiIsConstant AND NOT bIgnoreStandDetection THEN
            rVelocity := 0.0;
         END_IF;
         // use sign, don't need estimator if only actual velocity but not acceleration calculated
         rVelocitySign := rVelocity;
         rVelocity := ABS(rVelocity);
      END_IF; 
      rOldValue := rValue;  
        
      //velocity estimator
      IF mDerivationEstimateParam.bUseDerivationEstimator AND mbDerivationEstimatorInitDone THEN
         abDerivationEstimator.aRun(rValue := rValue);
         rValueEstimate := abDerivationEstimator.aRun.rValueEstimate;
         rDiffValueEstimate := abDerivationEstimator.aRun.rDiffValueEstimate;
         rDDiffValueEstimate := abDerivationEstimator.aRun.rDDiffValueEstimate;
      END_IF;    
   END_IF;
END_IF;
//set alarm if error occurs during measure
fbRTrigMeasureError(CLK := bMeasureError);
IF fbRTrigMeasureError.Q THEN
    SET_ALARM(Name := erAnalogMeasure,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId,
              SubID3 := iErrorInfo);
END_IF;

// Variables for SWO Server
mrActPosition := rValue;
mrActPositionEstimate := rValueEstimate;
mrActVelocity := rVelocityNotFiltered;
mrActVelocityFilt := rVelocity;
mrActVelocityEstimate := rDiffValueEstimate;


;#END_EDIT_BLOCK END_ALGORITHM

(*
This algorithm reacts on changes of the lintab.
If the lintab changes, the flag for reparam is set.
*)

POSTUPDATE_ALGORITHM pLintabChanged ON PU_Task_7 WITH mpLintab^

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbReParam := TRUE;
mbReParamLight := TRUE;

// Calculate new limit for indicating sensor calibration error,
// lintabs are monotonic, limit should depend on highest value
mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintab^.LintabPoints.Point[mpLintab^.LintabPoints.uNoOfPoints].rY-
                             mpLintab^.LintabPoints.Point[1].rY);


;#END_EDIT_BLOCK END_ALGORITHM

(*
This algorithm reacts on changes of the lintab.
If the lintab changes, the flag for reparam is set.
*)

POSTUPDATE_ALGORITHM pOpenArrayLintabChanged ON PU_Task_7 WITH mpLintabPointArray^,mpiUsedLintabPoints^


VAR
 iPoints : UDINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbReParam := TRUE;
mbReParamLight := TRUE;

// Calculate new limit for indicating sensor calibration error,
// lintabs are monotonic, limit should depend on highest value
iPoints := MIN(mpiUsedLintabPoints^, miMaxLintabSize);
mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintabPointArray^[iPoints].rY - mpLintabPointArray^[1].rY);


;#END_EDIT_BLOCK END_ALGORITHM

(*
This algorithm reacts on a change of the velocity filter time.
The new filter time is copied and the flag for reparam is set.
*)

POSTUPDATE_ALGORITHM pFilterTimeChanged ON PU_Task_7 WITH mpVelFilterTime^

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mdFilterTime := mpVelFilterTime^;
mbReParam := TRUE;
mbReParamLight := TRUE;


;#END_EDIT_BLOCK END_ALGORITHM

(*
This algorithm reacts on a change of the velocity filter time.
The new filter time is copied and the flag for reparam is set.
*)

POSTUPDATE_ALGORITHM pPosFilterTimeChanged ON PU_Task_7 WITH mpPosFilterTime^

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mdT1Position := mpPosFilterTime^;
IF (mdT1Position > T#0s) THEN
   mT1PositionUsed := TRUE;
ELSE
   mT1PositionUsed := FALSE;
END_IF;

mbReParamLight := TRUE;


;#END_EDIT_BLOCK END_ALGORITHM

(*
This algorithm reacts on a changes of the _stat flag (error - flag).
If a sensor error is detected an alarm is set.
If the sensor error disappears, the alarm is resetted.

*)

POSTUPDATE_ALGORITHM pStateChanged ON PU_Task_7 WITH mpbRawValue_stat^,sv_bInitDone

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT mbValidStatFlag THEN
    RETURN;
END_IF;

mbSensorError := mpbRawValue_stat^;

IF mbSensorError THEN
    SET_ALARM(Name := erAnalogInput,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId,
              SubID3 := InstanceId,
              Param1 := msRawValue,
              Param2 := msHWPath);
    
ELSE
    RESET_ALARM(Name := erAnalogInput,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                SubID3 := InstanceId);
    
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
This algorithm checks if the given references are valid.
If a reference is not valid an alarm will be set.
*)

ALGORITHM aInit


VAR_INPUT
 sRawValue : STRING(64) (* endpointname of analog input  e.g.: 'Mold1.ai_Position' *);
 pLintab : REFTO KAPPL_LintabData (* pointer to lintab that should be used *);
 pdVelocityFilterTime : REFTO TIME (* reference to systemvariable that contains the filter time for velocity measuring *);
 pInstanceCounter : REFTO INT;
 pDerivationEstimateParam : REFTO tsDerivationEstimateParam;
 pdPositionFilterTime : REFTO TIME (* reference to systemvariable that contains the filter time for position measuring *);
 pLintabPointArray : REFTO tyLintabPoints (* reference to array with lintab points (open array!!) *);
 piUsedLintabPoints : REFTO UDINT (* reference to number of used lintab points *);
END_VAR

VAR
 state : KSYS_Status;
 sEndpointName : STRING(70);
 bInitDone : BOOL;
 mpInstanceCounter : REFTO INT;
 swoState : KSWO_Status;
 fuName : STRING(32);
 variableName : STRING(255);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bInitDone THEN
    //count instances of MeasureAI in superior fu
    IF CHECK_REF(pInstanceCounter^) THEN
        mpInstanceCounter := pInstanceCounter;
        InstanceId := mpInstanceCounter^ + 1;
        mpInstanceCounter^ := InstanceId; 
    END_IF;
    //copy reference of lintab and check if reference is valid
    mpLintab := pLintab;
    mpLintabPointArray := pLintabPointArray;
    mpiUsedLintabPoints := piUsedLintabPoints;
    IF CHECK_REF(mpLintab^) THEN
        mbValidLintabReference := TRUE;
    ELSIF CHECK_REF(mpLintabPointArray^) AND CHECK_REF(mpiUsedLintabPoints^) THEN
        mbValidLintabReference := TRUE;
        mbOpenArray := TRUE;
        miMaxLintabSize := GET_HIGH_BOUND(mpLintabPointArray^);
    ELSE
        SET_ALARM(Name := erInvalidLintabReference,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId);
    END_IF; 
    
    
    //get reference of endpoint and check if reference is valid
    msRawValue := sRawValue;
    mpRawValue := GET_SYNC_REFTO(sRawValue, T#0s, state);
    
    IF state = KSYS_Status_OK THEN
        mbValidEndpointReference := TRUE;
    ELSE
        SET_ALARM(Name := erInvalidEndpointReference,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                Param1 := msRawValue);
    END_IF;    
    
    
    //get reference of endpoint _stat - flag
    sEndpointName := CONCAT(sRawValue,'_stat');
    mpbRawValue_stat := GET_SYNC_REFTO(sEndpointName, T#0s, state);
    
    IF state = KSYS_Status_OK THEN
        mbValidStatFlag := TRUE;
       
        //get hw path of analog input
        msHWPath := FGetHWPath(sRawValue, TRUE);
    ELSE
        SET_ALARM(Name := erInvalidStatReference,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                Param1 := msRawValue);
    END_IF;
    
    //get reference of velocity filter time
    IF CHECK_REF(pdVelocityFilterTime^) THEN
        mdFilterTime := pdVelocityFilterTime^;
        mpVelFilterTime := pdVelocityFilterTime;
    ELSE
        // use default value if no reference is available
        // Filter with 12.5 Hz
        mdFilterTime := t#12ms732us;
    END_IF;

    //get reference derivation estimator data
    IF CHECK_REF(pDerivationEstimateParam^) THEN
        mDerivationEstimateParam := pDerivationEstimateParam^;
        mpDerivationEstimateParam := pDerivationEstimateParam;
        fuName := GET_MY_FU_NAME();
    
        variableName := CONCAT(fuName,'.',mDerivationEstimateParam.estimatorName,'.actPos');
        swoState := KSWO_AddVariable( Task := TaskInject,
                                      Name := variableName,
                                      Variable := mrActPosition);  
    
        variableName := CONCAT(fuName,'.',mDerivationEstimateParam.estimatorName,'.actPosEstimated');
        swoState := KSWO_AddVariable( Task := TaskInject,
                                      Name := variableName,
                                      Variable := mrActPositionEstimate);        

        variableName := CONCAT(fuName,'.',mDerivationEstimateParam.estimatorName,'.actVel');
        swoState := KSWO_AddVariable( Task := TaskInject,
                                      Name := variableName,
                                      Variable := mrActVelocity);        

        variableName := CONCAT(fuName,'.',mDerivationEstimateParam.estimatorName,'.actVelFiltered');
        swoState := KSWO_AddVariable( Task := TaskInject,
                                      Name := variableName,
                                      Variable := mrActVelocityFilt);        

        variableName := CONCAT(fuName,'.',mDerivationEstimateParam.estimatorName,'.actVelEstimated');
        swoState := KSWO_AddVariable( Task := TaskInject,
                                      Name := variableName,
                                      Variable := mrActVelocityEstimate);        
    ELSE
        //use default value if no reference is available
        mDerivationEstimateParam.bUseDerivationEstimator := FALSE;
        mDerivationEstimateParam.iN := 0;
        mDerivationEstimateParam.dT := T#0s;
        mDerivationEstimateParam.dMeasCycleTime := T#0s;
        mDerivationEstimateParam.iNu := 0;
    END_IF;
 
    IF CHECK_REF(pdPositionFilterTime^) THEN
        mdT1Position := pdPositionFilterTime^;
        IF (mdT1Position > T#0s) THEN
           mT1PositionUsed := TRUE;
        ELSE
           mT1PositionUsed := FALSE;
        END_IF;
        mpPosFilterTime := pdPositionFilterTime;
    ELSE
        mdT1Position := T#0s;
        mT1PositionUsed := FALSE;
    END_IF;
   
    bInitDone := TRUE;
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

(*
Allow lower limit monitoring of measured value. 
If monitoring enabled, alarm will be set if measured value smaller than mrMonLowFailureLimit.
The failure limit mrMonLowFailureLimit can be set to mrMonLimit by using rFailureFactor = 0.0.
If mbMonLimitation is true all measured values in the area [mrMonLowFailureLimit mrMonLowLimit] 
will be set to mrMonLowLimit.
*)

ALGORITHM aInitMonitoring


VAR_INPUT
 bEnable : BOOL;
 rLowLimit : REAL;
 bLimitation : BOOL;
 rFailureFactor : REAL := 0.01;
 bCheckLowerLimit : BOOL (* TRUE: set alarm if value is below the lower limit (calculated by rLowLimit, rFailureFactor and  given lintab) *);
END_VAR

VAR
 iPoints : UDINT;
END_VAR
#BEGIN_EDIT_BLOCK
mbMonEnable := bEnable;
mrMonLowLimit := rLowLimit;
mbCheckLowerLimit := bCheckLowerLimit;

// Limitation only with monitoring
mbMonLimitation := bLimitation AND mbMonEnable;
mrMonFailureFactor := rFailureFactor;
// Define lowest value without setting alarm by using maximum and minimum lintab points 
IF mbOpenArray THEN
   iPoints := MIN(mpiUsedLintabPoints^, miMaxLintabSize);
   mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintabPointArray^[iPoints].rY - mpLintabPointArray^[1].rY);
ELSE
   mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintab^.LintabPoints.Point[mpLintab^.LintabPoints.uNoOfPoints].rY-
                             mpLintab^.LintabPoints.Point[1].rY);
END_IF;   


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paInitDerivationEstimator ON TaskMid

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abDerivationEstimator.aInit(sDerivationEstimateParam := mDerivationEstimateParam);
mbDerivationEstimatorInitDone := TRUE;
STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pDerivationEstimateParamChanged ON PU_Task_7 WITH mpDerivationEstimateParam^

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mDerivationEstimateParam := mpDerivationEstimateParam^;
mbReParam := TRUE;


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 157 @Pou 25 
@@@BEG_Comment@@@
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

This AB is used for measuring of analog inputs.
It includes the following funcionalities:
- converting an analog input to a measure value by using a linearization table 
- automatic reparam after a change in lintab
- automatic detection of analog inut errors
- velocity measurement by using a filter
- fast and slow measuring


@FunctionID: S_KPIEC_ALASENS_01

@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
7 
@Var @RT(9)SET_ALARM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)RESET_ALARM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)GET_TASK_INTERVAL @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)GET_SYNC_REFTO @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)FGetHWPath @RT(0) @T @T @DERIVED 0 @F @RT(8)FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)GET_MY_FU_NAME @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)KSWO_AddVariable @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
7 
@Var @RT(23)cMeasureReductionFactor @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(1)5 @RT(103)reduction factor for measure block (reduction is active if no movement of this function unit is active) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(30)cApplPlasticsWrongLintabParams @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(4)-111 @RT(41)Lintabparams are wrong or not initialized 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)KCTRL_Ret_OK @RT(0) @T @T @DERIVED 0 @F @RT(9)KCTRL_Ret @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(27)cApplPlasticsWrongPT1Params @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(4)-121 @RT(39)PT1 params are wrong or not initialized 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(26)cApplPlasticsPT1CalcFailed @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(4)-122 @RT(29)cyclic PT1 calculation failed 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)cPointsLastAIValue @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(1)5 @RT(69)Number of Points for calculating mean value of the last analog inputs 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)KSYS_Status_OK @RT(0) @T @T @DERIVED 0 @F @RT(11)KSYS_Status @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(11)ABMeasureAI @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
51 
@Var @RT(11)sv_DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(9)PU_Task_7 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)TaskInject @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(7)TaskMid @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(13)erAnalogInput @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(14)erAnalogSensor @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(24)erInvalidLintabReference @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(26)erInvalidEndpointReference @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(22)erInvalidStatReference @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(15)erAnalogMeasure @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(8)mpLintab @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)mbReParam @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mpbRawValue_stat @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mbSensorError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)msRawValue @RT(0) @T @F @DT @RT(10)STRING(64) @RT(0) @T @T @STRING 0 @F @RT(2)64 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mbValidStatFlag @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)mpRawValue @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)fbMeasure @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)KAPPL_Plastics_Measure @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mbValidLintabReference @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)info if lintab reference is valid @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(24)mbValidEndpointReference @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)info if endpoint reference is valid @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mdFilterTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(36)filter time for velocity measurement @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mpVelFilterTime @RT(0) @T @T @REFTO 0 @T @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)mbMonEnable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)FALSE @RT(28)enable monitoring for rValue @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrMonLowLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)lower limit for monitoring @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mbMonLimitation @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(42)use limitation, set values to lower limit  @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mrMonFailureFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(37)define the area without setting alarm @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)mrMonLowFailureLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)lowest value without alarm @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mbReParamLight @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)mbRun @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)fbRTrigMeasureError @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(6)R_TRIG @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)miCount @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(64)Idle: counts up to cMeasureReductionFactor-1, NOT Idle: always 0 @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)InstanceId @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(25)mpDerivationEstimateParam @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(25)tsDerivationEstimateParam @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(24)mDerivationEstimateParam @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(25)tsDerivationEstimateParam @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(29)mbDerivationEstimatorInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrActPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)mrActPositionEstimate @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrActVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mrActVelocityFilt @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)mrActVelocityEstimate @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)abDerivationEstimator @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)ABDerivationEstimator @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)msHWPath @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mbCheckLowerLimit @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mdT1Position @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mT1PositionUsed @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mpPosFilterTime @RT(0) @T @T @REFTO 0 @T @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mpLintabPointArray @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(14)tyLintabPoints @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mpiUsedLintabPoints @RT(0) @T @T @REFTO 0 @T @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)mbOpenArray @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(56)is set to TRUE if an open array of lintab points is used @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)miMaxLintabSize @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

11 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(9)aRunLight @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
13 
@Var @RT(5)bIdle @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(51)if TRUE measurement is done with reduced cycle time @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)rValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)result of measuring (e.g. position) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(12)bSensorError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(12)sensor error @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(13)bMeasureError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(13)measure error @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(20)additional erro info @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(15)bLintabAlarmSet @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)bEndpointAlarmSet @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)bStatAlarmSet @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)bAnalogSensorError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)fbFTrigSensorError @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(6)F_TRIG @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)fbRTrigSensorError @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(6)R_TRIG @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aRun @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
27 
@Var @RT(5)bIdle @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(51)if TRUE measurement is done with reduced cycle time @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(21)bIgnoreStandDetection @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(43)if TRUE standstill detection is deactivated @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)rValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)result of measuring (e.g. position) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(9)rVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(66)change of the measure result per time (e.g. mm/s)(always positive) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(13)rVelocitySign @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(47)change of the measure result per time with sign @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(14)rValueEstimate @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(50)approximation of measured value with taylor series @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(18)rDiffValueEstimate @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(76)estimation of derivation of measured value with respect to time (drValue/dt) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(19)rDDiffValueEstimate @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(85)estimation of second derivation of measured value with respect to time (d2rValue/dt2) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(12)bSensorError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(12)sensor error @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(13)bMeasureError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(13)measure error @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(20)additional erro info @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(8)uCounter @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(9)bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)dCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rCycleTime @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)cycletime of this Task in seconds @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)rOldValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(52)result of measuring from the last call of this block @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)abKCTRL_PTn @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KCTRL_PTN @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)ptnParams @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KCTRL_PTN_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)rVelocityNotFiltered @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)rDelta @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)bAiIsConstant @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rMeanAIValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)uMeanAIValuesCounter @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(1)1 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)rMinDelta @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(6)9999.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)tyLastAIValues @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)tyLastAIValueArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bInitIdle @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)bInitNotIdle @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(14)pLintabChanged @STRUCTURED_TEXT 
@RT(0) @RT(9)mpLintab^ @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(23)pOpenArrayLintabChanged @STRUCTURED_TEXT 
@RT(0) @RT(40)mpLintabPointArray^,mpiUsedLintabPoints^ @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(7)iPoints @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(18)pFilterTimeChanged @STRUCTURED_TEXT 
@RT(0) @RT(16)mpVelFilterTime^ @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(21)pPosFilterTimeChanged @STRUCTURED_TEXT 
@RT(0) @RT(16)mpPosFilterTime^ @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(13)pStateChanged @STRUCTURED_TEXT 
@RT(0) @RT(30)mpbRawValue_stat^,sv_bInitDone @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(5)aInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
15 
@Var @RT(9)sRawValue @RT(0) @T @F @DT @RT(10)STRING(64) @RT(0) @T @T @STRING 0 @F @RT(2)64 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(55)endpointname of analog input  e.g.: 'Mold1.ai_Position' @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)pLintab @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(37)pointer to lintab that should be used @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)pdVelocityFilterTime @RT(0) @T @T @REFTO 0 @T @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(80)reference to systemvariable that contains the filter time for velocity measuring @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)pInstanceCounter @RT(0) @T @T @REFTO 0 @T @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(24)pDerivationEstimateParam @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(25)tsDerivationEstimateParam @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)pdPositionFilterTime @RT(0) @T @T @REFTO 0 @T @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(80)reference to systemvariable that contains the filter time for position measuring @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(5)state @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSYS_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)sEndpointName @RT(0) @T @F @DT @RT(10)STRING(70) @RT(0) @T @T @STRING 0 @F @RT(2)70 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mpInstanceCounter @RT(0) @T @T @REFTO 0 @T @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)swoState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSWO_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)fuName @RT(0) @T @F @DT @RT(10)STRING(32) @RT(0) @T @T @STRING 0 @F @RT(2)32 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)variableName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)pLintabPointArray @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(14)tyLintabPoints @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(52)reference to array with lintab points (open array!!) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)piUsedLintabPoints @RT(0) @T @T @REFTO 0 @T @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)reference to number of used lintab points @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(15)aInitMonitoring @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
6 
@Var @RT(7)bEnable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)rLowLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)bLimitation @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)rFailureFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)0.01 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)bCheckLowerLimit @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(109)TRUE: set alarm if value is below the lower limit (calculated by rLowLimit, rFailureFactor and  given lintab) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)iPoints @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(25)paInitDerivationEstimator @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(7)TaskMid @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(31)pDerivationEstimateParamChanged @STRUCTURED_TEXT 
@RT(0) @RT(26)mpDerivationEstimateParam^ @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Body 
@TL(121)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//don´t do measurement if references are not valid
IF NOT mbValidLintabReference OR NOT mbValidEndpointReference OR NOT mbValidStatFlag THEN
    
    IF NOT mbValidLintabReference AND NOT bLintabAlarmSet THEN
        SET_ALARM(Name := erInvalidLintabReference,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId);
        bLintabAlarmSet := TRUE;
    END_IF;
    
    IF NOT mbValidEndpointReference AND NOT bEndpointAlarmSet THEN
        SET_ALARM(Name := erInvalidEndpointReference,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId,
              Param1 := msRawValue);
        bEndpointAlarmSet := TRUE;
    END_IF;
    
    IF NOT mbValidStatFlag AND NOT bStatAlarmSet THEN
        SET_ALARM(Name := erInvalidStatReference,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                Param1 := msRawValue);
        bStatAlarmSet := TRUE;
    END_IF;
    mbRun := FALSE;
    RETURN;        
END_IF;


IF NOT bInitDone OR mbReParamLight THEN
    //reparam measure block
    IF mbOpenArray THEN
       FOR i := 1 TO miMaxLintabSize DO
          fbMeasure.Lintab.LintabPoints.Point[i].rX := mpLintabPointArray^[i].rX;
          fbMeasure.Lintab.LintabPoints.Point[i].rY := mpLintabPointArray^[i].rY;
       END_FOR;
       fbMeasure.Lintab.LintabPoints.uNoOfPoints := MIN(mpiUsedLintabPoints^, miMaxLintabSize);
    ELSE
       fbMeasure.Lintab := mpLintab^;
    END_IF;
       
    fbMeasure(LintabUsed := TRUE,
              ReParam := TRUE,
              T1 := mdT1Position,
              T1Used := mT1PositionUsed);
    
    mbReParamLight := FALSE;
    bInitDone := TRUE;
END_IF;


//do fast measurement only if movement is active
//if movement is not active then measurement should be done every cMeasureReduction - cycle 
IF NOT bIdle OR miCount = (cMeasureReductionFactor - 1) THEN
    IF NOT mbSensorError THEN
        fbMeasure(RawValue := mpRawValue^,
                  ReParam := FALSE,
                  OutputValue => rValue,
                  Error => bMeasureError,
                  ErrorInfo => iErrorInfo);
        // Allow only Analog Input values >= mrMonLowLimit. Set values to zero in small area 
        // [mrMonLowFailureLimit mrMonLowLimit]
        // and set error, if the value is smaller than mrMonLowFailureLimit 
        IF mbMonEnable THEN
            IF mbCheckLowerLimit THEN
               bAnalogSensorError := FALSE;
               IF rValue < mrMonLowFailureLimit THEN
                  bAnalogSensorError := TRUE;
                  iErrorInfo := cApplPlasticsWrongLintabParams;
               END_IF;
            END_IF;
            
            IF mbMonLimitation THEN
                rValue := MAX(rValue, mrMonLowLimit);
            END_IF;
        END_IF;       
    END_IF;
    miCount := 0;
ELSE
    //increase counter
    miCount := miCount + 1;
END_IF;
//cyclic part
bSensorError := mbSensorError;

//set alarm if error occurs during measure
fbRTrigMeasureError(CLK := bMeasureError);
IF fbRTrigMeasureError.Q THEN
    SET_ALARM(Name := erAnalogMeasure,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId,
              SubID3 := iErrorInfo);
END_IF;

// Set alarm, if value not allowed
IF mbMonEnable AND mbCheckLowerLimit THEN
    //set alarm if error occurs during measure
    fbRTrigSensorError(CLK := bAnalogSensorError);
    IF fbRTrigSensorError.Q THEN
        SET_ALARM(Name := erAnalogSensor,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                Param1 := msRawValue);
    END_IF;
    // Reset alarm after measured value is greater than limit,
    // user reset still neccessary
    fbFTrigSensorError(CLK := bAnalogSensorError);
    IF fbFTrigSensorError.Q THEN
        RESET_ALARM(Name := erAnalogSensor,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId);
    END_IF;
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(7)
Following functions are realized in this algorithm:

1) fast and slow measuring by using the given lintab
2) errorhandling

This is a light version of algorithm aRun, because it is without the measuring of the velocity.
This algorithm has to be used for measure pressure or pure position. So you can save performance.  
@@@END_Comment@@@ 

@BEG_Body 
@TL(159)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
mbRun := TRUE;
aRunLight(bIdle := bIdle,
          rValue => rValue, 
          bSensorError => bSensorError, 
          bMeasureError => bMeasureError, 
          iErrorInfo => iErrorInfo);
// Part for calculating differential quotient (e.g. velocity)
IF mbRun THEN
    IF NOT bInitDone OR mbReParam THEN
        IF NOT bInitDone THEN
            //get cycle time
            dCycleTime :=  GET_TASK_INTERVAL();
            rCycleTime := (LINT_TO_REAL(TIME_TO_LINT(dCycleTime))) / 1000000.0;
        END_IF;
        
        //filter initialization
        // Test shows good results by using
        // 12.5 Hz and order 2
        ptnParams.uN := 2;
        ptnParams.rK := 1.0;
        ptnParams.dT1 := mdFilterTime;
        ptnParams.dT2 := mdFilterTime;
        abKCTRL_PTn.Par(dCycleTime := dCycleTime,
                        Param := ptnParams);
        IF (abKCTRL_PTn.Par.parStatus <> KCTRL_Ret_OK) THEN
            bMeasureError := TRUE;
            iErrorInfo := cApplPlasticsWrongPT1Params;
            SET_ALARM(Name := erAnalogMeasure,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                SubID3 := iErrorInfo);
        ELSE
            bMeasureError := FALSE;
        END_IF;
        abKCTRL_PTn.Init(rOutVal := 0.0);      
    
        // init derivation estimator
        IF mDerivationEstimateParam.bUseDerivationEstimator THEN
            mbDerivationEstimatorInitDone := FALSE;
            mDerivationEstimateParam.dMeasCycleTime := dCycleTime;
            START_PROCESS_ALGORITHM(paInitDerivationEstimator);
        END_IF; 
    
        rValueEstimate := 0.0;
        rDiffValueEstimate := 0.0;
        rDDiffValueEstimate := 0.0;
    
        rOldValue := rValue;
        mbReParam := FALSE;
        bInitDone := TRUE;
    END_IF;
    
    
   //do fast measurement only if movement is active
   //if movement is not active then measurement should be done every cMeasureReduction - cycle 
   IF (NOT bIdle OR miCount = 0) AND NOT mbSensorError THEN
       
      //velocity measurement (without abs-function)
      IF bIdle THEN
         IF (NOT bInitIdle) THEN
            bInitIdle := TRUE;
            bInitNotIdle := FALSE;
            abKCTRL_PTn.Par(dCycleTime := MULTIME(dCycleTime, cMeasureReductionFactor));
            abKCTRL_PTn.Init(rOutVal := abKCTRL_PTn.Calculate.rOutVal);
         END_IF;            
         rVelocityNotFiltered := (rValue - rOldValue) / (rCycleTime * DINT_TO_REAL(cMeasureReductionFactor));         
      ELSE
         IF (NOT bInitNotIdle) THEN
            bInitIdle := FALSE;
            bInitNotIdle := TRUE;
            abKCTRL_PTn.Par(dCycleTime := dCycleTime);
            abKCTRL_PTn.Init(rOutVal := abKCTRL_PTn.Calculate.rOutVal);
         END_IF;            
         rVelocityNotFiltered := (rValue - rOldValue) / rCycleTime;
      END_IF;
      //use a filter for velocity measurement
      abKCTRL_PTn.Calculate(rInVal := rVelocityNotFiltered);
      IF (abKCTRL_PTn.Calculate.calcStatus <> KCTRL_Ret_OK) THEN
         bMeasureError := TRUE;
         iErrorInfo := cApplPlasticsPT1CalcFailed;
      ELSE
         rVelocity := abKCTRL_PTn.Calculate.rOutVal;              
             
         // standstill-detection
         // Set velocity to zero if Analog Input is not changing
         // Take more than two points, otherwise a small velocity (e.g. < 6.5% v_max) 
         // would also be set to zero all time of injection process            
             
         // find difference of 1 bit resolution 
         rDelta := ABS(rValue - rOldValue);
         IF (rDelta < rMinDelta) AND (rDelta > 0.0) THEN
            rMinDelta := rDelta;  
         END_IF;     
         // cyclic saving of screw position  
         // cPointsLastAIValue = 5 shows good results by tests
         IF uMeanAIValuesCounter >= cPointsLastAIValue THEN
            uMeanAIValuesCounter := 1;
         ELSE
            uMeanAIValuesCounter := uMeanAIValuesCounter + 1;
         END_IF;          
             
         // Calculating Mean Value in every step new,
         // because by subtracting old value and adding new value
         // there will be numerical noise after few minutes
         tyLastAIValues[uMeanAIValuesCounter] := rValue;
         rMeanAIValue := 0.0;
         FOR uCounter := 1 TO cPointsLastAIValue DO
            rMeanAIValue := rMeanAIValue + tyLastAIValues[uCounter];
         END_FOR;
         rMeanAIValue := rMeanAIValue / DINT_TO_REAL(cPointsLastAIValue);
               
         bAiIsConstant := TRUE; 
         // Start standstill detection only if filtered velocity < v_min_Timediff
         IF (ABS(rVelocity) > (rMinDelta / rCycleTime)) THEN
            bAiIsConstant := bAiIsConstant AND FALSE;
         END_IF;
         FOR uCounter := 1 TO cPointsLastAIValue DO
            IF (ABS(tyLastAIValues[uCounter] - rMeanAIValue) >= rMinDelta ) THEN
               bAiIsConstant := bAiIsConstant AND FALSE;
            END_IF;
         END_FOR; 
            IF bAiIsConstant AND NOT bIgnoreStandDetection THEN
            rVelocity := 0.0;
         END_IF;
         // use sign, don't need estimator if only actual velocity but not acceleration calculated
         rVelocitySign := rVelocity;
         rVelocity := ABS(rVelocity);
      END_IF; 
      rOldValue := rValue;  
        
      //velocity estimator
      IF mDerivationEstimateParam.bUseDerivationEstimator AND mbDerivationEstimatorInitDone THEN
         abDerivationEstimator.aRun(rValue := rValue);
         rValueEstimate := abDerivationEstimator.aRun.rValueEstimate;
         rDiffValueEstimate := abDerivationEstimator.aRun.rDiffValueEstimate;
         rDDiffValueEstimate := abDerivationEstimator.aRun.rDDiffValueEstimate;
      END_IF;    
   END_IF;
END_IF;
//set alarm if error occurs during measure
fbRTrigMeasureError(CLK := bMeasureError);
IF fbRTrigMeasureError.Q THEN
    SET_ALARM(Name := erAnalogMeasure,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId,
              SubID3 := iErrorInfo);
END_IF;

// Variables for SWO Server
mrActPosition := rValue;
mrActPositionEstimate := rValueEstimate;
mrActVelocity := rVelocityNotFiltered;
mrActVelocityFilt := rVelocity;
mrActVelocityEstimate := rDiffValueEstimate;

@END_Body 

@@@BEG_Comment@@@ 
@TL(5)
Following functions are realized in this algorithm:

1) fast and slow measuring by using the given lintab
2) velocity measuring
3) errorhandling
@@@END_Comment@@@ 

@BEG_Body 
@TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbReParam := TRUE;
mbReParamLight := TRUE;

// Calculate new limit for indicating sensor calibration error,
// lintabs are monotonic, limit should depend on highest value
mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintab^.LintabPoints.Point[mpLintab^.LintabPoints.uNoOfPoints].rY-
                             mpLintab^.LintabPoints.Point[1].rY);

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
This algorithm reacts on changes of the lintab.
If the lintab changes, the flag for reparam is set.
@@@END_Comment@@@ 

@BEG_Body 
@TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbReParam := TRUE;
mbReParamLight := TRUE;

// Calculate new limit for indicating sensor calibration error,
// lintabs are monotonic, limit should depend on highest value
iPoints := MIN(mpiUsedLintabPoints^, miMaxLintabSize);
mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintabPointArray^[iPoints].rY - mpLintabPointArray^[1].rY);

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
This algorithm reacts on changes of the lintab.
If the lintab changes, the flag for reparam is set.
@@@END_Comment@@@ 

@BEG_Body 
@TL(9)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mdFilterTime := mpVelFilterTime^;
mbReParam := TRUE;
mbReParamLight := TRUE;

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
This algorithm reacts on a change of the velocity filter time.
The new filter time is copied and the flag for reparam is set.
@@@END_Comment@@@ 

@BEG_Body 
@TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mdT1Position := mpPosFilterTime^;
IF (mdT1Position > T#0s) THEN
   mT1PositionUsed := TRUE;
ELSE
   mT1PositionUsed := FALSE;
END_IF;

mbReParamLight := TRUE;

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
This algorithm reacts on a change of the velocity filter time.
The new filter time is copied and the flag for reparam is set.
@@@END_Comment@@@ 

@BEG_Body 
@TL(27)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT mbValidStatFlag THEN
    RETURN;
END_IF;

mbSensorError := mpbRawValue_stat^;

IF mbSensorError THEN
    SET_ALARM(Name := erAnalogInput,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId,
              SubID3 := InstanceId,
              Param1 := msRawValue,
              Param2 := msHWPath);
    
ELSE
    RESET_ALARM(Name := erAnalogInput,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                SubID3 := InstanceId);
    
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(4)
This algorithm reacts on a changes of the _stat flag (error - flag).
If a sensor error is detected an alarm is set.
If the sensor error disappears, the alarm is resetted.

@@@END_Comment@@@ 

@BEG_Body 
@TL(125)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bInitDone THEN
    //count instances of MeasureAI in superior fu
    IF CHECK_REF(pInstanceCounter^) THEN
        mpInstanceCounter := pInstanceCounter;
        InstanceId := mpInstanceCounter^ + 1;
        mpInstanceCounter^ := InstanceId; 
    END_IF;
    //copy reference of lintab and check if reference is valid
    mpLintab := pLintab;
    mpLintabPointArray := pLintabPointArray;
    mpiUsedLintabPoints := piUsedLintabPoints;
    IF CHECK_REF(mpLintab^) THEN
        mbValidLintabReference := TRUE;
    ELSIF CHECK_REF(mpLintabPointArray^) AND CHECK_REF(mpiUsedLintabPoints^) THEN
        mbValidLintabReference := TRUE;
        mbOpenArray := TRUE;
        miMaxLintabSize := GET_HIGH_BOUND(mpLintabPointArray^);
    ELSE
        SET_ALARM(Name := erInvalidLintabReference,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId);
    END_IF; 
    
    
    //get reference of endpoint and check if reference is valid
    msRawValue := sRawValue;
    mpRawValue := GET_SYNC_REFTO(sRawValue, T#0s, state);
    
    IF state = KSYS_Status_OK THEN
        mbValidEndpointReference := TRUE;
    ELSE
        SET_ALARM(Name := erInvalidEndpointReference,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                Param1 := msRawValue);
    END_IF;    
    
    
    //get reference of endpoint _stat - flag
    sEndpointName := CONCAT(sRawValue,'_stat');
    mpbRawValue_stat := GET_SYNC_REFTO(sEndpointName, T#0s, state);
    
    IF state = KSYS_Status_OK THEN
        mbValidStatFlag := TRUE;
       
        //get hw path of analog input
        msHWPath := FGetHWPath(sRawValue, TRUE);
    ELSE
        SET_ALARM(Name := erInvalidStatReference,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                Param1 := msRawValue);
    END_IF;
    
    //get reference of velocity filter time
    IF CHECK_REF(pdVelocityFilterTime^) THEN
        mdFilterTime := pdVelocityFilterTime^;
        mpVelFilterTime := pdVelocityFilterTime;
    ELSE
        // use default value if no reference is available
        // Filter with 12.5 Hz
        mdFilterTime := t#12ms732us;
    END_IF;

    //get reference derivation estimator data
    IF CHECK_REF(pDerivationEstimateParam^) THEN
        mDerivationEstimateParam := pDerivationEstimateParam^;
        mpDerivationEstimateParam := pDerivationEstimateParam;
        fuName := GET_MY_FU_NAME();
    
        variableName := CONCAT(fuName,'.',mDerivationEstimateParam.estimatorName,'.actPos');
        swoState := KSWO_AddVariable( Task := TaskInject,
                                      Name := variableName,
                                      Variable := mrActPosition);  
    
        variableName := CONCAT(fuName,'.',mDerivationEstimateParam.estimatorName,'.actPosEstimated');
        swoState := KSWO_AddVariable( Task := TaskInject,
                                      Name := variableName,
                                      Variable := mrActPositionEstimate);        

        variableName := CONCAT(fuName,'.',mDerivationEstimateParam.estimatorName,'.actVel');
        swoState := KSWO_AddVariable( Task := TaskInject,
                                      Name := variableName,
                                      Variable := mrActVelocity);        

        variableName := CONCAT(fuName,'.',mDerivationEstimateParam.estimatorName,'.actVelFiltered');
        swoState := KSWO_AddVariable( Task := TaskInject,
                                      Name := variableName,
                                      Variable := mrActVelocityFilt);        

        variableName := CONCAT(fuName,'.',mDerivationEstimateParam.estimatorName,'.actVelEstimated');
        swoState := KSWO_AddVariable( Task := TaskInject,
                                      Name := variableName,
                                      Variable := mrActVelocityEstimate);        
    ELSE
        //use default value if no reference is available
        mDerivationEstimateParam.bUseDerivationEstimator := FALSE;
        mDerivationEstimateParam.iN := 0;
        mDerivationEstimateParam.dT := T#0s;
        mDerivationEstimateParam.dMeasCycleTime := T#0s;
        mDerivationEstimateParam.iNu := 0;
    END_IF;
 
    IF CHECK_REF(pdPositionFilterTime^) THEN
        mdT1Position := pdPositionFilterTime^;
        IF (mdT1Position > T#0s) THEN
           mT1PositionUsed := TRUE;
        ELSE
           mT1PositionUsed := FALSE;
        END_IF;
        mpPosFilterTime := pdPositionFilterTime;
    ELSE
        mdT1Position := T#0s;
        mT1PositionUsed := FALSE;
    END_IF;
   
    bInitDone := TRUE;
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
This algorithm checks if the given references are valid.
If a reference is not valid an alarm will be set.
@@@END_Comment@@@ 

@BEG_Body 
@TL(18)
mbMonEnable := bEnable;
mrMonLowLimit := rLowLimit;
mbCheckLowerLimit := bCheckLowerLimit;

// Limitation only with monitoring
mbMonLimitation := bLimitation AND mbMonEnable;
mrMonFailureFactor := rFailureFactor;
// Define lowest value without setting alarm by using maximum and minimum lintab points 
IF mbOpenArray THEN
   iPoints := MIN(mpiUsedLintabPoints^, miMaxLintabSize);
   mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintabPointArray^[iPoints].rY - mpLintabPointArray^[1].rY);
ELSE
   mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintab^.LintabPoints.Point[mpLintab^.LintabPoints.uNoOfPoints].rY-
                             mpLintab^.LintabPoints.Point[1].rY);
END_IF;   

@END_Body 

@@@BEG_Comment@@@ 
@TL(5)
Allow lower limit monitoring of measured value. 
If monitoring enabled, alarm will be set if measured value smaller than mrMonLowFailureLimit.
The failure limit mrMonLowFailureLimit can be set to mrMonLimit by using rFailureFactor = 0.0.
If mbMonLimitation is true all measured values in the area [mrMonLowFailureLimit mrMonLowLimit] 
will be set to mrMonLowLimit.
@@@END_Comment@@@ 

@BEG_Body 
@TL(9)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abDerivationEstimator.aInit(sDerivationEstimateParam := mDerivationEstimateParam);
mbDerivationEstimatorInitDone := TRUE;
STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mDerivationEstimateParam := mpDerivationEstimateParam^;
mbReParam := TRUE;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
