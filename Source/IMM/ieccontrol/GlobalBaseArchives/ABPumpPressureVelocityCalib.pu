(*
Do automatic Pump pressure/velocity calibration
*)

IMPORT_OVER_LISTFILE
 GET_MY_FU_NAME
, KSWO_AddVariable
, KFILE_IsDir
, KFILE_MakeDir
, KFILE_Open
, KFILE_Write
, KFILE_Close
, KAPPL_CalibSelection_PQ_P
, KAPPL_CalibSelection_PQ_V
, KAPPL_CalibSelection_Servo_P
, KAPPL_CalibSelection_Servo_V
, MIN_TOLERANCE
, CALIB_FILE_PATH
, KFILE_Status_NOTOK
, KFILE_Mode_ReadWriteDelete
, ABConstMovementForAutoCalib
, tsVelPre
, KAPPL_LintabData3D
, KCTRL_Stable_Param
, KAPPL_Plastics_AutoCalibration
, tMoveIdent
, KSWO_Status
, R_TRIG
, FBAutoCalibLog
, KAPPL_CalibParam
, TON
, KFILE_Status
, KFILE_Open_Data

END_IMPORT

ALGORITHM_BLOCK ABPumpPressureVelocityCalib #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_iCalibratingPump : DINT (* number of pump which is actually calibrating *);
END_VAR

SYSTEM_OBJECT
 TaskSlow : TASK;
END_OBJECT

VAR
 abConstMovement : ABConstMovementForAutoCalib;
 abConstMovementServo : ABConstMovementForAutoCalib;
 mpConstant : REFTO tsVelPre (* pointer to systemvariable that contains profile *);
 mpConstantServo : REFTO tsVelPre (* pointer to systemvariable that contains profile *);
 mpTmpLintab : REFTO KAPPL_LintabData3D;
 mpbPumpPreVelCalibDone : REFTO BOOL;
 mpbPumpPreVelCalibAnotherStepN : REFTO BOOL;
 mrMaxVoltage : REAL;
 mrMinVoltage : REAL;
 mpPressureStableParam : REFTO KCTRL_Stable_Param;
 mpVelocityStableParam : REFTO KCTRL_Stable_Param;
 mbStarted : BOOL;
 mbRampDown : BOOL;
 mbActive : BOOL;
 mOutputV : REAL (* Calculated output for pressure, swo recording *);
 mOutputP : REAL (* Calculated output for pressure, swo recording *);
 mOutputServo : REAL (* Calculated output for servo valve, swo recording *);
 mMeasDone : BOOL;
 mbMeasRdy : BOOL;
 mrActVel : REAL;
 mrActPosition : REAL;
 mrActPressure : REAL;
 mpbDebugCalibration : REFTO BOOL (* RefTo sv_TraceLevel.bDebugCalibration *);
 mbConstServoLinked : BOOL;
 fbAutoCalib : KAPPL_Plastics_AutoCalibration;
 mrSysPressure : REAL;
 mbMeasActive : BOOL;
 mprMaxVoltageVelocity : REFTO REAL;
 mbMaxVoltageVelocityValid : BOOL;
 mprMaxVoltagePressure : REFTO REAL;
 mbMaxVoltagePressureValid : BOOL;
 mrMaxVoltageAbs : REAL;
 mprMaxVoltageVelocityPresCalib : REFTO REAL;
 mbMaxVoltageVelocityPresValid : BOOL;
 mbCalcActive : BOOL;
 mbCalcDone : BOOL;
 msFuName : STRING(32);
END_VAR

PROCESS_ALGORITHM paCalc ON TaskSlow

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbAutoCalib(MeasureActive := FALSE);
IF fbAutoCalib.NextStartReady OR fbAutoCalib.Done OR fbAutoCalib.Error THEN
   mbCalcDone := TRUE;
   STOP_PROCESS_ALGORITHM();
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

(*
Initialisation 
*)

ALGORITHM aInit


VAR_INPUT
 pConst : REFTO tsVelPre (* pointer to systemvariable that contains profile *);
 pConstServo : REFTO tsVelPre (* pointer to systemvariable that contains profile *);
 MoveId : tMoveIdent (* moveId of constant movement *);
 pTmpLintab : REFTO KAPPL_LintabData3D (* reference to detected Lintab *);
 pbPumpPreVelCalibAnotherStepN : REFTO BOOL (* another movement necessary *);
 pbPumpPreVelCalibDone : REFTO BOOL (* calibration ready *);
 pPressureStableParam : REFTO KCTRL_Stable_Param (* stable paramater for pressure calibration *);
 pVelocityStableParam : REFTO KCTRL_Stable_Param (* stable paramater for velocity calibration *);
 debugInstanceName : STRING(255) (* instance name for debugging (used for Kemro.Scope) *);
 debugTask : TASK (* debug task used for Kemro.Scope *);
 pbDebugCalibration : REFTO BOOL (* debug calibration activated *);
END_VAR

VAR
 status : KSWO_Status;
 variableName : STRING(255);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mpTmpLintab := pTmpLintab;
mpbPumpPreVelCalibDone := pbPumpPreVelCalibDone;
mpbPumpPreVelCalibAnotherStepN := pbPumpPreVelCalibAnotherStepN;

mpConstant := pConst;
abConstMovement.aInit(pConst := mpConstant,
                      MoveId := MoveId);

IF CHECK_REF(pConstServo^) THEN
   mpConstantServo := pConstServo;
   abConstMovementServo.aInit(pConst := mpConstantServo,
                              MoveId := MoveId);
   mbConstServoLinked := TRUE;
ELSE
   mbConstServoLinked := FALSE;
END_IF;
mpPressureStableParam := pPressureStableParam;
mpVelocityStableParam := pVelocityStableParam;

msFuName := GET_MY_FU_NAME();

mpbDebugCalibration := pbDebugCalibration; 
// Add variables to Kemro.Scope if debugging is selected
IF mpbDebugCalibration^ THEN
   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mbStarted');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mbStarted);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mbRampDown');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mbRampDown);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mbActive');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mbActive);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mOutputV');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mOutputV);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mOutputP');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mOutputP);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mOutputServo');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mOutputServo);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mMeasDone');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mMeasDone);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mbMeasrdy');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mbMeasRdy);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mrActVel');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mrActVel);
   
   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mrActPosition');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mrActPosition);
   
   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mrActPressure');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mrActPressure);
  
   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mrSysPressure');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mrSysPressure);
   
   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mbMeasActive');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mbMeasActive);
END_IF;




;#END_EDIT_BLOCK END_ALGORITHM

(*
calibrates the pump pressure or velocity lintab
for calibrating of the pressure lintab a backpressure sensor is needed
for calibrating of the velocity lintab the injection transducer needs to be setup properly

*)

ALGORITHM aRun


VAR_INPUT
 bStart : BOOL (* start constant calib block *);
 bStop : BOOL (* stop constant calib block *);
 rActPosition : REAL (* actual position *);
 rMaxPosition : REAL (* maximum stroke for end pos calculation *);
 rActVel : REAL (* actual velocity *);
 rActPressure : REAL (* actual pressure *);
 rSysPressure : REAL (* system pressure (only relevant when servo valve calib is done) *);
 bIsPressureCalib : BOOL (* pressure calibration activated *);
 bIsVelocityCalib : BOOL (* pressure calibration activated *);
 bIsServoValveCalib : BOOL (* servo valve calibration activated *);
 bDirection : BOOL (* TRUE: position is getting bigger; FALSE: position is getting smaller *);
 dDelayTimePump : TIME (* Delay Time between preoutput and  constoutput *);
 dDelayTimeServo : TIME (* Delay Time between preoutput and  constoutput *);
 rLimitPositionFactor : REAL (* Factor for max position during velocity calibration *);
END_VAR

VAR_OUTPUT
 bActive : BOOL (* movement is active *);
 rOutputPre : REAL (* pressure output *);
 rOutputVel : REAL (* velocity output *);
 rOutputServo : REAL (* output to servo valve *);
 rMaxVelocityAbs : REAL (* max. measured velocity [cm³/s] *);
 rMaxPressureAbs : REAL (* max. measured pressure [bar] *);
 bPreOutputReached : BOOL (* preoutput ready *);
 bError : BOOL (* flag to indicate if error occured *);
 iErrorInfo : DINT (* additional error info *);
END_VAR

VAR
 fbREdge_Start : R_TRIG;
 bRampDown : BOOL (* Stop const movement *);
 bPressureCalib : BOOL;
 fbLog : FBAutoCalibLog (* Debug *);
 printtmp : DINT (* Debug *);
 bStarted : BOOL;
 Param : KAPPL_CalibParam (* Calibration parrameters *);
 rMinPosFactor : REAL := 0.1 (* Dont do velocity movement  until end of screw *);
 bDoAbsVelocityCalib : BOOL;
 bGetMaxPressure : BOOL;
 pStableParam : REFTO KCTRL_Stable_Param (* Stabliization conditions for recording *);
 bMeasRdy : BOOL (* Measurement ready *);
 uNoOfAequidistantPoints : UDINT := 13 (* Number of aequidistant points *);
 fbMeasDelay : TON;
 bUSetReached : BOOL := FALSE;
 rLimitPosition : REAL (* Max. position of measuring *);
 rStopPosition : REAL (* Max. position for valve closing *);
 rVelStopRamp : REAL;
 rPresStopRamp : REAL;
 rServoStopRamp : REAL;
 bCheckStopPosition : BOOL := FALSE;
 fbRTrigStop : R_TRIG;
 sCalib : STRING(32);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bStart THEN // Reset Errors
   bError := FALSE;
   iErrorInfo := 0;
END_IF; 
fbREdge_Start(CLK := bStart);
IF fbREdge_Start.Q THEN
   // reset Error
   bError := FALSE;
   iErrorInfo := 0;
   
   bPressureCalib := bIsPressureCalib;
   fbMeasDelay(IN := FALSE, PT :=MAX(dDelayTimePump,dDelayTimeServo));
   
   // validate calib
   IF NOT (bIsPressureCalib XOR bIsVelocityCalib) THEN
      printtmp := Print('only Pressure or Velocity calib can be active at a time');
      bActive := FALSE;
      bError := TRUE;
   END_IF;
   bRampDown := FALSE;
   bMeasRdy := FALSE;
   bStarted := TRUE;
   bActive := TRUE;
   mbCalcActive := FALSE; 
   bPreOutputReached := FALSE;
   // Take 13 Points, because than the aequidistant points are 0V, 1V, ..., 10V
   Param.uNoOfPoints := uNoOfAequidistantPoints;
    
   IF (mbMaxVoltagePressureValid) THEN
      Param.rMaxVoltagePressure := mprMaxVoltagePressure^ ;
   ELSE
      Param.rMaxVoltagePressure := mrMaxVoltageAbs;  
   END_IF;
   IF (mbMaxVoltageVelocityValid) THEN
      Param.rMaxVoltageVelocity := mprMaxVoltageVelocity^;
   ELSE
      Param.rMaxVoltageVelocity := mrMaxVoltageAbs;
   END_IF; 

    
   IF bPressureCalib AND NOT bIsServoValveCalib THEN
      Param.LintabType := KAPPL_CalibSelection_PQ_P;
      pStableParam := mpPressureStableParam; 
      mrMaxVoltage := Param.rMaxVoltagePressure; 
      IF mbMaxVoltageVelocityPresValid THEN
         Param.rMaxVoltageVelocity := mprMaxVoltageVelocityPresCalib^;
      END_IF; 
   ELSIF bIsVelocityCalib AND NOT bIsServoValveCalib THEN
      Param.LintabType := KAPPL_CalibSelection_PQ_V;
      pStableParam := mpVelocityStableParam;
      mrMaxVoltage := Param.rMaxVoltageVelocity; 
   ELSIF bPressureCalib AND bIsServoValveCalib THEN
      Param.LintabType := KAPPL_CalibSelection_Servo_P;
      pStableParam := mpPressureStableParam;
      mrMaxVoltage := mrMaxVoltageAbs; 
      IF mbMaxVoltageVelocityPresValid THEN
         Param.rMaxVoltageVelocity := mprMaxVoltageVelocityPresCalib^;
      END_IF; 
   ELSIF bIsVelocityCalib AND bIsServoValveCalib THEN
      Param.LintabType := KAPPL_CalibSelection_Servo_V;
      pStableParam := mpVelocityStableParam;
      mrMaxVoltage := mrMaxVoltageAbs; 
   ELSE
      printtmp := Print('invalid calib selection');
      bActive := FALSE;
      bError := TRUE;
      //iErrorInfo := ??? ;//FIXME
   END_IF;
   
   Param.rMaxVoltage := mrMaxVoltage;
   Param.rMinVoltage := mrMinVoltage;
    
    
   // reset const movement
   abConstMovement.aRun(bStart := FALSE);
   IF mbConstServoLinked THEN
      mpConstantServo^.Pressure.rMinOutput := mrMinVoltage;
      mpConstantServo^.Velocity.rMinOutput := mrMinVoltage;
      abConstMovementServo.aRun(bStart := FALSE);
   END_IF;

    
   // only do reinit on the first time doing the calib
   IF NOT mpbPumpPreVelCalibAnotherStepN^ THEN
      fbAutoCalib(ReParam := TRUE, 
                  MeasureActive := FALSE, 
                  Param := Param, 
                  pStableParam := pStableParam, 
                  bDebugCalibration := mpbDebugCalibration^,
                  DecelerationRamp := mpConstant^.Velocity.Output.rRamp);
      fbAutoCalib(ReParam := FALSE, MeasureActive := FALSE);
       
      mpConstant^.Velocity.Output.rOutputValue := fbAutoCalib.PumpVelocityVoltage;
      mpConstant^.Pressure.Output.rOutputValue := fbAutoCalib.PumpPressureVoltage;
      
      IF mbConstServoLinked THEN
         mpConstantServo^.Velocity.Output.rOutputValue := fbAutoCalib.ServoValveVoltage;
      END_IF;
   
      //this is the first init so we do a absolute velocity calib
      IF bIsVelocityCalib THEN
         bDoAbsVelocityCalib := TRUE;
         sCalib := 'velocity';
      ELSE
         bGetMaxPressure := TRUE;
         sCalib := 'pressure';
      END_IF;
   END_IF;
   
   mpbPumpPreVelCalibAnotherStepN^ := FALSE;
   mpbPumpPreVelCalibDone^ := FALSE;
   
    IF (rLimitPositionFactor > 0.0) AND (rLimitPositionFactor <= 1.0) THEN
        rMinPosFactor := 1.0 -  rLimitPositionFactor;
    ELSE
        rMinPosFactor := 0.1; // use default value if limit not set
    END_IF;
 
    IF bDirection THEN 
        rLimitPosition := rMaxPosition - rMinPosFactor * rMaxPosition; 
        rStopPosition  := rMaxPosition - 0.5 * rMinPosFactor * rMaxPosition; 
    ELSE
        rLimitPosition := rMinPosFactor * rMaxPosition; 
        rStopPosition  := 0.5 * rMinPosFactor * rMaxPosition; 
    END_IF;

    IF (NOT bPressureCalib) AND (ABS(rLimitPosition - rStopPosition)>0.0) THEN
        bCheckStopPosition := TRUE;
    ELSE
        bCheckStopPosition := FALSE;
    END_IF;    
END_IF;

fbRTrigStop(CLK := bStop);

IF fbRTrigStop.Q THEN
   //start ramping down
   bStarted := FALSE;
   bRampDown := TRUE;
END_IF;

fbMeasDelay(IN := bStarted, PT :=MAX(dDelayTimePump,dDelayTimeServo));    

IF bStarted THEN
   // const movement active
   abConstMovement.aRun(bStart := bStart,
                    bStop := bStop OR bRampDown,
                    bUsePosDetect := FALSE,
                    rStartOutputPre := 0.0,
                    rStartOutputVel := 0.0,
                    dDelayTimeOn := dDelayTimePump);
   rOutputPre := abConstMovement.aRun.rOutputPre;
   rOutputVel := abConstMovement.aRun.rOutputVel;
   bPreOutputReached := abConstMovement.aRun.bPreOutputReached;
   
   IF mbConstServoLinked THEN
      abConstMovementServo.aRun(bStart := bStart,
                                bStop := bStop OR bRampDown,
                                bUsePosDetect := FALSE,
                                rStartOutputPre := 0.0,
                                rStartOutputVel := 0.0,
                                dDelayTimeOn := dDelayTimeServo);
      rOutputServo := abConstMovementServo.aRun.rOutputVel;
      bPreOutputReached := bPreOutputReached AND abConstMovementServo.aRun.bPreOutputReached;
      
      IF ABS(abConstMovementServo.aRun.rOutputVel) > 0.95 * ABS(mpConstantServo^.Velocity.Output.rOutputValue) THEN
        bUSetReached := TRUE;
      ELSE
        bUSetReached := FALSE;  
      END_IF; 
   ELSE
      rOutputServo := 0.0;
   END_IF;
 
   // start measurement when delaytime of pump or servo valve is ellapsed
   IF fbMeasDelay.Q THEN
      mbMeasActive := TRUE;
      fbAutoCalib(MeasureActive := TRUE, 
                  ScrewPosUnit := rActPosition, 
                  ScrewVelFiltered := rActVel, 
                  ScrewPressure := rActPressure,
                  SystemPressure := rSysPressure,
                  bCheckLimitPosition := NOT bPressureCalib,
                  bCheckSysPressure := bIsServoValveCalib AND bUSetReached,
                  rLimitPosition := rLimitPosition,
                  bDirection := bDirection,
                  DecelerationRamp := mpConstant^.Velocity.Output.rRamp);
   END_IF;
   
   IF fbAutoCalib.MeasDone THEN
      bMeasRdy := TRUE;
      mbMeasActive := FALSE;
   END_IF;
                                                         
   // measurement ready or error during measurement, then stop movement
   IF bMeasRdy OR bError OR fbAutoCalib.Error OR abConstMovement.aRun.bError OR  abConstMovementServo.aRun.bError THEN
      bRampDown := TRUE;
      bStarted := FALSE;
   END_IF;

ELSIF bRampDown THEN
   // stop const movement
   abConstMovement.aRun(bStart := bStart,
                    bStop := TRUE,
                    bUsePosDetect := FALSE,
                    dDelayTimeOn := dDelayTimePump);
   rOutputPre := abConstMovement.aRun.rOutputPre;
   rOutputVel := abConstMovement.aRun.rOutputVel;
   bPreOutputReached := abConstMovement.aRun.bPreOutputReached;   

   IF mbConstServoLinked THEN
      abConstMovementServo.aRun(bStart := bStart,
                                bStop := TRUE,
                                bUsePosDetect := FALSE,
                                dDelayTimeOn := dDelayTimeServo);
      rOutputServo := abConstMovementServo.aRun.rOutputVel;
      bPreOutputReached := bPreOutputReached AND abConstMovementServo.aRun.bPreOutputReached;
   ELSE
      rOutputServo := 0.0;
   END_IF;
   
   IF (NOT abConstMovement.aRun.bActive AND NOT abConstMovementServo.aRun.bActive) OR
         abConstMovement.aRun.bError OR abConstMovementServo.aRun.bError THEN
      bStarted := FALSE;
      bRampDown := FALSE;
   END_IF;

   IF (bCheckStopPosition) THEN // check limit position if velocity calib
      IF (bDirection AND rActPosition > rLimitPosition) OR 
         (NOT bDirection AND rActPosition < rLimitPosition) THEN
         IF (bDirection AND rActPosition > rStopPosition - MIN_TOLERANCE) OR 
            (NOT bDirection AND rActPosition < rStopPosition + MIN_TOLERANCE) THEN
            rVelStopRamp := 0.0;
            rPresStopRamp := 0.0;
            IF mbConstServoLinked THEN 
                rOutputServo := 0.0; 
            END_IF;    
         ELSE
            rVelStopRamp  := mpConstant^.Velocity.Output.rOutputValue * ABS((rActPosition - rStopPosition)/(rLimitPosition - rStopPosition));
            rPresStopRamp := mpConstant^.Pressure.Output.rOutputValue * ABS((rActPosition - rStopPosition)/(rLimitPosition - rStopPosition));
            IF mbConstServoLinked THEN
                rServoStopRamp := mpConstantServo^.Velocity.Output.rOutputValue * ABS((rActPosition - rStopPosition)/(rLimitPosition - rStopPosition));
                rOutputServo := MIN(abConstMovementServo.aRun.rOutputVel, rServoStopRamp); 
            END_IF;    
         END_IF;
         rOutputPre := MIN(abConstMovement.aRun.rOutputPre, rPresStopRamp);
         rOutputVel := MIN(abConstMovement.aRun.rOutputVel, rVelStopRamp);
      END_IF;
   END_IF;    
   
ELSIF bActive THEN    
    rOutputPre := 0.0;
    rOutputVel := 0.0;
    rOutputServo := 0.0;
    bPreOutputReached := FALSE;
    
   //use slow task for calculation
    IF NOT mbCalcActive THEN
        mbCalcActive := TRUE;
        mbCalcDone   := FALSE;
        START_PROCESS_ALGORITHM(paCalc);
    END_IF;
    
   IF fbAutoCalib.Done THEN
      //overall calibration done
      IF bDoAbsVelocityCalib THEN
         rMaxVelocityAbs := fbAutoCalib.rMaxVal;
         bDoAbsVelocityCalib := FALSE;
      ELSIF bGetMaxPressure THEN // Get max pressure when pressure calib is active
         rMaxPressureAbs := fbAutoCalib.rMaxVal;
         bGetMaxPressure := FALSE;
      END_IF;
      mpTmpLintab^.LintabPoints := fbAutoCalib.Lintab;
      mpbPumpPreVelCalibAnotherStepN^ := FALSE;          
      mpbPumpPreVelCalibDone^ := TRUE;
      
      fbLog(CONCAT(sCalib, ' calib finished'));
      bActive := FALSE;
      IF mpbDebugCalibration^ THEN
         START_PROCESS_ALGORITHM(paDebug);
      END_IF; 
   ELSIF (fbAutoCalib.Error AND mbCalcDone)OR 
          bError OR abConstMovement.aRun.bError OR abConstMovementServo.aRun.bError THEN
      // errorhandling
      bDoAbsVelocityCalib := FALSE;
      bGetMaxPressure := FALSE;
      bError := TRUE;
      mpbPumpPreVelCalibAnotherStepN^ := FALSE;
      mpbPumpPreVelCalibDone^ := FALSE;
      IF fbAutoCalib.Error THEN
         iErrorInfo := fbAutoCalib.ErrorInfo;
      ELSIF abConstMovement.aRun.bError OR abConstMovementServo.aRun.bError THEN
         iErrorInfo := -500;
      END_IF;
      fbLog(CONCAT(sCalib,' calib error ',DINT_TO_STRING(iErrorInfo)));
      bActive := FALSE;
      IF mpbDebugCalibration^ THEN
         START_PROCESS_ALGORITHM(paDebug);
      END_IF; 
      STOP_PROCESS_ALGORITHM(paCalc); 
   ELSIF fbAutoCalib.NextStartReady THEN
      // displaying lintab during calib
      mpTmpLintab^.LintabPoints := fbAutoCalib.Lintab;
      // set const data of next calib step
      mpConstant^.Velocity.Output.rOutputValue := fbAutoCalib.PumpVelocityVoltage;
      mpConstant^.Pressure.Output.rOutputValue := fbAutoCalib.PumpPressureVoltage;
      IF mbConstServoLinked THEN
         mpConstantServo^.Velocity.Output.rOutputValue := fbAutoCalib.ServoValveVoltage;
      END_IF;
      mpbPumpPreVelCalibAnotherStepN^ := TRUE;
      bActive := FALSE;
   ELSIF bStop THEN
      bDoAbsVelocityCalib := FALSE;
      bGetMaxPressure := FALSE;
      IF mbConstServoLinked THEN
         abConstMovementServo.aRun();
      END_IF;
      abConstMovement.aRun();
       
      IF (NOT abConstMovement.aRun.bActive AND NOT abConstMovementServo.aRun.bActive) OR
         abConstMovement.aRun.bError OR abConstMovementServo.aRun.bError THEN
         bStarted := FALSE;
         bRampDown := FALSE;
         bActive := FALSE;  
      END_IF;
      STOP_PROCESS_ALGORITHM(paCalc); 
   END_IF;
   
END_IF;

// Write actual measure data to Kemro.Scope if debugging selected
IF mpbDebugCalibration^ THEN
   mbStarted := bStarted;
   mbRampDown := bRampDown;
   mbActive :=  bActive;
   mOutputV :=  rOutputVel;
   mOutputP :=  rOutputPre;
   mOutputServo :=  rOutputServo;
   mMeasDone := fbAutoCalib.MeasDone;
   mbMeasRdy := bMeasRdy;
   mrActVel := rActVel;
   mrActPosition := rActPosition;
   mrActPressure := rActPressure;
   mrSysPressure := rSysPressure;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
If debugging is selected, write results of each step of calibration process to autocalibPV_steps_*.txt-file
*)

PROCESS_ALGORITHM paDebug ON TaskSlow


VAR_TEMP
 i : UDINT;
END_VAR

VAR
 status : KFILE_Status;
 tmpstr : STRING(255);
 dummy : DINT;
 count : UDINT;
 filetoken : KFILE_Open_Data;
 calibcount : UDINT := 1;
 bIsDir : BOOL;
 sPath : STRING(255);
 bInitDone : BOOL;
 sWorkPath : STRING(255);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bInitDone THEN
   sWorkPath := FGetCatConfigValueString('System.workPath', '/harddisk0/');
   bInitDone := TRUE;
END_IF;

IF sv_iCalibratingPump = 0 THEN
   sPath := CONCAT(sWorkPath, CALIB_FILE_PATH, msFuName, '/');
ELSE
   sPath := CONCAT(sWorkPath, CALIB_FILE_PATH, 'Pump', DINT_TO_STRING(sv_iCalibratingPump), '/');
END_IF;
 

status := KFILE_IsDir (Name := sPath, IsDirectory := bIsDir);
IF status = KFILE_Status_NOTOK THEN
   status := KFILE_MakeDir (Path := sPath);
END_IF;

count := fbAutoCalib.ArraySize;
filetoken := KFILE_Open(Name:= CONCAT(sPath,'autocalibPV_steps_',UDINT_TO_STRING(calibcount), '.txt'), Mode := KFILE_Mode_ReadWriteDelete);
IF count > 1 THEN
   FOR i:=1 TO count - 1 DO
       tmpstr := CONCAT(UDINT_TO_STRING(i), ';', REAL_TO_STRING(fbAutoCalib.Array[i].rX), ';', REAL_TO_STRING(fbAutoCalib.Array[i].rY), ';',
                        REAL_TO_STRING(fbAutoCalib.Array[i].rZ),'$N');            
       dummy := KFILE_Write(Token := filetoken.Token, Length := LEN(tmpstr), Buffer := tmpstr);   
   END_FOR;
END_IF;
status := KFILE_Close(Token := filetoken.Token);  
calibcount := calibcount + 1;
STOP_PROCESS_ALGORITHM();
   


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aInitMaxVoltages


VAR_INPUT
 rMaxVoltage : REAL (* max. voltage for pump/valve calib *);
 rMinVoltage : REAL (* min. voltage for pump/valve calib *);
 prMaxVoltageVelocity : REFTO REAL;
 prMaxVoltagePressure : REFTO REAL;
 prMaxVoltageVelocityPresCalib : REFTO REAL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mrMaxVoltage := rMaxVoltage;
mrMinVoltage := rMinVoltage;
mrMaxVoltageAbs := rMaxVoltage;

IF CHECK_REF(prMaxVoltageVelocity^) THEN
   mprMaxVoltageVelocity := prMaxVoltageVelocity;
   mbMaxVoltageVelocityValid := TRUE;
ELSE
   mbMaxVoltageVelocityValid := FALSE;
END_IF;

IF CHECK_REF(prMaxVoltagePressure^) THEN
   mprMaxVoltagePressure := prMaxVoltagePressure;
   mbMaxVoltagePressureValid := TRUE;
ELSE
   mbMaxVoltagePressureValid := FALSE;
END_IF;

IF CHECK_REF(prMaxVoltageVelocityPresCalib^) THEN
   mprMaxVoltageVelocityPresCalib := prMaxVoltageVelocityPresCalib;
   mbMaxVoltageVelocityPresValid := TRUE;
ELSE
   mbMaxVoltageVelocityPresValid := FALSE;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 120 @Pou 25 
@@@BEG_Comment@@@
Do automatic Pump pressure/velocity calibration
@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
7 
@Var @RT(14)GET_MY_FU_NAME @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)KSWO_AddVariable @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)KFILE_IsDir @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)KFILE_MakeDir @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)KFILE_Open @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)KFILE_Write @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)KFILE_Close @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
8 
@Var @RT(25)KAPPL_CalibSelection_PQ_P @RT(0) @T @T @DERIVED 0 @F @RT(20)KAPPL_CalibSelection @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(25)KAPPL_CalibSelection_PQ_V @RT(0) @T @T @DERIVED 0 @F @RT(20)KAPPL_CalibSelection @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(28)KAPPL_CalibSelection_Servo_P @RT(0) @T @T @DERIVED 0 @F @RT(20)KAPPL_CalibSelection @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(28)KAPPL_CalibSelection_Servo_V @RT(0) @T @T @DERIVED 0 @F @RT(20)KAPPL_CalibSelection @F 
@T 
@BEG_Attrib 
0 @RT(1)2 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)MIN_TOLERANCE @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)0.1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)CALIB_FILE_PATH @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(26)'/protocol/log/autocalib/' @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)KFILE_Status_NOTOK @RT(0) @T @T @DERIVED 0 @F @RT(12)KFILE_Status @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(22)command not successful 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(26)KFILE_Mode_ReadWriteDelete @RT(0) @T @T @DERIVED 0 @F @RT(10)KFILE_Mode @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(102)opens for reading and writing, if file doesn't exist, it will be created, its contents will be deleted 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(27)ABPumpPressureVelocityCalib @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
39 
@Var @RT(8)TaskSlow @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(15)abConstMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(27)ABConstMovementForAutoCalib @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)abConstMovementServo @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(27)ABConstMovementForAutoCalib @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)mpConstant @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(47)pointer to systemvariable that contains profile @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mpConstantServo @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(47)pointer to systemvariable that contains profile @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)mpTmpLintab @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(18)KAPPL_LintabData3D @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mpbPumpPreVelCalibDone @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(30)mpbPumpPreVelCalibAnotherStepN @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mrMaxVoltage @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mrMinVoltage @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)mpPressureStableParam @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(18)KCTRL_Stable_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)mpVelocityStableParam @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(18)KCTRL_Stable_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)mbStarted @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)mbRampDown @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)mbActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)mOutputV @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(45)Calculated output for pressure, swo recording @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)mOutputP @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(45)Calculated output for pressure, swo recording @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mOutputServo @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(48)Calculated output for servo valve, swo recording @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)mMeasDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)mbMeasRdy @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)mrActVel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrActPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrActPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mpbDebugCalibration @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(37)RefTo sv_TraceLevel.bDebugCalibration @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mbConstServoLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)fbAutoCalib @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(30)KAPPL_Plastics_AutoCalibration @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrSysPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mbMeasActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)mprMaxVoltageVelocity @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(25)mbMaxVoltageVelocityValid @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)mprMaxVoltagePressure @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(25)mbMaxVoltagePressureValid @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mrMaxVoltageAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(30)mprMaxVoltageVelocityPresCalib @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(29)mbMaxVoltageVelocityPresValid @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mbCalcActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)mbCalcDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)msFuName @RT(0) @T @F @DT @RT(10)STRING(32) @RT(0) @T @T @STRING 0 @F @RT(2)32 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)sv_iCalibratingPump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(44)number of pump which is actually calibrating @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

5 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(6)paCalc @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(5)aInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
13 
@Var @RT(6)pConst @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(47)pointer to systemvariable that contains profile @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)pConstServo @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(47)pointer to systemvariable that contains profile @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)MoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(27)moveId of constant movement @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)pTmpLintab @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(18)KAPPL_LintabData3D @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(28)reference to detected Lintab @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(29)pbPumpPreVelCalibAnotherStepN @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)another movement necessary @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(21)pbPumpPreVelCalibDone @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(17)calibration ready @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)pPressureStableParam @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(18)KCTRL_Stable_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)stable paramater for pressure calibration @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)pVelocityStableParam @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(18)KCTRL_Stable_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)stable paramater for velocity calibration @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)debugInstanceName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(50)instance name for debugging (used for Kemro.Scope) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)debugTask @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(31)debug task used for Kemro.Scope @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)pbDebugCalibration @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(27)debug calibration activated @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)status @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSWO_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)variableName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aRun @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
46 
@Var @RT(6)bStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)start constant calib block @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(5)bStop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(25)stop constant calib block @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)rActPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(15)actual position @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)rMaxPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(38)maximum stroke for end pos calculation @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)rActVel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(15)actual velocity @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)rActPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(15)actual pressure @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)rSysPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(62)system pressure (only relevant when servo valve calib is done) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)bIsPressureCalib @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(30)pressure calibration activated @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)bIsVelocityCalib @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(30)pressure calibration activated @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)bIsServoValveCalib @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)servo valve calibration activated @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)bDirection @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(68)TRUE: position is getting bigger; FALSE: position is getting smaller @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)dDelayTimePump @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(45)Delay Time between preoutput and  constoutput @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)dDelayTimeServo @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(45)Delay Time between preoutput and  constoutput @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)rLimitPositionFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(51)Factor for max position during velocity calibration @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)bActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)movement is active @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)rOutputPre @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(15)pressure output @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)rOutputVel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(15)velocity output @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(12)rOutputServo @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(21)output to servo valve @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(15)rMaxVelocityAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(30)max. measured velocity [cm³/s] @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(15)rMaxPressureAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(28)max. measured pressure [bar] @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(17)bPreOutputReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(15)preoutput ready @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)flag to indicate if error occured @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(21)additional error info @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(13)fbREdge_Start @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(6)R_TRIG @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bRampDown @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(19)Stop const movement @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)bPressureCalib @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)fbLog @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)FBAutoCalibLog @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(5)Debug @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)printtmp @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(5)Debug @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)bStarted @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)Param @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_CalibParam @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(23)Calibration parrameters @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)rMinPosFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.1 @RT(45)Dont do velocity movement  until end of screw @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)bDoAbsVelocityCalib @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)bGetMaxPressure @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)pStableParam @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(18)KCTRL_Stable_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(38)Stabliization conditions for recording @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)bMeasRdy @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(17)Measurement ready @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(23)uNoOfAequidistantPoints @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(2)13 @RT(29)Number of aequidistant points @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)fbMeasDelay @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)TON @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)bUSetReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)FALSE @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)rLimitPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)Max. position of measuring @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)rStopPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(31)Max. position for valve closing @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rVelStopRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)rPresStopRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)rServoStopRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)bCheckStopPosition @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)FALSE @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)fbRTrigStop @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(6)R_TRIG @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)sCalib @RT(0) @T @F @DT @RT(10)STRING(32) @RT(0) @T @T @STRING 0 @F @RT(2)32 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(7)paDebug @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
11 
@Var @RT(1)i @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(6)status @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)KFILE_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)tmpstr @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)count @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)filetoken @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KFILE_Open_Data @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)calibcount @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(1)1 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)bIsDir @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)sPath @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)sWorkPath @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(16)aInitMaxVoltages @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(11)rMaxVoltage @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)max. voltage for pump/valve calib @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)rMinVoltage @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)min. voltage for pump/valve calib @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)prMaxVoltageVelocity @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)prMaxVoltagePressure @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(29)prMaxVoltageVelocityPresCalib @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(12)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbAutoCalib(MeasureActive := FALSE);
IF fbAutoCalib.NextStartReady OR fbAutoCalib.Done OR fbAutoCalib.Error THEN
   mbCalcDone := TRUE;
   STOP_PROCESS_ALGORITHM();
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(97)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mpTmpLintab := pTmpLintab;
mpbPumpPreVelCalibDone := pbPumpPreVelCalibDone;
mpbPumpPreVelCalibAnotherStepN := pbPumpPreVelCalibAnotherStepN;

mpConstant := pConst;
abConstMovement.aInit(pConst := mpConstant,
                      MoveId := MoveId);

IF CHECK_REF(pConstServo^) THEN
   mpConstantServo := pConstServo;
   abConstMovementServo.aInit(pConst := mpConstantServo,
                              MoveId := MoveId);
   mbConstServoLinked := TRUE;
ELSE
   mbConstServoLinked := FALSE;
END_IF;
mpPressureStableParam := pPressureStableParam;
mpVelocityStableParam := pVelocityStableParam;

msFuName := GET_MY_FU_NAME();

mpbDebugCalibration := pbDebugCalibration; 
// Add variables to Kemro.Scope if debugging is selected
IF mpbDebugCalibration^ THEN
   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mbStarted');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mbStarted);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mbRampDown');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mbRampDown);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mbActive');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mbActive);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mOutputV');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mOutputV);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mOutputP');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mOutputP);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mOutputServo');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mOutputServo);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mMeasDone');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mMeasDone);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mbMeasrdy');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mbMeasRdy);

   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mrActVel');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mrActVel);
   
   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mrActPosition');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mrActPosition);
   
   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mrActPressure');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mrActPressure);
  
   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mrSysPressure');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mrSysPressure);
   
   variableName := CONCAT(msFuName,'.',debugInstanceName,'.mbMeasActive');
   status := KSWO_AddVariable( Task := debugTask,
                              Name := variableName,
                              Variable := mbMeasActive);
END_IF;



@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
Initialisation 
@@@END_Comment@@@ 

@BEG_Body 
@TL(351)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bStart THEN // Reset Errors
   bError := FALSE;
   iErrorInfo := 0;
END_IF; 
fbREdge_Start(CLK := bStart);
IF fbREdge_Start.Q THEN
   // reset Error
   bError := FALSE;
   iErrorInfo := 0;
   
   bPressureCalib := bIsPressureCalib;
   fbMeasDelay(IN := FALSE, PT :=MAX(dDelayTimePump,dDelayTimeServo));
   
   // validate calib
   IF NOT (bIsPressureCalib XOR bIsVelocityCalib) THEN
      printtmp := Print('only Pressure or Velocity calib can be active at a time');
      bActive := FALSE;
      bError := TRUE;
   END_IF;
   bRampDown := FALSE;
   bMeasRdy := FALSE;
   bStarted := TRUE;
   bActive := TRUE;
   mbCalcActive := FALSE; 
   bPreOutputReached := FALSE;
   // Take 13 Points, because than the aequidistant points are 0V, 1V, ..., 10V
   Param.uNoOfPoints := uNoOfAequidistantPoints;
    
   IF (mbMaxVoltagePressureValid) THEN
      Param.rMaxVoltagePressure := mprMaxVoltagePressure^ ;
   ELSE
      Param.rMaxVoltagePressure := mrMaxVoltageAbs;  
   END_IF;
   IF (mbMaxVoltageVelocityValid) THEN
      Param.rMaxVoltageVelocity := mprMaxVoltageVelocity^;
   ELSE
      Param.rMaxVoltageVelocity := mrMaxVoltageAbs;
   END_IF; 

    
   IF bPressureCalib AND NOT bIsServoValveCalib THEN
      Param.LintabType := KAPPL_CalibSelection_PQ_P;
      pStableParam := mpPressureStableParam; 
      mrMaxVoltage := Param.rMaxVoltagePressure; 
      IF mbMaxVoltageVelocityPresValid THEN
         Param.rMaxVoltageVelocity := mprMaxVoltageVelocityPresCalib^;
      END_IF; 
   ELSIF bIsVelocityCalib AND NOT bIsServoValveCalib THEN
      Param.LintabType := KAPPL_CalibSelection_PQ_V;
      pStableParam := mpVelocityStableParam;
      mrMaxVoltage := Param.rMaxVoltageVelocity; 
   ELSIF bPressureCalib AND bIsServoValveCalib THEN
      Param.LintabType := KAPPL_CalibSelection_Servo_P;
      pStableParam := mpPressureStableParam;
      mrMaxVoltage := mrMaxVoltageAbs; 
      IF mbMaxVoltageVelocityPresValid THEN
         Param.rMaxVoltageVelocity := mprMaxVoltageVelocityPresCalib^;
      END_IF; 
   ELSIF bIsVelocityCalib AND bIsServoValveCalib THEN
      Param.LintabType := KAPPL_CalibSelection_Servo_V;
      pStableParam := mpVelocityStableParam;
      mrMaxVoltage := mrMaxVoltageAbs; 
   ELSE
      printtmp := Print('invalid calib selection');
      bActive := FALSE;
      bError := TRUE;
      //iErrorInfo := ??? ;//FIXME
   END_IF;
   
   Param.rMaxVoltage := mrMaxVoltage;
   Param.rMinVoltage := mrMinVoltage;
    
    
   // reset const movement
   abConstMovement.aRun(bStart := FALSE);
   IF mbConstServoLinked THEN
      mpConstantServo^.Pressure.rMinOutput := mrMinVoltage;
      mpConstantServo^.Velocity.rMinOutput := mrMinVoltage;
      abConstMovementServo.aRun(bStart := FALSE);
   END_IF;

    
   // only do reinit on the first time doing the calib
   IF NOT mpbPumpPreVelCalibAnotherStepN^ THEN
      fbAutoCalib(ReParam := TRUE, 
                  MeasureActive := FALSE, 
                  Param := Param, 
                  pStableParam := pStableParam, 
                  bDebugCalibration := mpbDebugCalibration^,
                  DecelerationRamp := mpConstant^.Velocity.Output.rRamp);
      fbAutoCalib(ReParam := FALSE, MeasureActive := FALSE);
       
      mpConstant^.Velocity.Output.rOutputValue := fbAutoCalib.PumpVelocityVoltage;
      mpConstant^.Pressure.Output.rOutputValue := fbAutoCalib.PumpPressureVoltage;
      
      IF mbConstServoLinked THEN
         mpConstantServo^.Velocity.Output.rOutputValue := fbAutoCalib.ServoValveVoltage;
      END_IF;
   
      //this is the first init so we do a absolute velocity calib
      IF bIsVelocityCalib THEN
         bDoAbsVelocityCalib := TRUE;
         sCalib := 'velocity';
      ELSE
         bGetMaxPressure := TRUE;
         sCalib := 'pressure';
      END_IF;
   END_IF;
   
   mpbPumpPreVelCalibAnotherStepN^ := FALSE;
   mpbPumpPreVelCalibDone^ := FALSE;
   
    IF (rLimitPositionFactor > 0.0) AND (rLimitPositionFactor <= 1.0) THEN
        rMinPosFactor := 1.0 -  rLimitPositionFactor;
    ELSE
        rMinPosFactor := 0.1; // use default value if limit not set
    END_IF;
 
    IF bDirection THEN 
        rLimitPosition := rMaxPosition - rMinPosFactor * rMaxPosition; 
        rStopPosition  := rMaxPosition - 0.5 * rMinPosFactor * rMaxPosition; 
    ELSE
        rLimitPosition := rMinPosFactor * rMaxPosition; 
        rStopPosition  := 0.5 * rMinPosFactor * rMaxPosition; 
    END_IF;

    IF (NOT bPressureCalib) AND (ABS(rLimitPosition - rStopPosition)>0.0) THEN
        bCheckStopPosition := TRUE;
    ELSE
        bCheckStopPosition := FALSE;
    END_IF;    
END_IF;

fbRTrigStop(CLK := bStop);

IF fbRTrigStop.Q THEN
   //start ramping down
   bStarted := FALSE;
   bRampDown := TRUE;
END_IF;

fbMeasDelay(IN := bStarted, PT :=MAX(dDelayTimePump,dDelayTimeServo));    

IF bStarted THEN
   // const movement active
   abConstMovement.aRun(bStart := bStart,
                    bStop := bStop OR bRampDown,
                    bUsePosDetect := FALSE,
                    rStartOutputPre := 0.0,
                    rStartOutputVel := 0.0,
                    dDelayTimeOn := dDelayTimePump);
   rOutputPre := abConstMovement.aRun.rOutputPre;
   rOutputVel := abConstMovement.aRun.rOutputVel;
   bPreOutputReached := abConstMovement.aRun.bPreOutputReached;
   
   IF mbConstServoLinked THEN
      abConstMovementServo.aRun(bStart := bStart,
                                bStop := bStop OR bRampDown,
                                bUsePosDetect := FALSE,
                                rStartOutputPre := 0.0,
                                rStartOutputVel := 0.0,
                                dDelayTimeOn := dDelayTimeServo);
      rOutputServo := abConstMovementServo.aRun.rOutputVel;
      bPreOutputReached := bPreOutputReached AND abConstMovementServo.aRun.bPreOutputReached;
      
      IF ABS(abConstMovementServo.aRun.rOutputVel) > 0.95 * ABS(mpConstantServo^.Velocity.Output.rOutputValue) THEN
        bUSetReached := TRUE;
      ELSE
        bUSetReached := FALSE;  
      END_IF; 
   ELSE
      rOutputServo := 0.0;
   END_IF;
 
   // start measurement when delaytime of pump or servo valve is ellapsed
   IF fbMeasDelay.Q THEN
      mbMeasActive := TRUE;
      fbAutoCalib(MeasureActive := TRUE, 
                  ScrewPosUnit := rActPosition, 
                  ScrewVelFiltered := rActVel, 
                  ScrewPressure := rActPressure,
                  SystemPressure := rSysPressure,
                  bCheckLimitPosition := NOT bPressureCalib,
                  bCheckSysPressure := bIsServoValveCalib AND bUSetReached,
                  rLimitPosition := rLimitPosition,
                  bDirection := bDirection,
                  DecelerationRamp := mpConstant^.Velocity.Output.rRamp);
   END_IF;
   
   IF fbAutoCalib.MeasDone THEN
      bMeasRdy := TRUE;
      mbMeasActive := FALSE;
   END_IF;
                                                         
   // measurement ready or error during measurement, then stop movement
   IF bMeasRdy OR bError OR fbAutoCalib.Error OR abConstMovement.aRun.bError OR  abConstMovementServo.aRun.bError THEN
      bRampDown := TRUE;
      bStarted := FALSE;
   END_IF;

ELSIF bRampDown THEN
   // stop const movement
   abConstMovement.aRun(bStart := bStart,
                    bStop := TRUE,
                    bUsePosDetect := FALSE,
                    dDelayTimeOn := dDelayTimePump);
   rOutputPre := abConstMovement.aRun.rOutputPre;
   rOutputVel := abConstMovement.aRun.rOutputVel;
   bPreOutputReached := abConstMovement.aRun.bPreOutputReached;   

   IF mbConstServoLinked THEN
      abConstMovementServo.aRun(bStart := bStart,
                                bStop := TRUE,
                                bUsePosDetect := FALSE,
                                dDelayTimeOn := dDelayTimeServo);
      rOutputServo := abConstMovementServo.aRun.rOutputVel;
      bPreOutputReached := bPreOutputReached AND abConstMovementServo.aRun.bPreOutputReached;
   ELSE
      rOutputServo := 0.0;
   END_IF;
   
   IF (NOT abConstMovement.aRun.bActive AND NOT abConstMovementServo.aRun.bActive) OR
         abConstMovement.aRun.bError OR abConstMovementServo.aRun.bError THEN
      bStarted := FALSE;
      bRampDown := FALSE;
   END_IF;

   IF (bCheckStopPosition) THEN // check limit position if velocity calib
      IF (bDirection AND rActPosition > rLimitPosition) OR 
         (NOT bDirection AND rActPosition < rLimitPosition) THEN
         IF (bDirection AND rActPosition > rStopPosition - MIN_TOLERANCE) OR 
            (NOT bDirection AND rActPosition < rStopPosition + MIN_TOLERANCE) THEN
            rVelStopRamp := 0.0;
            rPresStopRamp := 0.0;
            IF mbConstServoLinked THEN 
                rOutputServo := 0.0; 
            END_IF;    
         ELSE
            rVelStopRamp  := mpConstant^.Velocity.Output.rOutputValue * ABS((rActPosition - rStopPosition)/(rLimitPosition - rStopPosition));
            rPresStopRamp := mpConstant^.Pressure.Output.rOutputValue * ABS((rActPosition - rStopPosition)/(rLimitPosition - rStopPosition));
            IF mbConstServoLinked THEN
                rServoStopRamp := mpConstantServo^.Velocity.Output.rOutputValue * ABS((rActPosition - rStopPosition)/(rLimitPosition - rStopPosition));
                rOutputServo := MIN(abConstMovementServo.aRun.rOutputVel, rServoStopRamp); 
            END_IF;    
         END_IF;
         rOutputPre := MIN(abConstMovement.aRun.rOutputPre, rPresStopRamp);
         rOutputVel := MIN(abConstMovement.aRun.rOutputVel, rVelStopRamp);
      END_IF;
   END_IF;    
   
ELSIF bActive THEN    
    rOutputPre := 0.0;
    rOutputVel := 0.0;
    rOutputServo := 0.0;
    bPreOutputReached := FALSE;
    
   //use slow task for calculation
    IF NOT mbCalcActive THEN
        mbCalcActive := TRUE;
        mbCalcDone   := FALSE;
        START_PROCESS_ALGORITHM(paCalc);
    END_IF;
    
   IF fbAutoCalib.Done THEN
      //overall calibration done
      IF bDoAbsVelocityCalib THEN
         rMaxVelocityAbs := fbAutoCalib.rMaxVal;
         bDoAbsVelocityCalib := FALSE;
      ELSIF bGetMaxPressure THEN // Get max pressure when pressure calib is active
         rMaxPressureAbs := fbAutoCalib.rMaxVal;
         bGetMaxPressure := FALSE;
      END_IF;
      mpTmpLintab^.LintabPoints := fbAutoCalib.Lintab;
      mpbPumpPreVelCalibAnotherStepN^ := FALSE;          
      mpbPumpPreVelCalibDone^ := TRUE;
      
      fbLog(CONCAT(sCalib, ' calib finished'));
      bActive := FALSE;
      IF mpbDebugCalibration^ THEN
         START_PROCESS_ALGORITHM(paDebug);
      END_IF; 
   ELSIF (fbAutoCalib.Error AND mbCalcDone)OR 
          bError OR abConstMovement.aRun.bError OR abConstMovementServo.aRun.bError THEN
      // errorhandling
      bDoAbsVelocityCalib := FALSE;
      bGetMaxPressure := FALSE;
      bError := TRUE;
      mpbPumpPreVelCalibAnotherStepN^ := FALSE;
      mpbPumpPreVelCalibDone^ := FALSE;
      IF fbAutoCalib.Error THEN
         iErrorInfo := fbAutoCalib.ErrorInfo;
      ELSIF abConstMovement.aRun.bError OR abConstMovementServo.aRun.bError THEN
         iErrorInfo := -500;
      END_IF;
      fbLog(CONCAT(sCalib,' calib error ',DINT_TO_STRING(iErrorInfo)));
      bActive := FALSE;
      IF mpbDebugCalibration^ THEN
         START_PROCESS_ALGORITHM(paDebug);
      END_IF; 
      STOP_PROCESS_ALGORITHM(paCalc); 
   ELSIF fbAutoCalib.NextStartReady THEN
      // displaying lintab during calib
      mpTmpLintab^.LintabPoints := fbAutoCalib.Lintab;
      // set const data of next calib step
      mpConstant^.Velocity.Output.rOutputValue := fbAutoCalib.PumpVelocityVoltage;
      mpConstant^.Pressure.Output.rOutputValue := fbAutoCalib.PumpPressureVoltage;
      IF mbConstServoLinked THEN
         mpConstantServo^.Velocity.Output.rOutputValue := fbAutoCalib.ServoValveVoltage;
      END_IF;
      mpbPumpPreVelCalibAnotherStepN^ := TRUE;
      bActive := FALSE;
   ELSIF bStop THEN
      bDoAbsVelocityCalib := FALSE;
      bGetMaxPressure := FALSE;
      IF mbConstServoLinked THEN
         abConstMovementServo.aRun();
      END_IF;
      abConstMovement.aRun();
       
      IF (NOT abConstMovement.aRun.bActive AND NOT abConstMovementServo.aRun.bActive) OR
         abConstMovement.aRun.bError OR abConstMovementServo.aRun.bError THEN
         bStarted := FALSE;
         bRampDown := FALSE;
         bActive := FALSE;  
      END_IF;
      STOP_PROCESS_ALGORITHM(paCalc); 
   END_IF;
   
END_IF;

// Write actual measure data to Kemro.Scope if debugging selected
IF mpbDebugCalibration^ THEN
   mbStarted := bStarted;
   mbRampDown := bRampDown;
   mbActive :=  bActive;
   mOutputV :=  rOutputVel;
   mOutputP :=  rOutputPre;
   mOutputServo :=  rOutputServo;
   mMeasDone := fbAutoCalib.MeasDone;
   mbMeasRdy := bMeasRdy;
   mrActVel := rActVel;
   mrActPosition := rActPosition;
   mrActPressure := rActPressure;
   mrSysPressure := rSysPressure;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(4)
calibrates the pump pressure or velocity lintab
for calibrating of the pressure lintab a backpressure sensor is needed
for calibrating of the velocity lintab the injection transducer needs to be setup properly

@@@END_Comment@@@ 

@BEG_Body 
@TL(36)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bInitDone THEN
   sWorkPath := FGetCatConfigValueString('System.workPath', '/harddisk0/');
   bInitDone := TRUE;
END_IF;

IF sv_iCalibratingPump = 0 THEN
   sPath := CONCAT(sWorkPath, CALIB_FILE_PATH, msFuName, '/');
ELSE
   sPath := CONCAT(sWorkPath, CALIB_FILE_PATH, 'Pump', DINT_TO_STRING(sv_iCalibratingPump), '/');
END_IF;
 

status := KFILE_IsDir (Name := sPath, IsDirectory := bIsDir);
IF status = KFILE_Status_NOTOK THEN
   status := KFILE_MakeDir (Path := sPath);
END_IF;

count := fbAutoCalib.ArraySize;
filetoken := KFILE_Open(Name:= CONCAT(sPath,'autocalibPV_steps_',UDINT_TO_STRING(calibcount), '.txt'), Mode := KFILE_Mode_ReadWriteDelete);
IF count > 1 THEN
   FOR i:=1 TO count - 1 DO
       tmpstr := CONCAT(UDINT_TO_STRING(i), ';', REAL_TO_STRING(fbAutoCalib.Array[i].rX), ';', REAL_TO_STRING(fbAutoCalib.Array[i].rY), ';',
                        REAL_TO_STRING(fbAutoCalib.Array[i].rZ),'$N');            
       dummy := KFILE_Write(Token := filetoken.Token, Length := LEN(tmpstr), Buffer := tmpstr);   
   END_FOR;
END_IF;
status := KFILE_Close(Token := filetoken.Token);  
calibcount := calibcount + 1;
STOP_PROCESS_ALGORITHM();
   

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
If debugging is selected, write results of each step of calibration process to autocalibPV_steps_*.txt-file
@@@END_Comment@@@ 

@BEG_Body 
@TL(30)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mrMaxVoltage := rMaxVoltage;
mrMinVoltage := rMinVoltage;
mrMaxVoltageAbs := rMaxVoltage;

IF CHECK_REF(prMaxVoltageVelocity^) THEN
   mprMaxVoltageVelocity := prMaxVoltageVelocity;
   mbMaxVoltageVelocityValid := TRUE;
ELSE
   mbMaxVoltageVelocityValid := FALSE;
END_IF;

IF CHECK_REF(prMaxVoltagePressure^) THEN
   mprMaxVoltagePressure := prMaxVoltagePressure;
   mbMaxVoltagePressureValid := TRUE;
ELSE
   mbMaxVoltagePressureValid := FALSE;
END_IF;

IF CHECK_REF(prMaxVoltageVelocityPresCalib^) THEN
   mprMaxVoltageVelocityPresCalib := prMaxVoltageVelocityPresCalib;
   mbMaxVoltageVelocityPresValid := TRUE;
ELSE
   mbMaxVoltageVelocityPresValid := FALSE;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
