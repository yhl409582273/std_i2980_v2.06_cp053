(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

This AB is used for measuring of analog inputs.
It includes the following funcionalities:
- converting an analog input to a measure value by using a linearization table 
- automatic reparam after a change in lintab
- automatic detection of analog inut errors
- velocity measurement by using a filter
- fast and slow measuring


@FunctionID: S_KPIEC_ALASENS_01

*)

IMPORT_OVER_LISTFILE
 SET_ALARM
, RESET_ALARM
, GET_TASK_INTERVAL
, cMeasureReductionFactor
, cApplPlasticsWrongLintabParams
, KCTRL_Ret_OK
, cApplPlasticsWrongPT1Params
, cApplPlasticsPT1CalcFailed
, cPointsLastAIValue
, tsDeviceId
, KAPPL_LintabData
, KAPPL_Plastics_Measure
, R_TRIG
, tyLintabPoints
, F_TRIG
, KCTRL_PTN
, KCTRL_PTN_Param
, tyLastAIValueArray

END_IMPORT

ALGORITHM_BLOCK ABMeasureAnalog #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_bDeviceReady : BOOL;
 sv_DeviceId : tsDeviceId;
END_VAR

SYSTEM_OBJECT
 PU_Task_7 : TASK;
 erInvalidLintabReference : ALARM;
 erAnalogMeasure : ALARM;
 erAnalogSensor : ALARM;
END_OBJECT

VAR
 mpLintab : REFTO KAPPL_LintabData;
 mbReParam : BOOL;
 fbMeasure : KAPPL_Plastics_Measure;
 mbValidLintabReference : BOOL (* info if lintab reference is valid *);
 mdFilterTime : TIME (* filter time for velocity measurement *);
 mpVelFilterTime : REFTO TIME;
 msRawValue : STRING(64);
 mbMonEnable : BOOL := FALSE (* enable monitoring for rValue *);
 mrMonLowLimit : REAL (* lower limit for monitoring *);
 mbMonLimitation : BOOL (* use limitation, set values to lower limit  *);
 mrMonFailureFactor : REAL (* define the area without setting alarm *);
 mrMonLowFailureLimit : REAL (* lowest value without alarm *);
 mbReParamLight : BOOL;
 mbRun : BOOL;
 fbRTrigMeasureError : R_TRIG;
 miCount : DINT (* Idle: counts up to cMeasureReductionFactor-1, NOT Idle: always 0 *);
 mbCheckLowerLimit : BOOL;
 mdT1Position : TIME;
 mT1PositionUsed : BOOL;
 mpPosFilterTime : REFTO TIME;
 mpLintabPointArray : REFTO tyLintabPoints;
 mpiUsedLintabPoints : REFTO UDINT;
 mbOpenArray : BOOL (* is set to TRUE if an open array of lintab points is used *);
 miMaxLintabSize : UDINT;
END_VAR

(*
Following functions are realized in this algorithm:

1) fast and slow measuring by using the given lintab
2) errorhandling

NO velocity measuring, e.g. for pressure AIs.
*)

ALGORITHM aRunLight


VAR_INPUT
 rRawValue : REAL;
END_VAR

VAR_OUTPUT
 rValue : REAL (* result of measuring (e.g. position) *);
 bError : BOOL (* measure error *);
 iErrorInfo : DINT (* additional erro info *);
END_VAR

VAR_TEMP
 i : UDINT;
END_VAR

VAR
 bLintabAlarmSet : BOOL;
 bInitDone : BOOL;
 bAnalogSensorError : BOOL;
 fbFTrigSensorError : F_TRIG;
 fbRTrigSensorError : R_TRIG;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//don´t do measurement if references are not valid
IF NOT mbValidLintabReference THEN
    
    IF NOT mbValidLintabReference AND NOT bLintabAlarmSet THEN
        SET_ALARM(Name := erInvalidLintabReference,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId);
        bLintabAlarmSet := TRUE;
    END_IF;
    mbRun := FALSE;
    RETURN;        
END_IF;


IF NOT bInitDone OR mbReParamLight THEN
    //reparam measure block
    IF mbOpenArray THEN
       FOR i := 1 TO miMaxLintabSize DO
          fbMeasure.Lintab.LintabPoints.Point[i].rX := mpLintabPointArray^[i].rX;
          fbMeasure.Lintab.LintabPoints.Point[i].rY := mpLintabPointArray^[i].rY;
       END_FOR;
       fbMeasure.Lintab.LintabPoints.uNoOfPoints := MIN(mpiUsedLintabPoints^, miMaxLintabSize);
    ELSE
       fbMeasure.Lintab := mpLintab^;
    END_IF;
                            
    fbMeasure(LintabUsed := TRUE,
              ReParam := TRUE,
              T1 := mdT1Position,
              T1Used := mT1PositionUsed);
    
    mbReParamLight := FALSE;
    bInitDone := TRUE;
END_IF;


//do fast measurement only if movement is active
//if movement is not active then measurement should be done every cMeasureReduction - cycle 
IF NOT sv_bDeviceReady OR miCount = (cMeasureReductionFactor - 1) THEN
    
    fbMeasure(RawValue := rRawValue,
             ReParam := FALSE,
             OutputValue => rValue,
             Error => bError,
             ErrorInfo => iErrorInfo);
    // Allow only Analog Input values >= mrMonLowLimit. Set values to zero in small area 
    // [mrMonLowFailureLimit mrMonLowLimit]
    // and set error, if the value is smaller than mrMonLowFailureLimit 
    IF mbMonEnable THEN
        IF mbCheckLowerLimit THEN
           bAnalogSensorError := FALSE;
           IF rValue < mrMonLowFailureLimit THEN
              bAnalogSensorError := TRUE;
              iErrorInfo := cApplPlasticsWrongLintabParams; 
           END_IF;
        END_IF;
              
        IF mbMonLimitation THEN
            rValue := MAX(rValue, mrMonLowLimit);
        END_IF;        
    END_IF;

    miCount := 0;
ELSE
    //increase counter
    miCount := miCount + 1;
END_IF;

//set alarm if error occurs during measure
fbRTrigMeasureError(CLK := bError);
IF fbRTrigMeasureError.Q THEN
    SET_ALARM(Name := erAnalogMeasure,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId,
              SubID3 := iErrorInfo);
END_IF;

// Set alarm, if value not allowed
IF mbMonEnable AND mbCheckLowerLimit THEN
    //set alarm if error occurs during measure
    fbRTrigSensorError(CLK := bAnalogSensorError);
    IF fbRTrigSensorError.Q THEN
        SET_ALARM(Name := erAnalogSensor,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                Param1 := msRawValue);
    END_IF;
    // Reset alarm after measured value is greater than limit,
    // user reset still neccessary
    fbFTrigSensorError(CLK := bAnalogSensorError);
    IF fbFTrigSensorError.Q THEN
        RESET_ALARM(Name := erAnalogSensor,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId);
    END_IF;
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

(*
Following functions are realized in this algorithm:

1) fast and slow measuring by using the given lintab
2) velocity measuring
3) errorhandling
*)

ALGORITHM aRun


VAR_INPUT
 rRawValue : REAL;
END_VAR

VAR_OUTPUT
 rValue : REAL (* result of measuring (e.g. position) *);
 rValueDiff : REAL (* change of the measure result per time (e.g. mm/s) (always positive) *);
 bError : BOOL (* measure error *);
 iErrorInfo : DINT (* additional erro info *);
END_VAR

VAR_TEMP
 uCounter : DINT;
END_VAR

VAR
 bInitDone : BOOL;
 dCycleTime : TIME;
 rCycleTime : REAL (* cycletime of this Task in seconds *);
 rOldValue : REAL (* result of measuring from the last call of this block *);
 abKCTRL_PTn : KCTRL_PTN;
 ptnParams : KCTRL_PTN_Param;
 rVelocityNotFiltered : REAL;
 rDelta : REAL;
 bAiIsConstant : BOOL;
 rMeanAIValue : REAL := 0.0;
 uMeanAIValuesCounter : DINT := 1;
 rMinDelta : REAL := 9999.0;
 tyLastAIValues : tyLastAIValueArray;
 bInitIdle : BOOL;
 bInitNotIdle : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
mbRun := TRUE;
aRunLight(rValue => rValue, 
          bError => bError, 
          iErrorInfo => iErrorInfo,
          rRawValue := rRawValue);
// Part for calculating differential quotient (e.g. velocity)
IF mbRun THEN
   IF NOT bInitDone OR mbReParam THEN
    
       IF NOT bInitDone THEN
           //get cycle time
           dCycleTime :=  GET_TASK_INTERVAL();
           rCycleTime := (LINT_TO_REAL(TIME_TO_LINT(dCycleTime))) / 1000000.0;
       END_IF;
       //filter initialization
       // Test shows good results by using
       // 12.5 Hz and order 2
       ptnParams.uN := 2;
       ptnParams.rK := 1.0;
       ptnParams.dT1 := mdFilterTime;
       ptnParams.dT2 := mdFilterTime;
       abKCTRL_PTn.Par(dCycleTime := dCycleTime,
                       Param := ptnParams);
       IF (abKCTRL_PTn.Par.parStatus <> KCTRL_Ret_OK) THEN
          bError := TRUE;
          iErrorInfo := cApplPlasticsWrongPT1Params;
          SET_ALARM(Name := erAnalogMeasure,
                    SubID1 := sv_DeviceId.CompId,
                    SubID2 := sv_DeviceId.IndexId,
                    SubID3 := iErrorInfo);
       ELSE
          bError := FALSE;
       END_IF;
    
       abKCTRL_PTn.Init(rOutVal := 0.0);
    
       rOldValue := rValue;
       mbReParam := FALSE;
       bInitDone := TRUE;
   END_IF;

   //do fast measurement only if movement is active
   //if movement is not active then measurement should be done every cMeasureReduction - cycle 
   IF miCount = 0 THEN
      //velocity measurement
      IF sv_bDeviceReady THEN
         IF (NOT bInitIdle ) THEN
            bInitIdle := TRUE;
            bInitNotIdle := FALSE;
            abKCTRL_PTn.Par(dCycleTime := MULTIME(dCycleTime, cMeasureReductionFactor));
            abKCTRL_PTn.Init(rOutVal := abKCTRL_PTn.Calculate.rOutVal);
         END_IF;                     
         rVelocityNotFiltered := (rValue - rOldValue) / (rCycleTime * DINT_TO_REAL(cMeasureReductionFactor));         
      ELSE
         IF (NOT bInitNotIdle) THEN
            bInitIdle := FALSE;
            bInitNotIdle := TRUE;
            abKCTRL_PTn.Par(dCycleTime := dCycleTime);
            abKCTRL_PTn.Init(rOutVal := abKCTRL_PTn.Calculate.rOutVal);
         END_IF;            
         rVelocityNotFiltered := (rValue - rOldValue) / rCycleTime;
      END_IF;
      //use a filter for velocity measurement
      abKCTRL_PTn.Calculate(rInVal := rVelocityNotFiltered);
      IF (abKCTRL_PTn.Calculate.calcStatus <> KCTRL_Ret_OK) THEN
         bError := TRUE;
         iErrorInfo := cApplPlasticsPT1CalcFailed;
      ELSE
         rValueDiff := abKCTRL_PTn.Calculate.rOutVal;
         // standstill-detection
         // Set velocity to zero if Analog Input is not changing
         // Take more than two points, otherwise a small velocity (e.g. < 6.5% v_max) 
         // would also be set to zero all time of injection process            
            
         // find difference of 1 bit resolution 
         rDelta := ABS(rValue - rOldValue);
         IF (rDelta < rMinDelta) AND (rDelta > 0.0) THEN
            rMinDelta := rDelta;  
         END_IF;     
         // cyclic saving of screw position  
         // cPointsLastAIValue = 5 shows good results by tests
         IF uMeanAIValuesCounter >= cPointsLastAIValue THEN
            uMeanAIValuesCounter := 1;
         ELSE
            uMeanAIValuesCounter := uMeanAIValuesCounter + 1;
         END_IF;
            
         // Calculating Mean Value of filtered velocity in every step new,
         // because by subtracting old value and adding new value
         // there will be numerical noise after few minutes
         tyLastAIValues[uMeanAIValuesCounter] := rValue;
         rMeanAIValue := 0.0;
         FOR uCounter := 1 TO cPointsLastAIValue DO
             rMeanAIValue := rMeanAIValue + tyLastAIValues[uCounter];
         END_FOR;
         rMeanAIValue := rMeanAIValue / DINT_TO_REAL(cPointsLastAIValue);
            
         bAiIsConstant := TRUE; 
         // Start standstill detection only if filtered velocity < v_min_Timediff
         IF (ABS(rValueDiff) > (rMinDelta / rCycleTime)) THEN
            bAiIsConstant := bAiIsConstant AND FALSE;
         END_IF;   
         FOR uCounter := 1 TO cPointsLastAIValue DO
            IF (ABS(tyLastAIValues[uCounter] - rMeanAIValue) >= rMinDelta ) THEN
                bAiIsConstant := bAiIsConstant AND FALSE;
            END_IF;
         END_FOR; 
         IF bAiIsConstant THEN
            rValueDiff := 0.0;
         END_IF; 
         rValueDiff := ABS(rValueDiff);
      END_IF;  
      rOldValue := rValue;       
   END_IF;
END_IF;

//set alarm if error occurs during measure
fbRTrigMeasureError(CLK := bError);
IF fbRTrigMeasureError.Q THEN
    SET_ALARM(Name := erAnalogMeasure,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId,
              SubID3 := iErrorInfo);
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
This algorithm reacts on changes of the lintab.
If the lintab changes, the flag for reparam is set.
*)

POSTUPDATE_ALGORITHM pLintabChanged ON PU_Task_7 WITH mpLintab^

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbReParam := TRUE;
mbReParamLight := TRUE;

// Calculate new limit for indicating sensor calibration error,
// lintabs are monotonic, limit should depend on highest value
mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintab^.LintabPoints.Point[mpLintab^.LintabPoints.uNoOfPoints].rY-
                             mpLintab^.LintabPoints.Point[1].rY);


;#END_EDIT_BLOCK END_ALGORITHM

(*
This algorithm reacts on changes of the lintab.
If the lintab changes, the flag for reparam is set.
*)

POSTUPDATE_ALGORITHM pOpenArrayLintabChanged ON PU_Task_7 WITH mpLintabPointArray^,mpiUsedLintabPoints^


VAR
 iPoints : UDINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbReParam := TRUE;
mbReParamLight := TRUE;

// Calculate new limit for indicating sensor calibration error,
// lintabs are monotonic, limit should depend on highest value
iPoints := MIN(mpiUsedLintabPoints^, miMaxLintabSize);
mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintabPointArray^[iPoints].rY - mpLintabPointArray^[1].rY);


;#END_EDIT_BLOCK END_ALGORITHM

(*
This algorithm reacts on a change of the velocity filter time.
The new filter time is copied and the flag for reparam is set.
*)

POSTUPDATE_ALGORITHM pFilterTimeChanged ON PU_Task_7 WITH mpVelFilterTime^

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mdFilterTime := mpVelFilterTime^;
mbReParam := TRUE;
mbReParamLight := TRUE;


;#END_EDIT_BLOCK END_ALGORITHM

(*
This algorithm reacts on a change of the velocity filter time.
The new filter time is copied and the flag for reparam is set.
*)

POSTUPDATE_ALGORITHM pPosFilterTimeChanged ON PU_Task_7 WITH mpPosFilterTime^

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mdT1Position := mpPosFilterTime^;
IF (mdT1Position > T#0s) THEN
   mT1PositionUsed := TRUE;
ELSE
   mT1PositionUsed := FALSE;
END_IF;

mbReParamLight := TRUE;


;#END_EDIT_BLOCK END_ALGORITHM

(*
This algorithm checks if the given references are valid.
If a reference is not valid an alarm will be set.
*)

ALGORITHM aInit


VAR_INPUT
 pLintab : REFTO KAPPL_LintabData (* pointer to lintab that should be used *);
 pdVelocityFilterTime : REFTO TIME (* reference to systemvariable that contains the filter time for velocity measuring *);
 pdPositionFilterTime : REFTO TIME (* reference to systemvariable that contains the filter time for position measuring *);
 sRawValue : STRING(64);
 pLintabPointArray : REFTO tyLintabPoints (* reference to array with lintab points (open array!!) *);
 piUsedLintabPoints : REFTO UDINT (* reference to number of used lintab points *);
END_VAR

VAR
 bInitDone : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bInitDone THEN
    
    //copy reference of lintab and check if reference is valid
    mpLintab := pLintab;
    mpLintabPointArray := pLintabPointArray;
    mpiUsedLintabPoints := piUsedLintabPoints;
    IF CHECK_REF(mpLintab^) THEN
        mbValidLintabReference := TRUE; 
    ELSIF CHECK_REF(mpLintabPointArray^) AND CHECK_REF(mpiUsedLintabPoints^) THEN
        mbValidLintabReference := TRUE;
        mbOpenArray := TRUE;
        miMaxLintabSize := GET_HIGH_BOUND(mpLintabPointArray^);
    ELSE
        SET_ALARM(Name := erInvalidLintabReference,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId);
    END_IF; 
        
    //get reference of velocity filter time
    IF CHECK_REF(pdVelocityFilterTime^) THEN
        mdFilterTime := pdVelocityFilterTime^;
        mpVelFilterTime := pdVelocityFilterTime;
    ELSE
        //use default value if no reference is available
        // <=> 12.5 Hz
        mdFilterTime := t#12ms732us;
    END_IF;

    IF CHECK_REF(pdPositionFilterTime^) THEN
        mdT1Position := pdPositionFilterTime^;
        IF (mdT1Position > T#0s) THEN
           mT1PositionUsed := TRUE;
        ELSE
           mT1PositionUsed := FALSE;
        END_IF;
        mpPosFilterTime := pdPositionFilterTime;
    ELSE
        mdT1Position := T#0s;
        mT1PositionUsed := FALSE;
    END_IF;
      
    msRawValue := sRawValue;
    bInitDone := TRUE;
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

(*
Allow lower limit monitoring of measured value. 
If monitoring enabled, alarm will be set if measured value smaller than mrMonLowFailureLimit.
The failure limit mrMonLowFailureLimit can be set to mrMonLimit by using rFailureFactor = 0.0.
If mbMonLimitation is true all measured values in the area [mrMonLowFailureLimit mrMonLowLimit] 
will be set to mrMonLowLimit.
*)

ALGORITHM aInitMonitoring


VAR_INPUT
 bEnable : BOOL;
 rLowLimit : REAL;
 bLimitation : BOOL;
 rFailureFactor : REAL := 0.01;
 bCheckLowerLimit : BOOL (* TRUE: set alarm if value is below the lower limit (calculated by rLowLimit, rFailureFactor and  given lintab) *);
END_VAR

VAR
 iPoints : UDINT;
END_VAR
#BEGIN_EDIT_BLOCK
mbMonEnable := bEnable;
mrMonLowLimit := rLowLimit;
mbCheckLowerLimit := bCheckLowerLimit;

// Limitation only with monitoring
mbMonLimitation := bLimitation AND mbMonEnable;
mrMonFailureFactor := rFailureFactor;
// Define lowest value without setting alarm by using maximum and minimum lintab points 
IF mbOpenArray THEN
   iPoints := MIN(mpiUsedLintabPoints^, miMaxLintabSize);
   mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintabPointArray^[iPoints].rY - mpLintabPointArray^[1].rY);
ELSE
   mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintab^.LintabPoints.Point[mpLintab^.LintabPoints.uNoOfPoints].rY-
                             mpLintab^.LintabPoints.Point[1].rY);
END_IF;
    


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 157 @Pou 25 
@@@BEG_Comment@@@
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

This AB is used for measuring of analog inputs.
It includes the following funcionalities:
- converting an analog input to a measure value by using a linearization table 
- automatic reparam after a change in lintab
- automatic detection of analog inut errors
- velocity measurement by using a filter
- fast and slow measuring


@FunctionID: S_KPIEC_ALASENS_01

@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
3 
@Var @RT(9)SET_ALARM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)RESET_ALARM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)GET_TASK_INTERVAL @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
6 
@Var @RT(23)cMeasureReductionFactor @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(1)5 @RT(103)reduction factor for measure block (reduction is active if no movement of this function unit is active) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(30)cApplPlasticsWrongLintabParams @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(4)-111 @RT(41)Lintabparams are wrong or not initialized 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)KCTRL_Ret_OK @RT(0) @T @T @DERIVED 0 @F @RT(9)KCTRL_Ret @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(27)cApplPlasticsWrongPT1Params @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(4)-121 @RT(39)PT1 params are wrong or not initialized 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(26)cApplPlasticsPT1CalcFailed @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(4)-122 @RT(29)cyclic PT1 calculation failed 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)cPointsLastAIValue @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(1)5 @RT(69)Number of Points for calculating mean value of the last analog inputs 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(15)ABMeasureAnalog @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
30 
@Var @RT(15)sv_bDeviceReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(11)sv_DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(9)PU_Task_7 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(24)erInvalidLintabReference @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(15)erAnalogMeasure @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(14)erAnalogSensor @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(8)mpLintab @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)mbReParam @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)fbMeasure @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)KAPPL_Plastics_Measure @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mbValidLintabReference @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)info if lintab reference is valid @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mdFilterTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(36)filter time for velocity measurement @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mpVelFilterTime @RT(0) @T @T @REFTO 0 @T @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)msRawValue @RT(0) @T @F @DT @RT(10)STRING(64) @RT(0) @T @T @STRING 0 @F @RT(2)64 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)mbMonEnable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)FALSE @RT(28)enable monitoring for rValue @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrMonLowLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)lower limit for monitoring @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mbMonLimitation @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(42)use limitation, set values to lower limit  @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mrMonFailureFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(37)define the area without setting alarm @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)mrMonLowFailureLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)lowest value without alarm @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mbReParamLight @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)mbRun @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)fbRTrigMeasureError @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(6)R_TRIG @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)miCount @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(64)Idle: counts up to cMeasureReductionFactor-1, NOT Idle: always 0 @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mbCheckLowerLimit @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mdT1Position @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mT1PositionUsed @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mpPosFilterTime @RT(0) @T @T @REFTO 0 @T @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mpLintabPointArray @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(14)tyLintabPoints @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mpiUsedLintabPoints @RT(0) @T @T @REFTO 0 @T @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)mbOpenArray @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(56)is set to TRUE if an open array of lintab points is used @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)miMaxLintabSize @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

8 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(9)aRunLight @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
10 
@Var @RT(9)rRawValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)rValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)result of measuring (e.g. position) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(13)measure error @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(20)additional erro info @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(15)bLintabAlarmSet @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)bAnalogSensorError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)fbFTrigSensorError @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(6)F_TRIG @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)fbRTrigSensorError @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(6)R_TRIG @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aRun @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
21 
@Var @RT(9)rRawValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)rValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)result of measuring (e.g. position) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)rValueDiff @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(67)change of the measure result per time (e.g. mm/s) (always positive) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(13)measure error @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(20)additional erro info @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(8)uCounter @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(9)bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)dCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rCycleTime @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)cycletime of this Task in seconds @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)rOldValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(52)result of measuring from the last call of this block @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)abKCTRL_PTn @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KCTRL_PTN @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)ptnParams @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KCTRL_PTN_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)rVelocityNotFiltered @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)rDelta @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)bAiIsConstant @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rMeanAIValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)uMeanAIValuesCounter @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(1)1 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)rMinDelta @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(6)9999.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)tyLastAIValues @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)tyLastAIValueArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bInitIdle @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)bInitNotIdle @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(14)pLintabChanged @STRUCTURED_TEXT 
@RT(0) @RT(9)mpLintab^ @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(23)pOpenArrayLintabChanged @STRUCTURED_TEXT 
@RT(0) @RT(40)mpLintabPointArray^,mpiUsedLintabPoints^ @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(7)iPoints @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(18)pFilterTimeChanged @STRUCTURED_TEXT 
@RT(0) @RT(16)mpVelFilterTime^ @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(21)pPosFilterTimeChanged @STRUCTURED_TEXT 
@RT(0) @RT(16)mpPosFilterTime^ @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(5)aInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
7 
@Var @RT(7)pLintab @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(37)pointer to lintab that should be used @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)pdVelocityFilterTime @RT(0) @T @T @REFTO 0 @T @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(80)reference to systemvariable that contains the filter time for velocity measuring @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)pdPositionFilterTime @RT(0) @T @T @REFTO 0 @T @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(80)reference to systemvariable that contains the filter time for position measuring @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)sRawValue @RT(0) @T @F @DT @RT(10)STRING(64) @RT(0) @T @T @STRING 0 @F @RT(2)64 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)pLintabPointArray @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(14)tyLintabPoints @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(52)reference to array with lintab points (open array!!) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)piUsedLintabPoints @RT(0) @T @T @REFTO 0 @T @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)reference to number of used lintab points @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(15)aInitMonitoring @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
6 
@Var @RT(7)bEnable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)rLowLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)bLimitation @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)rFailureFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)0.01 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)bCheckLowerLimit @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(109)TRUE: set alarm if value is below the lower limit (calculated by rLowLimit, rFailureFactor and  given lintab) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)iPoints @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(103)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//don´t do measurement if references are not valid
IF NOT mbValidLintabReference THEN
    
    IF NOT mbValidLintabReference AND NOT bLintabAlarmSet THEN
        SET_ALARM(Name := erInvalidLintabReference,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId);
        bLintabAlarmSet := TRUE;
    END_IF;
    mbRun := FALSE;
    RETURN;        
END_IF;


IF NOT bInitDone OR mbReParamLight THEN
    //reparam measure block
    IF mbOpenArray THEN
       FOR i := 1 TO miMaxLintabSize DO
          fbMeasure.Lintab.LintabPoints.Point[i].rX := mpLintabPointArray^[i].rX;
          fbMeasure.Lintab.LintabPoints.Point[i].rY := mpLintabPointArray^[i].rY;
       END_FOR;
       fbMeasure.Lintab.LintabPoints.uNoOfPoints := MIN(mpiUsedLintabPoints^, miMaxLintabSize);
    ELSE
       fbMeasure.Lintab := mpLintab^;
    END_IF;
                            
    fbMeasure(LintabUsed := TRUE,
              ReParam := TRUE,
              T1 := mdT1Position,
              T1Used := mT1PositionUsed);
    
    mbReParamLight := FALSE;
    bInitDone := TRUE;
END_IF;


//do fast measurement only if movement is active
//if movement is not active then measurement should be done every cMeasureReduction - cycle 
IF NOT sv_bDeviceReady OR miCount = (cMeasureReductionFactor - 1) THEN
    
    fbMeasure(RawValue := rRawValue,
             ReParam := FALSE,
             OutputValue => rValue,
             Error => bError,
             ErrorInfo => iErrorInfo);
    // Allow only Analog Input values >= mrMonLowLimit. Set values to zero in small area 
    // [mrMonLowFailureLimit mrMonLowLimit]
    // and set error, if the value is smaller than mrMonLowFailureLimit 
    IF mbMonEnable THEN
        IF mbCheckLowerLimit THEN
           bAnalogSensorError := FALSE;
           IF rValue < mrMonLowFailureLimit THEN
              bAnalogSensorError := TRUE;
              iErrorInfo := cApplPlasticsWrongLintabParams; 
           END_IF;
        END_IF;
              
        IF mbMonLimitation THEN
            rValue := MAX(rValue, mrMonLowLimit);
        END_IF;        
    END_IF;

    miCount := 0;
ELSE
    //increase counter
    miCount := miCount + 1;
END_IF;

//set alarm if error occurs during measure
fbRTrigMeasureError(CLK := bError);
IF fbRTrigMeasureError.Q THEN
    SET_ALARM(Name := erAnalogMeasure,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId,
              SubID3 := iErrorInfo);
END_IF;

// Set alarm, if value not allowed
IF mbMonEnable AND mbCheckLowerLimit THEN
    //set alarm if error occurs during measure
    fbRTrigSensorError(CLK := bAnalogSensorError);
    IF fbRTrigSensorError.Q THEN
        SET_ALARM(Name := erAnalogSensor,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId,
                Param1 := msRawValue);
    END_IF;
    // Reset alarm after measured value is greater than limit,
    // user reset still neccessary
    fbFTrigSensorError(CLK := bAnalogSensorError);
    IF fbFTrigSensorError.Q THEN
        RESET_ALARM(Name := erAnalogSensor,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId);
    END_IF;
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(6)
Following functions are realized in this algorithm:

1) fast and slow measuring by using the given lintab
2) errorhandling

NO velocity measuring, e.g. for pressure AIs.
@@@END_Comment@@@ 

@BEG_Body 
@TL(129)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
mbRun := TRUE;
aRunLight(rValue => rValue, 
          bError => bError, 
          iErrorInfo => iErrorInfo,
          rRawValue := rRawValue);
// Part for calculating differential quotient (e.g. velocity)
IF mbRun THEN
   IF NOT bInitDone OR mbReParam THEN
    
       IF NOT bInitDone THEN
           //get cycle time
           dCycleTime :=  GET_TASK_INTERVAL();
           rCycleTime := (LINT_TO_REAL(TIME_TO_LINT(dCycleTime))) / 1000000.0;
       END_IF;
       //filter initialization
       // Test shows good results by using
       // 12.5 Hz and order 2
       ptnParams.uN := 2;
       ptnParams.rK := 1.0;
       ptnParams.dT1 := mdFilterTime;
       ptnParams.dT2 := mdFilterTime;
       abKCTRL_PTn.Par(dCycleTime := dCycleTime,
                       Param := ptnParams);
       IF (abKCTRL_PTn.Par.parStatus <> KCTRL_Ret_OK) THEN
          bError := TRUE;
          iErrorInfo := cApplPlasticsWrongPT1Params;
          SET_ALARM(Name := erAnalogMeasure,
                    SubID1 := sv_DeviceId.CompId,
                    SubID2 := sv_DeviceId.IndexId,
                    SubID3 := iErrorInfo);
       ELSE
          bError := FALSE;
       END_IF;
    
       abKCTRL_PTn.Init(rOutVal := 0.0);
    
       rOldValue := rValue;
       mbReParam := FALSE;
       bInitDone := TRUE;
   END_IF;

   //do fast measurement only if movement is active
   //if movement is not active then measurement should be done every cMeasureReduction - cycle 
   IF miCount = 0 THEN
      //velocity measurement
      IF sv_bDeviceReady THEN
         IF (NOT bInitIdle ) THEN
            bInitIdle := TRUE;
            bInitNotIdle := FALSE;
            abKCTRL_PTn.Par(dCycleTime := MULTIME(dCycleTime, cMeasureReductionFactor));
            abKCTRL_PTn.Init(rOutVal := abKCTRL_PTn.Calculate.rOutVal);
         END_IF;                     
         rVelocityNotFiltered := (rValue - rOldValue) / (rCycleTime * DINT_TO_REAL(cMeasureReductionFactor));         
      ELSE
         IF (NOT bInitNotIdle) THEN
            bInitIdle := FALSE;
            bInitNotIdle := TRUE;
            abKCTRL_PTn.Par(dCycleTime := dCycleTime);
            abKCTRL_PTn.Init(rOutVal := abKCTRL_PTn.Calculate.rOutVal);
         END_IF;            
         rVelocityNotFiltered := (rValue - rOldValue) / rCycleTime;
      END_IF;
      //use a filter for velocity measurement
      abKCTRL_PTn.Calculate(rInVal := rVelocityNotFiltered);
      IF (abKCTRL_PTn.Calculate.calcStatus <> KCTRL_Ret_OK) THEN
         bError := TRUE;
         iErrorInfo := cApplPlasticsPT1CalcFailed;
      ELSE
         rValueDiff := abKCTRL_PTn.Calculate.rOutVal;
         // standstill-detection
         // Set velocity to zero if Analog Input is not changing
         // Take more than two points, otherwise a small velocity (e.g. < 6.5% v_max) 
         // would also be set to zero all time of injection process            
            
         // find difference of 1 bit resolution 
         rDelta := ABS(rValue - rOldValue);
         IF (rDelta < rMinDelta) AND (rDelta > 0.0) THEN
            rMinDelta := rDelta;  
         END_IF;     
         // cyclic saving of screw position  
         // cPointsLastAIValue = 5 shows good results by tests
         IF uMeanAIValuesCounter >= cPointsLastAIValue THEN
            uMeanAIValuesCounter := 1;
         ELSE
            uMeanAIValuesCounter := uMeanAIValuesCounter + 1;
         END_IF;
            
         // Calculating Mean Value of filtered velocity in every step new,
         // because by subtracting old value and adding new value
         // there will be numerical noise after few minutes
         tyLastAIValues[uMeanAIValuesCounter] := rValue;
         rMeanAIValue := 0.0;
         FOR uCounter := 1 TO cPointsLastAIValue DO
             rMeanAIValue := rMeanAIValue + tyLastAIValues[uCounter];
         END_FOR;
         rMeanAIValue := rMeanAIValue / DINT_TO_REAL(cPointsLastAIValue);
            
         bAiIsConstant := TRUE; 
         // Start standstill detection only if filtered velocity < v_min_Timediff
         IF (ABS(rValueDiff) > (rMinDelta / rCycleTime)) THEN
            bAiIsConstant := bAiIsConstant AND FALSE;
         END_IF;   
         FOR uCounter := 1 TO cPointsLastAIValue DO
            IF (ABS(tyLastAIValues[uCounter] - rMeanAIValue) >= rMinDelta ) THEN
                bAiIsConstant := bAiIsConstant AND FALSE;
            END_IF;
         END_FOR; 
         IF bAiIsConstant THEN
            rValueDiff := 0.0;
         END_IF; 
         rValueDiff := ABS(rValueDiff);
      END_IF;  
      rOldValue := rValue;       
   END_IF;
END_IF;

//set alarm if error occurs during measure
fbRTrigMeasureError(CLK := bError);
IF fbRTrigMeasureError.Q THEN
    SET_ALARM(Name := erAnalogMeasure,
              SubID1 := sv_DeviceId.CompId,
              SubID2 := sv_DeviceId.IndexId,
              SubID3 := iErrorInfo);
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(5)
Following functions are realized in this algorithm:

1) fast and slow measuring by using the given lintab
2) velocity measuring
3) errorhandling
@@@END_Comment@@@ 

@BEG_Body 
@TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbReParam := TRUE;
mbReParamLight := TRUE;

// Calculate new limit for indicating sensor calibration error,
// lintabs are monotonic, limit should depend on highest value
mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintab^.LintabPoints.Point[mpLintab^.LintabPoints.uNoOfPoints].rY-
                             mpLintab^.LintabPoints.Point[1].rY);

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
This algorithm reacts on changes of the lintab.
If the lintab changes, the flag for reparam is set.
@@@END_Comment@@@ 

@BEG_Body 
@TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbReParam := TRUE;
mbReParamLight := TRUE;

// Calculate new limit for indicating sensor calibration error,
// lintabs are monotonic, limit should depend on highest value
iPoints := MIN(mpiUsedLintabPoints^, miMaxLintabSize);
mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintabPointArray^[iPoints].rY - mpLintabPointArray^[1].rY);

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
This algorithm reacts on changes of the lintab.
If the lintab changes, the flag for reparam is set.
@@@END_Comment@@@ 

@BEG_Body 
@TL(9)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mdFilterTime := mpVelFilterTime^;
mbReParam := TRUE;
mbReParamLight := TRUE;

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
This algorithm reacts on a change of the velocity filter time.
The new filter time is copied and the flag for reparam is set.
@@@END_Comment@@@ 

@BEG_Body 
@TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mdT1Position := mpPosFilterTime^;
IF (mdT1Position > T#0s) THEN
   mT1PositionUsed := TRUE;
ELSE
   mT1PositionUsed := FALSE;
END_IF;

mbReParamLight := TRUE;

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
This algorithm reacts on a change of the velocity filter time.
The new filter time is copied and the flag for reparam is set.
@@@END_Comment@@@ 

@BEG_Body 
@TL(51)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bInitDone THEN
    
    //copy reference of lintab and check if reference is valid
    mpLintab := pLintab;
    mpLintabPointArray := pLintabPointArray;
    mpiUsedLintabPoints := piUsedLintabPoints;
    IF CHECK_REF(mpLintab^) THEN
        mbValidLintabReference := TRUE; 
    ELSIF CHECK_REF(mpLintabPointArray^) AND CHECK_REF(mpiUsedLintabPoints^) THEN
        mbValidLintabReference := TRUE;
        mbOpenArray := TRUE;
        miMaxLintabSize := GET_HIGH_BOUND(mpLintabPointArray^);
    ELSE
        SET_ALARM(Name := erInvalidLintabReference,
                SubID1 := sv_DeviceId.CompId,
                SubID2 := sv_DeviceId.IndexId);
    END_IF; 
        
    //get reference of velocity filter time
    IF CHECK_REF(pdVelocityFilterTime^) THEN
        mdFilterTime := pdVelocityFilterTime^;
        mpVelFilterTime := pdVelocityFilterTime;
    ELSE
        //use default value if no reference is available
        // <=> 12.5 Hz
        mdFilterTime := t#12ms732us;
    END_IF;

    IF CHECK_REF(pdPositionFilterTime^) THEN
        mdT1Position := pdPositionFilterTime^;
        IF (mdT1Position > T#0s) THEN
           mT1PositionUsed := TRUE;
        ELSE
           mT1PositionUsed := FALSE;
        END_IF;
        mpPosFilterTime := pdPositionFilterTime;
    ELSE
        mdT1Position := T#0s;
        mT1PositionUsed := FALSE;
    END_IF;
      
    msRawValue := sRawValue;
    bInitDone := TRUE;
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
This algorithm checks if the given references are valid.
If a reference is not valid an alarm will be set.
@@@END_Comment@@@ 

@BEG_Body 
@TL(19)
mbMonEnable := bEnable;
mrMonLowLimit := rLowLimit;
mbCheckLowerLimit := bCheckLowerLimit;

// Limitation only with monitoring
mbMonLimitation := bLimitation AND mbMonEnable;
mrMonFailureFactor := rFailureFactor;
// Define lowest value without setting alarm by using maximum and minimum lintab points 
IF mbOpenArray THEN
   iPoints := MIN(mpiUsedLintabPoints^, miMaxLintabSize);
   mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintabPointArray^[iPoints].rY - mpLintabPointArray^[1].rY);
ELSE
   mrMonLowFailureLimit := mrMonLowLimit - mrMonFailureFactor * 
                         ABS(mpLintab^.LintabPoints.Point[mpLintab^.LintabPoints.uNoOfPoints].rY-
                             mpLintab^.LintabPoints.Point[1].rY);
END_IF;
    

@END_Body 

@@@BEG_Comment@@@ 
@TL(5)
Allow lower limit monitoring of measured value. 
If monitoring enabled, alarm will be set if measured value smaller than mrMonLowFailureLimit.
The failure limit mrMonLowFailureLimit can be set to mrMonLimit by using rFailureFactor = 0.0.
If mbMonLimitation is true all measured values in the area [mrMonLowFailureLimit mrMonLowLimit] 
will be set to mrMonLowLimit.
@@@END_Comment@@@ 
@END_Body 

@END_Contents 
