(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

This block contains the necessary algorithms to request and release the output devices
for a defined movement.
Furthermore it is possible to check if all required pumps are free (aCheckRequiredPumpsFree).
The algorithm aRequestSinglePump can be used to request only one defined pump.
By calling the algorithm aReleaseSinglePump, it is possible to release a definded pump during a movement.
*)

IMPORT_OVER_LISTFILE
 SET_EVENT
, cCompPump
, tevOutputRequest
, tevOutputResponse
, tsDeviceId
, tsMoveData
, FBDebugTrace
, tsTraceLevel
, tyNumberOfDevices
, tyPumpData
, tevReleaseSinglePump
, tyRequiredPumps
, tevInterruptActivePump
, tevRequestSinglePump
, tpMoveData
, tnAnaOutputMode
, tevOutputRequestData
, tevOutputResponseData
, tevReleaseSinglePumpData
, tevInterruptActivePumpData
, tevRequestSinglePumpData

END_IMPORT

ALGORITHM_BLOCK ABOutputRequest #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_DeviceId : tsDeviceId;
 sv_TraceLevel : tsTraceLevel;
 sv_rPressure : REAL;
 sv_rVelocity : REAL;
 sv_NumberOfDevices : tyNumberOfDevices;
 sv_PumpData : tyPumpData;
END_VAR

SYSTEM_OBJECT
 evOutputRequest : tevOutputRequest;
 evOutputResponse : tevOutputResponse;
 EV_Task_1 : TASK;
 evReleaseSinglePump : tevReleaseSinglePump;
 evInterruptActivePump : tevInterruptActivePump;
 evRequestSinglePump : tevRequestSinglePump;
END_OBJECT

VAR
 mevOutputResponse : tevOutputResponse;
 mMoveData : tsMoveData;
 mbOutputRequested : BOOL;
 mbOutputIdle : BOOL;
 fbDebugTrace : FBDebugTrace;
 mRequestedPumps : tyRequiredPumps;
 mNoPumps : tyRequiredPumps;
 mbWaitForResponse : BOOL (* TRUE: wait for evAnaDevResponse; FALSE: check sv_PumpData to find out if the requested pumps are ready for output *);
END_VAR

ALGORITHM aRequest


VAR_INPUT
 pMoveData : tpMoveData;
 AnaOutputMode : tnAnaOutputMode;
 prVelocity : REFTO REAL (* optional parameter; by default sv_rVelocity is used *);
 prPressure : REFTO REAL (* optional parameter; by default sv_rPressure is used *);
END_VAR

VAR
 evOutputRequestData : tevOutputRequestData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bAnalog THEN
    fbDebugTrace(CONCAT('ABOutputRequest-aRequest() ',
                        DINT_TO_STRING(sv_DeviceId.CompId), '.', DINT_TO_STRING(sv_DeviceId.IndexId),
                        ' ',
                        DINT_TO_STRING(pMoveData^.MoveId), '/', DINT_TO_STRING(pMoveData^.MoveDir)));
END_IF;

IF NOT mbOutputRequested THEN
    
    mbOutputIdle := FALSE;
    mMoveData := pMoveData^;
    
    evOutputRequestData.pMoveData := pMoveData;    
    evOutputRequestData.DeviceIdSender := sv_DeviceId;
    evOutputRequestData.bRelease := FALSE;
    evOutputRequestData.AnaOutputMode := AnaOutputMode;
    mbOutputRequested := TRUE;
   
    IF CHECK_REF(mMoveData.AnaOutData.pRequiredPumps^) THEN
       //save requested pumps
       mRequestedPumps := mMoveData.AnaOutData.pRequiredPumps^.RequiredPumps;
    ELSE
       mRequestedPumps := mNoPumps;
    END_IF;
   
    IF CHECK_REF(prVelocity^) THEN
       evOutputRequestData.prVelocity := prVelocity;  
    ELSE
       evOutputRequestData.prVelocity := @sv_rVelocity;
    END_IF;
   
    IF CHECK_REF(prPressure^) THEN
       evOutputRequestData.prPressure := prPressure;  
    ELSE
       evOutputRequestData.prPressure := @sv_rPressure;
    END_IF;
   
    IF (sv_NumberOfDevices[cCompPump] > 0) AND CHECK_REF(mMoveData.AnaOutData.pRequiredPumps^) THEN
       //use sv_PumpData instead of listening to evOutputResponse
       mbWaitForResponse := FALSE;
    ELSE
       mbWaitForResponse := TRUE;
       mevOutputResponse := evOutputResponse;  //"activate" event algorithm
    END_IF;
   
    SET_EVENT(evOutputRequest, evOutputRequestData);
ELSE
    IF sv_TraceLevel.bAnalog THEN
        fbDebugTrace('ABOutputRequest-aRequest() mbOutputRequested already TRUE -> not sending request');
    END_IF;
END_IF; 


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aRelease


VAR_INPUT
 pMoveData : tpMoveData;
END_VAR

VAR
 evOutputRequestData : tevOutputRequestData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bAnalog THEN
    fbDebugTrace(CONCAT('ABOutputRequest-aRelease() ',
                        DINT_TO_STRING(sv_DeviceId.CompId), '.', DINT_TO_STRING(sv_DeviceId.IndexId),
                        ' ',
                        DINT_TO_STRING(pMoveData^.MoveId), '/', DINT_TO_STRING(pMoveData^.MoveDir)));
END_IF;

IF mbOutputRequested THEN 
        
    evOutputRequestData.DeviceIdSender := sv_DeviceId; 
    evOutputRequestData.pMoveData := pMoveData;
    evOutputRequestData.bRelease := TRUE;
    SET_EVENT(evOutputRequest, evOutputRequestData);
    mbOutputRequested := FALSE;
   
    mRequestedPumps := mNoPumps;
    mbWaitForResponse := FALSE;
ELSE
    IF sv_TraceLevel.bAnalog THEN
        fbDebugTrace('ABOutputRequest-aRelease() mbOutputRequested FALSE -> not sending release request');
    END_IF;
END_IF;    


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aCheck


VAR_OUTPUT
 bReady : BOOL;
END_VAR

VAR_TEMP
 iPump : DINT;
END_VAR

VAR
 iReadyBlockCounter : DINT;
 fbDebugTrace : FBDebugTrace;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbWaitForResponse THEN
   //wait for response event (for example on EIMM)
   bReady := mbOutputRequested AND mbOutputIdle;
ELSE
   //check if all requested pumps are available for this movement
   bReady := TRUE;
   FOR iPump := 1 TO sv_NumberOfDevices[cCompPump] DO
      IF (mRequestedPumps[iPump]) AND 
        ((sv_PumpData[iPump].ActiveDevice <> sv_DeviceId) OR (sv_PumpData[iPump].ActiveMoveId <> mMoveData.MoveId)) THEN
         //pump is requested but actually not available for this movement
         bReady := FALSE;
         EXIT;
      END_IF;
   END_FOR;   
END_IF;

IF bReady THEN
   iReadyBlockCounter := 0;
ELSE
   //check if request is blocked for a long time
   iReadyBlockCounter := iReadyBlockCounter + 1;
   IF iReadyBlockCounter = 100 THEN
      fbDebugTrace(CONCAT('ABOutputRequest-aCheck() request blocked for long time ',
                          DINT_TO_STRING(sv_DeviceId.CompId),
                          '.',
                          DINT_TO_STRING(sv_DeviceId.IndexId),
                          ' ',
                          DINT_TO_STRING(mMoveData.MoveId),
                          '/',
                          DINT_TO_STRING(mMoveData.MoveDir)));
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

EVENT_ALGORITHM evaOutputResponse ON EV_Task_1 WITH mevOutputResponse


VAR_INPUT
 evOutputResponseData : tevOutputResponseData;
END_VAR

VAR
 fbDebugTrace : FBDebugTrace;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbOutputRequested AND
   evOutputResponseData.DeviceId = sv_DeviceId AND
   evOutputResponseData.MoveId = mMoveData.MoveId THEN
   
   IF sv_TraceLevel.bAnalog THEN
      fbDebugTrace(CONCAT('ABOutputRequest-evaOutputResponse() ',
                          DINT_TO_STRING(evOutputResponseData.DeviceId.CompId), '.', DINT_TO_STRING(evOutputResponseData.DeviceId.IndexId),
                          ' ',
                          DINT_TO_STRING(evOutputResponseData.MoveId)));
   END_IF;

   mbOutputIdle := TRUE;
   mevOutputResponse := EMPTY; //"deactivate" event algorithm
END_IF;
                                                     


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aCheckRequiredPumpsFree


VAR_INPUT
 RequiredPumps : tyRequiredPumps (* required pumps *);
END_VAR

VAR_OUTPUT
 bRequiredPumpsFree : BOOL (* TRUE: all required pumps are free *);
END_VAR

VAR_TEMP
 iPump : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//check if all required pumps for a movement are free
bRequiredPumpsFree := TRUE;
FOR iPump := 1 TO sv_NumberOfDevices[cCompPump] DO
   IF (RequiredPumps[iPump]) AND (sv_PumpData[iPump].PumpState <> nPumpStateFree) THEN
      //required pump is busy
      bRequiredPumpsFree := FALSE;
      EXIT;
   END_IF;
END_FOR;


;#END_EDIT_BLOCK END_ALGORITHM

(*
algorithm for releasing a single pump
*)

ALGORITHM aReleaseSinglePump


VAR_INPUT
 iPump : DINT (* pump to release *);
END_VAR

VAR
 evReleaseSinglePumpData : tevReleaseSinglePumpData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF iPump = 0 OR iPump > cMaxNrOfPumps THEN
   fbDebugTrace(CONCAT('ABOutputRequest-aReleaseSinglePump was called with iPump = ',
                        DINT_TO_STRING(iPump)));
   RETURN;
END_IF;

evReleaseSinglePumpData.iPump := iPump;
evReleaseSinglePumpData.DeviceIdSender := sv_DeviceId;
SET_EVENT(evReleaseSinglePump, evReleaseSinglePumpData);

//mark this pump as "released"
mRequestedPumps[iPump] := FALSE;

//check if all requested pumps are released
IF mRequestedPumps = mNoPumps THEN
   mbOutputRequested := FALSE;
END_IF;




;#END_EDIT_BLOCK END_ALGORITHM

(*
algorithm for interrupting an active pump (pump is actually used by another movement)
The according pump is stopped (ramped down) and then it is started and outputs for this movement.
*)

ALGORITHM aInterruptActivePump


VAR_INPUT
 iPump : DINT (* pump to release *);
 pMoveData : tpMoveData;
 AnaOutputMode : tnAnaOutputMode;
 prVelocity : REFTO REAL (* optional parameter; by default sv_rVelocity is used *);
 prPressure : REFTO REAL (* optional parameter; by default sv_rPressure is used *);
END_VAR

VAR
 evInterruptActivePumpData : tevInterruptActivePumpData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF iPump = 0 OR iPump > cMaxNrOfPumps THEN
   fbDebugTrace(CONCAT('ABOutputRequest-aInterruptActivePump was called with iPump = ',
                        DINT_TO_STRING(iPump)));
   RETURN;
END_IF;

mbOutputRequested := TRUE;
mRequestedPumps[iPump] := TRUE;

IF CHECK_REF(prVelocity^) THEN
   evInterruptActivePumpData.prVelocity := prVelocity;  
ELSE
   evInterruptActivePumpData.prVelocity := @sv_rVelocity;
END_IF;

IF CHECK_REF(prPressure^) THEN
   evInterruptActivePumpData.prPressure := prPressure;  
ELSE
   evInterruptActivePumpData.prPressure := @sv_rPressure;
END_IF;

evInterruptActivePumpData.iPump := iPump;
evInterruptActivePumpData.AnaOutputMode := AnaOutputMode;
evInterruptActivePumpData.pMoveData := pMoveData;
evInterruptActivePumpData.DeviceIdSender := sv_DeviceId;
SET_EVENT(evInterruptActivePump, evInterruptActivePumpData);


;#END_EDIT_BLOCK END_ALGORITHM

(*
algorithm for releasing a single pump
*)

ALGORITHM aRequestSinglePump


VAR_INPUT
 iPump : DINT (* pump which should be requested *);
 pMoveData : tpMoveData;
 AnaOutputMode : tnAnaOutputMode (* output mode (fast or mid) *);
 prVelocity : REFTO REAL (* optional parameter; by default sv_rVelocity is used *);
 prPressure : REFTO REAL (* optional parameter; by default sv_rPressure is used *);
END_VAR

VAR
 evRequestSinglePumpData : tevRequestSinglePumpData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (iPump = 0) OR (iPump > cMaxNrOfPumps) THEN
   fbDebugTrace(CONCAT('ABOutputRequest-aRequestSinglePump was called with iPump = ',
                        DINT_TO_STRING(iPump)));
   RETURN;
END_IF;

IF sv_TraceLevel.bAnalog THEN
    fbDebugTrace(CONCAT('ABOutputRequest-aRequestSinglePump ',
                        '(Pump ', DINT_TO_STRING(iPump), ') for ', 
                        DINT_TO_STRING(sv_DeviceId.CompId), '.', DINT_TO_STRING(sv_DeviceId.IndexId),
                        ' ',
                        DINT_TO_STRING(pMoveData^.MoveId), '/', DINT_TO_STRING(pMoveData^.MoveDir)));
END_IF;


mMoveData := pMoveData^;
   
evRequestSinglePumpData.iPump := iPump; 
evRequestSinglePumpData.pMoveData := pMoveData;    
evRequestSinglePumpData.DeviceIdSender := sv_DeviceId;
evRequestSinglePumpData.AnaOutputMode := AnaOutputMode;

mbOutputRequested := TRUE;

//mark this pump as "requested"
mRequestedPumps[iPump] := TRUE;

IF CHECK_REF(prVelocity^) THEN
   evRequestSinglePumpData.prVelocity := prVelocity;  
ELSE
   evRequestSinglePumpData.prVelocity := @sv_rVelocity;
END_IF;

IF CHECK_REF(prPressure^) THEN
   evRequestSinglePumpData.prPressure := prPressure;  
ELSE
   evRequestSinglePumpData.prPressure := @sv_rPressure;
END_IF;

//use sv_PumpData instead of listening to evOutputResponse
mbWaitForResponse := FALSE;
 
SET_EVENT(evRequestSinglePump, evRequestSinglePumpData);



;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 97 @Pou 25 
@@@BEG_Comment@@@
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

This block contains the necessary algorithms to request and release the output devices
for a defined movement.
Furthermore it is possible to check if all required pumps are free (aCheckRequiredPumpsFree).
The algorithm aRequestSinglePump can be used to request only one defined pump.
By calling the algorithm aReleaseSinglePump, it is possible to release a definded pump during a movement.
@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
1 
@Var @RT(9)SET_EVENT @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
1 
@Var @RT(9)cCompPump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)113 @RT(14)Component Pump 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(15)ABOutputRequest @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
20 
@Var @RT(15)evOutputRequest @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)tevOutputRequest @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(16)evOutputResponse @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tevOutputResponse @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(17)mevOutputResponse @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tevOutputResponse @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)EV_Task_1 @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(11)sv_DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(9)mMoveData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mbOutputRequested @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mbOutputIdle @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbDebugTrace @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBDebugTrace @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)sv_TraceLevel @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsTraceLevel @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_rPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_rVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_NumberOfDevices @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tyNumberOfDevices @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(11)sv_PumpData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tyPumpData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)evReleaseSinglePump @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tevReleaseSinglePump @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(15)mRequestedPumps @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tyRequiredPumps @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)mNoPumps @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tyRequiredPumps @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mbWaitForResponse @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(113)TRUE: wait for evAnaDevResponse; FALSE: check sv_PumpData to find out if the requested pumps are ready for output @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)evInterruptActivePump @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tevInterruptActivePump @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(19)evRequestSinglePump @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tevRequestSinglePump @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

8 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(8)aRequest @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(9)pMoveData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tpMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)AnaOutputMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnAnaOutputMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)evOutputRequestData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tevOutputRequestData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)prVelocity @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(51)optional parameter; by default sv_rVelocity is used @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)prPressure @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(51)optional parameter; by default sv_rPressure is used @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(8)aRelease @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(9)pMoveData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tpMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)evOutputRequestData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tevOutputRequestData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(6)aCheck @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
4 
@Var @RT(6)bReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(18)iReadyBlockCounter @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbDebugTrace @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBDebugTrace @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)iPump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(17)evaOutputResponse @STRUCTURED_TEXT 
@RT(0) @RT(17)mevOutputResponse @RT(9)EV_Task_1 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(20)evOutputResponseData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)tevOutputResponseData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)fbDebugTrace @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBDebugTrace @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(23)aCheckRequiredPumpsFree @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(13)RequiredPumps @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tyRequiredPumps @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(14)required pumps @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)bRequiredPumpsFree @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)TRUE: all required pumps are free @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(5)iPump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(18)aReleaseSinglePump @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(5)iPump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(15)pump to release @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(23)evReleaseSinglePumpData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(24)tevReleaseSinglePumpData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(20)aInterruptActivePump @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
6 
@Var @RT(5)iPump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(15)pump to release @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(25)evInterruptActivePumpData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(26)tevInterruptActivePumpData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)pMoveData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tpMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)AnaOutputMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnAnaOutputMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)prVelocity @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(51)optional parameter; by default sv_rVelocity is used @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)prPressure @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(51)optional parameter; by default sv_rPressure is used @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(18)aRequestSinglePump @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
6 
@Var @RT(5)iPump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(30)pump which should be requested @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)pMoveData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tpMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)AnaOutputMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnAnaOutputMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(25)output mode (fast or mid) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(23)evRequestSinglePumpData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(24)tevRequestSinglePumpData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)prVelocity @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(51)optional parameter; by default sv_rVelocity is used @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)prPressure @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(51)optional parameter; by default sv_rPressure is used @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(57)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bAnalog THEN
    fbDebugTrace(CONCAT('ABOutputRequest-aRequest() ',
                        DINT_TO_STRING(sv_DeviceId.CompId), '.', DINT_TO_STRING(sv_DeviceId.IndexId),
                        ' ',
                        DINT_TO_STRING(pMoveData^.MoveId), '/', DINT_TO_STRING(pMoveData^.MoveDir)));
END_IF;

IF NOT mbOutputRequested THEN
    
    mbOutputIdle := FALSE;
    mMoveData := pMoveData^;
    
    evOutputRequestData.pMoveData := pMoveData;    
    evOutputRequestData.DeviceIdSender := sv_DeviceId;
    evOutputRequestData.bRelease := FALSE;
    evOutputRequestData.AnaOutputMode := AnaOutputMode;
    mbOutputRequested := TRUE;
   
    IF CHECK_REF(mMoveData.AnaOutData.pRequiredPumps^) THEN
       //save requested pumps
       mRequestedPumps := mMoveData.AnaOutData.pRequiredPumps^.RequiredPumps;
    ELSE
       mRequestedPumps := mNoPumps;
    END_IF;
   
    IF CHECK_REF(prVelocity^) THEN
       evOutputRequestData.prVelocity := prVelocity;  
    ELSE
       evOutputRequestData.prVelocity := @sv_rVelocity;
    END_IF;
   
    IF CHECK_REF(prPressure^) THEN
       evOutputRequestData.prPressure := prPressure;  
    ELSE
       evOutputRequestData.prPressure := @sv_rPressure;
    END_IF;
   
    IF (sv_NumberOfDevices[cCompPump] > 0) AND CHECK_REF(mMoveData.AnaOutData.pRequiredPumps^) THEN
       //use sv_PumpData instead of listening to evOutputResponse
       mbWaitForResponse := FALSE;
    ELSE
       mbWaitForResponse := TRUE;
       mevOutputResponse := evOutputResponse;  //"activate" event algorithm
    END_IF;
   
    SET_EVENT(evOutputRequest, evOutputRequestData);
ELSE
    IF sv_TraceLevel.bAnalog THEN
        fbDebugTrace('ABOutputRequest-aRequest() mbOutputRequested already TRUE -> not sending request');
    END_IF;
END_IF; 

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(28)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bAnalog THEN
    fbDebugTrace(CONCAT('ABOutputRequest-aRelease() ',
                        DINT_TO_STRING(sv_DeviceId.CompId), '.', DINT_TO_STRING(sv_DeviceId.IndexId),
                        ' ',
                        DINT_TO_STRING(pMoveData^.MoveId), '/', DINT_TO_STRING(pMoveData^.MoveDir)));
END_IF;

IF mbOutputRequested THEN 
        
    evOutputRequestData.DeviceIdSender := sv_DeviceId; 
    evOutputRequestData.pMoveData := pMoveData;
    evOutputRequestData.bRelease := TRUE;
    SET_EVENT(evOutputRequest, evOutputRequestData);
    mbOutputRequested := FALSE;
   
    mRequestedPumps := mNoPumps;
    mbWaitForResponse := FALSE;
ELSE
    IF sv_TraceLevel.bAnalog THEN
        fbDebugTrace('ABOutputRequest-aRelease() mbOutputRequested FALSE -> not sending release request');
    END_IF;
END_IF;    

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(38)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbWaitForResponse THEN
   //wait for response event (for example on EIMM)
   bReady := mbOutputRequested AND mbOutputIdle;
ELSE
   //check if all requested pumps are available for this movement
   bReady := TRUE;
   FOR iPump := 1 TO sv_NumberOfDevices[cCompPump] DO
      IF (mRequestedPumps[iPump]) AND 
        ((sv_PumpData[iPump].ActiveDevice <> sv_DeviceId) OR (sv_PumpData[iPump].ActiveMoveId <> mMoveData.MoveId)) THEN
         //pump is requested but actually not available for this movement
         bReady := FALSE;
         EXIT;
      END_IF;
   END_FOR;   
END_IF;

IF bReady THEN
   iReadyBlockCounter := 0;
ELSE
   //check if request is blocked for a long time
   iReadyBlockCounter := iReadyBlockCounter + 1;
   IF iReadyBlockCounter = 100 THEN
      fbDebugTrace(CONCAT('ABOutputRequest-aCheck() request blocked for long time ',
                          DINT_TO_STRING(sv_DeviceId.CompId),
                          '.',
                          DINT_TO_STRING(sv_DeviceId.IndexId),
                          ' ',
                          DINT_TO_STRING(mMoveData.MoveId),
                          '/',
                          DINT_TO_STRING(mMoveData.MoveDir)));
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(21)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbOutputRequested AND
   evOutputResponseData.DeviceId = sv_DeviceId AND
   evOutputResponseData.MoveId = mMoveData.MoveId THEN
   
   IF sv_TraceLevel.bAnalog THEN
      fbDebugTrace(CONCAT('ABOutputRequest-evaOutputResponse() ',
                          DINT_TO_STRING(evOutputResponseData.DeviceId.CompId), '.', DINT_TO_STRING(evOutputResponseData.DeviceId.IndexId),
                          ' ',
                          DINT_TO_STRING(evOutputResponseData.MoveId)));
   END_IF;

   mbOutputIdle := TRUE;
   mevOutputResponse := EMPTY; //"deactivate" event algorithm
END_IF;
                                                     

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(15)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//check if all required pumps for a movement are free
bRequiredPumpsFree := TRUE;
FOR iPump := 1 TO sv_NumberOfDevices[cCompPump] DO
   IF (RequiredPumps[iPump]) AND (sv_PumpData[iPump].PumpState <> nPumpStateFree) THEN
      //required pump is busy
      bRequiredPumpsFree := FALSE;
      EXIT;
   END_IF;
END_FOR;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(25)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF iPump = 0 OR iPump > cMaxNrOfPumps THEN
   fbDebugTrace(CONCAT('ABOutputRequest-aReleaseSinglePump was called with iPump = ',
                        DINT_TO_STRING(iPump)));
   RETURN;
END_IF;

evReleaseSinglePumpData.iPump := iPump;
evReleaseSinglePumpData.DeviceIdSender := sv_DeviceId;
SET_EVENT(evReleaseSinglePump, evReleaseSinglePumpData);

//mark this pump as "released"
mRequestedPumps[iPump] := FALSE;

//check if all requested pumps are released
IF mRequestedPumps = mNoPumps THEN
   mbOutputRequested := FALSE;
END_IF;



@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
algorithm for releasing a single pump
@@@END_Comment@@@ 

@BEG_Body 
@TL(32)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF iPump = 0 OR iPump > cMaxNrOfPumps THEN
   fbDebugTrace(CONCAT('ABOutputRequest-aInterruptActivePump was called with iPump = ',
                        DINT_TO_STRING(iPump)));
   RETURN;
END_IF;

mbOutputRequested := TRUE;
mRequestedPumps[iPump] := TRUE;

IF CHECK_REF(prVelocity^) THEN
   evInterruptActivePumpData.prVelocity := prVelocity;  
ELSE
   evInterruptActivePumpData.prVelocity := @sv_rVelocity;
END_IF;

IF CHECK_REF(prPressure^) THEN
   evInterruptActivePumpData.prPressure := prPressure;  
ELSE
   evInterruptActivePumpData.prPressure := @sv_rPressure;
END_IF;

evInterruptActivePumpData.iPump := iPump;
evInterruptActivePumpData.AnaOutputMode := AnaOutputMode;
evInterruptActivePumpData.pMoveData := pMoveData;
evInterruptActivePumpData.DeviceIdSender := sv_DeviceId;
SET_EVENT(evInterruptActivePump, evInterruptActivePumpData);

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
algorithm for interrupting an active pump (pump is actually used by another movement)
The according pump is stopped (ramped down) and then it is started and outputs for this movement.
@@@END_Comment@@@ 

@BEG_Body 
@TL(50)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (iPump = 0) OR (iPump > cMaxNrOfPumps) THEN
   fbDebugTrace(CONCAT('ABOutputRequest-aRequestSinglePump was called with iPump = ',
                        DINT_TO_STRING(iPump)));
   RETURN;
END_IF;

IF sv_TraceLevel.bAnalog THEN
    fbDebugTrace(CONCAT('ABOutputRequest-aRequestSinglePump ',
                        '(Pump ', DINT_TO_STRING(iPump), ') for ', 
                        DINT_TO_STRING(sv_DeviceId.CompId), '.', DINT_TO_STRING(sv_DeviceId.IndexId),
                        ' ',
                        DINT_TO_STRING(pMoveData^.MoveId), '/', DINT_TO_STRING(pMoveData^.MoveDir)));
END_IF;


mMoveData := pMoveData^;
   
evRequestSinglePumpData.iPump := iPump; 
evRequestSinglePumpData.pMoveData := pMoveData;    
evRequestSinglePumpData.DeviceIdSender := sv_DeviceId;
evRequestSinglePumpData.AnaOutputMode := AnaOutputMode;

mbOutputRequested := TRUE;

//mark this pump as "requested"
mRequestedPumps[iPump] := TRUE;

IF CHECK_REF(prVelocity^) THEN
   evRequestSinglePumpData.prVelocity := prVelocity;  
ELSE
   evRequestSinglePumpData.prVelocity := @sv_rVelocity;
END_IF;

IF CHECK_REF(prPressure^) THEN
   evRequestSinglePumpData.prPressure := prPressure;  
ELSE
   evRequestSinglePumpData.prPressure := @sv_rPressure;
END_IF;

//use sv_PumpData instead of listening to evOutputResponse
mbWaitForResponse := FALSE;
 
SET_EVENT(evRequestSinglePump, evRequestSinglePumpData);


@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
algorithm for releasing a single pump
@@@END_Comment@@@ 
@END_Body 

@END_Contents 
