(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

Profile is saved over a restart by Measure Statistics
*)

IMPORT_OVER_LISTFILE
 SET_EVENT
, GET_SYNC_REFTO
, SET_ALARM
, cMoveAll
, KMB_ProfileKind_PDSXY
, KMB_Status_OK
, KSYS_Status_OK
, KMB_Status_Not_Connected
, nLockAbort
, nSetup
, nUnlock
, tsMotionProtectSettings
, tsDeviceId
, tsTraceLevel
, tnOperationMode
, KMB_PDSXY_Event
, tevStart
, tevStop
, tevAlarmConfirm
, tevProtect
, KMB_MeasureBlock2
, KMB_CreateProfileData
, KMB_Status
, FBDebugTrace
, ALARM_EVENT
, tnLockUnlock
, FBLockUnlock
, tevProtectData
, KSYS_Status
, KMB_Curve
, KMB_CurveResult
, KMB_PDSXY_Data
, ALARM_EVENT_DATA
, tevStartData
, tevStopData
, tevAlarmConfirmData
, RTC

END_IMPORT

ALGORITHM_BLOCK ABProfileMonitoring #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_MotionProtectData : tsMotionProtectSettings;
 sv_bMotionProtection : BOOL;
 sv_bInitDone : BOOL;
 sv_DeviceId : tsDeviceId (* unique Device Identifier *);
 sv_TraceLevel : tsTraceLevel;
 sv_OperationMode : tnOperationMode;
 sv_bRecalcTrigger : BOOL;
 sv_rViolationPosition : REAL;
 sv_rPositionStartTeach : REAL;
 sv_rPositionStopTeach : REAL;
 sv_iActMoldProtectRetry : DINT;
 sv_iSetMoldProtectRetry : DINT;
 sv_bOpenAfterProtect : BOOL;
END_VAR

SYSTEM_OBJECT
 EV_Task_3 : TASK;
 EV_Task_7 : TASK;
 evMotionProtectEvent : KMB_PDSXY_Event;
 evStart : tevStart;
 evStop : tevStop;
 erMotionProtect : ALARM;
 evAlarmConfirm : tevAlarmConfirm;
 evProtect : tevProtect;
 TaskVis : TASK;
 PU_Task_8 : TASK;
 erMotionProtectNotReady : ALARM;
 evAlarmAutoManual : ALARM_EVENT;
END_OBJECT

VAR
 abMeasureBlock : KMB_MeasureBlock2;
 ProfileData : KMB_CreateProfileData;
 status : KMB_Status;
 mbErrorDuringMove : BOOL;
 mbInitDone : BOOL;
 mbMovementStarted : BOOL;
 mpTolYUpper : REFTO REAL (* local references to limits, for postupdate *);
 mpTolYLower : REFTO REAL (* local references to limits, for postupdate *);
 mpTolX : REFTO REAL (* local references to limits, for postupdate *);
 fbDebugTrace : FBDebugTrace;
 mpCurveId : REFERENCE;
 mbWantRecalcAfterMovement : BOOL;
 mbRecalcReqDuringMove : BOOL;
 mbUseLastCurve : BOOL;
 mbRecalcRunning : BOOL;
 mbMeasureRunning : BOOL;
 mbRecalcIdleTime : BOOL;
 mprVarX : REFTO REAL;
 mprVarY : REFTO REAL;
 mbViolationPositionLinked : BOOL;
 mPositionTeachLinked : BOOL;
 mrPositionStartTeach : REAL;
 mrPositionStopTeach : REAL;
END_VAR

(*
This algorithm locks/unlocks the movements, defined in the motion protect data
*)

ALGORITHM aLockUnlock


VAR_INPUT
 nMode : tnLockUnlock;
END_VAR

VAR
 bInitDone : BOOL;
 fbLockUnlock : FBLockUnlock;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bInitDone THEN
   RETURN;
END_IF;

IF NOT bInitDone THEN
   fbLockUnlock.DeviceId.CompId := sv_MotionProtectData.DeviceId.CompId;
   fbLockUnlock.DeviceId.IndexId := sv_MotionProtectData.DeviceId.IndexId;
   fbLockUnlock.MoveDir := sv_MotionProtectData.MoveDir;
   fbLockUnlock.MoveId := cMoveAll;
   fbLockUnlock.Alarm.AlarmId := erMotionProtect;
   bInitDone := TRUE;
END_IF;

fbLockUnlock.Mode := nMode;

// lock/unlock movements, defined in the motion protect data
fbLockUnlock();


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aSendProtectEvent


VAR
 evProtectData : tevProtectData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//send protect event
evProtectData.DeviceIdSender := sv_DeviceId;
evProtectData.DeviceIdReceiver.CompId := sv_MotionProtectData.DeviceId.CompId;
evProtectData.DeviceIdReceiver.IndexId := sv_MotionProtectData.DeviceId.IndexId;
SET_EVENT(evProtect, evProtectData);



;#END_EDIT_BLOCK END_ALGORITHM

(*
Initialize KMB_MeasureBlock with right variables, connect to it
so the block can start / stop measurement
*)

ALGORITHM aInit


VAR_TEMP
 sysStatusVarX : KSYS_Status;
 sysStatusVarY : KSYS_Status;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

(* create profile in IEC so there is no need to change configuration files *)
ProfileData.ProfileName := sv_MotionProtectData.Name; // unique name to keep several Motion Protection recorders apart
ProfileData.CfgPath := '/workspace/data/ms_config/';
ProfileData.DataPath := '/protocol/ms_data/';
ProfileData.ElementCount := sv_MotionProtectData.iMaxPoints;
ProfileData.ErrorEventName := sv_MotionProtectData.ErrorEventName;// name of event, that will be sent when a limit is reached
ProfileData.MultiCurveCount := 0; // only 1 curve
ProfileData.ThreadPriority := 12;
ProfileData.Type := KMB_ProfileKind_PDSXY; // check Y value for given X value

status := abMeasureBlock.CreateProfile(Data := ProfileData);
IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: creating profile failed');
    END_IF;    
END_IF;

status := abMeasureBlock.DisableProfileFlashPersistence();
status := abMeasureBlock.DisableAutoSaveConfig();

status := abMeasureBlock.Connect( Name := sv_MotionProtectData.Name);
IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: connecting failed');
    END_IF;
END_IF;

//check x / y variables
mprVarX := GET_SYNC_REFTO(sv_MotionProtectData.sVariableX, T#0s, sysStatusVarX);
mprVarY := GET_SYNC_REFTO(sv_MotionProtectData.sVariableY, T#0s, sysStatusVarY);
IF (sysStatusVarX <> KSYS_Status_OK) OR (sysStatusVarY <> KSYS_Status_OK) THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: x or y var not available');
    END_IF;
ELSE
    // Add curve with x and y value to profile
    START_PROCESS_ALGORITHM(paAddCurve);
END_IF;

// check tolerances
IF NOT CHECK_REF(sv_MotionProtectData.pTolYLower^) OR 
   NOT CHECK_REF(sv_MotionProtectData.pTolYLower^) OR
   NOT CHECK_REF(sv_MotionProtectData.pTolX^)THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: x or y limit refto not initialzed');
    END_IF;
END_IF;

mbViolationPositionLinked := IS_LINKED(sv_rViolationPosition);
mPositionTeachLinked := IS_LINKED(sv_rPositionStartTeach) AND IS_LINKED(sv_rPositionStopTeach);
IF mPositionTeachLinked THEN
   mrPositionStartTeach := sv_rPositionStartTeach;
   mrPositionStopTeach := sv_rPositionStopTeach;
ELSE
   mrPositionStartTeach := sv_MotionProtectData.rStartPos;
   mrPositionStopTeach := sv_MotionProtectData.rStopPos;
END_IF;
IF (sv_MotionProtectData.rStartPos <= sv_MotionProtectData.rStopPos) THEN
   IF mrPositionStartTeach > sv_MotionProtectData.rStartPos THEN
      mrPositionStartTeach := sv_MotionProtectData.rStartPos;
   END_IF;
   IF mrPositionStopTeach < sv_MotionProtectData.rStopPos THEN
      mrPositionStopTeach := sv_MotionProtectData.rStopPos;
   END_IF;
ELSE
   IF mrPositionStartTeach < sv_MotionProtectData.rStartPos THEN
      mrPositionStartTeach := sv_MotionProtectData.rStartPos;
   END_IF;
   IF mrPositionStopTeach > sv_MotionProtectData.rStopPos THEN
      mrPositionStopTeach := sv_MotionProtectData.rStopPos;
   END_IF;
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paAddCurve ON TaskVis


VAR
 curve : KMB_Curve;
 curveStatus : KMB_CurveResult;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

curve.VariableX := sv_MotionProtectData.sVariableX;
curve.VariableY := sv_MotionProtectData.sVariableY;
curveStatus := abMeasureBlock.AddCurve(curve);

IF (curveStatus.Status = KMB_Status_Not_Connected) THEN
    // see iec library doc and CR_0053873 "KMB_MeasureBlock2: curve is added twice"
    // if a profile has been created it will be installed async. to the IEC task
    // so it may happen that installation of profile has not been finished. 
    // we have to repeat here until Status different to "not connected" 
    RETURN; 
END_IF;

mpCurveId := curveStatus.CurveId;

// for postupdate
mpTolYLower := sv_MotionProtectData.pTolYLower;
mpTolYUpper := sv_MotionProtectData.pTolYUpper;
mpTolX      := sv_MotionProtectData.pTolX;

mbInitDone := TRUE;
STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

(*
Motion protection is enabled when sv_MotionProtectData.bEnabled flag is set to TRUE
Supervision is started when Movement is started (evStart received and XPosition is bigger
than the start position at that time)
when XPosition gets smaller than Start position recording the Data is started

When the recorded Y value exceeds the limit curve a evMotionProtectEvent is sent by the system

Depending on status of the measurement the event will trigger a evStop for the movement and a
erMotionProtect Alarm,
or will be silently thrown away (when a new limit curve is recorded)

There are 2 types of limit curve recalculation:
* after movement
  for auto readjustment mode
  when profile changed
* in idle time before movement
  when limit values are changed -> still uses old curve but new offsets
*)

ALGORITHM aMeasure


VAR
 bDirection : BOOL;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP SInit:
END_STEP


(* steps *)
STEP SWaitPosBigger:
AResetError (P);
ATriggerRecalcDuringWait (N);
ACheckDirection (P);
END_STEP

ACTION AResetError: #BEGIN_EDIT_BLOCK
mbErrorDuringMove := FALSE;

;#END_EDIT_BLOCK END_ACTION (*AResetError*)
ACTION ATriggerRecalcDuringWait: #BEGIN_EDIT_BLOCK
IF mbRecalcIdleTime THEN
    // Trigger recalculation (executed with different prio)
    sv_bRecalcTrigger := TRUE;
    mbRecalcIdleTime := FALSE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ATriggerRecalcDuringWait*)
ACTION ACheckDirection: #BEGIN_EDIT_BLOCK
//startposition is bigger than stopposition: descending position-values during movement 
//startposition is smaller than stopposition: ascending position-values during movement
bDirection := sv_MotionProtectData.rStartPos <= sv_MotionProtectData.rStopPos;

;#END_EDIT_BLOCK END_ACTION (*ACheckDirection*)
STEP SWaitForStart:
AResetViolationPosition (P);
END_STEP

ACTION AResetViolationPosition: #BEGIN_EDIT_BLOCK
IF mbViolationPositionLinked THEN
   // reset violation position
   sv_rViolationPosition := 0.0;
END_IF;


;#END_EDIT_BLOCK END_ACTION (*AResetViolationPosition*)
STEP SCheckRecalcDone:
END_STEP

STEP SProtectNotReady:
ARecalcStillRunning (P);
END_STEP

ACTION ARecalcStillRunning: #BEGIN_EDIT_BLOCK
// Recalc triggered or still running
SET_ALARM(erMotionProtectNotReady);

;#END_EDIT_BLOCK END_ACTION (*ARecalcStillRunning*)
STEP SMeasure:
AStartMeasure (P);
ADoMeasure (N);
AStopMeasure (P0);
END_STEP

ACTION AStartMeasure: #BEGIN_EDIT_BLOCK
mbMeasureRunning := TRUE;
// start manual measure
// all points are measure by DoMeasure()
status := abMeasureBlock.StartMeasure(-1);

IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN      
        fbDebugTrace(sText := 'MotionProtect: StartMeasure failed');
    END_IF;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AStartMeasure*)
ACTION ADoMeasure: #BEGIN_EDIT_BLOCK
// do a manual measure so it is possible to specify the exact point when variables are sampled
status := abMeasureBlock.DoMeasure();
IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: DoMeasure failed -> probably not enough points avaliable for profile');
    END_IF;

    //lock movements, defined in the motion protect data
    aLockUnlock(nMode := nLockAbort);
    //send protect event
    aSendProtectEvent();
    
    mbMovementStarted := FALSE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ADoMeasure*)
ACTION AStopMeasure: #BEGIN_EDIT_BLOCK
//measurement automatically stopped, when step is left
status := abMeasureBlock.StopMeasure();

IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: StopMeasure failed');
    END_IF;
END_IF;

mbMovementStarted := FALSE;
mbMeasureRunning := FALSE;


;#END_EDIT_BLOCK END_ACTION (*AStopMeasure*)
STEP Step12:
END_STEP

STEP SMotionSuccess:
Action8 (P);
END_STEP

ACTION Action8: #BEGIN_EDIT_BLOCK
// movement was a success
// use last movement as a reference curve
IF sv_TraceLevel.bApplication THEN    
    fbDebugTrace(sText := 'MotionProtect: Protection success');
END_IF;

mbUseLastCurve := TRUE;
IF NOT mbRecalcReqDuringMove THEN
    mbWantRecalcAfterMovement := FALSE;
END_IF;
mbRecalcReqDuringMove := FALSE;

// Trigger recalculation (executed with different prio)
sv_bRecalcTrigger := TRUE;

;#END_EDIT_BLOCK END_ACTION (*Action8*)
STEP Step15:
Action27 (N);
END_STEP

ACTION Action27: #BEGIN_EDIT_BLOCK
IF sv_TraceLevel.bApplication THEN    
    fbDebugTrace(sText := 
        'MotionProtect: Protection success, no update');
END_IF;

;#END_EDIT_BLOCK END_ACTION (*Action27*)
STEP SMotionStopped:
Action18 (N);
END_STEP

ACTION Action18: #BEGIN_EDIT_BLOCK
// do not update 
IF sv_TraceLevel.bApplication THEN    
    fbDebugTrace(sText := 
     'MotionProtect: Protected movement stopped, no update');
END_IF;


;#END_EDIT_BLOCK END_ACTION (*Action18*)
STEP Step3:
END_STEP


(* transitions *)
GO_ON_TRANSITION Trans5 (* Trans5 *) FROM SInit TO SWaitPosBigger :=  #BEGIN_EDIT_BLOCK
mbInitDone
AND sv_MotionProtectData.bEnabled
AND sv_OperationMode > nSetup
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans8 (* Trans8 *) FROM SWaitPosBigger TO SWaitForStart :=  #BEGIN_EDIT_BLOCK
//wait until actual position is before the monitoring range - depending on the direction
(((NOT mPositionTeachLinked) OR (NOT mbWantRecalcAfterMovement)) AND mbMovementStarted AND (bDirection XOR mprVarX^ > sv_MotionProtectData.rStartPos)) OR
((mPositionTeachLinked AND mbWantRecalcAfterMovement) AND mbMovementStarted AND (bDirection XOR mprVarX^ > mrPositionStartTeach))
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans1 (* Trans1 *) FROM SWaitForStart TO SCheckRecalcDone :=  #BEGIN_EDIT_BLOCK
//begin measurement when StartPos is crossed - depending on the direction
(((NOT mPositionTeachLinked) OR (NOT mbWantRecalcAfterMovement)) AND (bDirection XOR mprVarX^ <= sv_MotionProtectData.rStartPos)) OR
((mPositionTeachLinked AND mbWantRecalcAfterMovement) AND (bDirection XOR mprVarX^ <= mrPositionStartTeach))
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans12 (* Trans12 *) FROM SCheckRecalcDone TO SMeasure :=  #BEGIN_EDIT_BLOCK
NOT sv_bRecalcTrigger AND 
NOT mbRecalcRunning
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans13 (* Trans13 *) FROM SCheckRecalcDone TO SProtectNotReady :=  #BEGIN_EDIT_BLOCK
sv_bRecalcTrigger OR mbRecalcRunning

;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans14 (* Trans14 *) FROM SProtectNotReady TO SWaitPosBigger :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TSaveMotionData (* TSaveMotionData *) FROM SMeasure TO Step12 :=  #BEGIN_EDIT_BLOCK
//stop measurement when StopPos is crossed - depending on the direction
bDirection XOR 
((((NOT mPositionTeachLinked) OR (NOT mbWantRecalcAfterMovement)) AND (mprVarX^ <= sv_MotionProtectData.rStopPos)) OR
 ((mPositionTeachLinked AND mbWantRecalcAfterMovement  AND (mprVarX^ <= mrPositionStopTeach))))
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TUpdate (* TUpdate *) FROM Step12 TO SMotionSuccess :=  #BEGIN_EDIT_BLOCK
sv_MotionProtectData.bUseLastCycle OR mbWantRecalcAfterMovement
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans2 (* Trans2 *) FROM SMotionSuccess TO Step3 :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TNoUpdate (* TNoUpdate *) FROM Step12 TO Step15 :=  #BEGIN_EDIT_BLOCK
NOT sv_MotionProtectData.bUseLastCycle AND NOT mbWantRecalcAfterMovement
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans21 (* Trans21 *) FROM Step15 TO Step3 :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TIgnoreMotionData (* TIgnoreMotionData *) FROM SMeasure TO SMotionStopped :=  #BEGIN_EDIT_BLOCK
// stop measurement when evStop is received
// or error happens
NOT mbMovementStarted
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans15 (* Trans15 *) FROM SMotionStopped TO Step3 :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TTrue (* TTrue *) FROM Step3 TO SWaitPosBigger :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
// ACTION AStartMeasure: #BEGIN_EDIT_BLOCK


// ;#END_EDIT_BLOCK END_ACTION (*AStartMeasure*)

(* exits *)

EXIT_TRANSITION ENotEnabled := #BEGIN_EDIT_BLOCK
(NOT sv_MotionProtectData.bEnabled OR sv_OperationMode = nSetup) AND NOT SInit.X
;#END_EDIT_BLOCK
PRIORITY 1 WITH  INITIAL_STEP SInit: END_STEP
END_TRANSITION

EXIT_TRANSITION EMotionProtectError := #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// a error occured during the movement -> abort measuring
mbErrorDuringMove
;#END_EDIT_BLOCK
PRIORITY 1 WITH  INITIAL_STEP SWaitPosBigger: END_STEP
END_TRANSITION
(* end sfc-code *)


END_ALGORITHM

(*
Called when a profile changes so much that Motion protection has to ignore next 
movement, because measured values are guarenteed to be different

*)

ALGORITHM aIgnoreNextCycle

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbWantRecalcAfterMovement := TRUE;

IF mbMovementStarted THEN
    // Movement is running -> Ignore cycle after next cycle
    mbRecalcReqDuringMove := TRUE;
END_IF;

IF sv_TraceLevel.bApplication THEN    
    fbDebugTrace(sText := 'MotionProtect: next cycle ignored');
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

(*
Inject a Motion Protection Error
Used for addition Motion Protection cases not covered by limit curves
No error is raised when supervised movement is not currently active
*)

ALGORITHM aInjectError

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// a motion protect error can only happen when movement is started
IF mbMovementStarted THEN
   mbErrorDuringMove := TRUE;
    
   //lock movements, defined in the motion protect data
   aLockUnlock(nMode := nLockAbort);
   sv_bMotionProtection := TRUE;    
   mbMovementStarted := FALSE;
    
   //send protect event
   aSendProtectEvent();
    
   IF sv_TraceLevel.bApplication THEN    
      fbDebugTrace(sText := CONCAT('MotionProtect: error injected at ',REAL_TO_STRING(mprVarX^),' (',REAL_TO_STRING(mprVarY^), ')'));
   END_IF;    
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

(*
React to the limit curve exceeded event, which is set by the data recorder, when a limit is reached


*)

EVENT_ALGORITHM evaMotionProtectEvent ON EV_Task_3 WITH evMotionProtectEvent


VAR_INPUT
 EventData : KMB_PDSXY_Data;
END_VAR

VAR
 // tmp : DINT;
 evAlarmAutoManualData : ALARM_EVENT_DATA;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//tmp := Print('error event received for profile %s VariableX:%s', EventData.Profile, EventData.VariableX);

IF NOT (EventData.Profile = sv_MotionProtectData.Name) THEN
   IF sv_TraceLevel.bApplication THEN    
      fbDebugTrace(sText := 'MotionProtect: event not for this profile, ignoring error event');
   END_IF;
   RETURN;
END_IF;

IF NOT sv_MotionProtectData.bEnabled THEN
   IF sv_TraceLevel.bApplication THEN    
      fbDebugTrace(sText := 'MotionProtect: motion protect not enabled, ignoring error event');
   END_IF;
   RETURN;
END_IF;

IF NOT mbMovementStarted THEN
   IF sv_TraceLevel.bApplication THEN    
      fbDebugTrace(sText := 'MotionProtect: movement not running, ignoring error event');
   END_IF;
   RETURN;
END_IF;

IF mbWantRecalcAfterMovement THEN
   IF sv_TraceLevel.bApplication THEN    
      fbDebugTrace(sText := 'MotionProtect: recalculating limit curve, ignoring error event');
   END_IF;    
   RETURN;
END_IF;


IF sv_TraceLevel.bApplication THEN    
   fbDebugTrace(sText := 'MotionProtect: got error');
END_IF;

mbErrorDuringMove := TRUE;

IF (sv_OperationMode > nManual) AND sv_bOpenAfterProtect AND (sv_iActMoldProtectRetry < sv_iSetMoldProtectRetry) THEN
   //only switch opmode, no alarm or buzzer
   SET_EVENT(evAlarmAutoManual, evAlarmAutoManualData);
ELSE
   //lock movements, defined in the motion protect data
   aLockUnlock(nMode := nLockAbort);
END_IF;

sv_bMotionProtection := TRUE;
mbMovementStarted := FALSE;

//send protect event
aSendProtectEvent();

IF sv_TraceLevel.bApplication THEN
   fbDebugTrace(sText := CONCAT('MotionProtect: got error at position ',LREAL_TO_STRING(EventData.ErrorValueX),' (limit: ',LREAL_TO_STRING(EventData.LimitY), ' act: ',LREAL_TO_STRING(EventData.ErrorValueY), ')'));
END_IF;

IF mbViolationPositionLinked THEN
   sv_rViolationPosition := LREAL_TO_REAL(EventData.ErrorValueX);
END_IF;




;#END_EDIT_BLOCK END_ALGORITHM

(*
react on start of supervised movement
*)

EVENT_ALGORITHM evaStart ON EV_Task_7 WITH evStart


VAR_INPUT
 evStartData : tevStartData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// start if DeviceId and MoveDir are right, or cMoveAll is specified
IF (evStartData.DeviceId = sv_MotionProtectData.DeviceId) AND
   (evStartData.MoveDir  = sv_MotionProtectData.MoveDir   OR  sv_MotionProtectData.MoveDir = cMoveAll) THEN
   mbMovementStarted := TRUE;
   sv_bMotionProtection := FALSE;
   IF sv_TraceLevel.bApplication THEN    
      fbDebugTrace(sText := 'MotionProtect: supervised movement started');
   END_IF;
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

EVENT_ALGORITHM evaStop ON EV_Task_7 WITH evStop


VAR_INPUT
 evStopData : tevStopData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF evStopData.DeviceId = sv_MotionProtectData.DeviceId AND mbMovementStarted THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: evStop');
    END_IF;

   mbMovementStarted := FALSE;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
This event algorithm reacts on pressing the alarm confirm button.
After alarm confirmation the movements which are defined in the motion protect data are unlocked
*)

EVENT_ALGORITHM evaAlarmConfirm ON EV_Task_7 WITH evAlarmConfirm


VAR_INPUT
 evAlarmConfirmData : tevAlarmConfirmData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//unlock movements (defined in the motion protect data) when alarm confirm button is pressed
aLockUnlock(nMode := nUnlock);



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aRecalcLimitCurves


VAR
 fbRTC : RTC;
 dStartTime : DATE_AND_TIME;
 dStopTime : DATE_AND_TIME;
 sTimeDiff : STRING(255);
 dummy : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbRecalcRunning THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: Recalc limit curves requested but recalc still running');
    END_IF;
    RETURN;
END_IF;

IF mbMeasureRunning THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: Recalc limit curves requested but measurement is running');
    END_IF;
    RETURN;
END_IF;

mbRecalcRunning := TRUE;

IF sv_TraceLevel.bApplication THEN 
    // Start time measurement
    fbRTC(EN := FALSE,
          CDT => dStartTime);
END_IF;

IF mbUseLastCurve THEN
    // Set actual recorded curve as ideal curve
    status := abMeasureBlock.SetIdealCurve(CurveId := mpCurveId);
    
    IF status <> KMB_Status_OK THEN
        IF sv_TraceLevel.bApplication THEN    
            fbDebugTrace(sText := 'MotionProtect: SetIdealCurve failed');
        END_IF;
    END_IF;
    
    mbUseLastCurve := FALSE;
END_IF;

// Set x tolerance
// Time consumption very low -> No need to check if x tolerance has changed or not
status := abMeasureBlock.SetDeltaX(CurveId := mpCurveId,
                                   DeltaX := mpTolX^);

IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: SetDeltaX failed');
    END_IF;
END_IF;

// Recalculate lower/upper limit curves
status := abMeasureBlock.CalcUpperAndLowerLimitCurve(CurveId := mpCurveId,
                                                     UpperTolerance := mpTolYUpper^,
                                                     LowerTolerance := mpTolYLower^);

IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: CalcUpperAndLowerLimitCurve failed');
    END_IF;
END_IF;

IF sv_TraceLevel.bApplication THEN 
    fbRTC(EN := FALSE,
          CDT => dStopTime);
    sTimeDiff:= TIME_TO_STRING(SUB_DT_DT(dStopTime, dStartTime));
    dummy := Print('MotionProtect: Time for recalc limit curves = %s', sTimeDiff);
END_IF;

mbRecalcRunning := FALSE;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pTolChanged ON PU_Task_8 WITH mpTolX^,mpTolYUpper^,mpTolYLower^

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// Trigger recalc of limit curves during wait (measurement not running)
mbRecalcIdleTime := TRUE;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pRecalcRequested ON PU_Task_8 WITH sv_bRecalcTrigger

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bRecalcTrigger THEN
    aRecalcLimitCurves();
    sv_bRecalcTrigger := FALSE;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pRecalcBoarder ON PU_Task_8 WITH sv_rPositionStartTeach,sv_rPositionStopTeach

#BEGIN_EDIT_BLOCK
mrPositionStartTeach := sv_rPositionStartTeach;
mrPositionStopTeach := sv_rPositionStopTeach;


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 177 @Pou 25 
@@@BEG_Comment@@@
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

Profile is saved over a restart by Measure Statistics
@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
3 
@Var @RT(9)SET_EVENT @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)GET_SYNC_REFTO @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)SET_ALARM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
8 
@Var @RT(8)cMoveAll @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)100 @RT(32)all movements (for evLockUnlock) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(21)KMB_ProfileKind_PDSXY @RT(0) @T @T @DERIVED 0 @F @RT(15)KMB_ProfileKind @F 
@T 
@BEG_Attrib 
0 @RT(1)5 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)KMB_Status_OK @RT(0) @T @T @DERIVED 0 @F @RT(10)KMB_Status @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(2)ok 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)KSYS_Status_OK @RT(0) @T @T @DERIVED 0 @F @RT(11)KSYS_Status @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(24)KMB_Status_Not_Connected @RT(0) @T @T @DERIVED 0 @F @RT(10)KMB_Status @F 
@T 
@BEG_Attrib 
0 @RT(1)4 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)nLockAbort @RT(0) @T @T @DERIVED 0 @F @RT(12)tnLockUnlock @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)nSetup @RT(0) @T @T @DERIVED 0 @F @RT(15)tnOperationMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(36)Setup mode only for service engineer 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)nUnlock @RT(0) @T @T @DERIVED 0 @F @RT(12)tnLockUnlock @F 
@T 
@BEG_Attrib 
0 @RT(1)2 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(19)ABProfileMonitoring @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
48 
@Var @RT(20)sv_MotionProtectData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(23)tsMotionProtectSettings @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_bMotionProtection @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(11)sv_DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(24)unique Device Identifier @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_TraceLevel @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsTraceLevel @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_OperationMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnOperationMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_bRecalcTrigger @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_rViolationPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_rPositionStartTeach @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_rPositionStopTeach @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(9)EV_Task_3 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)EV_Task_7 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(20)evMotionProtectEvent @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KMB_PDSXY_Event @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(7)evStart @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tevStart @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(6)evStop @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(7)tevStop @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(15)erMotionProtect @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(14)evAlarmConfirm @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tevAlarmConfirm @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)evProtect @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tevProtect @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(7)TaskVis @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)PU_Task_8 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(23)erMotionProtectNotReady @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(14)abMeasureBlock @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)KMB_MeasureBlock2 @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)ProfileData @RT(0) @T @T @DERIVED 0 @F @RT(21)KMB_CreateProfileData @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)status @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)KMB_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mbErrorDuringMove @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)mbInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mbMovementStarted @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)mpTolYUpper @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(42)local references to limits, for postupdate @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)mpTolYLower @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(42)local references to limits, for postupdate @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)mpTolX @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(42)local references to limits, for postupdate @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbDebugTrace @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBDebugTrace @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)mpCurveId @RT(0) @T @F @DT @RT(9)REFERENCE @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(25)mbWantRecalcAfterMovement @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)mbRecalcReqDuringMove @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mbUseLastCurve @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mbRecalcRunning @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mbMeasureRunning @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mbRecalcIdleTime @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)mprVarX @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)mprVarY @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(25)mbViolationPositionLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)mPositionTeachLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)mrPositionStartTeach @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mrPositionStopTeach @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(23)sv_iActMoldProtectRetry @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_iSetMoldProtectRetry @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)evAlarmAutoManual @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(11)ALARM_EVENT @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(20)sv_bOpenAfterProtect @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

15 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(11)aLockUnlock @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(5)nMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tnLockUnlock @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbLockUnlock @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBLockUnlock @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(17)aSendProtectEvent @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(13)evProtectData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)tevProtectData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(5)aInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(13)sysStatusVarX @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSYS_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(13)sysStatusVarY @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSYS_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(10)paAddCurve @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(7)TaskVis @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(5)curve @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KMB_Curve @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)curveStatus @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KMB_CurveResult @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(8)aMeasure @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(10)bDirection @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(16)aIgnoreNextCycle @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(12)aInjectError @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(21)evaMotionProtectEvent @STRUCTURED_TEXT 
@RT(0) @RT(20)evMotionProtectEvent @RT(9)EV_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(9)EventData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)KMB_PDSXY_Data @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(3)tmp @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @T 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)evAlarmAutoManualData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)ALARM_EVENT_DATA @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(8)evaStart @STRUCTURED_TEXT 
@RT(0) @RT(7)evStart @RT(9)EV_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(11)evStartData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tevStartData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(7)evaStop @STRUCTURED_TEXT 
@RT(0) @RT(6)evStop @RT(9)EV_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(10)evStopData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tevStopData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(15)evaAlarmConfirm @STRUCTURED_TEXT 
@RT(0) @RT(14)evAlarmConfirm @RT(9)EV_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(18)evAlarmConfirmData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tevAlarmConfirmData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(18)aRecalcLimitCurves @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(5)fbRTC @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)RTC @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)dStartTime @RT(0) @T @F @DT @RT(13)DATE_AND_TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)dStopTime @RT(0) @T @F @DT @RT(13)DATE_AND_TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)sTimeDiff @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(11)pTolChanged @STRUCTURED_TEXT 
@RT(0) @RT(33)mpTolX^,mpTolYUpper^,mpTolYLower^ @RT(9)PU_Task_8 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(16)pRecalcRequested @STRUCTURED_TEXT 
@RT(0) @RT(17)sv_bRecalcTrigger @RT(9)PU_Task_8 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(14)pRecalcBoarder @STRUCTURED_TEXT 
@RT(0) @RT(44)sv_rPositionStartTeach,sv_rPositionStopTeach @RT(9)PU_Task_8 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Body 
@TL(23)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bInitDone THEN
   RETURN;
END_IF;

IF NOT bInitDone THEN
   fbLockUnlock.DeviceId.CompId := sv_MotionProtectData.DeviceId.CompId;
   fbLockUnlock.DeviceId.IndexId := sv_MotionProtectData.DeviceId.IndexId;
   fbLockUnlock.MoveDir := sv_MotionProtectData.MoveDir;
   fbLockUnlock.MoveId := cMoveAll;
   fbLockUnlock.Alarm.AlarmId := erMotionProtect;
   bInitDone := TRUE;
END_IF;

fbLockUnlock.Mode := nMode;

// lock/unlock movements, defined in the motion protect data
fbLockUnlock();

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
This algorithm locks/unlocks the movements, defined in the motion protect data
@@@END_Comment@@@ 

@BEG_Body 
@TL(12)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//send protect event
evProtectData.DeviceIdSender := sv_DeviceId;
evProtectData.DeviceIdReceiver.CompId := sv_MotionProtectData.DeviceId.CompId;
evProtectData.DeviceIdReceiver.IndexId := sv_MotionProtectData.DeviceId.IndexId;
SET_EVENT(evProtect, evProtectData);


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(79)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

(* create profile in IEC so there is no need to change configuration files *)
ProfileData.ProfileName := sv_MotionProtectData.Name; // unique name to keep several Motion Protection recorders apart
ProfileData.CfgPath := '/workspace/data/ms_config/';
ProfileData.DataPath := '/protocol/ms_data/';
ProfileData.ElementCount := sv_MotionProtectData.iMaxPoints;
ProfileData.ErrorEventName := sv_MotionProtectData.ErrorEventName;// name of event, that will be sent when a limit is reached
ProfileData.MultiCurveCount := 0; // only 1 curve
ProfileData.ThreadPriority := 12;
ProfileData.Type := KMB_ProfileKind_PDSXY; // check Y value for given X value

status := abMeasureBlock.CreateProfile(Data := ProfileData);
IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: creating profile failed');
    END_IF;    
END_IF;

status := abMeasureBlock.DisableProfileFlashPersistence();
status := abMeasureBlock.DisableAutoSaveConfig();

status := abMeasureBlock.Connect( Name := sv_MotionProtectData.Name);
IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: connecting failed');
    END_IF;
END_IF;

//check x / y variables
mprVarX := GET_SYNC_REFTO(sv_MotionProtectData.sVariableX, T#0s, sysStatusVarX);
mprVarY := GET_SYNC_REFTO(sv_MotionProtectData.sVariableY, T#0s, sysStatusVarY);
IF (sysStatusVarX <> KSYS_Status_OK) OR (sysStatusVarY <> KSYS_Status_OK) THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: x or y var not available');
    END_IF;
ELSE
    // Add curve with x and y value to profile
    START_PROCESS_ALGORITHM(paAddCurve);
END_IF;

// check tolerances
IF NOT CHECK_REF(sv_MotionProtectData.pTolYLower^) OR 
   NOT CHECK_REF(sv_MotionProtectData.pTolYLower^) OR
   NOT CHECK_REF(sv_MotionProtectData.pTolX^)THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: x or y limit refto not initialzed');
    END_IF;
END_IF;

mbViolationPositionLinked := IS_LINKED(sv_rViolationPosition);
mPositionTeachLinked := IS_LINKED(sv_rPositionStartTeach) AND IS_LINKED(sv_rPositionStopTeach);
IF mPositionTeachLinked THEN
   mrPositionStartTeach := sv_rPositionStartTeach;
   mrPositionStopTeach := sv_rPositionStopTeach;
ELSE
   mrPositionStartTeach := sv_MotionProtectData.rStartPos;
   mrPositionStopTeach := sv_MotionProtectData.rStopPos;
END_IF;
IF (sv_MotionProtectData.rStartPos <= sv_MotionProtectData.rStopPos) THEN
   IF mrPositionStartTeach > sv_MotionProtectData.rStartPos THEN
      mrPositionStartTeach := sv_MotionProtectData.rStartPos;
   END_IF;
   IF mrPositionStopTeach < sv_MotionProtectData.rStopPos THEN
      mrPositionStopTeach := sv_MotionProtectData.rStopPos;
   END_IF;
ELSE
   IF mrPositionStartTeach < sv_MotionProtectData.rStartPos THEN
      mrPositionStartTeach := sv_MotionProtectData.rStartPos;
   END_IF;
   IF mrPositionStopTeach > sv_MotionProtectData.rStopPos THEN
      mrPositionStopTeach := sv_MotionProtectData.rStopPos;
   END_IF;
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
Initialize KMB_MeasureBlock with right variables, connect to it
so the block can start / stop measurement
@@@END_Comment@@@ 

@BEG_Body 
@TL(27)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

curve.VariableX := sv_MotionProtectData.sVariableX;
curve.VariableY := sv_MotionProtectData.sVariableY;
curveStatus := abMeasureBlock.AddCurve(curve);

IF (curveStatus.Status = KMB_Status_Not_Connected) THEN
    // see iec library doc and CR_0053873 "KMB_MeasureBlock2: curve is added twice"
    // if a profile has been created it will be installed async. to the IEC task
    // so it may happen that installation of profile has not been finished. 
    // we have to repeat here until Status different to "not connected" 
    RETURN; 
END_IF;

mpCurveId := curveStatus.CurveId;

// for postupdate
mpTolYLower := sv_MotionProtectData.pTolYLower;
mpTolYUpper := sv_MotionProtectData.pTolYUpper;
mpTolX      := sv_MotionProtectData.pTolX;

mbInitDone := TRUE;
STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
12 13 15 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 3 
@Step @RT(5)SInit @F @T @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@Trans @RT(6)Trans5 @F @T @F @F @T @F @TL(4)
mbInitDone
AND sv_MotionProtectData.bEnabled
AND sv_OperationMode > nSetup

@RT(6)Trans5 @F 
@Loop @RT(4)loop @F 2 
@StepSeq @RT(4)sseq @F 9 
@Step @RT(14)SWaitPosBigger @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(11)AResetError @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
mbErrorDuringMove := FALSE;

@F 
@Acb @RT(24)ATriggerRecalcDuringWait @F @T @RT(1)N @RT(0) @F @F @T @TL(6)
IF mbRecalcIdleTime THEN
    // Trigger recalculation (executed with different prio)
    sv_bRecalcTrigger := TRUE;
    mbRecalcIdleTime := FALSE;
END_IF;

@F 
@Acb @RT(15)ACheckDirection @F @T @RT(1)P @RT(0) @F @F @T @TL(4)
//startposition is bigger than stopposition: descending position-values during movement 
//startposition is smaller than stopposition: ascending position-values during movement
bDirection := sv_MotionProtectData.rStartPos <= sv_MotionProtectData.rStopPos;

@F 

@Trans @RT(6)Trans8 @F @T @F @F @T @T @TL(4)
//wait until actual position is before the monitoring range - depending on the direction
(((NOT mPositionTeachLinked) OR (NOT mbWantRecalcAfterMovement)) AND mbMovementStarted AND (bDirection XOR mprVarX^ > sv_MotionProtectData.rStartPos)) OR
((mPositionTeachLinked AND mbWantRecalcAfterMovement) AND mbMovementStarted AND (bDirection XOR mprVarX^ > mrPositionStartTeach))

@RT(6)Trans8 @F 
@Step @RT(13)SWaitForStart @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(23)AResetViolationPosition @F @T @RT(1)P @RT(0) @F @F @T @TL(6)
IF mbViolationPositionLinked THEN
   // reset violation position
   sv_rViolationPosition := 0.0;
END_IF;


@F 

@Trans @RT(6)Trans1 @F @T @F @F @T @F @TL(4)
//begin measurement when StartPos is crossed - depending on the direction
(((NOT mPositionTeachLinked) OR (NOT mbWantRecalcAfterMovement)) AND (bDirection XOR mprVarX^ <= sv_MotionProtectData.rStartPos)) OR
((mPositionTeachLinked AND mbWantRecalcAfterMovement) AND (bDirection XOR mprVarX^ <= mrPositionStartTeach))

@RT(6)Trans1 @F 
@Step @RT(16)SCheckRecalcDone @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans12 @F @T @F @F @T @F @TL(3)
NOT sv_bRecalcTrigger AND 
NOT mbRecalcRunning

@RT(7)Trans12 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(7)Trans13 @F @T @F @F @T @F @TL(3)
sv_bRecalcTrigger OR mbRecalcRunning


@RT(7)Trans13 @F 
@Step @RT(16)SProtectNotReady @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(19)ARecalcStillRunning @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
// Recalc triggered or still running
SET_ALARM(erMotionProtectNotReady);

@F 

@Trans @RT(7)Trans14 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans14 @F 
@Goto @RT(14)SWaitPosBigger @F @F 


@Step @RT(8)SMeasure @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(13)AStartMeasure @F @T @RT(1)P @RT(0) @F @F @T @TL(11)
mbMeasureRunning := TRUE;
// start manual measure
// all points are measure by DoMeasure()
status := abMeasureBlock.StartMeasure(-1);

IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN      
        fbDebugTrace(sText := 'MotionProtect: StartMeasure failed');
    END_IF;
END_IF;

@F 
@Acb @RT(10)ADoMeasure @F @T @RT(1)N @RT(0) @F @F @T @TL(15)
// do a manual measure so it is possible to specify the exact point when variables are sampled
status := abMeasureBlock.DoMeasure();
IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: DoMeasure failed -> probably not enough points avaliable for profile');
    END_IF;

    //lock movements, defined in the motion protect data
    aLockUnlock(nMode := nLockAbort);
    //send protect event
    aSendProtectEvent();
    
    mbMovementStarted := FALSE;
END_IF;

@F 
@Acb @RT(12)AStopMeasure @F @T @RT(2)P0 @RT(0) @F @F @T @TL(13)
//measurement automatically stopped, when step is left
status := abMeasureBlock.StopMeasure();

IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: StopMeasure failed');
    END_IF;
END_IF;

mbMovementStarted := FALSE;
mbMeasureRunning := FALSE;


@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(15)TSaveMotionData @F @T @F @F @T @T @TL(5)
//stop measurement when StopPos is crossed - depending on the direction
bDirection XOR 
((((NOT mPositionTeachLinked) OR (NOT mbWantRecalcAfterMovement)) AND (mprVarX^ <= sv_MotionProtectData.rStopPos)) OR
 ((mPositionTeachLinked AND mbWantRecalcAfterMovement  AND (mprVarX^ <= mrPositionStopTeach))))

@RT(15)TSaveMotionData @F 
@Step @RT(6)Step12 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(7)TUpdate @F @T @F @F @T @T @TL(2)
sv_MotionProtectData.bUseLastCycle OR mbWantRecalcAfterMovement

@RT(7)TUpdate @F 
@Step @RT(14)SMotionSuccess @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(7)Action8 @F @T @RT(1)P @RT(0) @F @F @T @TL(15)
// movement was a success
// use last movement as a reference curve
IF sv_TraceLevel.bApplication THEN    
    fbDebugTrace(sText := 'MotionProtect: Protection success');
END_IF;

mbUseLastCurve := TRUE;
IF NOT mbRecalcReqDuringMove THEN
    mbWantRecalcAfterMovement := FALSE;
END_IF;
mbRecalcReqDuringMove := FALSE;

// Trigger recalculation (executed with different prio)
sv_bRecalcTrigger := TRUE;

@F 

@Trans @RT(6)Trans2 @F @T @F @F @T @T @TL(2)
TRUE

@RT(6)Trans2 @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(9)TNoUpdate @F @T @F @F @T @T @TL(2)
NOT sv_MotionProtectData.bUseLastCycle AND NOT mbWantRecalcAfterMovement

@RT(9)TNoUpdate @F 
@Step @RT(6)Step15 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(8)Action27 @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
IF sv_TraceLevel.bApplication THEN    
    fbDebugTrace(sText := 
        'MotionProtect: Protection success, no update');
END_IF;

@F 

@Trans @RT(7)Trans21 @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)Trans21 @F 



@TransSeq @RT(4)tseq @F 3 
@Trans @RT(17)TIgnoreMotionData @F @T @F @F @T @T @TL(4)
// stop measurement when evStop is received
// or error happens
NOT mbMovementStarted

@RT(17)TIgnoreMotionData @F 
@Step @RT(14)SMotionStopped @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(8)Action18 @F @T @RT(1)N @RT(0) @F @F @T @TL(7)
// do not update 
IF sv_TraceLevel.bApplication THEN    
    fbDebugTrace(sText := 
     'MotionProtect: Protected movement stopped, no update');
END_IF;


@F 

@Trans @RT(7)Trans15 @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)Trans15 @F 


@Step @RT(5)Step3 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 


@Trans @RT(5)TTrue @F @T @T @T @T @T @TL(2)
TRUE

@RT(5)TTrue @F 

@END_SfcData 
@SaActions 1 
@SaText @RT(13)AStartMeasure 1 @TL(2)



@SaTrans 0 
@SaExits 2 
@SaExit @SaText @RT(11)ENotEnabled 1 @TL(2)
(NOT sv_MotionProtectData.bEnabled OR sv_OperationMode = nSetup) AND NOT SInit.X

@RT(5)SInit @RT(1)1 @F @F @SaSfc @RT(11)ENotEnabled 5 @RT(5)DUMMY 
@BEG_SfcData 2 
@ExitSeq @RT(4)sseq @F 3 
@Step @RT(8)unnamed1 @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@Trans @RT(8)unnamed3 @F @T @F @F @T @T @TL(2)


@RT(8)unnamed3 @F 
@Goto @RT(9)unlabeled @F @F 
@END_SfcData 

@SaExit @SaText @RT(19)EMotionProtectError 1 @TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// a error occured during the movement -> abort measuring
mbErrorDuringMove

@RT(14)SWaitPosBigger @RT(1)1 @F @F @SaSfc @RT(19)EMotionProtectError 5 @RT(5)DUMMY 
@BEG_SfcData 2 
@ExitSeq @RT(4)sseq @F 3 
@Step @RT(8)unnamed4 @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@Trans @RT(8)unnamed6 @F @T @F @F @T @T @TL(2)


@RT(8)unnamed6 @F 
@Goto @RT(9)unlabeled @F @F 
@END_SfcData 

@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(17)
Motion protection is enabled when sv_MotionProtectData.bEnabled flag is set to TRUE
Supervision is started when Movement is started (evStart received and XPosition is bigger
than the start position at that time)
when XPosition gets smaller than Start position recording the Data is started

When the recorded Y value exceeds the limit curve a evMotionProtectEvent is sent by the system

Depending on status of the measurement the event will trigger a evStop for the movement and a
erMotionProtect Alarm,
or will be silently thrown away (when a new limit curve is recorded)

There are 2 types of limit curve recalculation:
* after movement
  for auto readjustment mode
  when profile changed
* in idle time before movement
  when limit values are changed -> still uses old curve but new offsets
@@@END_Comment@@@ 

@BEG_Body 
@TL(17)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbWantRecalcAfterMovement := TRUE;

IF mbMovementStarted THEN
    // Movement is running -> Ignore cycle after next cycle
    mbRecalcReqDuringMove := TRUE;
END_IF;

IF sv_TraceLevel.bApplication THEN    
    fbDebugTrace(sText := 'MotionProtect: next cycle ignored');
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(3)
Called when a profile changes so much that Motion protection has to ignore next 
movement, because measured values are guarenteed to be different

@@@END_Comment@@@ 

@BEG_Body 
@TL(23)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// a motion protect error can only happen when movement is started
IF mbMovementStarted THEN
   mbErrorDuringMove := TRUE;
    
   //lock movements, defined in the motion protect data
   aLockUnlock(nMode := nLockAbort);
   sv_bMotionProtection := TRUE;    
   mbMovementStarted := FALSE;
    
   //send protect event
   aSendProtectEvent();
    
   IF sv_TraceLevel.bApplication THEN    
      fbDebugTrace(sText := CONCAT('MotionProtect: error injected at ',REAL_TO_STRING(mprVarX^),' (',REAL_TO_STRING(mprVarY^), ')'));
   END_IF;    
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(3)
Inject a Motion Protection Error
Used for addition Motion Protection cases not covered by limit curves
No error is raised when supervised movement is not currently active
@@@END_Comment@@@ 

@BEG_Body 
@TL(66)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//tmp := Print('error event received for profile %s VariableX:%s', EventData.Profile, EventData.VariableX);

IF NOT (EventData.Profile = sv_MotionProtectData.Name) THEN
   IF sv_TraceLevel.bApplication THEN    
      fbDebugTrace(sText := 'MotionProtect: event not for this profile, ignoring error event');
   END_IF;
   RETURN;
END_IF;

IF NOT sv_MotionProtectData.bEnabled THEN
   IF sv_TraceLevel.bApplication THEN    
      fbDebugTrace(sText := 'MotionProtect: motion protect not enabled, ignoring error event');
   END_IF;
   RETURN;
END_IF;

IF NOT mbMovementStarted THEN
   IF sv_TraceLevel.bApplication THEN    
      fbDebugTrace(sText := 'MotionProtect: movement not running, ignoring error event');
   END_IF;
   RETURN;
END_IF;

IF mbWantRecalcAfterMovement THEN
   IF sv_TraceLevel.bApplication THEN    
      fbDebugTrace(sText := 'MotionProtect: recalculating limit curve, ignoring error event');
   END_IF;    
   RETURN;
END_IF;


IF sv_TraceLevel.bApplication THEN    
   fbDebugTrace(sText := 'MotionProtect: got error');
END_IF;

mbErrorDuringMove := TRUE;

IF (sv_OperationMode > nManual) AND sv_bOpenAfterProtect AND (sv_iActMoldProtectRetry < sv_iSetMoldProtectRetry) THEN
   //only switch opmode, no alarm or buzzer
   SET_EVENT(evAlarmAutoManual, evAlarmAutoManualData);
ELSE
   //lock movements, defined in the motion protect data
   aLockUnlock(nMode := nLockAbort);
END_IF;

sv_bMotionProtection := TRUE;
mbMovementStarted := FALSE;

//send protect event
aSendProtectEvent();

IF sv_TraceLevel.bApplication THEN
   fbDebugTrace(sText := CONCAT('MotionProtect: got error at position ',LREAL_TO_STRING(EventData.ErrorValueX),' (limit: ',LREAL_TO_STRING(EventData.LimitY), ' act: ',LREAL_TO_STRING(EventData.ErrorValueY), ')'));
END_IF;

IF mbViolationPositionLinked THEN
   sv_rViolationPosition := LREAL_TO_REAL(EventData.ErrorValueX);
END_IF;



@END_Body 

@@@BEG_Comment@@@ 
@TL(3)
React to the limit curve exceeded event, which is set by the data recorder, when a limit is reached


@@@END_Comment@@@ 

@BEG_Body 
@TL(16)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// start if DeviceId and MoveDir are right, or cMoveAll is specified
IF (evStartData.DeviceId = sv_MotionProtectData.DeviceId) AND
   (evStartData.MoveDir  = sv_MotionProtectData.MoveDir   OR  sv_MotionProtectData.MoveDir = cMoveAll) THEN
   mbMovementStarted := TRUE;
   sv_bMotionProtection := FALSE;
   IF sv_TraceLevel.bApplication THEN    
      fbDebugTrace(sText := 'MotionProtect: supervised movement started');
   END_IF;
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
react on start of supervised movement
@@@END_Comment@@@ 

@BEG_Body 
@TL(13)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF evStopData.DeviceId = sv_MotionProtectData.DeviceId AND mbMovementStarted THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: evStop');
    END_IF;

   mbMovementStarted := FALSE;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(9)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//unlock movements (defined in the motion protect data) when alarm confirm button is pressed
aLockUnlock(nMode := nUnlock);


@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
This event algorithm reacts on pressing the alarm confirm button.
After alarm confirmation the movements which are defined in the motion protect data are unlocked
@@@END_Comment@@@ 

@BEG_Body 
@TL(71)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbRecalcRunning THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: Recalc limit curves requested but recalc still running');
    END_IF;
    RETURN;
END_IF;

IF mbMeasureRunning THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: Recalc limit curves requested but measurement is running');
    END_IF;
    RETURN;
END_IF;

mbRecalcRunning := TRUE;

IF sv_TraceLevel.bApplication THEN 
    // Start time measurement
    fbRTC(EN := FALSE,
          CDT => dStartTime);
END_IF;

IF mbUseLastCurve THEN
    // Set actual recorded curve as ideal curve
    status := abMeasureBlock.SetIdealCurve(CurveId := mpCurveId);
    
    IF status <> KMB_Status_OK THEN
        IF sv_TraceLevel.bApplication THEN    
            fbDebugTrace(sText := 'MotionProtect: SetIdealCurve failed');
        END_IF;
    END_IF;
    
    mbUseLastCurve := FALSE;
END_IF;

// Set x tolerance
// Time consumption very low -> No need to check if x tolerance has changed or not
status := abMeasureBlock.SetDeltaX(CurveId := mpCurveId,
                                   DeltaX := mpTolX^);

IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: SetDeltaX failed');
    END_IF;
END_IF;

// Recalculate lower/upper limit curves
status := abMeasureBlock.CalcUpperAndLowerLimitCurve(CurveId := mpCurveId,
                                                     UpperTolerance := mpTolYUpper^,
                                                     LowerTolerance := mpTolYLower^);

IF status <> KMB_Status_OK THEN
    IF sv_TraceLevel.bApplication THEN    
        fbDebugTrace(sText := 'MotionProtect: CalcUpperAndLowerLimitCurve failed');
    END_IF;
END_IF;

IF sv_TraceLevel.bApplication THEN 
    fbRTC(EN := FALSE,
          CDT => dStopTime);
    sTimeDiff:= TIME_TO_STRING(SUB_DT_DT(dStopTime, dStartTime));
    dummy := Print('MotionProtect: Time for recalc limit curves = %s', sTimeDiff);
END_IF;

mbRecalcRunning := FALSE;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// Trigger recalc of limit curves during wait (measurement not running)
mbRecalcIdleTime := TRUE;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(10)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bRecalcTrigger THEN
    aRecalcLimitCurves();
    sv_bRecalcTrigger := FALSE;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(3)
mrPositionStartTeach := sv_rPositionStartTeach;
mrPositionStopTeach := sv_rPositionStopTeach;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
