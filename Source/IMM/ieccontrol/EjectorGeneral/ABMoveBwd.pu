(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".
*)

IMPORT_OVER_LISTFILE
 GET_MY_FU_NAME
, WRITE_SVREAL_DIRECT
, KSWO_AddVariable
, cLockGroupClampingUnit
, cLockGroupMotor
, cLockGroupSafetyGateMold
, cMoveBwd
, nActive
, nDeviceState
, nInactive
, nSetup
, tnCalibState_Error
, tsMoveData
, tnOperationMode
, tsVelPre
, KCTRL_Lintab_Point
, tsSetTimes
, tsActTimes
, KAPPL_LintabData
, tsCalibMovement
, ABProfileMovement
, ABConstMovement
, ABConstCalib
, ABLintabApply
, ABStepOutput
, ABMovementRegister
, tsAlarm
, FBSetMovementState
, FBDebugTrace2
, KAPPL_VisProfile
, KSWO_Status

END_IMPORT

ALGORITHM_BLOCK ABMoveBwd #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_MoveBwd : tsMoveData;
 sv_bBwdActive : BOOL (* Ejector backward is active *);
 sv_bEjectorBwd : BOOL;
 sv_OperationMode : tnOperationMode;
 sv_rPressure : REAL;
 sv_rVelocity : REAL;
 sv_iActiveStage : DINT;
 sv_rEjectorPosition : REAL;
 sv_ConstBwdVis : tsVelPre;
 ai_Position : REAL;
 sv_dStandStillDetectTime : TIME (* time for standstill detection *);
 sv_rMaxVoltageDiff : REAL (* max. voltage difference to detect stand still *);
 sv_TmpLintabPoint : KCTRL_Lintab_Point;
 sv_bOutputActive : BOOL (* Output is active *);
 sv_bPreOutputReady : BOOL (* PreOutput is ready *);
 sv_bDoTransducerCalib : BOOL;
 sv_bTransducerError : BOOL;
 sv_EjectorBwdTimesSet : tsSetTimes;
 sv_EjectorBwdTimesAct : tsActTimes;
 sv_bMoveEjectorUntilEnd : BOOL;
 sv_rVelocityAbs : REAL;
 sv_rPressureAbs : REAL;
 sv_LintabOutBwdP : KAPPL_LintabData;
 sv_LintabOutBwdV : KAPPL_LintabData;
 sv_rMaxSpeedBwd : REAL;
 sv_CalibState : tsCalibMovement;
 sv_bTransducerAvailable : BOOL (* chad(CR_0038565) *);
 sv_ConstBwdVisLS : tsVelPre (* chad(CR_0038565) *);
 sv_bVerticalMachine : BOOL;
 sv_bMoveIdent : BOOL;
 sv_rIdentPosition : REAL;
 sv_rIdentStopRamp : REAL;
 sv_dSetDelayTimeOffBwd : TIME;
 sv_rSmoothFactor : REAL;
 sv_bDoPumpVelocityCalib : BOOL;
 sv_rEjectorStroke : REAL;
END_VAR

SYSTEM_OBJECT
 erEjectorNotBackward : ALARM;
 TaskSlow : TASK;
 TaskAnalog : TASK;
END_OBJECT

VAR_EXTERNAL
 g_dActMoveTimeBwd : TIME;
END_VAR

VAR
 abEjectorBwd : ABProfileMovement;
 abEjectorBwdConst : ABConstMovement;
 abEjectorBwdCalib : ABConstCalib;
 abLintabApplyVel : ABLintabApply;
 abLintabApplyPres : ABLintabApply;
 mpdCalculatedDuration : REFTO TIME;
 abEjectorBwdConstLS : ABConstMovement (* chad(CR_0038565) *);
 abEjectorBwdStep : ABStepOutput;
END_VAR

ALGORITHM aRegister


VAR
 abMovementRegister : ABMovementRegister;
 Alarm : tsAlarm;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bVerticalMachine THEN
   //for a vertical machine the ejector can also be operated while mold is closed(depending on mode)
   //ejector can be inserted after mold close
   //-> the automatic safety check could forbid ejector operation in manual mode while mold is open
   sv_MoveBwd.iSafetyIdentifier := 0;
END_IF;

// movement registration
sv_MoveBwd.LockGroups[1] := cLockGroupClampingUnit;
sv_MoveBwd.LockGroups[2] := cLockGroupMotor;
sv_MoveBwd.LockGroups[3] := cLockGroupSafetyGateMold;

sv_MoveBwd.pbPosReached := @sv_bEjectorBwd;
sv_MoveBwd.pdStartDelaySet := @sv_EjectorBwdTimesSet.dSetDelayTime;
sv_MoveBwd.pdStartDelayAct := @sv_EjectorBwdTimesAct.dActDelayTime;
sv_MoveBwd.pdActiveTimeAct := @sv_EjectorBwdTimesAct.dActMoveTime;
sv_MoveBwd.pdTimeLimit     := @sv_EjectorBwdTimesSet.dMaxMoveTime;


Alarm.AlarmId := erEjectorNotBackward;
sv_MoveBwd.Alarm := Alarm;
sv_MoveBwd.sIconPath := CONCAT(GET_MY_FU_NAME(), '\hmi\images\movEjectBwd.gif');

abMovementRegister.aRegister(@sv_MoveBwd);



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aRun


VAR_OUTPUT
 bReady : BOOL;
END_VAR

VAR_INPUT
 bStop : BOOL;
END_VAR

VAR_TEMP
 b : BOOL;
END_VAR

VAR
 dummy : DINT;
 fbSetMovementState : FBSetMovementState;
 dummypoint : KCTRL_Lintab_Point;
 bError : BOOL;
 iErrorInfo : DINT;
 fbDebugTrace2 : FBDebugTrace2;
 rTargetPosition : REAL;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP START:
AStart (P);
END_STEP

ACTION AStart: #BEGIN_EDIT_BLOCK
bReady := FALSE;
fbSetMovementState(MoveId   := cMoveBwd,
                   MoveDir  := cMoveBwd,
                   State    := nActive);
sv_bBwdActive := TRUE;
fbDebugTrace2(nDeviceState, 'Ejector Bwd Started');

;#END_EDIT_BLOCK END_ACTION (*AStart*)

(* steps *)
STEP S_CheckIfCalib:
END_STEP

STEP S_ConstMove:
AResetConstBlock (P);
ASetTargetPosition (P);
AConstOutput (N);
END_STEP

STEP S_Calib:
AResetCalibBlock (P);
ATransducerCalib (N);
ACheckCalibError (N);
END_STEP

STEP S_MoveUntilEnd:
AResetCalibBlock2 (P);
ATransducerCalib2 (N);
END_STEP

STEP S_MoveIdent:
AResetIdentBlock (P);
AStepOutput (N);
END_STEP

STEP S_IsTransLinkedAndActive:
END_STEP

STEP S_ProfileMove:
AResetProfileBlock (P);
AProfileOutput (N);
END_STEP

STEP S_ConstMoveLS:
AResetConstBlockLS (P);
AConstOutputLS (N);
END_STEP

STEP READY:
AReady (P);
END_STEP

ACTION AReady: #BEGIN_EDIT_BLOCK
bReady := TRUE;
fbSetMovementState(MoveId   := cMoveBwd,
                   MoveDir  := cMoveBwd,
                   State    := nInactive);
sv_bBwdActive := FALSE;
fbDebugTrace2(nDeviceState, 'Ejector Bwd Ready');

;#END_EDIT_BLOCK END_ACTION (*AReady*)

(* transitions *)
GO_ON_TRANSITION TSetupMode (* TSetupMode *) FROM START TO S_CheckIfCalib :=  #BEGIN_EDIT_BLOCK
sv_OperationMode = nSetup
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNotCalib (* TNotCalib *) FROM S_CheckIfCalib TO S_ConstMove :=  #BEGIN_EDIT_BLOCK
(NOT sv_bDoTransducerCalib) AND
(NOT sv_bMoveEjectorUntilEnd) AND
(NOT sv_bMoveIdent)
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TConstMoveReady (* TConstMoveReady *) FROM S_ConstMove TO READY :=  #BEGIN_EDIT_BLOCK
NOT abEjectorBwdConst.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TCalibActivated (* TCalibActivated *) FROM S_CheckIfCalib TO S_Calib :=  #BEGIN_EDIT_BLOCK
sv_bDoTransducerCalib
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TCalibReady (* TCalibReady *) FROM S_Calib TO READY :=  #BEGIN_EDIT_BLOCK
NOT abEjectorBwdCalib.aRun.bActive OR bError
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TMoveUntilEnd (* TMoveUntilEnd *) FROM S_CheckIfCalib TO S_MoveUntilEnd :=  #BEGIN_EDIT_BLOCK
sv_bMoveEjectorUntilEnd
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveUntilEndReady (* TMoveUntilEndReady *) FROM S_MoveUntilEnd TO READY :=  #BEGIN_EDIT_BLOCK
(NOT abEjectorBwdCalib.aRun.bActive) AND
(NOT abEjectorBwdConst.aRun.bActive)
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TMoveIdentActivated (* TMoveIdentActivated *) FROM S_CheckIfCalib TO S_MoveIdent :=  #BEGIN_EDIT_BLOCK
sv_bMoveIdent
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveIdentReady (* TMoveIdentReady *) FROM S_MoveIdent TO READY :=  #BEGIN_EDIT_BLOCK
NOT abEjectorBwdStep.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNotSetup (* TNotSetup *) FROM START TO S_IsTransLinkedAndActive :=  #BEGIN_EDIT_BLOCK
sv_OperationMode <> nSetup
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TTransLinkedAndActivated (* TTransLinkedAndActivated *) FROM S_IsTransLinkedAndActive TO S_ProfileMove :=  #BEGIN_EDIT_BLOCK
sv_bTransducerAvailable
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TProfileMoveReady (* TProfileMoveReady *) FROM S_ProfileMove TO READY :=  #BEGIN_EDIT_BLOCK
NOT abEjectorBwd.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TTransNotActivated (* TTransNotActivated *) FROM S_IsTransLinkedAndActive TO S_ConstMoveLS :=  #BEGIN_EDIT_BLOCK
NOT sv_bTransducerAvailable
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TConstMoveLSReady (* TConstMoveLSReady *) FROM S_ConstMoveLS TO READY :=  #BEGIN_EDIT_BLOCK
NOT abEjectorBwdConstLS.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans12 (* Trans12 *) FROM READY TO START :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION AResetConstBlockLS: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwdConstLS.aRun(bStart := FALSE);

;#END_EDIT_BLOCK END_ACTION (*AResetConstBlockLS*)
ACTION AResetCalibBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
bError := FALSE;
abEjectorBwdCalib.aRun(bStart := FALSE,
                       LintabPoint := sv_TmpLintabPoint);
IF abEjectorBwdCalib.aRun.bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   bError := TRUE;
   dummy := Print("Calib Error: Reset calib block failed"); 
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AResetCalibBlock*)
ACTION AResetProfileBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
abEjectorBwd.aRun(bStart := FALSE);

;#END_EDIT_BLOCK END_ACTION (*AResetProfileBlock*)
ACTION AResetCalibBlock2: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//the point is set to dummy, as this block is only used for moving back ejector
IF sv_bTransducerAvailable THEN
   abEjectorBwdCalib.aRun(bStart := FALSE,
                          LintabPoint := dummypoint);
ELSE
   abEjectorBwdConst.aRun(bStart:=FALSE);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AResetCalibBlock2*)
ACTION ATransducerCalib2: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bTransducerAvailable THEN
    abEjectorBwdCalib.aRun(bStart := TRUE,
                           bStop := (bStop OR sv_bTransducerError),
                           rActVoltage := ai_Position,
                           rMaxVoltageDiff := sv_rMaxVoltageDiff,
                           dStandStillDetectTime := sv_dStandStillDetectTime,
                           LintabPoint:=dummypoint,
                           rSetValue := 0.0,
                           bActive => sv_bOutputActive,
                           rOutputPre => sv_rPressureAbs,
                           rOutputVel => sv_rVelocityAbs,
                           bPreOutputReached => sv_bPreOutputReady);
ELSE
    abEjectorBwdConst.aRun(bStart := TRUE,
                           bStop := (bStop OR sv_bEjectorBwd),
                           dMaxTime := sv_EjectorBwdTimesSet.dMaxMoveTime,
                           rOutputPre => sv_rPressureAbs,
                           rOutputVel => sv_rVelocityAbs,
                           bActive => sv_bOutputActive,
                           dActTime => sv_EjectorBwdTimesAct.dActMoveTime,
                           bPreOutputReached => sv_bPreOutputReady);
END_IF;



abLintabApplyPres.aCalc(rX:=sv_rPressureAbs,
                        rY=>sv_rPressure);


abLintabApplyVel.aCalc(rX:=sv_rVelocityAbs,
                       rY=>sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*ATransducerCalib2*)
ACTION ACheckCalibError: #BEGIN_EDIT_BLOCK
IF bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   dummy := Print("Calib Error: %i", iErrorInfo);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckCalibError*)
ACTION AResetConstBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwdConst.aRun(bStart := FALSE);

;#END_EDIT_BLOCK END_ACTION (*AResetConstBlock*)
ACTION AResetIdentBlock: #BEGIN_EDIT_BLOCK
abEjectorBwdStep.aRun(bStart := FALSE);


;#END_EDIT_BLOCK END_ACTION (*AResetIdentBlock*)
ACTION ASetTargetPosition: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bDoPumpVelocityCalib THEN
   //move bwd to 5% of complete stroke
   rTargetPosition := (0.05 * sv_rEjectorStroke);
ELSE
   rTargetPosition := 0.0;
END_IF;



;#END_EDIT_BLOCK END_ACTION (*ASetTargetPosition*)
ACTION ATransducerCalib: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwdCalib.aRun(bStop := bStop OR sv_bTransducerError,
                       bStart := TRUE,
                       rActVoltage := ai_Position,
                       rMaxVoltageDiff := sv_rMaxVoltageDiff,
                       dStandStillDetectTime := sv_dStandStillDetectTime,
                       LintabPoint := sv_TmpLintabPoint,
                       rSetValue := 0.0,
                       dDelayTimeOn := sv_EjectorBwdTimesSet.dSetDelayTimePump,
                       dDelayTimeOff := sv_EjectorBwdTimesSet.dSetDelayTimeValve,
                       bActive => sv_bOutputActive,
                       rOutputPre => sv_rPressureAbs,
                       rOutputVel => sv_rVelocityAbs,
                       bPreOutputReached => sv_bPreOutputReady,
                       iErrorInfo => iErrorInfo);

sv_bDoTransducerCalib := NOT (abEjectorBwdCalib.aRun.bPointDetected);
bError := abEjectorBwdCalib.aRun.bError OR bError;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*ATransducerCalib*)
ACTION AStepOutput: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwdStep.aRun(bUsePosDetect := sv_rIdentPosition <> 0.0,
                      rPositionDown := (sv_rEjectorPosition + sv_rIdentPosition) * 0.5,
                      rLowOutput := sv_rMaxSpeedBwd * 0.1,
                      bStart := TRUE,
                      bStop := bStop,
                      bDirection := FALSE,
                      rActPos := sv_rEjectorPosition,
                      rTargetPos := sv_rIdentPosition,
                      dDelayTimeOn := sv_EjectorBwdTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_dSetDelayTimeOffBwd,
                      rPositionUp := sv_rEjectorPosition,
                      rHighOutput := sv_ConstBwdVis.Velocity.Output.rOutputValue,
                      dMaxMoveTime := sv_EjectorBwdTimesSet.dMaxMoveTime,
                      rStopRamp := sv_rIdentStopRamp,
                      bActive => sv_bOutputActive,
                      rOutputPre => sv_rPressureAbs,
                      rOutputVel => sv_rVelocityAbs,
                      bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


;#END_EDIT_BLOCK END_ACTION (*AStepOutput*)
ACTION AProfileOutput: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwd.aRun(bStop := bStop OR sv_bTransducerError,
                  bStart := TRUE,
                  rActPosition := sv_rEjectorPosition,
                  dMaxMoveTime := sv_EjectorBwdTimesSet.dMaxMoveTime,
                  dDelayTimeOn := sv_EjectorBwdTimesSet.dSetDelayTimePump,
                  dDelayTimeOff := sv_EjectorBwdTimesSet.dSetDelayTimeValve,
                  DeadTime := sv_dSetDelayTimeOffBwd,
                  rSmoothFactor := sv_rSmoothFactor,
                  bActive => sv_bOutputActive,
                  iActiveStage => sv_iActiveStage,
                  bPreOutputReached => sv_bPreOutputReady,
                  dActMoveTime => g_dActMoveTimeBwd);

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abEjectorBwd.aRun.rPressureOutput);
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abEjectorBwd.aRun.rVelocityOutput);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);

;#END_EDIT_BLOCK END_ACTION (*AProfileOutput*)
ACTION AConstOutputLS: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwdConstLS.aRun(bStop := bStop OR sv_bEjectorBwd,
                         bStart := TRUE,
                         dMaxTime := sv_EjectorBwdTimesSet.dMaxMoveTime,
                         dDelayTimeOn := sv_EjectorBwdTimesSet.dSetDelayTimePump,
                         dDelayTimeOff := sv_EjectorBwdTimesSet.dSetDelayTimeValve,
                         rOutputPre => sv_rPressureAbs,
                         rOutputVel => sv_rVelocityAbs,
                         bActive => sv_bOutputActive,
                         dActTime => g_dActMoveTimeBwd,
                         bPreOutputReached => sv_bPreOutputReady);              

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abEjectorBwdConstLS.aRun.rOutputPre);
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abEjectorBwdConstLS.aRun.rOutputVel);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);


;#END_EDIT_BLOCK END_ACTION (*AConstOutputLS*)
ACTION AConstOutput: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwdConst.aRun(bUsePosDetect := rTargetPosition <> 0.0,
                       bStart := TRUE,
                       bStop := bStop,
                       bDirection := FALSE,
                       rActPos := sv_rEjectorPosition,
                       rTargetPos := rTargetPosition,
                       dDelayTimeOn := sv_EjectorBwdTimesSet.dSetDelayTimePump,
                       dDelayTimeOff := sv_EjectorBwdTimesSet.dSetDelayTimeValve,
                       rOutputPre => sv_rPressureAbs,
                       rOutputVel => sv_rVelocityAbs,
                       bActive => sv_bOutputActive,
                       dActTime => sv_EjectorBwdTimesAct.dActMoveTime,
                       bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*AConstOutput*)
(* end sfc-code *)


END_ALGORITHM

ALGORITHM aInit


VAR_INPUT
 pProfile : REFTO KAPPL_VisProfile;
 pdCalculatedDuration : REFTO TIME;
 prCalcDurationStartPosition : REFTO REAL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwd.aInit(pProfile := pProfile,
                   MoveDir := cMoveBwd,
                   pdCalcedDuration := pdCalculatedDuration,
                   prCalcDurationStartPosition := prCalcDurationStartPosition);

mpdCalculatedDuration := pdCalculatedDuration;

abEjectorBwdConst.aInit(pConst := @sv_ConstBwdVis,
                        MoveId := cMoveBwd);

abEjectorBwdConstLS.aInit(pConst := @sv_ConstBwdVisLS,
                          MoveId := cMoveBwd);

abEjectorBwdCalib.aInit(pConst := @sv_ConstBwdVis,
                        MoveId := cMoveBwd);

abLintabApplyPres.aInit(pLintab := @sv_LintabOutBwdP);

abLintabApplyVel.aInit(pLintab := @sv_LintabOutBwdV);

abEjectorBwdStep.aInit(pConst := @sv_ConstBwdVis,
                       MoveId := cMoveBwd,
                       prMaxSpeed := @sv_rMaxSpeedBwd);



;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paInitDebugMeasurement ON TaskSlow AUTOSTART


VAR
 fuName : STRING(255);
 variableName : STRING(255);
 swoState : KSWO_Status;
END_VAR
#BEGIN_EDIT_BLOCK
fuName := GET_MY_FU_NAME();
variableName := CONCAT(fuName,'.Bwd.rSetPressure bar');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rPressureAbs);
variableName := CONCAT(fuName,'.Bwd.rSetVelocity mm/s');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rVelocityAbs);
variableName := CONCAT(fuName,'.Bwd.bActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bOutputActive);
STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 152 @Pou 25 
@@@BEG_Comment@@@
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".
@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
3 
@Var @RT(14)GET_MY_FU_NAME @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)WRITE_SVREAL_DIRECT @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)KSWO_AddVariable @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
9 
@Var @RT(22)cLockGroupClampingUnit @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)65 @RT(29)Members: Mold, Ejector, Cores 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)cLockGroupMotor @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)69 @RT(56)Members: Mold, Ejector, Cores, Injection, Plast, Purge,  
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(24)cLockGroupSafetyGateMold @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)61 @RT(73)Members: Mold Close, Mold Hight Forward, Auto Mold Hight, Core In, Inject 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveBwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)11 @RT(17)movement backward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)nActive @RT(0) @T @T @DERIVED 0 @F @RT(16)tnActiveInactive @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)nDeviceState @RT(0) @T @T @DERIVED 0 @F @RT(12)tnTraceLevel @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)nInactive @RT(0) @T @T @DERIVED 0 @F @RT(16)tnActiveInactive @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)nSetup @RT(0) @T @T @DERIVED 0 @F @RT(15)tnOperationMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(36)Setup mode only for service engineer 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)tnCalibState_Error @RT(0) @T @T @DERIVED 0 @F @RT(12)tnCalibState @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(32)error occured during calibration 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(9)ABMoveBwd @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
48 
@Var @RT(10)sv_MoveBwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bBwdActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)Ejector backward is active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(14)sv_bEjectorBwd @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_OperationMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnOperationMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_rPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_rVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_iActiveStage @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_rEjectorPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(14)sv_ConstBwdVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(11)ai_Position @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_dStandStillDetectTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(29)time for standstill detection @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_rMaxVoltageDiff @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(45)max. voltage difference to detect stand still @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_TmpLintabPoint @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)KCTRL_Lintab_Point @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_bOutputActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(16)Output is active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_bPreOutputReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)PreOutput is ready @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_bDoTransducerCalib @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_bTransducerError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_EjectorBwdTimesSet @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsSetTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_EjectorBwdTimesAct @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsActTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bMoveEjectorUntilEnd @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rVelocityAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rPressureAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LintabOutBwdP @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LintabOutBwdV @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rMaxSpeedBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_CalibState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsCalibMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bTransducerAvailable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(16)chad(CR_0038565) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_ConstBwdVisLS @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(16)chad(CR_0038565) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_bVerticalMachine @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bMoveIdent @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rIdentPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rIdentStopRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_dSetDelayTimeOffBwd @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_rSmoothFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bDoPumpVelocityCalib @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rEjectorStroke @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)erEjectorNotBackward @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(8)TaskSlow @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)TaskAnalog @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(17)g_dActMoveTimeBwd @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(12)abEjectorBwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)ABProfileMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)abEjectorBwdConst @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)ABConstMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)abEjectorBwdCalib @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)ABConstCalib @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abLintabApplyVel @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)abLintabApplyPres @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)mpdCalculatedDuration @RT(0) @T @T @REFTO 0 @T @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)abEjectorBwdConstLS @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)ABConstMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(16)chad(CR_0038565) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abEjectorBwdStep @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)ABStepOutput @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

4 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(9)aRegister @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(18)abMovementRegister @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABMovementRegister @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)Alarm @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(7)tsAlarm @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aRun @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
10 
@Var @RT(6)bReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(5)bStop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)fbSetMovementState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)FBSetMovementState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)dummypoint @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)KCTRL_Lintab_Point @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)fbDebugTrace2 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)FBDebugTrace2 @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)rTargetPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(5)aInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(8)pProfile @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)pdCalculatedDuration @RT(0) @T @T @REFTO 0 @T @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(27)prCalcDurationStartPosition @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(22)paInitDebugMeasurement @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @T @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(6)fuName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)variableName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)swoState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSWO_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(31)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bVerticalMachine THEN
   //for a vertical machine the ejector can also be operated while mold is closed(depending on mode)
   //ejector can be inserted after mold close
   //-> the automatic safety check could forbid ejector operation in manual mode while mold is open
   sv_MoveBwd.iSafetyIdentifier := 0;
END_IF;

// movement registration
sv_MoveBwd.LockGroups[1] := cLockGroupClampingUnit;
sv_MoveBwd.LockGroups[2] := cLockGroupMotor;
sv_MoveBwd.LockGroups[3] := cLockGroupSafetyGateMold;

sv_MoveBwd.pbPosReached := @sv_bEjectorBwd;
sv_MoveBwd.pdStartDelaySet := @sv_EjectorBwdTimesSet.dSetDelayTime;
sv_MoveBwd.pdStartDelayAct := @sv_EjectorBwdTimesAct.dActDelayTime;
sv_MoveBwd.pdActiveTimeAct := @sv_EjectorBwdTimesAct.dActMoveTime;
sv_MoveBwd.pdTimeLimit     := @sv_EjectorBwdTimesSet.dMaxMoveTime;


Alarm.AlarmId := erEjectorNotBackward;
sv_MoveBwd.Alarm := Alarm;
sv_MoveBwd.sIconPath := CONCAT(GET_MY_FU_NAME(), '\hmi\images\movEjectBwd.gif');

abMovementRegister.aRegister(@sv_MoveBwd);


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
17 11 16 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 1 
@Loop @RT(4)loop @F 2 
@StepSeq @RT(4)sseq @F 3 
@Step @RT(5)START @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)AStart @F @T @RT(1)P @RT(0) @F @F @T @TL(7)
bReady := FALSE;
fbSetMovementState(MoveId   := cMoveBwd,
                   MoveDir  := cMoveBwd,
                   State    := nActive);
sv_bBwdActive := TRUE;
fbDebugTrace2(nDeviceState, 'Ejector Bwd Started');

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(10)TSetupMode @F @T @F @F @T @F @TL(2)
sv_OperationMode = nSetup

@RT(10)TSetupMode @F 
@Step @RT(14)S_CheckIfCalib @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 4 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(9)TNotCalib @F @T @F @F @T @F @TL(4)
(NOT sv_bDoTransducerCalib) AND
(NOT sv_bMoveEjectorUntilEnd) AND
(NOT sv_bMoveIdent)

@RT(9)TNotCalib @F 
@Step @RT(11)S_ConstMove @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(16)AResetConstBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(18)ASetTargetPosition @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(12)AConstOutput @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(15)TConstMoveReady @F @T @F @F @T @T @TL(2)
NOT abEjectorBwdConst.aRun.bActive

@RT(15)TConstMoveReady @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(15)TCalibActivated @F @T @F @F @T @F @TL(2)
sv_bDoTransducerCalib

@RT(15)TCalibActivated @F 
@Step @RT(7)S_Calib @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(16)AResetCalibBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(16)ATransducerCalib @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(16)ACheckCalibError @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(11)TCalibReady @F @T @F @F @T @T @TL(2)
NOT abEjectorBwdCalib.aRun.bActive OR bError

@RT(11)TCalibReady @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(13)TMoveUntilEnd @F @T @F @F @T @F @TL(2)
sv_bMoveEjectorUntilEnd

@RT(13)TMoveUntilEnd @F 
@Step @RT(14)S_MoveUntilEnd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(17)AResetCalibBlock2 @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(17)ATransducerCalib2 @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(18)TMoveUntilEndReady @F @T @F @F @T @T @TL(3)
(NOT abEjectorBwdCalib.aRun.bActive) AND
(NOT abEjectorBwdConst.aRun.bActive)

@RT(18)TMoveUntilEndReady @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(19)TMoveIdentActivated @F @T @F @F @T @F @TL(2)
sv_bMoveIdent

@RT(19)TMoveIdentActivated @F 
@Step @RT(11)S_MoveIdent @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(16)AResetIdentBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(11)AStepOutput @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(15)TMoveIdentReady @F @T @F @F @T @T @TL(2)
NOT abEjectorBwdStep.aRun.bActive

@RT(15)TMoveIdentReady @F 



@TransSeq @RT(4)tseq @F 3 
@Trans @RT(9)TNotSetup @F @T @F @F @T @F @TL(2)
sv_OperationMode <> nSetup

@RT(9)TNotSetup @F 
@Step @RT(24)S_IsTransLinkedAndActive @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(24)TTransLinkedAndActivated @F @T @F @F @T @F @TL(2)
sv_bTransducerAvailable

@RT(24)TTransLinkedAndActivated @F 
@Step @RT(13)S_ProfileMove @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(18)AResetProfileBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(14)AProfileOutput @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(17)TProfileMoveReady @F @T @F @F @T @F @TL(2)
NOT abEjectorBwd.aRun.bActive

@RT(17)TProfileMoveReady @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(18)TTransNotActivated @F @T @F @F @T @F @TL(2)
NOT sv_bTransducerAvailable

@RT(18)TTransNotActivated @F 
@Step @RT(13)S_ConstMoveLS @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(18)AResetConstBlockLS @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(14)AConstOutputLS @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(17)TConstMoveLSReady @F @T @F @F @T @F @TL(2)
NOT abEjectorBwdConstLS.aRun.bActive

@RT(17)TConstMoveLSReady @F 




@Step @RT(5)READY @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)AReady @F @T @RT(1)P @RT(0) @F @F @T @TL(7)
bReady := TRUE;
fbSetMovementState(MoveId   := cMoveBwd,
                   MoveDir  := cMoveBwd,
                   State    := nInactive);
sv_bBwdActive := FALSE;
fbDebugTrace2(nDeviceState, 'Ejector Bwd Ready');

@F 


@Trans @RT(7)Trans12 @F @T @F @T @T @T @TL(2)
TRUE

@RT(7)Trans12 @F 

@END_SfcData 
@SaActions 14 
@SaText @RT(18)AResetConstBlockLS 1 @TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwdConstLS.aRun(bStart := FALSE);


@SaText @RT(16)AResetCalibBlock 1 @TL(13)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
bError := FALSE;
abEjectorBwdCalib.aRun(bStart := FALSE,
                       LintabPoint := sv_TmpLintabPoint);
IF abEjectorBwdCalib.aRun.bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   bError := TRUE;
   dummy := Print("Calib Error: Reset calib block failed"); 
END_IF;


@SaText @RT(18)AResetProfileBlock 1 @TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
abEjectorBwd.aRun(bStart := FALSE);


@SaText @RT(17)AResetCalibBlock2 1 @TL(13)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//the point is set to dummy, as this block is only used for moving back ejector
IF sv_bTransducerAvailable THEN
   abEjectorBwdCalib.aRun(bStart := FALSE,
                          LintabPoint := dummypoint);
ELSE
   abEjectorBwdConst.aRun(bStart:=FALSE);
END_IF;


@SaText @RT(17)ATransducerCalib2 1 @TL(37)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bTransducerAvailable THEN
    abEjectorBwdCalib.aRun(bStart := TRUE,
                           bStop := (bStop OR sv_bTransducerError),
                           rActVoltage := ai_Position,
                           rMaxVoltageDiff := sv_rMaxVoltageDiff,
                           dStandStillDetectTime := sv_dStandStillDetectTime,
                           LintabPoint:=dummypoint,
                           rSetValue := 0.0,
                           bActive => sv_bOutputActive,
                           rOutputPre => sv_rPressureAbs,
                           rOutputVel => sv_rVelocityAbs,
                           bPreOutputReached => sv_bPreOutputReady);
ELSE
    abEjectorBwdConst.aRun(bStart := TRUE,
                           bStop := (bStop OR sv_bEjectorBwd),
                           dMaxTime := sv_EjectorBwdTimesSet.dMaxMoveTime,
                           rOutputPre => sv_rPressureAbs,
                           rOutputVel => sv_rVelocityAbs,
                           bActive => sv_bOutputActive,
                           dActTime => sv_EjectorBwdTimesAct.dActMoveTime,
                           bPreOutputReached => sv_bPreOutputReady);
END_IF;



abLintabApplyPres.aCalc(rX:=sv_rPressureAbs,
                        rY=>sv_rPressure);


abLintabApplyVel.aCalc(rX:=sv_rVelocityAbs,
                       rY=>sv_rVelocity);


@SaText @RT(16)ACheckCalibError 1 @TL(5)
IF bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   dummy := Print("Calib Error: %i", iErrorInfo);
END_IF;


@SaText @RT(16)AResetConstBlock 1 @TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwdConst.aRun(bStart := FALSE);


@SaText @RT(16)AResetIdentBlock 1 @TL(3)
abEjectorBwdStep.aRun(bStart := FALSE);



@SaText @RT(18)ASetTargetPosition 1 @TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bDoPumpVelocityCalib THEN
   //move bwd to 5% of complete stroke
   rTargetPosition := (0.05 * sv_rEjectorStroke);
ELSE
   rTargetPosition := 0.0;
END_IF;




@SaText @RT(16)ATransducerCalib 1 @TL(29)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwdCalib.aRun(bStop := bStop OR sv_bTransducerError,
                       bStart := TRUE,
                       rActVoltage := ai_Position,
                       rMaxVoltageDiff := sv_rMaxVoltageDiff,
                       dStandStillDetectTime := sv_dStandStillDetectTime,
                       LintabPoint := sv_TmpLintabPoint,
                       rSetValue := 0.0,
                       dDelayTimeOn := sv_EjectorBwdTimesSet.dSetDelayTimePump,
                       dDelayTimeOff := sv_EjectorBwdTimesSet.dSetDelayTimeValve,
                       bActive => sv_bOutputActive,
                       rOutputPre => sv_rPressureAbs,
                       rOutputVel => sv_rVelocityAbs,
                       bPreOutputReached => sv_bPreOutputReady,
                       iErrorInfo => iErrorInfo);

sv_bDoTransducerCalib := NOT (abEjectorBwdCalib.aRun.bPointDetected);
bError := abEjectorBwdCalib.aRun.bError OR bError;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


@SaText @RT(11)AStepOutput 1 @TL(31)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwdStep.aRun(bUsePosDetect := sv_rIdentPosition <> 0.0,
                      rPositionDown := (sv_rEjectorPosition + sv_rIdentPosition) * 0.5,
                      rLowOutput := sv_rMaxSpeedBwd * 0.1,
                      bStart := TRUE,
                      bStop := bStop,
                      bDirection := FALSE,
                      rActPos := sv_rEjectorPosition,
                      rTargetPos := sv_rIdentPosition,
                      dDelayTimeOn := sv_EjectorBwdTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_dSetDelayTimeOffBwd,
                      rPositionUp := sv_rEjectorPosition,
                      rHighOutput := sv_ConstBwdVis.Velocity.Output.rOutputValue,
                      dMaxMoveTime := sv_EjectorBwdTimesSet.dMaxMoveTime,
                      rStopRamp := sv_rIdentStopRamp,
                      bActive => sv_bOutputActive,
                      rOutputPre => sv_rPressureAbs,
                      rOutputVel => sv_rVelocityAbs,
                      bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);



@SaText @RT(14)AProfileOutput 1 @TL(27)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwd.aRun(bStop := bStop OR sv_bTransducerError,
                  bStart := TRUE,
                  rActPosition := sv_rEjectorPosition,
                  dMaxMoveTime := sv_EjectorBwdTimesSet.dMaxMoveTime,
                  dDelayTimeOn := sv_EjectorBwdTimesSet.dSetDelayTimePump,
                  dDelayTimeOff := sv_EjectorBwdTimesSet.dSetDelayTimeValve,
                  DeadTime := sv_dSetDelayTimeOffBwd,
                  rSmoothFactor := sv_rSmoothFactor,
                  bActive => sv_bOutputActive,
                  iActiveStage => sv_iActiveStage,
                  bPreOutputReached => sv_bPreOutputReady,
                  dActMoveTime => g_dActMoveTimeBwd);

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abEjectorBwd.aRun.rPressureOutput);
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abEjectorBwd.aRun.rVelocityOutput);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);


@SaText @RT(14)AConstOutputLS 1 @TL(26)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwdConstLS.aRun(bStop := bStop OR sv_bEjectorBwd,
                         bStart := TRUE,
                         dMaxTime := sv_EjectorBwdTimesSet.dMaxMoveTime,
                         dDelayTimeOn := sv_EjectorBwdTimesSet.dSetDelayTimePump,
                         dDelayTimeOff := sv_EjectorBwdTimesSet.dSetDelayTimeValve,
                         rOutputPre => sv_rPressureAbs,
                         rOutputVel => sv_rVelocityAbs,
                         bActive => sv_bOutputActive,
                         dActTime => g_dActMoveTimeBwd,
                         bPreOutputReached => sv_bPreOutputReady);              

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abEjectorBwdConstLS.aRun.rOutputPre);
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abEjectorBwdConstLS.aRun.rOutputVel);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);



@SaText @RT(12)AConstOutput 1 @TL(25)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwdConst.aRun(bUsePosDetect := rTargetPosition <> 0.0,
                       bStart := TRUE,
                       bStop := bStop,
                       bDirection := FALSE,
                       rActPos := sv_rEjectorPosition,
                       rTargetPos := rTargetPosition,
                       dDelayTimeOn := sv_EjectorBwdTimesSet.dSetDelayTimePump,
                       dDelayTimeOff := sv_EjectorBwdTimesSet.dSetDelayTimeValve,
                       rOutputPre => sv_rPressureAbs,
                       rOutputVel => sv_rVelocityAbs,
                       bActive => sv_bOutputActive,
                       dActTime => sv_EjectorBwdTimesAct.dActMoveTime,
                       bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


@SaTrans 0 
@SaExits 0 
@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(30)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abEjectorBwd.aInit(pProfile := pProfile,
                   MoveDir := cMoveBwd,
                   pdCalcedDuration := pdCalculatedDuration,
                   prCalcDurationStartPosition := prCalcDurationStartPosition);

mpdCalculatedDuration := pdCalculatedDuration;

abEjectorBwdConst.aInit(pConst := @sv_ConstBwdVis,
                        MoveId := cMoveBwd);

abEjectorBwdConstLS.aInit(pConst := @sv_ConstBwdVisLS,
                          MoveId := cMoveBwd);

abEjectorBwdCalib.aInit(pConst := @sv_ConstBwdVis,
                        MoveId := cMoveBwd);

abLintabApplyPres.aInit(pLintab := @sv_LintabOutBwdP);

abLintabApplyVel.aInit(pLintab := @sv_LintabOutBwdV);

abEjectorBwdStep.aInit(pConst := @sv_ConstBwdVis,
                       MoveId := cMoveBwd,
                       prMaxSpeed := @sv_rMaxSpeedBwd);


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(15)
fuName := GET_MY_FU_NAME();
variableName := CONCAT(fuName,'.Bwd.rSetPressure bar');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rPressureAbs);
variableName := CONCAT(fuName,'.Bwd.rSetVelocity mm/s');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rVelocityAbs);
variableName := CONCAT(fuName,'.Bwd.bActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bOutputActive);
STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
