IMPORT_OVER_LISTFILE
 GET_SYNC_REFTO
, SET_ALARM
, SET_EVENT
, CHECK_REF
, cCompEjector
, cCompMold
, KSYS_Status_OK
, cOptionHydraulic
, tnCalibState_None
, tnCalibState_Running
, tnCalibCommand_Stop
, tnCalibState_Aborted
, cMoveFwd
, cMoveNone
, cMoveBwd
, cMoveDecompAftPlast
, tnCalibState_Error
, cCalibMovements
, nSetup
, tnCalibCommand_None
, tnCalibState_Done
, tnCalibCommand_Start
, tsGlobalIdentSpeedStatus
, tsIdentSpeedMovement
, tnOperationMode
, tyPumpData
, tevRedoIdentSpeedEvent
, tevStopRequest
, tevStartRequest
, tsDeviceId
, tpIdentSpeedMovement
, FBCheckReady
, tevStartRequestData
, tevStopRequestData
, FBIdentSpeedWriteLog
, ABAutoIdentSpeedMeasure
, tnDataState
, KSYS_Status
, tOptionId
, FBTracePendingAlarms
, tevRedoIdentSpeedEventData
, tsVelPre
, tyIdentSpeedMovements
, TON

END_IMPORT

ALGORITHM_BLOCK ABAutoIdentSpeed #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_GlobalIdentMaxSpeedStatus : tsGlobalIdentSpeedStatus;
 sv_EjectorIdentMaxMovement : tsIdentSpeedMovement;
 sv_MoldIdentMaxMovement : tsIdentSpeedMovement;
 sv_InjectionIdentMaxMovement : tsIdentSpeedMovement;
 sv_NozzleIdentMaxMovement : tsIdentSpeedMovement;
 sv_GlobalIdentMinSpeedStatus : tsGlobalIdentSpeedStatus;
 sv_EjectorIdentMinMovement : tsIdentSpeedMovement;
 sv_MoldIdentMinMovement : tsIdentSpeedMovement;
 sv_InjectionIdentMinMovement : tsIdentSpeedMovement;
 sv_NozzleIdentMinMovement : tsIdentSpeedMovement;
 sv_iPendingAlarms : DINT;
 sv_OperationMode : tnOperationMode;
 sv_bAutoIdentRunning : BOOL (* auto calibration active *);
 sv_bCoresActive : BOOL;
 sv_PumpData : tyPumpData;
 sv_DataState : tnDataState;
END_VAR

SYSTEM_OBJECT
 TaskMid : TASK;
 TaskSlow : TASK;
 TaskInject : TASK;
 TaskAnalog : TASK;
 PU_Task_7 : TASK;
 EV_Task_7 : TASK;
 erCalibrationSpeedStopped : ALARM;
 erSetupModeRequiredForCalib : ALARM;
 erCalibCoresActive : ALARM;
 evRedoIdentMaxSpeedStart : tevRedoIdentSpeedEvent;
 evRedoIdentMinSpeedStart : tevRedoIdentSpeedEvent;
 evStopRequest : tevStopRequest;
 evStartRequest : tevStartRequest;
 PU_Task_13 : TASK;
END_OBJECT

VAR
 DeviceIdEjector : tsDeviceId := (CompId:=cCompEjector,IndexId:=1);
 DeviceIdMold : tsDeviceId := (CompId:=cCompMold,IndexId:=1);
 mActMovement : tpIdentSpeedMovement;
 mCalibCounter : DINT;
 mbUseSingleMovement : BOOL;
 fbCheckReady : FBCheckReady;
 evStartRequestData : tevStartRequestData;
 evStopRequestData : tevStopRequestData;
 fbIdentWriteLog : FBIdentSpeedWriteLog;
 miFileCounter : UDINT;
 mbDeleteFiles : BOOL;
 mbLogFileSaved : BOOL := TRUE;
 msFileName : STRING(255);
 mbRestartMeas : BOOL;
 abSpeedMeasure : ABAutoIdentSpeedMeasure;
 mrRefVelocity : REAL;
 mrRefPressure : REAL;
 mrMaxLimitPosition : REAL;
 mrMinLimitPosition : REAL;
 dummy : DINT;
 mrMinPositionFactor : REAL := 0.2 (* 20% of stroke *);
 mrMaxPositionFactor : REAL := 0.8 (* 80% of stroke *);
 mrMaxVelocity : REAL;
 mrMaxPressure : REAL;
 mbVelocityLimitReached : BOOL;
 mbPressureLimitReached : BOOL;
 miErrorNo : INT;
 cIdentSpeedMaxSequence : INT := 100;
 cIdentSpeedMinSequence : INT := 200;
 cIdentSpeedMaxFwdIdent : INT := 101;
 cIdentSpeedMinFwdIdent : INT := 201;
 cIdentSpeedMaxBwdIdent : INT := 102;
 cIdentSpeedMinBwdIdent : INT := 202;
 cIdentSpeedMaxBwdInit : INT := 103;
 cIdentSpeedMinBwdInit : INT := 203;
 cIdentSpeedMaxFwdInit : INT := 104;
 cIdentSpeedMinFwdInit : INT := 204;
 cIdentSpeedMaxFwdStart : INT := 105;
 cIdentSpeedMinFwdStart : INT := 205;
 cIdentSpeedMaxBwdStart : INT := 106;
 cIdentSpeedMinBwdStart : INT := 206;
 cIdentSpeedMaxEnd : INT := 107;
 cIdentSpeedMinEnd : INT := 207;
 mrBwdStopPosition : REAL := 0.05;
 mprActPressure : REFTO REAL;
 mbprActPressureLinked : BOOL;
END_VAR

PROCESS_ALGORITHM paInit ON TaskMid AUTOSTART


VAR_TEMP
 j : DINT;
 k : DINT;
END_VAR

VAR
 i : DINT;
 Status : KSYS_Status;
 rpPosition : REFTO REAL;
 tmpM : tpIdentSpeedMovement;
 pOption : REFTO tOptionId;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

i := 1;

rpPosition := GET_SYNC_REFTO('Ejector1.ai_Position', T#0s, Status);
IF Status = KSYS_Status_OK THEN
    sv_GlobalIdentMaxSpeedStatus.pMovements[i] := @sv_EjectorIdentMaxMovement;
    sv_GlobalIdentMinSpeedStatus.pMovements[i] := @sv_EjectorIdentMinMovement;
    i := i + 1; 
END_IF;

sv_GlobalIdentMaxSpeedStatus.pMovements[i] := @sv_MoldIdentMaxMovement;
sv_GlobalIdentMinSpeedStatus.pMovements[i] := @sv_MoldIdentMinMovement;
i := i + 1; 

pOption := GET_SYNC_REFTO('Nozzle1.sv_Options', T#0s, Status);
IF (Status = KSYS_Status_OK) AND ((pOption^ AND cOptionHydraulic) = cOptionHydraulic) THEN;
    //hydraulic nozzle -> check if ai_Position is available
    rpPosition := GET_SYNC_REFTO('Nozzle1.ai_Position', T#0s, Status);
    IF Status = KSYS_Status_OK THEN
        sv_GlobalIdentMaxSpeedStatus.pMovements[i] := @sv_NozzleIdentMaxMovement;
        sv_GlobalIdentMinSpeedStatus.pMovements[i] := @sv_NozzleIdentMinMovement;
        i := i + 1; 
    END_IF;
END_IF;

sv_GlobalIdentMaxSpeedStatus.pMovements[i] := @sv_InjectionIdentMaxMovement;
sv_GlobalIdentMinSpeedStatus.pMovements[i] := @sv_InjectionIdentMinMovement;
i := i + 1; 

(* sort them by iOrder *)
FOR k := 1 TO i - 2 DO
    FOR j := 1 TO i - 1 - k DO
        IF sv_GlobalIdentMaxSpeedStatus.pMovements[j]^.iOrder > sv_GlobalIdentMaxSpeedStatus.pMovements[j + 1]^.iOrder THEN
            tmpM := sv_GlobalIdentMaxSpeedStatus.pMovements[j];
            sv_GlobalIdentMaxSpeedStatus.pMovements[j] := sv_GlobalIdentMaxSpeedStatus.pMovements[j + 1];
            sv_GlobalIdentMaxSpeedStatus.pMovements[j + 1] := tmpM;
            tmpM := sv_GlobalIdentMinSpeedStatus.pMovements[j];
            sv_GlobalIdentMinSpeedStatus.pMovements[j] := sv_GlobalIdentMinSpeedStatus.pMovements[j + 1];
            sv_GlobalIdentMinSpeedStatus.pMovements[j + 1] := tmpM;
        END_IF;    
    END_FOR;    
END_FOR;

sv_GlobalIdentMaxSpeedStatus.iMaxStep := i - 1;
sv_GlobalIdentMinSpeedStatus.iMaxStep := i - 1;

sv_GlobalIdentMaxSpeedStatus.iCurrentStep := 0;
sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_None;
sv_GlobalIdentMaxSpeedStatus.bInitDone := TRUE;

sv_GlobalIdentMinSpeedStatus.iCurrentStep := 0;
sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_None;
sv_GlobalIdentMinSpeedStatus.bInitDone := TRUE;

STOP_PROCESS_ALGORITHM();




;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pAlarmPending ON PU_Task_7 WITH sv_iPendingAlarms


VAR
 fbTracePendingAlarms : FBTracePendingAlarms;
END_VAR
#BEGIN_EDIT_BLOCK
IF ((sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Running) OR (sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Running)) AND 
    (sv_iPendingAlarms <> 0) THEN
   
   dummy := Print('auto max. speed identification stopped because alarms of class 1/2/3 pending');
   
   //trace all pending alarms
   fbTracePendingAlarms();
   
   IF (sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Running) THEN
      sv_GlobalIdentMaxSpeedStatus.Command := tnCalibCommand_Stop;
      sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Aborted;
   ELSE
      sv_GlobalIdentMinSpeedStatus.Command := tnCalibCommand_Stop;
      sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Aborted;
   END_IF;

   SET_ALARM(Name := erCalibrationSpeedStopped,
             Param1 := miErrorNo);
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aMeasure


VAR
 rActPressure : REAL;
END_VAR
#BEGIN_EDIT_BLOCK
IF mbprActPressureLinked THEN
   rActPressure := mprActPressure^;
ELSE
   rActPressure := 0.0;
END_IF;
abSpeedMeasure.aMeasure(bRestart := mbRestartMeas,
                        rPosition := mActMovement^.prPosition^,
                        rRefVelocity := mrRefVelocity,
                        rActVelocity := mActMovement^.prActVelocity^,
                        rRefPressure := mrRefPressure,
                        rActPressure := rActPressure,
                        rMaxLimitPosition := mrMaxLimitPosition,
                        rMinLimitPosition := mrMinLimitPosition);
mbRestartMeas := FALSE;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paMeasureFast ON TaskInject

#BEGIN_EDIT_BLOCK
aMeasure();


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paMeasureMid ON TaskAnalog

#BEGIN_EDIT_BLOCK
aMeasure();


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aStartMeasurement

#BEGIN_EDIT_BLOCK
mbRestartMeas := TRUE;
abSpeedMeasure.aReset();
abSpeedMeasure.aMeasure(bRestart := TRUE);
START_PROCESS_ALGORITHM(paMeasureMid);


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aStopMeasurement

#BEGIN_EDIT_BLOCK
STOP_PROCESS_ALGORITHM(paMeasureMid);
abSpeedMeasure.aCloseMeasure();



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aWriteLog


VAR_INPUT
 sFileName : STRING(255) (* file name movement *);
 iFileCounter : UDINT (* actual ident cycle index *);
 bDeleteFiles : BOOL (* delete old files *);
END_VAR
#BEGIN_EDIT_BLOCK
mbLogFileSaved := FALSE;
msFileName := sFileName;
miFileCounter := iFileCounter;
mbDeleteFiles := bDeleteFiles;

START_PROCESS_ALGORITHM(paWriteLog);


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paWriteLog ON TaskSlow

#BEGIN_EDIT_BLOCK
fbIdentWriteLog(sFileName    := msFileName,
                iFileCounter := miFileCounter,
                bDeleteFiles := mbDeleteFiles,
                rMaxVelocity := mrMaxVelocity,
                rMaxPressure := mrMaxPressure,
                bVelocityLimitReached := mbVelocityLimitReached,
                bPressureLimitReached := mbPressureLimitReached);
IF fbIdentWriteLog.bDone THEN
   mbLogFileSaved := TRUE;
ELSE   
   mbLogFileSaved := FALSE;
END_IF;
STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aStartMovementFwd

#BEGIN_EDIT_BLOCK
IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMaxPositionFactor;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMinPositionFactor;
END_IF;
mActMovement^.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveFwd;
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := mActMovement^.MoveId;   
ELSE
   evStartRequestData.MoveId := cMoveFwd;
END_IF;

SET_EVENT(evStartRequest, evStartRequestData); 



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aStartMovementBwd

#BEGIN_EDIT_BLOCK
IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMinPositionFactor;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMaxPositionFactor;
END_IF;
mActMovement^.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveBwd; 
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := cMoveDecompAftPlast;
ELSE
   evStartRequestData.MoveId := cMoveBwd;
END_IF;

SET_EVENT(evStartRequest, evStartRequestData); 



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aStopMovementFwd

#BEGIN_EDIT_BLOCK
evStopRequestData.DeviceId := mActMovement^.DeviceId;
evStopRequestData.MoveDir := cMoveFwd; 
evStopRequestData.MoveId := cMoveFwd;
SET_EVENT(evStopRequest, evStopRequestData);
mActMovement^.pbMoveIdent^ := FALSE;
mActMovement^.prIdentPosition^ := 0.0;
mActMovement^.prStopRamp^ := 0.0;





;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aStopMovementBwd

#BEGIN_EDIT_BLOCK
evStopRequestData.DeviceId := mActMovement^.DeviceId;
evStopRequestData.MoveDir := cMoveBwd; 
IF mActMovement^.MoveId > cMoveNone THEN
   evStopRequestData.MoveId := cMoveDecompAftPlast;
ELSE
   evStopRequestData.MoveId := cMoveBwd;
END_IF;
SET_EVENT(evStopRequest, evStopRequestData);
mActMovement^.pbMoveIdent^ := FALSE;
mActMovement^.prIdentPosition^ := 0.0;
mActMovement^.prStopRamp^ := 0.0;




;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aStopMovementError


VAR_INPUT
 sMovementName : STRING(255) (* Movement information *);
END_VAR
#BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Aborted;
mActMovement^.Status := tnCalibState_Error;

dummy := Print('Calib movement "%s" aborted.', sMovementName);




;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aCalcMaxSpeedOutput


VAR_INPUT
 rMaxSpeedLimit : REAL (* Maximum speed limit of actual device *);
 rActSpeedLimit : REAL (* Actual speed limit of actual device *);
 rActMaxSpeed : REAL (* Maximum measured speed *);
 bPresLimitReached : BOOL (* Pressure limit reached during movement *);
 bUsePressureMode : BOOL (* Use pressure to check maimum speed limit reached. Otherwise use actual  velocity *);
END_VAR

VAR_OUTPUT
 bMaxDetected : BOOL (* Speed limit detected *);
 rRefSpeed : REAL (* Speed limit for next try *);
 rMaxSpeed : REAL (* Identified max speed *);
END_VAR

VAR
 rSpeedReachedFactor : REAL := 0.95;
 rMaxActSpeed : REAL;
 rMinActSpeed : REAL := 0.0;
 rMinSpeedDifference : REAL := 0.05;
END_VAR
#BEGIN_EDIT_BLOCK
IF (bUsePressureMode) THEN
   IF (rMaxActSpeed = 0.0) THEN
      rMaxActSpeed := rMaxSpeedLimit;
   END_IF;
   IF (bPresLimitReached) THEN
      // reduce refernce value
      rMaxActSpeed := rActSpeedLimit;
      IF (ABS(rMaxActSpeed - rMinActSpeed) < rMinSpeedDifference * rMaxSpeedLimit) THEN
         bMaxDetected := TRUE;
         rMaxSpeed := rMinActSpeed;
         rMinActSpeed := 0.0;
         rMaxActSpeed := 0.0;
      ELSE   
         bMaxDetected := FALSE;
         rRefSpeed := 0.5 * (rMaxActSpeed + rMinActSpeed);
      END_IF;   
   ELSE
      // ccompare with old value
      IF (rActSpeedLimit = rMaxSpeedLimit) THEN // maximum used at start
         // maximum with tolerance reached   
         bMaxDetected := TRUE;
         rMaxSpeed := rMaxSpeedLimit;
         rMinActSpeed := 0.0;
         rMaxActSpeed := 0.0;
      ELSE
         // increase
         rMinActSpeed := rActSpeedLimit;
         IF (ABS(rMaxActSpeed - rMinActSpeed) < rMinSpeedDifference * rMaxSpeedLimit) THEN
            bMaxDetected := TRUE;
            rMaxSpeed := rMinActSpeed;
            rMinActSpeed := 0.0;
            rMaxActSpeed := 0.0;
         ELSE
            rRefSpeed := 0.5 * (rMaxActSpeed + rMinActSpeed);
         END_IF;
      END_IF;
   END_IF;   
ELSE
   IF (rActSpeedLimit = rMaxSpeedLimit) THEN // maximum used at start
      IF (rActMaxSpeed > rSpeedReachedFactor * rActSpeedLimit)  THEN
      // maximum with tolerance reached   
         bMaxDetected := TRUE;
         rMaxSpeed := rMaxSpeedLimit;
      ELSE
      // actual speed lower than maximum with tolerance
         bMaxDetected := FALSE;
         rRefSpeed := rActMaxSpeed;
         rMaxActSpeed := rActMaxSpeed;
      END_IF;
   ELSE
      IF (rActMaxSpeed > rSpeedReachedFactor * rActSpeedLimit) THEN
      // reference speed with tolerance reached
         bMaxDetected := TRUE;
         rMaxSpeed := rRefSpeed;
      ELSE
      // actual speed lower than reference speed with tolerance reached
      // check calibration of pump/valve   
         bMaxDetected := TRUE;
         rMaxSpeed := rRefSpeed;
      END_IF;
   END_IF;   
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

EVENT_ALGORITHM evaRedoMaxEvent ON EV_Task_7 WITH evRedoIdentMaxSpeedStart


VAR_INPUT
 evRedoIdentEventData : tevRedoIdentSpeedEventData (* Event data to start max speed identification *);
END_VAR
#BEGIN_EDIT_BLOCK

START_PROCESS_ALGORITHM(paRedoMax);



;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paRedoMax ON TaskMid


VAR_TEMP
 i : DINT;
 bIdentActive : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
bIdentActive := FALSE;
FOR i:= 1 TO cCalibMovements DO
   IF CHECK_REF(sv_GlobalIdentMaxSpeedStatus.pMovements[i]^) THEN
      IF sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.bRedo THEN
         mActMovement := sv_GlobalIdentMaxSpeedStatus.pMovements[i];
         bIdentActive := TRUE;
         sv_GlobalIdentMaxSpeedStatus.iCurrentStep :=  i;
         mCalibCounter := i;
         IF sv_OperationMode = nSetup THEN
            mbUseSingleMovement := TRUE;
            START_PROCESS_ALGORITHM(paMaxSingleMovement);
         ELSE
            sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.bRedo := FALSE;
            SET_ALARM(erSetupModeRequiredForCalib);
         END_IF;
         EXIT;
      END_IF;
   END_IF;
END_FOR;
IF ((NOT bIdentActive) AND (sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Running)) THEN
   sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Aborted;
END_IF;
       

STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paMaxSingleMovement ON TaskMid


VAR
 bMoveBwdDone : BOOL := FALSE;
 bMoveFwdDone : BOOL := FALSE;
 bMoveIdentDone : BOOL := FALSE;
 sFileName : STRING(255);
 iFileCounter : UDINT := 1;
 ConstVis : tsVelPre (* const output for ejector forward movement *);
 ConstVisFwd : tsVelPre (* const output for ejector forward movement *);
 ConstVisBwd : tsVelPre (* const output for ejector forward movement *);
 bMaxFwdRetry : BOOL;
 bMaxBwdRetry : BOOL;
 bMaxFwdDetected : BOOL;
 bMaxBwdDetected : BOOL;
 sMoveName : STRING(32);
 rMaxPressureLimit : REAL;
 rRefSpeedLimit : REAL;
 rSpeedLimitFwd : REAL;
 rSpeedLimitBwd : REAL;
 rMaxRefPressureLimit : REAL;
 sWriteSpeedLimit : STRING(255);
 rVelocitSizeFactor : REAL := 1.0;
 rStartFactor : REAL := 0.1;
 rMinStopRamp : REAL := 1.0;
 rMinStrokeFactor : REAL := 0.5;
 bDelayTimeOffFwdLinked : BOOL;
 bDelayTimeOffBwdLinked : BOOL;
 dDelayTimeOffFwd : TIME;
 dDelayTimeOffBwd : TIME;
 dMinDelayTimeOff : TIME := T#25ms;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP S_INIT:
Action3 (P);
END_STEP

ACTION Action3: #BEGIN_EDIT_BLOCK
miErrorNo := 0;

ConstVisFwd := mActMovement^.pConstFwdVis^;
ConstVisBwd := mActMovement^.pConstBwdVis^;

sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Running;
mActMovement^.Status := tnCalibState_Running;
sMoveName := mActMovement^.sName;

abSpeedMeasure.aInit();

bMaxFwdRetry := FALSE;
bMaxBwdRetry := FALSE;

IF (mActMovement^.rMaxPositionLimitFactor > mActMovement^.rMinPositionLimitFactor) AND
   (mActMovement^.rMinPositionLimitFactor > 0.0) AND (mActMovement^.rMaxPositionLimitFactor < 1.0) THEN
   mrMaxPositionFactor := mActMovement^.rMaxPositionLimitFactor;
   mrMinPositionFactor := mActMovement^.rMinPositionLimitFactor;
ELSE // use deafult values
   mrMaxPositionFactor := 0.8;
   mrMinPositionFactor := 0.2;
END_IF;

mprActPressure := sv_PumpData[mActMovement^.DeviceId.IndexId].prActSysPressure;
IF CHECK_REF(mprActPressure^) THEN
   mbprActPressureLinked := TRUE;
ELSE
   mbprActPressureLinked := FALSE;
END_IF;

IF CHECK_REF(mActMovement^.pdDelayTimeOffFwd^) THEN
   bDelayTimeOffFwdLinked := TRUE;
   dDelayTimeOffFwd := mActMovement^.pdDelayTimeOffFwd^;
ELSE
   bDelayTimeOffFwdLinked := FALSE;
END_IF;
IF CHECK_REF(mActMovement^.pdDelayTimeOffBwd^) THEN
   bDelayTimeOffBwdLinked := TRUE;
   dDelayTimeOffBwd := mActMovement^.pdDelayTimeOffBwd^;
ELSE
   bDelayTimeOffBwdLinked := FALSE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*Action3*)

(* steps *)
STEP S_RESET:
END_STEP

STEP S_STOP:
AStopSelf (P);
END_STEP

ACTION AStopSelf: #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Command := tnCalibCommand_None;
sv_bAutoIdentRunning := FALSE;
mActMovement^.bRedo := FALSE;
mActMovement^.prStopRamp^ := 0.0;
mActMovement^.pConstFwdVis^ := ConstVisFwd;
mActMovement^.pConstBwdVis^ := ConstVisBwd;

//release memory
abSpeedMeasure.aEnd();

STOP_PROCESS_ALGORITHM();

;#END_EDIT_BLOCK END_ACTION (*AStopSelf*)
STEP S_MoveStartBwd:
AMoveStartBwd (P);
ACheckMoveStartBwdReady (N);
AMoveStartBwdReady (P0);
END_STEP

ACTION AMoveStartBwd: #BEGIN_EDIT_BLOCK
bMoveBwdDone := FALSE;
miErrorNo := cIdentSpeedMaxBwdInit;
aStartMovementBwd();

;#END_EDIT_BLOCK END_ACTION (*AMoveStartBwd*)
ACTION ACheckMoveStartBwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveBwdDone := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckMoveStartBwdReady*)
ACTION AMoveStartBwdReady: #BEGIN_EDIT_BLOCK
aStopMovementBwd();

;#END_EDIT_BLOCK END_ACTION (*AMoveStartBwdReady*)
STEP S_StopMoveStartBwd:
AStopMoveStartBwd (P);
END_STEP

ACTION AStopMoveStartBwd: #BEGIN_EDIT_BLOCK
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Fwd: Bwd to initial position'));

;#END_EDIT_BLOCK END_ACTION (*AStopMoveStartBwd*)
STEP S_CHECK_ALARMS_INITBWD:
END_STEP

STEP S_INITCALIB_FWD:
aInitIdentFwd (P);
END_STEP

ACTION aInitIdentFwd: #BEGIN_EDIT_BLOCK
iFileCounter := 1;
IF (CHECK_REF(mActMovement^.prSizeFactorFwd^)) THEN
   IF (mActMovement^.prSizeFactorFwd^ > 0.0) THEN
      rVelocitSizeFactor := mActMovement^.prSizeFactorFwd^;        
   END_IF;
ELSE
   rVelocitSizeFactor := 1.0;
END_IF;
rRefSpeedLimit := mActMovement^.prVelocityLimitFwd^;
rMaxPressureLimit := mActMovement^.prMaxPressureFwd^;
IF CHECK_REF(mActMovement^.prMaxPressureFwdHydr^) THEN
   rMaxRefPressureLimit := mActMovement^.prMaxPressureFwdHydr^;
ELSE   
   rMaxRefPressureLimit := rMaxPressureLimit;
END_IF; 

dummy := Print('Calib max speed %s Fwd started', sMoveName);

;#END_EDIT_BLOCK END_ACTION (*aInitIdentFwd*)
STEP S_CALIB_FWD:
ADoCalib (P);
AStartMovementFwd (P);
ACheckActMovementFwdReady (N);
AStopMovementFwd (P0);
END_STEP

ACTION ADoCalib: #BEGIN_EDIT_BLOCK
(* start calibration *)
// save actual settings
ConstVis := mActMovement^.pConstFwdVis^;

mActMovement^.pConstFwdVis^.Velocity.Output.rOutputValue := rRefSpeedLimit * rVelocitSizeFactor;
mActMovement^.pConstFwdVis^.Velocity.rMinOutput := 0.0;
mActMovement^.pConstFwdVis^.Pressure.Output.rOutputValue := MAX(mActMovement^.pConstFwdVis^.Pressure.Output.rOutputValue, rMaxPressureLimit);
mActMovement^.pConstFwdVis^.Pressure.Output.rRamp := MAX(1.0e9,ConstVis.Pressure.Output.rRamp);
IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMaxPositionFactor;
   mrMinLimitPosition := rStartFactor * mActMovement^.prIdentPosition^ + (1.0 - rStartFactor) * mActMovement^.prPosition^;
   IF (mActMovement^.prIdentPosition^ - mActMovement^.prPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit  * rRefSpeedLimit/ ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstFwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMaxLimitPosition := mActMovement^.prIdentPosition^;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMinPositionFactor;
   mrMaxLimitPosition := (1.0 - rStartFactor) * mActMovement^.prPosition^ + rStartFactor * mActMovement^.prIdentPosition^;
   IF (mActMovement^.prPosition^ - mActMovement^.prIdentPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstFwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMinLimitPosition := mActMovement^.prIdentPosition^;
END_IF;
mActMovement^.pbMoveIdent^ := TRUE;
bMoveIdentDone := FALSE;

bMaxFwdDetected := FALSE;

mrRefVelocity := rRefSpeedLimit;
mrRefPressure := rMaxRefPressureLimit;
mbRestartMeas := TRUE;

IF bDelayTimeOffFwdLinked THEN
   mActMovement^.pdDelayTimeOffFwd^ := MAX(mActMovement^.pdDelayTimeOffFwd^, dMinDelayTimeOff);
END_IF;
IF bDelayTimeOffBwdLinked THEN
   mActMovement^.pdDelayTimeOffBwd^ := MAX(mActMovement^.pdDelayTimeOffBwd^, dMinDelayTimeOff);
END_IF;

aStartMeasurement();

sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
dummy := Print('Calib max output: act. max speed: %s', sWriteSpeedLimit);
miErrorNo := cIdentSpeedMaxFwdIdent;


;#END_EDIT_BLOCK END_ACTION (*ADoCalib*)
ACTION AStartMovementFwd: #BEGIN_EDIT_BLOCK
evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveFwd;
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := mActMovement^.MoveId;   
ELSE
   evStartRequestData.MoveId := cMoveFwd;
END_IF;
SET_EVENT(evStartRequest, evStartRequestData); 

;#END_EDIT_BLOCK END_ACTION (*AStartMovementFwd*)
ACTION ACheckActMovementFwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveIdentDone := TRUE;      
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckActMovementFwdReady*)
ACTION AStopMovementFwd: #BEGIN_EDIT_BLOCK
aStopMeasurement();
aStopMovementFwd();

mActMovement^.pConstFwdVis^ := ConstVis;
mActMovement^.prStopRamp^ := 0.0;

IF bDelayTimeOffFwdLinked THEN
   mActMovement^.pdDelayTimeOffFwd^ := dDelayTimeOffFwd;
END_IF;
IF bDelayTimeOffBwdLinked THEN
   mActMovement^.pdDelayTimeOffBwd^ := dDelayTimeOffBwd;
END_IF;



;#END_EDIT_BLOCK END_ACTION (*AStopMovementFwd*)
STEP S_StopIdentFwd:
AStopIdentFwd (P);
END_STEP

ACTION AStopIdentFwd: #BEGIN_EDIT_BLOCK
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Fwd'));

;#END_EDIT_BLOCK END_ACTION (*AStopIdentFwd*)
STEP S_CHECK_ALARMS_FWD:
END_STEP

STEP S_WRITE_FWD:
AWriteFwd (P);
END_STEP

ACTION AWriteFwd: #BEGIN_EDIT_BLOCK
abSpeedMeasure.aGetMaxValues(rMaxSpeed => mrMaxVelocity,
                             rMaxPressure => mrMaxPressure,
                             bPressureLimitReached => mbPressureLimitReached,
                             bSpeedLimitReached => mbVelocityLimitReached);
sFileName := CONCAT(sMoveName,"_MAXSPEED_FWD_");
aWriteLog(sFileName := sFileName,
          iFileCounter := iFileCounter,
          bDeleteFiles := TRUE);
iFileCounter := iFileCounter + 1;


;#END_EDIT_BLOCK END_ACTION (*AWriteFwd*)
STEP S_AbortedWriteFwd:
AAbortedWriteFwd (P);
END_STEP

ACTION AAbortedWriteFwd: #BEGIN_EDIT_BLOCK
mActMovement^.Status := tnCalibState_Error;


;#END_EDIT_BLOCK END_ACTION (*AAbortedWriteFwd*)
STEP S_CHECK_MAXSPEED_FWD:
ACheckMaxSpeedFwd (P);
END_STEP

ACTION ACheckMaxSpeedFwd: #BEGIN_EDIT_BLOCK
aCalcMaxSpeedOutput(rMaxSpeedLimit := mActMovement^.prVelocityLimitFwd^,
                    rActSpeedLimit := rRefSpeedLimit,
                    rActMaxSpeed := abSpeedMeasure.aGetMaxValues.rMaxSpeed,
                    bPresLimitReached := abSpeedMeasure.aGetMaxValues.bPressureLimitReached,
                    bUsePressureMode := (mrMaxPressure > 0.0));
bMaxFwdDetected := aCalcMaxSpeedOutput.bMaxDetected;
IF (bMaxFwdDetected) THEN
   rSpeedLimitFwd := rRefSpeedLimit;
   dummy := Print('Calib max output %s Fwd finished: max speed fwd = %f$N', sMoveName, rSpeedLimitFwd);         
ELSE   
   IF abSpeedMeasure.aGetMaxValues.bPressureLimitReached THEN
      sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
      dummy := Print('Calib max output: pressure limit reached with act. max speed %s', sWriteSpeedLimit);
   END_IF;
   bMaxFwdRetry := TRUE;
   rRefSpeedLimit := aCalcMaxSpeedOutput.rRefSpeed;   
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckMaxSpeedFwd*)
STEP S_MaxFwdRetry:
AStartMovementFwdBwd (P);
ACheckActMovementFwdBwdReady (N);
AStopMovementFwdBwd (P0);
END_STEP

ACTION AStartMovementFwdBwd: #BEGIN_EDIT_BLOCK
bMoveBwdDone := FALSE;
miErrorNo := cIdentSpeedMaxFwdStart;
aStartMovementBwd();

;#END_EDIT_BLOCK END_ACTION (*AStartMovementFwdBwd*)
ACTION ACheckActMovementFwdBwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveBwdDone := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckActMovementFwdBwdReady*)
ACTION AStopMovementFwdBwd: #BEGIN_EDIT_BLOCK
aStopMovementBwd();

;#END_EDIT_BLOCK END_ACTION (*AStopMovementFwdBwd*)
STEP S_StopMoveBwd:
AStopMoveBwd (P);
END_STEP

ACTION AStopMoveBwd: #BEGIN_EDIT_BLOCK
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Fwd: Bwd to start position'));

;#END_EDIT_BLOCK END_ACTION (*AStopMoveBwd*)
STEP S_CHECK_ALARMS_RETRYFWD:
END_STEP

STEP S_InitStartMovementBwdFwd:
AInitStartMovementBwdFwd (P);
ACheckInitMovementBwdFwdReady (N);
AStopInitMovementBwdFwd (P0);
END_STEP

ACTION AInitStartMovementBwdFwd: #BEGIN_EDIT_BLOCK
bMoveFwdDone := FALSE;
miErrorNo := cIdentSpeedMaxFwdInit;
aStartMovementFwd();

;#END_EDIT_BLOCK END_ACTION (*AInitStartMovementBwdFwd*)
ACTION ACheckInitMovementBwdFwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveFwdDone := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckInitMovementBwdFwdReady*)
ACTION AStopInitMovementBwdFwd: #BEGIN_EDIT_BLOCK
aStopMovementFwd();

;#END_EDIT_BLOCK END_ACTION (*AStopInitMovementBwdFwd*)
STEP S_StopInitMoveFwd:
AStopInitMoveFwd (P);
END_STEP

ACTION AStopInitMoveFwd: #BEGIN_EDIT_BLOCK
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Bwd: Fwd to initial position'));

;#END_EDIT_BLOCK END_ACTION (*AStopInitMoveFwd*)
STEP S_CHECK_ALARMS_STARTBWD:
END_STEP

STEP S_INITCALIB_BWD:
AInitCalibBwd (P);
END_STEP

ACTION AInitCalibBwd: #BEGIN_EDIT_BLOCK
iFileCounter := 1;
IF (CHECK_REF(mActMovement^.prSizeFactorBwd^)) THEN
   IF (mActMovement^.prSizeFactorBwd^ > 0.0) THEN
      rVelocitSizeFactor := mActMovement^.prSizeFactorBwd^;        
   END_IF;
ELSE
   rVelocitSizeFactor := 1.0;
END_IF;
rRefSpeedLimit := mActMovement^.prVelocityLimitBwd^;
rMaxPressureLimit := mActMovement^.prMaxPressureBwd^;
IF CHECK_REF(mActMovement^.prMaxPressureBwdHydr^) THEN
   rMaxRefPressureLimit := mActMovement^.prMaxPressureBwdHydr^;
ELSE   
   rMaxRefPressureLimit := mActMovement^.prMaxPressureFwd^;
END_IF; 

dummy := Print('Calib max speed %s Bwd started', sMoveName);


;#END_EDIT_BLOCK END_ACTION (*AInitCalibBwd*)
STEP S_CALIB_BWD:
ADoCalibBwd (P);
AStartMovementBwd (P);
ACheckActMovementBwdReady (N);
AStopMovementBwd (P0);
END_STEP

ACTION ADoCalibBwd: #BEGIN_EDIT_BLOCK
ConstVis := mActMovement^.pConstBwdVis^;

mActMovement^.pConstBwdVis^.Velocity.Output.rOutputValue := rRefSpeedLimit * rVelocitSizeFactor;
mActMovement^.pConstBwdVis^.Velocity.rMinOutput := 0.0;
mActMovement^.pConstBwdVis^.Pressure.Output.rOutputValue := MAX(mActMovement^.pConstBwdVis^.Pressure.Output.rOutputValue, rMaxPressureLimit);
mActMovement^.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e9,ConstVis.Pressure.Output.rRamp);
IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMinPositionFactor;
   mrMaxLimitPosition := rStartFactor * mActMovement^.prIdentPosition^ + (1.0 - rStartFactor) * mActMovement^.prPosition^;
   rMinStopRamp := rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   IF (mActMovement^.prPosition^ - mActMovement^.prIdentPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstBwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMinLimitPosition := mActMovement^.prIdentPosition^;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMaxPositionFactor;
   mrMinLimitPosition := rStartFactor * mActMovement^.prPosition^ + (1.0 - rStartFactor) * mActMovement^.prIdentPosition^;
   IF (mActMovement^.prIdentPosition^ - mActMovement^.prPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstBwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMaxLimitPosition := mActMovement^.prIdentPosition^;
END_IF;
mActMovement^.pbMoveIdent^ := TRUE;

bMoveIdentDone := FALSE;

mrRefVelocity := rRefSpeedLimit;
mrRefPressure := rMaxRefPressureLimit;
mbRestartMeas := TRUE;

IF bDelayTimeOffFwdLinked THEN
   mActMovement^.pdDelayTimeOffFwd^ := MAX(mActMovement^.pdDelayTimeOffFwd^, dMinDelayTimeOff);
END_IF;
IF bDelayTimeOffBwdLinked THEN
   mActMovement^.pdDelayTimeOffBwd^ := MAX(mActMovement^.pdDelayTimeOffBwd^, dMinDelayTimeOff);
END_IF;

aStartMeasurement();

sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
dummy := Print('Calib max output: act. max speed: %s', sWriteSpeedLimit);
miErrorNo := cIdentSpeedMaxBwdIdent;


;#END_EDIT_BLOCK END_ACTION (*ADoCalibBwd*)
ACTION AStartMovementBwd: #BEGIN_EDIT_BLOCK
evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveBwd;
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := cMoveDecompAftPlast;
ELSE
   evStartRequestData.MoveId := cMoveBwd;
END_IF;
SET_EVENT(evStartRequest, evStartRequestData); 

;#END_EDIT_BLOCK END_ACTION (*AStartMovementBwd*)
ACTION ACheckActMovementBwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveIdentDone := TRUE;      
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckActMovementBwdReady*)
ACTION AStopMovementBwd: #BEGIN_EDIT_BLOCK
aStopMeasurement();
aStopMovementBwd();

mActMovement^.pConstBwdVis^ := ConstVis;
mActMovement^.prStopRamp^ := 0.0;

IF bDelayTimeOffFwdLinked THEN
   mActMovement^.pdDelayTimeOffFwd^ := dDelayTimeOffFwd;
END_IF;
IF bDelayTimeOffBwdLinked THEN
   mActMovement^.pdDelayTimeOffBwd^ := dDelayTimeOffBwd;
END_IF;



;#END_EDIT_BLOCK END_ACTION (*AStopMovementBwd*)
STEP S_StopCalibBwd:
AStopCalibBwd (P);
END_STEP

ACTION AStopCalibBwd: #BEGIN_EDIT_BLOCK
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Bwd'));

;#END_EDIT_BLOCK END_ACTION (*AStopCalibBwd*)
STEP S_CHECK_ALARMS_BWD:
END_STEP

STEP S_WRITE_BWD:
AWriteBwd (P);
END_STEP

ACTION AWriteBwd: #BEGIN_EDIT_BLOCK
abSpeedMeasure.aGetMaxValues(rMaxSpeed => mrMaxVelocity,
                             rMaxPressure => mrMaxPressure,
                             bPressureLimitReached => mbPressureLimitReached,
                             bSpeedLimitReached => mbVelocityLimitReached);
sFileName := CONCAT(sMoveName,"_MAXSPEED_BWD_");
aWriteLog(sFileName := sFileName,
          iFileCounter := iFileCounter,
          bDeleteFiles := TRUE);
iFileCounter := iFileCounter + 1;


;#END_EDIT_BLOCK END_ACTION (*AWriteBwd*)
STEP S_CHECK_MAXSPEED_BWD:
ACheckMaxSpeedBwd (P);
END_STEP

ACTION ACheckMaxSpeedBwd: #BEGIN_EDIT_BLOCK
aCalcMaxSpeedOutput(rMaxSpeedLimit := mActMovement^.prVelocityLimitBwd^,
                    rActSpeedLimit := rRefSpeedLimit,
                    rActMaxSpeed := abSpeedMeasure.aGetMaxValues.rMaxSpeed,
                    bPresLimitReached := abSpeedMeasure.aGetMaxValues.bPressureLimitReached,
                    bUsePressureMode := (mrMaxPressure > 0.0));
bMaxBwdDetected := aCalcMaxSpeedOutput.bMaxDetected;
IF (bMaxBwdDetected) THEN
   rSpeedLimitBwd := rRefSpeedLimit;
   dummy := Print('Calib max output %s Bwd finished: max speed bwd = %f$N', sMoveName, rSpeedLimitBwd);           
ELSE   
   IF abSpeedMeasure.aGetMaxValues.bPressureLimitReached THEN
      sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
      dummy := Print('Calib max output: pressure limit reached with act. max speed %s', sWriteSpeedLimit);
   END_IF;
   bMaxBwdRetry := TRUE;
   rRefSpeedLimit := aCalcMaxSpeedOutput.rRefSpeed;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckMaxSpeedBwd*)
STEP S_MaxBwdRetry:
AStartMovementBwdFwd (P);
ACheckActMovementBwdFwdReady (N);
AStopMovementBwdFwd (P0);
END_STEP

ACTION AStartMovementBwdFwd: #BEGIN_EDIT_BLOCK
bMoveFwdDone := FALSE;
miErrorNo := cIdentSpeedMaxBwdStart;
aStartMovementFwd();

;#END_EDIT_BLOCK END_ACTION (*AStartMovementBwdFwd*)
ACTION ACheckActMovementBwdFwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveFwdDone := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckActMovementBwdFwdReady*)
ACTION AStopMovementBwdFwd: #BEGIN_EDIT_BLOCK
aStopMovementFwd();

;#END_EDIT_BLOCK END_ACTION (*AStopMovementBwdFwd*)
STEP S_StopMoveFwd:
AStopMoveFwd (P);
END_STEP

ACTION AStopMoveFwd: #BEGIN_EDIT_BLOCK
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Bwd: Fwd to start position'));

;#END_EDIT_BLOCK END_ACTION (*AStopMoveFwd*)
STEP S_CHECK_ALARMS_RETRYBWD:
END_STEP

STEP S_MoveEndBwd:
AMoveEndBwd (P);
ACheckMoveEndBwdReady (N);
AMoveEndBwdReady (P0);
END_STEP

ACTION AMoveEndBwd: #BEGIN_EDIT_BLOCK
bMoveBwdDone := FALSE;

IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mrBwdStopPosition;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ - mrBwdStopPosition;
END_IF;
mActMovement^.prStopRamp^ := 1.0e10;
mActMovement^.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e20,mActMovement^.pConstBwdVis^.Pressure.Output.rRamp);
mActMovement^.pConstBwdVis^.Pressure.rMinOutput := 0.1 * rMaxPressureLimit;
sv_EjectorIdentMinMovement.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e10, sv_EjectorIdentMinMovement.pConstBwdVis^.Pressure.Output.rRamp);
sv_EjectorIdentMinMovement.pConstBwdVis^.Pressure.rMinOutput := 0.1 * sv_EjectorIdentMinMovement.prMaxPressureBwd^;

mActMovement^.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveBwd; 
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := cMoveDecompAftPlast;
ELSE
   evStartRequestData.MoveId := cMoveBwd;
END_IF;
miErrorNo := cIdentSpeedMaxEnd;

SET_EVENT(evStartRequest, evStartRequestData); 


;#END_EDIT_BLOCK END_ACTION (*AMoveEndBwd*)
ACTION ACheckMoveEndBwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveBwdDone := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckMoveEndBwdReady*)
ACTION AMoveEndBwdReady: #BEGIN_EDIT_BLOCK
aStopMovementBwd();

;#END_EDIT_BLOCK END_ACTION (*AMoveEndBwdReady*)
STEP S_StopMoveEndBwd:
AStopMoveEndBwd (P);
END_STEP

ACTION AStopMoveEndBwd: #BEGIN_EDIT_BLOCK
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Bwd to end position'));

;#END_EDIT_BLOCK END_ACTION (*AStopMoveEndBwd*)
STEP S_Done:
ADone (P);
END_STEP

ACTION ADone: #BEGIN_EDIT_BLOCK
mActMovement^.Status := tnCalibState_Done;
sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Done;

mActMovement^.prVelocityFwd^ := rSpeedLimitFwd;
mActMovement^.prVelocityBwd^ := rSpeedLimitBwd;

;#END_EDIT_BLOCK END_ACTION (*ADone*)

(* transitions *)
TRANSITION Trans47 (* Trans47 *) FROM S_RESET TO S_STOP :=  #BEGIN_EDIT_BLOCK
mbLogFileSaved
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TRestart (* TRestart *) FROM S_STOP TO S_INIT :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveStartBwd (* TMoveStartBwd *) FROM S_INIT TO S_MoveStartBwd :=  #BEGIN_EDIT_BLOCK
TRUE

;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TInitBwd (* TInitBwd *) FROM S_MoveStartBwd TO S_CHECK_ALARMS_INITBWD :=  #BEGIN_EDIT_BLOCK
bMoveBwdDone
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopMoveStartBwd (* TStopMoveStartBwd *) FROM S_MoveStartBwd TO S_StopMoveStartBwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TReset (* TReset *) FROM S_StopMoveStartBwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TStartIdent (* TStartIdent *) FROM S_CHECK_ALARMS_INITBWD TO S_INITCALIB_FWD :=  #BEGIN_EDIT_BLOCK
S_CHECK_ALARMS_INITBWD.T > T#100ms
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopInitBwd (* TStopInitBwd *) FROM S_CHECK_ALARMS_INITBWD TO S_StopMoveStartBwd :=  #BEGIN_EDIT_BLOCK
sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TDelay1 (* TDelay1 *) FROM S_INITCALIB_FWD TO S_CALIB_FWD :=  #BEGIN_EDIT_BLOCK
S_INITCALIB_FWD.T>T#1s
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveIdentFwdDone (* TMoveIdentFwdDone *) FROM S_CALIB_FWD TO S_CHECK_ALARMS_FWD :=  #BEGIN_EDIT_BLOCK
bMoveIdentDone
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopIdentFwd (* TStopIdentFwd *) FROM S_CALIB_FWD TO S_StopIdentFwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TReset1 (* TReset1 *) FROM S_StopIdentFwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TStartWriteFwd (* TStartWriteFwd *) FROM S_CHECK_ALARMS_FWD TO S_WRITE_FWD :=  #BEGIN_EDIT_BLOCK
S_CHECK_ALARMS_FWD.T > T#100ms
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopIdentFwd2 (* TStopIdentFwd2 *) FROM S_CHECK_ALARMS_FWD TO S_StopIdentFwd :=  #BEGIN_EDIT_BLOCK
sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TWriteFwd (* TWriteFwd *) FROM S_WRITE_FWD TO S_CHECK_MAXSPEED_FWD :=  #BEGIN_EDIT_BLOCK
mbLogFileSaved
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TAbortedWriteFwd (* TAbortedWriteFwd *) FROM S_WRITE_FWD TO S_AbortedWriteFwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TResetAbortedWriteFwd (* TResetAbortedWriteFwd *) FROM S_AbortedWriteFwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMaxFwdDetected (* TMaxFwdDetected *) FROM S_CHECK_MAXSPEED_FWD TO S_InitStartMovementBwdFwd :=  #BEGIN_EDIT_BLOCK
bMaxFwdDetected
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans15 (* Trans15 *) FROM S_CHECK_MAXSPEED_FWD TO S_MaxFwdRetry :=  #BEGIN_EDIT_BLOCK
bMaxFwdRetry
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveBwdDone (* TMoveBwdDone *) FROM S_MaxFwdRetry TO S_CHECK_ALARMS_RETRYFWD :=  #BEGIN_EDIT_BLOCK
bMoveBwdDone
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopMoveBwd (* TStopMoveBwd *) FROM S_MaxFwdRetry TO S_StopMoveBwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE

;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TReset2 (* TReset2 *) FROM S_StopMoveBwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TRetryFwd (* TRetryFwd *) FROM S_CHECK_ALARMS_RETRYFWD TO S_CALIB_FWD :=  #BEGIN_EDIT_BLOCK
S_CHECK_ALARMS_RETRYFWD.T > T#1s
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopIdentFwd4 (* TStopIdentFwd4 *) FROM S_CHECK_ALARMS_RETRYFWD TO S_StopMoveBwd :=  #BEGIN_EDIT_BLOCK
sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans35 (* Trans35 *) FROM S_InitStartMovementBwdFwd TO S_CHECK_ALARMS_STARTBWD :=  #BEGIN_EDIT_BLOCK
bMoveFwdDone
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopInitMoveFwd (* TStopInitMoveFwd *) FROM S_InitStartMovementBwdFwd TO S_StopInitMoveFwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TResetInitMoveFwd (* TResetInitMoveFwd *) FROM S_StopInitMoveFwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TStartInitBwd (* TStartInitBwd *) FROM S_CHECK_ALARMS_STARTBWD TO S_INITCALIB_BWD :=  #BEGIN_EDIT_BLOCK
S_CHECK_ALARMS_STARTBWD.T > T#100ms
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopIdentFwd3 (* TStopIdentFwd3 *) FROM S_CHECK_ALARMS_STARTBWD TO S_StopInitMoveFwd :=  #BEGIN_EDIT_BLOCK
sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TInitCalibBwd (* TInitCalibBwd *) FROM S_INITCALIB_BWD TO S_CALIB_BWD :=  #BEGIN_EDIT_BLOCK
S_INITCALIB_BWD.T>T#1s
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans14 (* Trans14 *) FROM S_CALIB_BWD TO S_CHECK_ALARMS_BWD :=  #BEGIN_EDIT_BLOCK
bMoveIdentDone
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopCalibBwd (* TStopCalibBwd *) FROM S_CALIB_BWD TO S_StopCalibBwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TResetCalibBwd (* TResetCalibBwd *) FROM S_StopCalibBwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TStartWriteBwd (* TStartWriteBwd *) FROM S_CHECK_ALARMS_BWD TO S_WRITE_BWD :=  #BEGIN_EDIT_BLOCK
S_CHECK_ALARMS_BWD.T > T#100ms
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopCalibBwd2 (* TStopCalibBwd2 *) FROM S_CHECK_ALARMS_BWD TO S_StopCalibBwd :=  #BEGIN_EDIT_BLOCK
sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TWriteBwd (* TWriteBwd *) FROM S_WRITE_BWD TO S_CHECK_MAXSPEED_BWD :=  #BEGIN_EDIT_BLOCK
mbLogFileSaved
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMaxBwdDetected (* TMaxBwdDetected *) FROM S_CHECK_MAXSPEED_BWD TO S_MoveEndBwd :=  #BEGIN_EDIT_BLOCK
bMaxBwdDetected
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMaxBwdRetry (* TMaxBwdRetry *) FROM S_CHECK_MAXSPEED_BWD TO S_MaxBwdRetry :=  #BEGIN_EDIT_BLOCK
bMaxBwdRetry
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveFwdDone (* TMoveFwdDone *) FROM S_MaxBwdRetry TO S_CHECK_ALARMS_RETRYBWD :=  #BEGIN_EDIT_BLOCK
bMoveFwdDone
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopMoveFwd (* TStopMoveFwd *) FROM S_MaxBwdRetry TO S_StopMoveFwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE

;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TResetBwd (* TResetBwd *) FROM S_StopMoveFwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TRetryBwd (* TRetryBwd *) FROM S_CHECK_ALARMS_RETRYBWD TO S_CALIB_BWD :=  #BEGIN_EDIT_BLOCK
S_CHECK_ALARMS_RETRYBWD.T > T#1s
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopIdentBwd4 (* TStopIdentBwd4 *) FROM S_CHECK_ALARMS_RETRYBWD TO S_StopMoveFwd :=  #BEGIN_EDIT_BLOCK
sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveEndBwdDone (* TMoveEndBwdDone *) FROM S_MoveEndBwd TO S_Done :=  #BEGIN_EDIT_BLOCK
bMoveBwdDone
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopMoveEndBwd (* TStopMoveEndBwd *) FROM S_MoveEndBwd TO S_StopMoveEndBwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TResetMoveEndBwd (* TResetMoveEndBwd *) FROM S_StopMoveEndBwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TDone (* TDone *) FROM S_Done TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)
(* end sfc-code *)


END_ALGORITHM

POSTUPDATE_ALGORITHM pMaxCommandListen ON PU_Task_7 WITH sv_GlobalIdentMaxSpeedStatus.Command,sv_GlobalIdentMaxSpeedStatus.bStart


VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
//stop all calibrations
// TEST
IF sv_GlobalIdentMaxSpeedStatus.Command = tnCalibCommand_Stop THEN
    sv_GlobalIdentMaxSpeedStatus.bStart := FALSE;
END_IF;
//
IF sv_GlobalIdentMaxSpeedStatus.Command = tnCalibCommand_Stop OR (NOT sv_GlobalIdentMaxSpeedStatus.bStart) THEN
    FOR i:= 1 TO cCalibMovements DO
        IF CHECK_REF(sv_GlobalIdentMaxSpeedStatus.pMovements[i]^) THEN
            IF sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.Status = tnCalibState_Running OR
               sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.bRedo THEN
                sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.Status := tnCalibState_Aborted;
                sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.bRedo := FALSE;//FIXME: check if needed
                sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Aborted;
                EXIT;
            END_IF;
        END_IF;
    END_FOR;
    IF (sv_GlobalIdentMaxSpeedStatus.Command = tnCalibCommand_Stop) THEN
       IF (sv_GlobalIdentMaxSpeedStatus.Status <> tnCalibState_Aborted) THEN
          sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_None;
       END_IF;
       
    END_IF;
ELSIF (sv_GlobalIdentMaxSpeedStatus.Command = tnCalibCommand_Start) OR (sv_GlobalIdentMaxSpeedStatus.bStart) THEN
    IF sv_OperationMode = nSetup THEN
        mbUseSingleMovement := FALSE;
        START_PROCESS_ALGORITHM(paMaxCalibSequence);
    ELSE
        sv_GlobalIdentMaxSpeedStatus.bStart := FALSE;
        SET_ALARM(erSetupModeRequiredForCalib);
    END_IF;
END_IF;
sv_GlobalIdentMaxSpeedStatus.Command := tnCalibCommand_None;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Coordinate sequential start of auto calib cycle
starts one auto calib movement after the other
*)

PROCESS_ALGORITHM paMaxCalibSequence ON TaskMid


VAR_TEMP
 j : DINT;
 i : DINT;
END_VAR

VAR
 tmpMovements : tyIdentSpeedMovements;
 iMaxMovements : DINT;
 tmpM : tpIdentSpeedMovement;
 ConstBwdVis : tsVelPre;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP S_INIT:
ASortCalibs (P);
Action108 (P);
END_STEP

ACTION ASortCalibs: #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Running;
miErrorNo := 0;

tmpMovements := sv_GlobalIdentMaxSpeedStatus.pMovements;

(* get number of movements *)
FOR i:= 1 TO cCalibMovements DO
    IF NOT CHECK_REF(tmpMovements[i]^)  THEN
        EXIT;
    END_IF;
END_FOR;
iMaxMovements := i -1;

(* sort them by iOrder *)
FOR i := 1 TO iMaxMovements -1 DO
    FOR j := 1 TO iMaxMovements - 1 - i +1 DO
        IF tmpMovements[j]^.iOrder > tmpMovements[j + 1]^.iOrder THEN
            tmpM := tmpMovements[j];
            tmpMovements[j] := tmpMovements[j + 1];
            tmpMovements[j + 1] := tmpM;
        END_IF;    
    END_FOR;    
END_FOR;

;#END_EDIT_BLOCK END_ACTION (*ASortCalibs*)
ACTION Action108: #BEGIN_EDIT_BLOCK
mCalibCounter := 0;
sv_GlobalIdentMaxSpeedStatus.iCurrentStep := mCalibCounter;

;#END_EDIT_BLOCK END_ACTION (*Action108*)

(* steps *)
STEP S_RESET:
AReset (P);
AStopMovements (N);
AStopSelf (P);
END_STEP

ACTION AReset: #BEGIN_EDIT_BLOCK
sv_bAutoIdentRunning := FALSE;

;#END_EDIT_BLOCK END_ACTION (*AReset*)
ACTION AStopMovements: #BEGIN_EDIT_BLOCK
(* stop all identification movements *)
FOR i:= 1 TO cCalibMovements DO
    IF CHECK_REF(sv_GlobalIdentMaxSpeedStatus.pMovements[i]^) THEN
        IF sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.Status = tnCalibState_Running OR
           sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.bRedo THEN
            sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.Status := tnCalibState_Aborted;
            sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.bRedo := FALSE;//FIXME: check if needed
            EXIT;
        END_IF;
    END_IF;
END_FOR;

;#END_EDIT_BLOCK END_ACTION (*AStopMovements*)
ACTION AStopSelf: #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.bStart := FALSE;
STOP_PROCESS_ALGORITHM();

;#END_EDIT_BLOCK END_ACTION (*AStopSelf*)
STEP Step74:
AAnyCoreActive (N);
END_STEP

STEP Step19:
ASignalStart (P);
END_STEP

ACTION ASignalStart: #BEGIN_EDIT_BLOCK
sv_bAutoIdentRunning := TRUE;

;#END_EDIT_BLOCK END_ACTION (*ASignalStart*)
STEP S_MoveEjectorBack:
AEjectorBack (P);
Action116 (N);
AResetEjectorBack (P0);
END_STEP

ACTION Action116: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := DeviceIdEjector)

;#END_EDIT_BLOCK END_ACTION (*Action116*)
ACTION AResetEjectorBack: #BEGIN_EDIT_BLOCK
miErrorNo := 0;
sv_EjectorIdentMaxMovement.prIdentPosition^ := 0.0;
sv_EjectorIdentMaxMovement.prStopRamp^ := 0.0;
sv_EjectorIdentMaxMovement.pbMoveIdent^ := FALSE;
sv_EjectorIdentMaxMovement.pConstBwdVis^ := ConstBwdVis;


;#END_EDIT_BLOCK END_ACTION (*AResetEjectorBack*)
STEP S_StopEjector:
AStopEjeMovement (P);
END_STEP

STEP S_MoveMoldBack:
AMoldBack (P);
Action118 (N);
AResetMoldBack (P0);
END_STEP

ACTION Action118: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := DeviceIdMold)

;#END_EDIT_BLOCK END_ACTION (*Action118*)
ACTION AResetMoldBack: #BEGIN_EDIT_BLOCK
miErrorNo := 0;
sv_MoldIdentMaxMovement.prIdentPosition^ := 0.0;
sv_MoldIdentMaxMovement.prStopRamp^ := 0.0;
sv_MoldIdentMaxMovement.pbMoveIdent^ := FALSE;
sv_MoldIdentMaxMovement.pConstBwdVis^ := ConstBwdVis;


;#END_EDIT_BLOCK END_ACTION (*AResetMoldBack*)
STEP S_StopMold:
AStopMoldMovement (P);
END_STEP

STEP S_CALIB_SINGLE:
AStartMovementStart (P);
END_STEP

ACTION AStartMovementStart: #BEGIN_EDIT_BLOCK
IF mCalibCounter < iMaxMovements THEN
   mCalibCounter := mCalibCounter +1;
   tmpMovements[mCalibCounter]^.bRedo := TRUE;
END_IF;   

;#END_EDIT_BLOCK END_ACTION (*AStartMovementStart*)
STEP S_CHECKNEXT:
END_STEP

STEP S_StopIdent:
AStopIdent (P);
END_STEP

ACTION AStopIdent: #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Done;

;#END_EDIT_BLOCK END_ACTION (*AStopIdent*)

(* transitions *)
TRANSITION Trans50 (* Trans50 *) FROM S_RESET TO S_INIT :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans80 (* Trans80 *) FROM S_INIT TO Step19 :=  #BEGIN_EDIT_BLOCK
NOT sv_bCoresActive AND
sv_iPendingAlarms = 0
;#END_EDIT_BLOCK
(*Comment : Start with moving ejector and 
mold in backward position, check if any failure 
occured. 
After that start the calibration cycle, if no alarm is 
pending*)
END_TRANSITION

GO_ON_TRANSITION Trans87 (* Trans87 *) FROM S_INIT TO Step74 :=  #BEGIN_EDIT_BLOCK
sv_bCoresActive OR 
sv_iPendingAlarms > 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans88 (* Trans88 *) FROM Step74 TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE

;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans18 (* Trans18 *) FROM Step19 TO S_MoveEjectorBack :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans72 (* Trans72 *) FROM S_MoveEjectorBack TO S_MoveMoldBack :=  #BEGIN_EDIT_BLOCK
fbCheckReady.bReady AND
sv_iPendingAlarms = 0
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans83 (* Trans83 *) FROM S_MoveEjectorBack TO S_StopEjector :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans84 (* Trans84 *) FROM S_StopEjector TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE

;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans81 (* Trans81 *) FROM S_MoveMoldBack TO S_CALIB_SINGLE :=  #BEGIN_EDIT_BLOCK
fbCheckReady.bReady AND
sv_iPendingAlarms = 0
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans85 (* Trans85 *) FROM S_MoveMoldBack TO S_StopMold :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans86 (* Trans86 *) FROM S_StopMold TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TCheckActMoveReady (* TCheckActMoveReady *) FROM S_CALIB_SINGLE TO S_CHECKNEXT :=  #BEGIN_EDIT_BLOCK
tmpMovements[mCalibCounter]^.bRedo = FALSE AND
NOT(sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
    sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Error)
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TCheckError (* TCheckError *) FROM S_CALIB_SINGLE TO S_RESET :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Error OR 
iMaxMovements = 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TNextUnit (* TNextUnit *) FROM S_CHECKNEXT TO S_CALIB_SINGLE :=  #BEGIN_EDIT_BLOCK
mCalibCounter < iMaxMovements
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TStopIdent (* TStopIdent *) FROM S_CHECKNEXT TO S_StopIdent :=  #BEGIN_EDIT_BLOCK
mCalibCounter >= iMaxMovements
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TReset (* TReset *) FROM S_StopIdent TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION AEjectorBack: #BEGIN_EDIT_BLOCK
miErrorNo := cIdentSpeedMaxSequence;

IF sv_EjectorIdentMaxMovement.bPositionIncreasingFwd THEN
   sv_EjectorIdentMaxMovement.prIdentPosition^ := mrBwdStopPosition;
ELSE
   sv_EjectorIdentMaxMovement.prIdentPosition^ := sv_EjectorIdentMaxMovement.prStroke^ - mrBwdStopPosition;
END_IF;
sv_EjectorIdentMaxMovement.prStopRamp^ := 1.0e10;
ConstBwdVis := sv_EjectorIdentMaxMovement.pConstBwdVis^;
sv_EjectorIdentMaxMovement.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e10, sv_EjectorIdentMaxMovement.pConstBwdVis^.Pressure.Output.rRamp);
sv_EjectorIdentMaxMovement.pConstBwdVis^.Pressure.rMinOutput := 0.1 * sv_EjectorIdentMaxMovement.prMaxPressureBwd^;
sv_EjectorIdentMaxMovement.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := DeviceIdEjector;
evStartRequestData.MoveDir := cMoveBwd; 
evStartRequestData.MoveId := cMoveBwd;
SET_EVENT(evStartRequest, evStartRequestData);



;#END_EDIT_BLOCK END_ACTION (*AEjectorBack*)
ACTION AMoldBack: #BEGIN_EDIT_BLOCK
miErrorNo := cIdentSpeedMaxSequence;

IF sv_MoldIdentMaxMovement.bPositionIncreasingFwd THEN
   sv_MoldIdentMaxMovement.prIdentPosition^ := mrBwdStopPosition;
ELSE
   sv_MoldIdentMaxMovement.prIdentPosition^ := sv_MoldIdentMaxMovement.prStroke^ - mrBwdStopPosition;
END_IF;
sv_MoldIdentMaxMovement.prStopRamp^ := 1.0e10;
ConstBwdVis := sv_MoldIdentMaxMovement.pConstBwdVis^;
sv_MoldIdentMaxMovement.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e10, sv_MoldIdentMaxMovement.pConstBwdVis^.Pressure.Output.rRamp);
sv_MoldIdentMaxMovement.pConstBwdVis^.Pressure.rMinOutput := 0.1 * sv_MoldIdentMaxMovement.prMaxPressureBwd^;
sv_MoldIdentMaxMovement.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := DeviceIdMold;
evStartRequestData.MoveDir := cMoveBwd; 
evStartRequestData.MoveId := cMoveBwd;
SET_EVENT(evStartRequest, evStartRequestData); 


;#END_EDIT_BLOCK END_ACTION (*AMoldBack*)
ACTION AStopEjeMovement: #BEGIN_EDIT_BLOCK
evStopRequestData.DeviceId := DeviceIdEjector;  
evStopRequestData.MoveDir := cMoveBwd;  
evStopRequestData.MoveId := cMoveBwd;      
SET_EVENT(evStopRequest, evStopRequestData);
IF sv_GlobalIdentMaxSpeedStatus.Status <> tnCalibState_None THEN
    sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Aborted;
END_IF;


;#END_EDIT_BLOCK END_ACTION (*AStopEjeMovement*)
ACTION AStopMoldMovement: #BEGIN_EDIT_BLOCK
evStopRequestData.DeviceId := DeviceIdMold;  
evStopRequestData.MoveDir := cMoveBwd;  
evStopRequestData.MoveId := cMoveBwd;      
SET_EVENT(evStopRequest, evStopRequestData);
IF sv_GlobalIdentMaxSpeedStatus.Status <> tnCalibState_None THEN
    sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Aborted;
END_IF;


;#END_EDIT_BLOCK END_ACTION (*AStopMoldMovement*)
ACTION AAnyCoreActive: #BEGIN_EDIT_BLOCK
IF sv_bCoresActive THEN
   SET_ALARM(erCalibCoresActive);
END_IF;
sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Aborted;


;#END_EDIT_BLOCK END_ACTION (*AAnyCoreActive*)

(* exits *)

EXIT_TRANSITION E_NotSetupMode := #BEGIN_EDIT_BLOCK
sv_OperationMode <> nSetup
;#END_EDIT_BLOCK
PRIORITY 1 WITH  INITIAL_STEP S_RESET: END_STEP
END_TRANSITION
(* end sfc-code *)


END_ALGORITHM

ALGORITHM aRound


VAR_INPUT
 rActNumber : REAL;
 rStep : REAL;
END_VAR

VAR_OUTPUT
 rRoundedNumber : REAL;
END_VAR

VAR
 rRealValue : REAL;
END_VAR
#BEGIN_EDIT_BLOCK
IF (rStep > 0.0) THEN
   rRealValue := (0.999 + rActNumber / rStep);
   rRoundedNumber := DINT_TO_REAL(TRUNC_TO_DINT(rRealValue)) * rStep;
ELSE
   rRoundedNumber := rActNumber;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aCalcMinSpeedOutput


VAR_INPUT
 bStart : BOOL (* Restart calculation of reference for min speed calibration *);
 rMaxSpeedLimit : REAL (* Maximum speed limit of actual device *);
 rActRefSpeed : REAL (* Actual speed limit of actual device *);
 rActMinSpeed : REAL (* Minimum measured speed *);
 bUnstable : BOOL (* Measured speed unstable *);
 bTimeOut : BOOL (* Timeout during movement aof actual device *);
END_VAR

VAR_OUTPUT
 bMinDetected : BOOL (* Speed limit detected *);
 rRefSpeed : REAL (* Speed limit for next try *);
 rMinSpeed : REAL (* Identified min output *);
END_VAR

VAR
 rMaxRefSpeed : REAL;
 rMinRefSpeed : REAL := 0.0;
 rMFactorMaxMinLimit : REAL := 0.2;
END_VAR
#BEGIN_EDIT_BLOCK
IF bStart THEN
   rMaxRefSpeed := rMaxSpeedLimit;
   rMinRefSpeed := 0.0;
END_IF;
IF (bUnstable OR bTimeOut) THEN
   // increase speed
   IF (rActRefSpeed >= rMFactorMaxMinLimit * rMaxSpeedLimit) THEN
      bMinDetected := TRUE;
      rMinSpeed := rActRefSpeed;
      RETURN;
   END_IF;      
   rMinRefSpeed := rActRefSpeed;
   bMinDetected := FALSE;
  IF (rMaxRefSpeed - rMinRefSpeed) < (0.0025 * rMaxSpeedLimit) THEN
  // difference to low to maximum - stop or increase maximum?    
      bMinDetected := TRUE;
      rMinSpeed := rMaxRefSpeed; 
   ELSIF (rMaxRefSpeed < rMaxSpeedLimit) AND (rMinRefSpeed > 0.0) THEN
      rRefSpeed := 0.5 * (rMaxRefSpeed + rMinRefSpeed);
      bMinDetected := FALSE;
   ELSE
      rRefSpeed := rActRefSpeed + 0.01 * rMaxSpeedLimit;
      IF (rRefSpeed >= rMaxSpeedLimit) THEN
         bMinDetected := TRUE;
         rMinSpeed := rMaxSpeedLimit;
      END_IF;
   END_IF;
ELSE
   // reduce speed
   rMaxRefSpeed := rActRefSpeed;
   IF (rMaxRefSpeed - rMinRefSpeed) < (0.0025 * rMaxSpeedLimit) THEN
      bMinDetected := TRUE;
      rMinSpeed := rActRefSpeed;
   ELSE
      bMinDetected := FALSE;
      rRefSpeed := 0.5 * (rMaxRefSpeed + rMinRefSpeed);
   END_IF;      
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paRedoMin ON TaskMid


VAR_TEMP
 i : DINT;
 bIdentActive : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
bIdentActive := FALSE;
FOR i:= 1 TO cCalibMovements DO
   IF CHECK_REF(sv_GlobalIdentMinSpeedStatus.pMovements[i]^) THEN
      IF sv_GlobalIdentMinSpeedStatus.pMovements[i]^.bRedo THEN
         mActMovement := sv_GlobalIdentMinSpeedStatus.pMovements[i];
         bIdentActive := TRUE;
         sv_GlobalIdentMinSpeedStatus.iCurrentStep :=  i;
         mCalibCounter := i;
         IF sv_OperationMode = nSetup THEN
            mbUseSingleMovement := TRUE;
            START_PROCESS_ALGORITHM(paMinSingleMovement);
         ELSE
            sv_GlobalIdentMinSpeedStatus.pMovements[i]^.bRedo := FALSE;
            SET_ALARM(erSetupModeRequiredForCalib);
         END_IF;
         EXIT;
      END_IF;
   END_IF;
END_FOR;
IF ((NOT bIdentActive) AND (sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Running)) THEN
   sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Done;
END_IF;
       

STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

EVENT_ALGORITHM evaRedoMinEvent ON EV_Task_7 WITH evRedoIdentMinSpeedStart


VAR_INPUT
 evRedoIdentEventData : tevRedoIdentSpeedEventData (* Event data to start min speed identification *);
END_VAR
#BEGIN_EDIT_BLOCK

START_PROCESS_ALGORITHM(paRedoMin);



;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paMinSingleMovement ON TaskMid


VAR
 bMoveBwdDone : BOOL := FALSE;
 bMoveFwdDone : BOOL := FALSE;
 bMoveIdentDone : BOOL := FALSE;
 sFileName : STRING(255);
 iFileCounter : UDINT := 1;
 ConstVisFwd : tsVelPre (* const output for ejector forward movement *);
 ConstVisBwd : tsVelPre (* const output for ejector forward movement *);
 bMinFwdRetry : BOOL;
 bMinBwdRetry : BOOL;
 bMinFwdDetected : BOOL;
 bMinBwdDetected : BOOL;
 sMoveName : STRING(32);
 rMaxPressureLimit : REAL := 150.0;
 rRefSpeedLimit : REAL;
 rSpeedLimitFwd : REAL;
 rSpeedLimitBwd : REAL;
 bTimeOut : BOOL;
 bStopUnstable : BOOL;
 dMaxMoveTime : TIME;
 dMaxMoveTimeSaveFwd : TIME;
 dMaxMoveTimeSaveBwd : TIME;
 TimeOut : TON;
 rMoveStrokeTime : REAL;
 rStartFactor : REAL := 0.1;
 rMaxRefPressureLimit : REAL;
 sWriteSpeedLimit : STRING(255);
 dMoveTimeLimit : TIME := T#2m;
 bMoveTimeLimited : BOOL;
 dMoveTimeOffset : TIME := T#5s;
 rStartPosition : REAL;
 rMinMovementPosition : REAL;
 rVelocitSizeFactor : REAL := 1.0;
 rMinStopRamp : REAL := 1.0;
 rMinStrokeFactor : REAL := 2.0;
 rMaxPressureFwd : REAL;
 rMaxPressureBwd : REAL;
 rPressureFactorFwd : REAL;
 rPressureFactorBwd : REAL;
 rPressureStep : REAL := 5.0;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP S_INIT:
Action3 (P);
END_STEP

ACTION Action3: #BEGIN_EDIT_BLOCK
miErrorNo := 0;

sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Running;
mActMovement^.Status := tnCalibState_Running;
sMoveName := mActMovement^.sName;

abSpeedMeasure.aInit();

bMinFwdRetry := FALSE;
bMinBwdRetry := FALSE;

dMaxMoveTimeSaveFwd := mActMovement^.pdMaxMoveTimeFwd^;
dMaxMoveTimeSaveBwd := mActMovement^.pdMaxMoveTimeBwd^;

ConstVisFwd := mActMovement^.pConstFwdVis^;
ConstVisBwd := mActMovement^.pConstBwdVis^;

rSpeedLimitFwd := mActMovement^.prVelocityFwd^;
rSpeedLimitBwd := mActMovement^.prVelocityBwd^;

IF (mActMovement^.rMaxPositionLimitFactor > mActMovement^.rMinPositionLimitFactor) AND
   (mActMovement^.rMinPositionLimitFactor > 0.0) AND (mActMovement^.rMaxPositionLimitFactor < 1.0) THEN
   mrMaxPositionFactor := mActMovement^.rMaxPositionLimitFactor;
   mrMinPositionFactor := mActMovement^.rMinPositionLimitFactor;
ELSE // use deafult values
   mrMaxPositionFactor := 0.8;
   mrMinPositionFactor := 0.2;
END_IF;

rMaxPressureFwd := 0.0;
rMaxPressureBwd := 0.0;
mprActPressure := sv_PumpData[mActMovement^.DeviceId.IndexId].prActSysPressure;
IF CHECK_REF(mprActPressure^) THEN
   mbprActPressureLinked := TRUE;
ELSE
   mbprActPressureLinked := FALSE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*Action3*)

(* steps *)
STEP S_RESET:
END_STEP

STEP S_STOP:
AStopSelf (P);
END_STEP

ACTION AStopSelf: #BEGIN_EDIT_BLOCK
IF (sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted) THEN
   mActMovement^.prVelocityFwd^ := rSpeedLimitFwd;
   mActMovement^.prVelocityBwd^ := rSpeedLimitBwd;
END_IF;
sv_GlobalIdentMinSpeedStatus.Command := tnCalibCommand_None;
sv_bAutoIdentRunning := FALSE;
mActMovement^.bRedo := FALSE;
mActMovement^.pdMaxMoveTimeFwd^ := dMaxMoveTimeSaveFwd;
mActMovement^.pdMaxMoveTimeBwd^ := dMaxMoveTimeSaveBwd;
mActMovement^.prStopRamp^ := 0.0;
mActMovement^.pConstFwdVis^ := ConstVisFwd;
mActMovement^.pConstBwdVis^ := ConstVisBwd;

//release memory
abSpeedMeasure.aEnd();

STOP_PROCESS_ALGORITHM();

;#END_EDIT_BLOCK END_ACTION (*AStopSelf*)
STEP S_MoveStartBwd:
AMoveStartBwd (P);
ACheckMoveStartBwdReady (N);
AMoveStartBwdReady (P0);
END_STEP

ACTION AMoveStartBwd: #BEGIN_EDIT_BLOCK
bMoveBwdDone := FALSE;
miErrorNo := cIdentSpeedMinBwdInit;
aStartMovementBwd();

;#END_EDIT_BLOCK END_ACTION (*AMoveStartBwd*)
ACTION ACheckMoveStartBwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveBwdDone := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckMoveStartBwdReady*)
ACTION AMoveStartBwdReady: #BEGIN_EDIT_BLOCK
aStopMovementBwd();




;#END_EDIT_BLOCK END_ACTION (*AMoveStartBwdReady*)
STEP S_StopMoveStartBwd:
AStopMoveErrorStartBwd (P);
END_STEP

ACTION AStopMoveErrorStartBwd: #BEGIN_EDIT_BLOCK
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident Fwd: Bwd to initial position'));

;#END_EDIT_BLOCK END_ACTION (*AStopMoveErrorStartBwd*)
STEP S_CHECK_ALARMS_INITBWD:
END_STEP

STEP S_INITCALIB_FWD:
aInitIdentFwd (P);
END_STEP

ACTION aInitIdentFwd: #BEGIN_EDIT_BLOCK
iFileCounter := 1;
IF (CHECK_REF(mActMovement^.prSizeFactorFwd^)) THEN
   IF (mActMovement^.prSizeFactorFwd^ > 0.0) THEN
      rVelocitSizeFactor := mActMovement^.prSizeFactorFwd^;        
   END_IF;
ELSE
   rVelocitSizeFactor := 1.0;
END_IF;
rRefSpeedLimit := 0.01 * mActMovement^.prVelocityLimitFwd^;
rMaxPressureLimit := mActMovement^.prMaxPressureFwd^;
IF CHECK_REF(mActMovement^.prMaxPressureFwdHydr^) THEN
   rMaxRefPressureLimit := mActMovement^.prMaxPressureFwdHydr^;
   IF (rMaxRefPressureLimit > 0.0) THEN
      rPressureFactorFwd := rMaxPressureLimit / rMaxRefPressureLimit;
   ELSE      
      rPressureFactorFwd := 1.0;
   END_IF;
ELSE   
   rMaxRefPressureLimit := mActMovement^.prMaxPressureFwd^;
   rPressureFactorFwd := 1.0;
END_IF; 

aCalcMinSpeedOutput.bStart := TRUE;

dummy := Print('Calib min output %s Fwd started', sMoveName);

;#END_EDIT_BLOCK END_ACTION (*aInitIdentFwd*)
STEP S_CALIB_FWD:
ADoCalib (P);
AStartMovementFwd (P);
ACheckActMovementFwdReady (N);
AStopMovementFwd (P0);
END_STEP

ACTION ADoCalib: #BEGIN_EDIT_BLOCK
// save actual settings
mActMovement^.pConstFwdVis^.Velocity.Output.rOutputValue := rRefSpeedLimit * rVelocitSizeFactor;
mActMovement^.pConstFwdVis^.Velocity.rMinOutput := 0.0;
mActMovement^.pConstFwdVis^.Pressure.Output.rOutputValue := MAX(mActMovement^.pConstFwdVis^.Pressure.Output.rOutputValue, rMaxPressureLimit);
mActMovement^.pConstFwdVis^.Pressure.Output.rRamp := MAX(1.0e10, ConstVisFwd.Pressure.Output.rRamp); 
IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMaxPositionFactor;
   mrMinLimitPosition := rStartFactor * mActMovement^.prIdentPosition^ + (1.0 - rStartFactor) * mActMovement^.prPosition^;
   IF (mActMovement^.prIdentPosition^ - mActMovement^.prPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit  * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstFwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMaxLimitPosition := mActMovement^.prIdentPosition^ - 0.5 * rRefSpeedLimit  * rRefSpeedLimit / mActMovement^.prStopRamp^;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMinPositionFactor;
   mrMaxLimitPosition := (1.0 - rStartFactor) * mActMovement^.prPosition^ + rStartFactor * mActMovement^.prIdentPosition^;
   IF (mActMovement^.prPosition^ - mActMovement^.prIdentPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit  * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstFwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMinLimitPosition := mActMovement^.prIdentPosition^ + 0.5 * rRefSpeedLimit  * rRefSpeedLimit / mActMovement^.prStopRamp^;
END_IF;
mActMovement^.pbMoveIdent^ := TRUE;
bMoveIdentDone := FALSE;

bMinFwdDetected := FALSE;

mrRefVelocity := rRefSpeedLimit;
mrRefPressure := rMaxRefPressureLimit;

aStartMeasurement();

bStopUnstable := FALSE;
bTimeOut := FALSE;
IF rRefSpeedLimit > 0.0 THEN
   rMoveStrokeTime := mActMovement^.prStroke^ / rRefSpeedLimit; 
ELSE
   rMoveStrokeTime := 0.0;
END_IF;
dMaxMoveTime := T#5s + LINT_TO_TIME(REAL_TO_LINT(rMoveStrokeTime*1.0e6));
IF (dMaxMoveTime > dMoveTimeLimit) THEN
   dMaxMoveTime := dMoveTimeLimit;
   bMoveTimeLimited := TRUE;
   rStartPosition := mActMovement^.prPosition^;
   IF (mActMovement^.bPositionIncreasingFwd) THEN
      rMinMovementPosition := rStartPosition + 0.1 * (mrMaxLimitPosition - mrMinLimitPosition);   
   ELSE;
      rMinMovementPosition := rStartPosition - 0.1 * (mrMaxLimitPosition - mrMinLimitPosition );      
   END_IF;
ELSE
   bMoveTimeLimited := FALSE;   
END_IF;
TimeOut(IN := FALSE,
        PT := dMaxMoveTime);
IF (mActMovement^.pdMaxMoveTimeFwd^ < dMaxMoveTime + dMoveTimeOffset) THEN
   mActMovement^.pdMaxMoveTimeFwd^ := dMaxMoveTime + dMoveTimeOffset;
END_IF;
mActMovement^.prVelocityFwd^ := rRefSpeedLimit;

sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
dummy := Print('Calib min output: act. min output: %s', sWriteSpeedLimit);
miErrorNo := cIdentSpeedMinFwdIdent;

;#END_EDIT_BLOCK END_ACTION (*ADoCalib*)
ACTION AStartMovementFwd: #BEGIN_EDIT_BLOCK
evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveFwd;
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := mActMovement^.MoveId;   
ELSE
   evStartRequestData.MoveId := cMoveFwd;
END_IF;
SET_EVENT(evStartRequest, evStartRequestData); 


;#END_EDIT_BLOCK END_ACTION (*AStartMovementFwd*)
ACTION ACheckActMovementFwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);

TimeOut(IN := TRUE);
IF (fbCheckReady.bReady) THEN
   aStopMeasurement();
   aStopMovementFwd();
   bMoveIdentDone := TRUE;      
ELSIF (TimeOut.Q) THEN
   aStopMeasurement();
   aStopMovementFwd();
   IF (bMoveTimeLimited) AND
     ((mActMovement^.bPositionIncreasingFwd AND (mActMovement^.prPosition^ > rMinMovementPosition)) OR
      (NOT mActMovement^.bPositionIncreasingFwd AND (mActMovement^.prPosition^ < rMinMovementPosition))) THEN
      bMoveIdentDone := TRUE;
      dummy := Print('Calib min output: max move time reached with act. min output %s', sWriteSpeedLimit);   
   ELSE
      bTimeOut := TRUE;      
      dummy := Print('Calib min output: timeout with act. min output %s', sWriteSpeedLimit);   
   END_IF;
ELSIF (abSpeedMeasure.aMeasure.bSpeedUnStable) THEN
   aStopMeasurement();
   aStopMovementFwd();
   bStopUnstable := TRUE;
   dummy := Print('Calib min output: unstable speed with act. min output %s', sWriteSpeedLimit);   
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckActMovementFwdReady*)
ACTION AStopMovementFwd: #BEGIN_EDIT_BLOCK
mActMovement^.prStopRamp^ := 0.0;
mActMovement^.pConstFwdVis^ := ConstVisFwd;
mActMovement^.pdMaxMoveTimeFwd^ := dMaxMoveTimeSaveFwd;


TimeOut(IN := FALSE);


;#END_EDIT_BLOCK END_ACTION (*AStopMovementFwd*)
STEP S_StopIdentFwd:
AStopIdentFwd (P);
END_STEP

ACTION AStopIdentFwd: #BEGIN_EDIT_BLOCK
aStopMovementFwd();
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident Fwd'));

;#END_EDIT_BLOCK END_ACTION (*AStopIdentFwd*)
STEP S_CHECK_ALARMS_FWD:
END_STEP

STEP S_WRITE_FWD:
AWriteFwd (P);
END_STEP

ACTION AWriteFwd: #BEGIN_EDIT_BLOCK
abSpeedMeasure.aGetMaxValues(rMaxSpeed => mrMaxVelocity,
                             rMaxPressure => mrMaxPressure,
                             bPressureLimitReached => mbPressureLimitReached,
                             bSpeedLimitReached => mbVelocityLimitReached);
IF mbprActPressureLinked THEN
   rMaxPressureFwd := MAX(rMaxPressureFwd,mrMaxPressure);
   dummy := Print('Calib min output: with act. min output %s max pressure %f needed', sWriteSpeedLimit, mrMaxPressure);           
END_IF;    
sFileName := CONCAT(sMoveName,"_MINSPEED_FWD_");
aWriteLog(sFileName := sFileName,
          iFileCounter := iFileCounter,
          bDeleteFiles := TRUE);
iFileCounter := iFileCounter + 1;

;#END_EDIT_BLOCK END_ACTION (*AWriteFwd*)
STEP S_AbortedWriteFwd:
AStopMoveErrorWriteFwd (P);
END_STEP

ACTION AStopMoveErrorWriteFwd: #BEGIN_EDIT_BLOCK
mActMovement^.Status := tnCalibState_Error;


;#END_EDIT_BLOCK END_ACTION (*AStopMoveErrorWriteFwd*)
STEP S_CHECK_MINSPEED_FWD:
ACheckMinSpeedFwd (P);
END_STEP

ACTION ACheckMinSpeedFwd: #BEGIN_EDIT_BLOCK
aCalcMinSpeedOutput(rMaxSpeedLimit := mActMovement^.prVelocityLimitFwd^,
                    rActRefSpeed := rRefSpeedLimit,
                    rActMinSpeed := abSpeedMeasure.aGetMaxValues.rMaxSpeed,
                    bUnstable := abSpeedMeasure.aGetMaxValues.bSpeedLimitUnStable,
                    bTimeOut := bTimeOut);
bMinFwdDetected := aCalcMinSpeedOutput.bMinDetected;
IF (bMinFwdDetected) THEN
   rSpeedLimitFwd := aCalcMinSpeedOutput.rMinSpeed;
   dummy := Print('Calib min output %s Fwd finished: min output fwd = %f$N', sMoveName, rSpeedLimitFwd);   
ELSE   
   bMinFwdRetry := TRUE;
   rRefSpeedLimit := aCalcMinSpeedOutput.rRefSpeed;
   aCalcMinSpeedOutput.bStart := FALSE;
END_IF;

mActMovement^.pConstFwdVis^ := ConstVisFwd;
mActMovement^.prVelocityFwd^ := rSpeedLimitFwd;
mActMovement^.pdMaxMoveTimeFwd^ := dMaxMoveTimeSaveFwd;


;#END_EDIT_BLOCK END_ACTION (*ACheckMinSpeedFwd*)
STEP S_ReadyMinFwdDetected:
AReadyMinFwdDetected (N);
END_STEP

ACTION AReadyMinFwdDetected: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := mActMovement^.DeviceId);

;#END_EDIT_BLOCK END_ACTION (*AReadyMinFwdDetected*)
STEP S_ReadyMinFwdRetry:
AReadyMinFwdRetry (N);
END_STEP

ACTION AReadyMinFwdRetry: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := mActMovement^.DeviceId);

;#END_EDIT_BLOCK END_ACTION (*AReadyMinFwdRetry*)
STEP S_MinFwdRetry:
AStartMovementFwdBwd (P);
ACheckActMovementFwdBwdReady (N);
AStopMovementFwdBwd (P0);
END_STEP

ACTION AStartMovementFwdBwd: #BEGIN_EDIT_BLOCK
bMoveBwdDone := FALSE;
miErrorNo := cIdentSpeedMinFwdStart;
aStartMovementBwd();

;#END_EDIT_BLOCK END_ACTION (*AStartMovementFwdBwd*)
ACTION ACheckActMovementFwdBwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveBwdDone := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckActMovementFwdBwdReady*)
ACTION AStopMovementFwdBwd: #BEGIN_EDIT_BLOCK
aStopMovementBwd();


;#END_EDIT_BLOCK END_ACTION (*AStopMovementFwdBwd*)
STEP S_StopMoveBwd:
AStopMoveErrorBwdFwd (P);
END_STEP

ACTION AStopMoveErrorBwdFwd: #BEGIN_EDIT_BLOCK
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident Fwd: Bwd to start position'));

;#END_EDIT_BLOCK END_ACTION (*AStopMoveErrorBwdFwd*)
STEP S_CHECK_ALARMS_RETRYFWD:
END_STEP

STEP S_InitStartMovementBwdFwd:
AInitStartMovementBwdFwd (P);
ACheckInitMovementBwdFwdReady (N);
AStopInitMovementBwdFwd (P0);
END_STEP

ACTION AInitStartMovementBwdFwd: #BEGIN_EDIT_BLOCK
bMoveFwdDone := FALSE;
miErrorNo := cIdentSpeedMinFwdInit;
aStartMovementFwd();

;#END_EDIT_BLOCK END_ACTION (*AInitStartMovementBwdFwd*)
ACTION ACheckInitMovementBwdFwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveFwdDone := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckInitMovementBwdFwdReady*)
ACTION AStopInitMovementBwdFwd: #BEGIN_EDIT_BLOCK
aStopMovementFwd();

;#END_EDIT_BLOCK END_ACTION (*AStopInitMovementBwdFwd*)
STEP S_StopInitMoveFwd:
AStopMoveErrorInitFwd (P);
END_STEP

ACTION AStopMoveErrorInitFwd: #BEGIN_EDIT_BLOCK
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident Bwd: Fwd to initial position'));

;#END_EDIT_BLOCK END_ACTION (*AStopMoveErrorInitFwd*)
STEP S_CHECK_ALARMS_STARTBWD:
END_STEP

STEP S_INITCALIB_BWD:
AInitCalibBwd (P);
END_STEP

ACTION AInitCalibBwd: #BEGIN_EDIT_BLOCK
iFileCounter := 1;
IF (CHECK_REF(mActMovement^.prSizeFactorBwd^)) THEN
   IF (mActMovement^.prSizeFactorBwd^ > 0.0) THEN
      rVelocitSizeFactor := mActMovement^.prSizeFactorBwd^;        
   END_IF;
ELSE
   rVelocitSizeFactor := 1.0;
END_IF;
rRefSpeedLimit := 0.01 * mActMovement^.prVelocityLimitBwd^;
rMaxPressureLimit := mActMovement^.prMaxPressureBwd^;
IF CHECK_REF(mActMovement^.prMaxPressureBwdHydr^) THEN
   rMaxRefPressureLimit := mActMovement^.prMaxPressureBwdHydr^;
   IF (rMaxRefPressureLimit > 0.0) THEN
      rPressureFactorBwd := rMaxPressureLimit / rMaxRefPressureLimit;
   ELSE      
      rPressureFactorBwd := 1.0;
   END_IF;   
ELSE   
   rMaxRefPressureLimit := mActMovement^.prMaxPressureFwd^;
   rPressureFactorBwd := 1.0;
END_IF; 

aCalcMinSpeedOutput.bStart := TRUE;

dummy := Print('Calib min output %s Bwd started', sMoveName);

;#END_EDIT_BLOCK END_ACTION (*AInitCalibBwd*)
STEP S_CALIB_BWD:
ADoCalibBwd (P);
AStartMovementBwd (P);
ACheckActMovementBwdReady (N);
AStopMovementBwd (P0);
END_STEP

ACTION ADoCalibBwd: #BEGIN_EDIT_BLOCK
mActMovement^.pConstBwdVis^.Velocity.Output.rOutputValue := rRefSpeedLimit * rVelocitSizeFactor;
mActMovement^.pConstBwdVis^.Velocity.rMinOutput := 0.0;
mActMovement^.pConstBwdVis^.Pressure.Output.rOutputValue := MAX(mActMovement^.pConstBwdVis^.Pressure.Output.rOutputValue, rMaxPressureLimit);
mActMovement^.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e10, ConstVisBwd.Pressure.Output.rRamp); 
IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMinPositionFactor;
   mrMaxLimitPosition := rStartFactor * mActMovement^.prIdentPosition^ + (1.0 - rStartFactor) * mActMovement^.prPosition^;
   IF (mActMovement^.prPosition^ - mActMovement^.prIdentPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit  * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstBwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMinLimitPosition := mActMovement^.prIdentPosition^ + 0.5 * rRefSpeedLimit  * rRefSpeedLimit / mActMovement^.prStopRamp^;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMaxPositionFactor;
   mrMinLimitPosition := rStartFactor * mActMovement^.prPosition^ + (1.0 - rStartFactor) * mActMovement^.prIdentPosition^;
   IF (mActMovement^.prIdentPosition^ - mActMovement^.prPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit  * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstBwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMaxLimitPosition := mActMovement^.prIdentPosition^ - 0.5 * rRefSpeedLimit  * rRefSpeedLimit / mActMovement^.prStopRamp^;
END_IF;
mActMovement^.pbMoveIdent^ := TRUE;

bMoveIdentDone := FALSE;

mrRefVelocity := rRefSpeedLimit;
mrRefPressure := rMaxRefPressureLimit;

aStartMeasurement();

bStopUnstable := FALSE;
bTimeOut := FALSE;
IF rRefSpeedLimit > 0.0 THEN
   rMoveStrokeTime := mActMovement^.prStroke^ / rRefSpeedLimit; 
ELSE
   rMoveStrokeTime := 0.0;
END_IF;
dMaxMoveTime := T#5s + LINT_TO_TIME(REAL_TO_LINT(rMoveStrokeTime*1.0e6));
IF (dMaxMoveTime > dMoveTimeLimit) THEN
   dMaxMoveTime := dMoveTimeLimit;
   bMoveTimeLimited := TRUE;
   rStartPosition := mActMovement^.prPosition^;
   IF (mActMovement^.bPositionIncreasingFwd) THEN
      rMinMovementPosition := rStartPosition - 0.1 * (mrMaxLimitPosition - mrMinLimitPosition);   
   ELSE;
      rMinMovementPosition := rStartPosition + 0.1 * (mrMaxLimitPosition - mrMinLimitPosition );      
   END_IF;
ELSE
   bMoveTimeLimited := FALSE;   
END_IF;

TimeOut(IN := FALSE,
        PT := dMaxMoveTime);    
IF (mActMovement^.pdMaxMoveTimeBwd^ < dMaxMoveTime + dMoveTimeOffset) THEN
   mActMovement^.pdMaxMoveTimeBwd^ := dMaxMoveTime + dMoveTimeOffset;
END_IF;
mActMovement^.prVelocityBwd^ := rRefSpeedLimit;

sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
dummy := Print('Calib min output: act. min output: %s', sWriteSpeedLimit);
miErrorNo := cIdentSpeedMinBwdIdent;

;#END_EDIT_BLOCK END_ACTION (*ADoCalibBwd*)
ACTION AStartMovementBwd: #BEGIN_EDIT_BLOCK
evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveBwd;
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := cMoveDecompAftPlast;
ELSE
   evStartRequestData.MoveId := cMoveBwd;
END_IF;
SET_EVENT(evStartRequest, evStartRequestData); 

;#END_EDIT_BLOCK END_ACTION (*AStartMovementBwd*)
ACTION ACheckActMovementBwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);

TimeOut(IN :=TRUE);
IF fbCheckReady.bReady THEN
   aStopMeasurement();
   aStopMovementBwd();
   bMoveIdentDone := TRUE;      
ELSIF TimeOut.Q THEN
   aStopMeasurement();
   aStopMovementBwd();
   IF (bMoveTimeLimited) AND
     ((mActMovement^.bPositionIncreasingFwd AND (mActMovement^.prPosition^ < rMinMovementPosition)) OR
      (NOT mActMovement^.bPositionIncreasingFwd AND (mActMovement^.prPosition^ > rMinMovementPosition))) THEN
      bMoveIdentDone := TRUE;
      dummy := Print('Calib min output: max move time reached with act. min output %s', sWriteSpeedLimit);   
   ELSE
      bTimeOut := TRUE;      
      dummy := Print('Calib min output: timeout with act. min output %s', sWriteSpeedLimit);   
   END_IF;   
ELSIF (abSpeedMeasure.aMeasure.bSpeedUnStable) THEN
   aStopMeasurement();
   aStopMovementBwd();
   bStopUnstable := TRUE;
   sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
   dummy := Print('Calib min output: unstable speed with act. min output %s', sWriteSpeedLimit);   
END_IF;


;#END_EDIT_BLOCK END_ACTION (*ACheckActMovementBwdReady*)
ACTION AStopMovementBwd: #BEGIN_EDIT_BLOCK
mActMovement^.pConstBwdVis^ := ConstVisBwd;
mActMovement^.pdMaxMoveTimeBwd^ := dMaxMoveTimeSaveBwd;

TimeOut(IN := FALSE);

;#END_EDIT_BLOCK END_ACTION (*AStopMovementBwd*)
STEP S_StopCalibBwd:
AStopMoveErrorCalibBwd (P);
END_STEP

ACTION AStopMoveErrorCalibBwd: #BEGIN_EDIT_BLOCK
aStopMovementBwd();
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident Bwd'));

;#END_EDIT_BLOCK END_ACTION (*AStopMoveErrorCalibBwd*)
STEP S_CHECK_ALARMS_BWD:
END_STEP

STEP S_WRITE_BWD:
AWriteBwd (P);
END_STEP

ACTION AWriteBwd: #BEGIN_EDIT_BLOCK
abSpeedMeasure.aGetMaxValues(rMaxSpeed => mrMaxVelocity,
                             rMaxPressure => mrMaxPressure,
                             bPressureLimitReached => mbPressureLimitReached,
                             bSpeedLimitReached => mbVelocityLimitReached);
IF mbprActPressureLinked THEN
   rMaxPressureBwd := MAX(rMaxPressureBwd, mrMaxPressure);
   dummy := Print('Calib min output: with act. min output %s max pressure %f needed', sWriteSpeedLimit, mrMaxPressure);       
END_IF;    
sFileName := CONCAT(sMoveName,"_MINSPEED_BWD_");
aWriteLog(sFileName := sFileName,
          iFileCounter := iFileCounter,
          bDeleteFiles := TRUE);
iFileCounter := iFileCounter + 1;

;#END_EDIT_BLOCK END_ACTION (*AWriteBwd*)
STEP S_CHECK_MINSPEED_BWD:
ACheckMinSpeedBwd (P);
END_STEP

ACTION ACheckMinSpeedBwd: #BEGIN_EDIT_BLOCK
aCalcMinSpeedOutput(rMaxSpeedLimit := mActMovement^.prVelocityLimitBwd^,
                    rActRefSpeed := rRefSpeedLimit,
                    rActMinSpeed := abSpeedMeasure.aGetMaxValues.rMaxSpeed,
                    bUnstable := abSpeedMeasure.aGetMaxValues.bSpeedLimitUnStable,
                    bTimeOut := bTimeOut);
bMinBwdDetected := aCalcMinSpeedOutput.bMinDetected;
IF (bMinBwdDetected) THEN
   rSpeedLimitBwd := aCalcMinSpeedOutput.rMinSpeed;
   dummy := Print('Calib min output %s Bwd finished: min output bwd = %f$N', sMoveName, rSpeedLimitBwd);
ELSE   
   bMinBwdRetry := TRUE;
   rRefSpeedLimit := aCalcMinSpeedOutput.rRefSpeed;
   aCalcMinSpeedOutput.bStart := FALSE;
END_IF;

mActMovement^.pConstBwdVis^ := ConstVisBwd;
mActMovement^.prVelocityBwd^ := rSpeedLimitBwd;
mActMovement^.pdMaxMoveTimeBwd^ := dMaxMoveTimeSaveBwd;


;#END_EDIT_BLOCK END_ACTION (*ACheckMinSpeedBwd*)
STEP S_ReadyMinBwdRetry:
AReadyMinBwdRetry (N);
END_STEP

ACTION AReadyMinBwdRetry: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := mActMovement^.DeviceId);

;#END_EDIT_BLOCK END_ACTION (*AReadyMinBwdRetry*)
STEP S_MinBwdRetry:
AStartMovementBwdFwd (P);
ACheckActMovementBwdFwdReady (N);
AStopMovementBwdFwd (P0);
END_STEP

ACTION AStartMovementBwdFwd: #BEGIN_EDIT_BLOCK
bMoveFwdDone := FALSE;
miErrorNo := cIdentSpeedMinBwdStart;
aStartMovementFwd();

;#END_EDIT_BLOCK END_ACTION (*AStartMovementBwdFwd*)
ACTION ACheckActMovementBwdFwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveFwdDone := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckActMovementBwdFwdReady*)
ACTION AStopMovementBwdFwd: #BEGIN_EDIT_BLOCK
aStopMovementFwd();



;#END_EDIT_BLOCK END_ACTION (*AStopMovementBwdFwd*)
STEP S_StopMoveFwd:
AStopMoveErrorFwd (P);
END_STEP

ACTION AStopMoveErrorFwd: #BEGIN_EDIT_BLOCK
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident Bwd: Fwd to start position'));

;#END_EDIT_BLOCK END_ACTION (*AStopMoveErrorFwd*)
STEP S_CHECK_ALARMS_RETRYBWD:
END_STEP

STEP S_MoveEndBwd:
AMoveEndBwd (P);
ACheckMoveEndBwdReady (N);
AMoveEndBwdReady (P0);
END_STEP

ACTION AMoveEndBwd: #BEGIN_EDIT_BLOCK
bMoveBwdDone := FALSE;

IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mrBwdStopPosition;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ - mrBwdStopPosition;
END_IF;
mActMovement^.prStopRamp^ := 1.0e10;
mActMovement^.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e20,mActMovement^.pConstBwdVis^.Pressure.Output.rRamp);
mActMovement^.pConstBwdVis^.Pressure.rMinOutput := 0.1 * rMaxPressureLimit;
mActMovement^.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveBwd; 
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := cMoveDecompAftPlast;
ELSE
   evStartRequestData.MoveId := cMoveBwd;
END_IF;
miErrorNo := cIdentSpeedMinEnd;
SET_EVENT(evStartRequest, evStartRequestData); 


;#END_EDIT_BLOCK END_ACTION (*AMoveEndBwd*)
ACTION ACheckMoveEndBwdReady: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveBwdDone := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckMoveEndBwdReady*)
ACTION AMoveEndBwdReady: #BEGIN_EDIT_BLOCK
aStopMovementBwd();

;#END_EDIT_BLOCK END_ACTION (*AMoveEndBwdReady*)
STEP S_StopMoveEndBwd:
AStopMoveErrorEndBwd (P);
END_STEP

ACTION AStopMoveErrorEndBwd: #BEGIN_EDIT_BLOCK
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident: Bwd to end position'));

;#END_EDIT_BLOCK END_ACTION (*AStopMoveErrorEndBwd*)
STEP S_Done:
ADone (P);
END_STEP

ACTION ADone: #BEGIN_EDIT_BLOCK
mActMovement^.Status := tnCalibState_Done;
sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Done;

mActMovement^.prVelocityFwd^ := rSpeedLimitFwd;
mActMovement^.prVelocityBwd^ := rSpeedLimitBwd;
IF mbprActPressureLinked THEN
   IF CHECK_REF(mActMovement^.prIdentPressureFwd^) THEN
      aRound(rActNumber := rMaxPressureFwd, rStep := rPressureStep);
      mActMovement^.prIdentPressureFwd^ := MAX(mActMovement^.prIdentPressureFwd^, aRound.rRoundedNumber * rPressureFactorFwd);
   END_IF;
   IF CHECK_REF(mActMovement^.prIdentPressureBwd^) THEN
      aRound(rActNumber := rMaxPressureBwd, rStep := rPressureStep);
      mActMovement^.prIdentPressureBwd^ := MAX(mActMovement^.prIdentPressureBwd^, aRound.rRoundedNumber * rPressureFactorBwd);
   END_IF;
END_IF;   

;#END_EDIT_BLOCK END_ACTION (*ADone*)

(* transitions *)
TRANSITION Trans47 (* Trans47 *) FROM S_RESET TO S_STOP :=  #BEGIN_EDIT_BLOCK
mbLogFileSaved
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TRestart (* TRestart *) FROM S_STOP TO S_INIT :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveStartBwd (* TMoveStartBwd *) FROM S_INIT TO S_MoveStartBwd :=  #BEGIN_EDIT_BLOCK
TRUE

;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TInitBwd (* TInitBwd *) FROM S_MoveStartBwd TO S_CHECK_ALARMS_INITBWD :=  #BEGIN_EDIT_BLOCK
bMoveBwdDone
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopMoveStartBwd (* TStopMoveStartBwd *) FROM S_MoveStartBwd TO S_StopMoveStartBwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TReset (* TReset *) FROM S_StopMoveStartBwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TStartIdent (* TStartIdent *) FROM S_CHECK_ALARMS_INITBWD TO S_INITCALIB_FWD :=  #BEGIN_EDIT_BLOCK
S_CHECK_ALARMS_INITBWD.T > T#100ms
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopInitBwd (* TStopInitBwd *) FROM S_CHECK_ALARMS_INITBWD TO S_StopMoveStartBwd :=  #BEGIN_EDIT_BLOCK
sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TDelay1 (* TDelay1 *) FROM S_INITCALIB_FWD TO S_CALIB_FWD :=  #BEGIN_EDIT_BLOCK
S_INITCALIB_FWD.T>T#100ms
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveIdentFwdDone (* TMoveIdentFwdDone *) FROM S_CALIB_FWD TO S_CHECK_ALARMS_FWD :=  #BEGIN_EDIT_BLOCK
bMoveIdentDone OR
bTimeOut OR
bStopUnstable
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopIdentFwd (* TStopIdentFwd *) FROM S_CALIB_FWD TO S_StopIdentFwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TReset1 (* TReset1 *) FROM S_StopIdentFwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TStartWriteFwd (* TStartWriteFwd *) FROM S_CHECK_ALARMS_FWD TO S_WRITE_FWD :=  #BEGIN_EDIT_BLOCK
S_CHECK_ALARMS_FWD.T > T#100ms
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopIdentFwd2 (* TStopIdentFwd2 *) FROM S_CHECK_ALARMS_FWD TO S_StopIdentFwd :=  #BEGIN_EDIT_BLOCK
sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TWriteFwd (* TWriteFwd *) FROM S_WRITE_FWD TO S_CHECK_MINSPEED_FWD :=  #BEGIN_EDIT_BLOCK
mbLogFileSaved
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TAbortedWriteFwd (* TAbortedWriteFwd *) FROM S_WRITE_FWD TO S_AbortedWriteFwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TResetAbortedWriteFwd (* TResetAbortedWriteFwd *) FROM S_AbortedWriteFwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMinFwdDetected (* TMinFwdDetected *) FROM S_CHECK_MINSPEED_FWD TO S_ReadyMinFwdDetected :=  #BEGIN_EDIT_BLOCK
bMinFwdDetected
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TReadyMinFwdDetected (* Trans49 *) FROM S_ReadyMinFwdDetected TO S_InitStartMovementBwdFwd :=  #BEGIN_EDIT_BLOCK
fbCheckReady.bReady
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans15 (* Trans15 *) FROM S_CHECK_MINSPEED_FWD TO S_ReadyMinFwdRetry :=  #BEGIN_EDIT_BLOCK
bMinFwdRetry
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TReadyMinFwdRetry (* Trans49 *) FROM S_ReadyMinFwdRetry TO S_MinFwdRetry :=  #BEGIN_EDIT_BLOCK
fbCheckReady.bReady
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveBwdDone (* TMoveBwdDone *) FROM S_MinFwdRetry TO S_CHECK_ALARMS_RETRYFWD :=  #BEGIN_EDIT_BLOCK
bMoveBwdDone
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopMoveBwd (* TStopMoveBwd *) FROM S_MinFwdRetry TO S_StopMoveBwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE

;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TReset2 (* TReset2 *) FROM S_StopMoveBwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TRetryFwd (* TRetryFwd *) FROM S_CHECK_ALARMS_RETRYFWD TO S_CALIB_FWD :=  #BEGIN_EDIT_BLOCK
S_CHECK_ALARMS_RETRYFWD.T > T#1s
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopIdentFwd4 (* TStopIdentFwd4 *) FROM S_CHECK_ALARMS_RETRYFWD TO S_StopMoveBwd :=  #BEGIN_EDIT_BLOCK
sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans35 (* Trans35 *) FROM S_InitStartMovementBwdFwd TO S_CHECK_ALARMS_STARTBWD :=  #BEGIN_EDIT_BLOCK
bMoveFwdDone
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopInitMoveFwd (* TStopInitMoveFwd *) FROM S_InitStartMovementBwdFwd TO S_StopInitMoveFwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TResetInitMoveFwd (* TResetInitMoveFwd *) FROM S_StopInitMoveFwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TStartInitBwd (* TStartInitBwd *) FROM S_CHECK_ALARMS_STARTBWD TO S_INITCALIB_BWD :=  #BEGIN_EDIT_BLOCK
S_CHECK_ALARMS_STARTBWD.T > T#100ms
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopIdentFwd3 (* TStopIdentFwd3 *) FROM S_CHECK_ALARMS_STARTBWD TO S_StopInitMoveFwd :=  #BEGIN_EDIT_BLOCK
sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TInitCalibBwd (* TInitCalibBwd *) FROM S_INITCALIB_BWD TO S_CALIB_BWD :=  #BEGIN_EDIT_BLOCK
S_INITCALIB_BWD.T>T#1s
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans14 (* Trans14 *) FROM S_CALIB_BWD TO S_CHECK_ALARMS_BWD :=  #BEGIN_EDIT_BLOCK
bMoveIdentDone OR
bTimeOut OR
bStopUnstable
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopCalibBwd (* TStopCalibBwd *) FROM S_CALIB_BWD TO S_StopCalibBwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TResetCalibBwd (* TResetCalibBwd *) FROM S_StopCalibBwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TStartWriteBwd (* TStartWriteBwd *) FROM S_CHECK_ALARMS_BWD TO S_WRITE_BWD :=  #BEGIN_EDIT_BLOCK
S_CHECK_ALARMS_BWD.T > T#100ms
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopIdentBwd2 (* TStopCalibBwd2 *) FROM S_CHECK_ALARMS_BWD TO S_StopCalibBwd :=  #BEGIN_EDIT_BLOCK
sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TWriteBwd (* TWriteBwd *) FROM S_WRITE_BWD TO S_CHECK_MINSPEED_BWD :=  #BEGIN_EDIT_BLOCK
mbLogFileSaved
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMaxBwdDetected (* TMaxBwdDetected *) FROM S_CHECK_MINSPEED_BWD TO S_MoveEndBwd :=  #BEGIN_EDIT_BLOCK
bMinBwdDetected
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMaxBwdRetry (* TMaxBwdRetry *) FROM S_CHECK_MINSPEED_BWD TO S_ReadyMinBwdRetry :=  #BEGIN_EDIT_BLOCK
bMinBwdRetry
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TReadyMinBwdRetry (* Trans49 *) FROM S_ReadyMinBwdRetry TO S_MinBwdRetry :=  #BEGIN_EDIT_BLOCK
fbCheckReady.bReady
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveFwdDone (* TMoveFwdDone *) FROM S_MinBwdRetry TO S_CHECK_ALARMS_RETRYBWD :=  #BEGIN_EDIT_BLOCK
bMoveFwdDone
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopMoveFwd (* TStopMoveFwd *) FROM S_MinBwdRetry TO S_StopMoveFwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE

;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TResetBwd (* TResetBwd *) FROM S_StopMoveFwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TRetryBwd (* TRetryBwd *) FROM S_CHECK_ALARMS_RETRYBWD TO S_CALIB_BWD :=  #BEGIN_EDIT_BLOCK
S_CHECK_ALARMS_RETRYBWD.T > T#1s
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopIdentBwd4 (* TStopIdentBwd4 *) FROM S_CHECK_ALARMS_RETRYBWD TO S_StopMoveFwd :=  #BEGIN_EDIT_BLOCK
sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveEndBwdDone (* TMoveEndBwdDone *) FROM S_MoveEndBwd TO S_Done :=  #BEGIN_EDIT_BLOCK
bMoveBwdDone
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopMoveEndBwd (* TStopMoveEndBwd *) FROM S_MoveEndBwd TO S_StopMoveEndBwd :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TResetMoveEndBwd (* TResetMoveEndBwd *) FROM S_StopMoveEndBwd TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TDone (* TDone *) FROM S_Done TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)
(* end sfc-code *)


END_ALGORITHM

POSTUPDATE_ALGORITHM pMinCommandListen ON PU_Task_7 WITH sv_GlobalIdentMinSpeedStatus.Command,sv_GlobalIdentMinSpeedStatus.bStart


VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
//stop all calibrations
// TEST
IF sv_GlobalIdentMinSpeedStatus.Command = tnCalibCommand_Stop THEN
    sv_GlobalIdentMinSpeedStatus.bStart := FALSE;
END_IF;
//
IF sv_GlobalIdentMinSpeedStatus.Command = tnCalibCommand_Stop OR (NOT sv_GlobalIdentMinSpeedStatus.bStart) THEN
    FOR i:= 1 TO cCalibMovements DO
        IF CHECK_REF(sv_GlobalIdentMinSpeedStatus.pMovements[i]^) THEN
            IF sv_GlobalIdentMinSpeedStatus.pMovements[i]^.Status = tnCalibState_Running OR
               sv_GlobalIdentMinSpeedStatus.pMovements[i]^.bRedo THEN
                sv_GlobalIdentMinSpeedStatus.pMovements[i]^.Status := tnCalibState_Aborted;
                sv_GlobalIdentMinSpeedStatus.pMovements[i]^.bRedo := FALSE;//FIXME: check if needed
                sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Aborted;
                EXIT;
            END_IF;
        END_IF;
    END_FOR;
    IF (sv_GlobalIdentMinSpeedStatus.Command = tnCalibCommand_Stop) THEN
       IF (sv_GlobalIdentMinSpeedStatus.Status <> tnCalibState_Aborted) THEN
          sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_None;
       END_IF;
       
    END_IF;
ELSIF (sv_GlobalIdentMinSpeedStatus.Command = tnCalibCommand_Start) OR (sv_GlobalIdentMinSpeedStatus.bStart) THEN
    IF sv_OperationMode = nSetup THEN
        mbUseSingleMovement := FALSE;
        START_PROCESS_ALGORITHM(paMinCalibSequence);
    ELSE
        sv_GlobalIdentMinSpeedStatus.bStart := FALSE;
        SET_ALARM(erSetupModeRequiredForCalib);
    END_IF;
END_IF;
sv_GlobalIdentMinSpeedStatus.Command := tnCalibCommand_None;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Coordinate sequential start of auto calib cycle
starts one auto calib movement after the other
*)

PROCESS_ALGORITHM paMinCalibSequence ON TaskMid


VAR_TEMP
 j : DINT;
 i : DINT;
END_VAR

VAR
 tmpMovements : tyIdentSpeedMovements;
 iMaxMovements : DINT;
 tmpM : tpIdentSpeedMovement;
 ConstBwdVis : tsVelPre;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP S_INIT:
ASortCalibs (P);
Action108 (P);
END_STEP

ACTION ASortCalibs: #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Running;
miErrorNo := 0;

tmpMovements := sv_GlobalIdentMinSpeedStatus.pMovements;

(* get number of movements *)
FOR i:= 1 TO cCalibMovements DO
    IF NOT CHECK_REF(tmpMovements[i]^)  THEN
        EXIT;
    END_IF;
END_FOR;
iMaxMovements := i -1;

(* sort them by iOrder *)
FOR i := 1 TO iMaxMovements -1 DO
    FOR j := 1 TO iMaxMovements - 1 - i +1 DO
        IF tmpMovements[j]^.iOrder > tmpMovements[j + 1]^.iOrder THEN
            tmpM := tmpMovements[j];
            tmpMovements[j] := tmpMovements[j + 1];
            tmpMovements[j + 1] := tmpM;
        END_IF;    
    END_FOR;    
END_FOR;

;#END_EDIT_BLOCK END_ACTION (*ASortCalibs*)
ACTION Action108: #BEGIN_EDIT_BLOCK
mCalibCounter := 0;
sv_GlobalIdentMinSpeedStatus.iCurrentStep := mCalibCounter;

;#END_EDIT_BLOCK END_ACTION (*Action108*)

(* steps *)
STEP S_RESET:
AReset (P);
AStopMovements (N);
AStopSelf (P);
END_STEP

ACTION AReset: #BEGIN_EDIT_BLOCK
sv_bAutoIdentRunning := FALSE;

;#END_EDIT_BLOCK END_ACTION (*AReset*)
ACTION AStopMovements: #BEGIN_EDIT_BLOCK
(* stop all identification movements *)
FOR i:= 1 TO cCalibMovements DO
    IF CHECK_REF(sv_GlobalIdentMinSpeedStatus.pMovements[i]^) THEN
        IF sv_GlobalIdentMinSpeedStatus.pMovements[i]^.Status = tnCalibState_Running OR
           sv_GlobalIdentMinSpeedStatus.pMovements[i]^.bRedo THEN
            sv_GlobalIdentMinSpeedStatus.pMovements[i]^.Status := tnCalibState_Aborted;
            sv_GlobalIdentMinSpeedStatus.pMovements[i]^.bRedo := FALSE;//FIXME: check if needed
            EXIT;
        END_IF;
    END_IF;
END_FOR;

;#END_EDIT_BLOCK END_ACTION (*AStopMovements*)
ACTION AStopSelf: #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.bStart := FALSE;
STOP_PROCESS_ALGORITHM();

;#END_EDIT_BLOCK END_ACTION (*AStopSelf*)
STEP Step74:
AAnyCoreActive (N);
END_STEP

STEP Step19:
ASignalStart (P);
END_STEP

ACTION ASignalStart: #BEGIN_EDIT_BLOCK
sv_bAutoIdentRunning := TRUE;

;#END_EDIT_BLOCK END_ACTION (*ASignalStart*)
STEP S_MoveEjectorBack:
AEjectorBack (P);
Action116 (N);
AResetEjectorBack (P0);
END_STEP

ACTION Action116: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := DeviceIdEjector)

;#END_EDIT_BLOCK END_ACTION (*Action116*)
ACTION AResetEjectorBack: #BEGIN_EDIT_BLOCK
miErrorNo := 0;
sv_EjectorIdentMinMovement.prIdentPosition^ := 0.0;
sv_EjectorIdentMinMovement.prStopRamp^ := 0.0;
sv_EjectorIdentMinMovement.pbMoveIdent^ := FALSE;
sv_EjectorIdentMinMovement.pConstBwdVis^ := ConstBwdVis;


;#END_EDIT_BLOCK END_ACTION (*AResetEjectorBack*)
STEP S_StopEjector:
AStopEjeMovement (P);
END_STEP

STEP S_MoveMoldBack:
AMoldBack (P);
Action118 (N);
AResetMoldBack (P0);
END_STEP

ACTION Action118: #BEGIN_EDIT_BLOCK
fbCheckReady(DeviceId := DeviceIdMold)

;#END_EDIT_BLOCK END_ACTION (*Action118*)
ACTION AResetMoldBack: #BEGIN_EDIT_BLOCK
miErrorNo := 0;
sv_MoldIdentMinMovement.prIdentPosition^ := 0.0;
sv_MoldIdentMinMovement.prStopRamp^ := 0.0;
sv_MoldIdentMinMovement.pbMoveIdent^ := FALSE;
sv_MoldIdentMinMovement.pConstBwdVis^ := ConstBwdVis;


;#END_EDIT_BLOCK END_ACTION (*AResetMoldBack*)
STEP S_StopMold:
AStopMoldMovement (P);
END_STEP

STEP S_CALIB_SINGLE:
AStartMovementStart (P);
END_STEP

ACTION AStartMovementStart: #BEGIN_EDIT_BLOCK
IF mCalibCounter < iMaxMovements THEN
   mCalibCounter := mCalibCounter +1;
   tmpMovements[mCalibCounter]^.bRedo := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AStartMovementStart*)
STEP S_CHECKNEXT:
END_STEP

STEP S_StopIdent:
AStopIdent (P);
END_STEP

ACTION AStopIdent: #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Done;

;#END_EDIT_BLOCK END_ACTION (*AStopIdent*)

(* transitions *)
TRANSITION Trans50 (* Trans50 *) FROM S_RESET TO S_INIT :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans80 (* Trans80 *) FROM S_INIT TO Step19 :=  #BEGIN_EDIT_BLOCK
NOT sv_bCoresActive AND
sv_iPendingAlarms = 0
;#END_EDIT_BLOCK
(*Comment : Start with moving ejector and 
mold in backward position, check if any failure 
occured. 
After that start the calibration cycle, if no alarm is 
pending*)
END_TRANSITION

GO_ON_TRANSITION Trans87 (* Trans87 *) FROM S_INIT TO Step74 :=  #BEGIN_EDIT_BLOCK
sv_bCoresActive OR 
sv_iPendingAlarms > 0

;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans88 (* Trans88 *) FROM Step74 TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE

;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans18 (* Trans18 *) FROM Step19 TO S_MoveEjectorBack :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans72 (* Trans72 *) FROM S_MoveEjectorBack TO S_MoveMoldBack :=  #BEGIN_EDIT_BLOCK
fbCheckReady.bReady AND
sv_iPendingAlarms = 0
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans83 (* Trans83 *) FROM S_MoveEjectorBack TO S_StopEjector :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans84 (* Trans84 *) FROM S_StopEjector TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE

;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans81 (* Trans81 *) FROM S_MoveMoldBack TO S_CALIB_SINGLE :=  #BEGIN_EDIT_BLOCK
fbCheckReady.bReady AND
sv_iPendingAlarms = 0
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans85 (* Trans85 *) FROM S_MoveMoldBack TO S_StopMold :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans86 (* Trans86 *) FROM S_StopMold TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TCheckActMoveReady (* TCheckActMoveReady *) FROM S_CALIB_SINGLE TO S_CHECKNEXT :=  #BEGIN_EDIT_BLOCK
tmpMovements[mCalibCounter]^.bRedo = FALSE AND
NOT(sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
    sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Error)
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TCheckError (* TCheckError *) FROM S_CALIB_SINGLE TO S_RESET :=  #BEGIN_EDIT_BLOCK
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Error OR 
iMaxMovements = 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TNextUnit (* TNextUnit *) FROM S_CHECKNEXT TO S_CALIB_SINGLE :=  #BEGIN_EDIT_BLOCK
mCalibCounter < iMaxMovements
//AND S_CHECKNEXT.T>T#3s
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TStopIdent (* TStopIdent *) FROM S_CHECKNEXT TO S_StopIdent :=  #BEGIN_EDIT_BLOCK
mCalibCounter >= iMaxMovements
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TReset (* TReset *) FROM S_StopIdent TO S_RESET :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION AEjectorBack: #BEGIN_EDIT_BLOCK
miErrorNo := cIdentSpeedMinSequence;

IF sv_EjectorIdentMinMovement.bPositionIncreasingFwd THEN
   sv_EjectorIdentMinMovement.prIdentPosition^ := mrBwdStopPosition;
ELSE
   sv_EjectorIdentMinMovement.prIdentPosition^ := sv_EjectorIdentMinMovement.prStroke^ - mrBwdStopPosition;
END_IF;
sv_EjectorIdentMinMovement.prStopRamp^ := 1.0e10;
ConstBwdVis := sv_EjectorIdentMinMovement.pConstBwdVis^;
sv_EjectorIdentMinMovement.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e10, sv_EjectorIdentMinMovement.pConstBwdVis^.Pressure.Output.rRamp);
sv_EjectorIdentMinMovement.pConstBwdVis^.Pressure.rMinOutput := 0.1 * sv_EjectorIdentMinMovement.prMaxPressureBwd^;
sv_EjectorIdentMinMovement.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := DeviceIdEjector;
evStartRequestData.MoveDir := cMoveBwd; 
evStartRequestData.MoveId := cMoveBwd;
SET_EVENT(evStartRequest, evStartRequestData);



;#END_EDIT_BLOCK END_ACTION (*AEjectorBack*)
ACTION AMoldBack: #BEGIN_EDIT_BLOCK
miErrorNo := cIdentSpeedMinSequence;

IF sv_MoldIdentMinMovement.bPositionIncreasingFwd THEN
   sv_MoldIdentMinMovement.prIdentPosition^ := mrBwdStopPosition;
ELSE
   sv_MoldIdentMinMovement.prIdentPosition^ := sv_MoldIdentMinMovement.prStroke^ - mrBwdStopPosition;
END_IF;
sv_MoldIdentMinMovement.prStopRamp^ := 1.0e10;
ConstBwdVis := sv_MoldIdentMinMovement.pConstBwdVis^;
sv_MoldIdentMinMovement.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e10, sv_MoldIdentMinMovement.pConstBwdVis^.Pressure.Output.rRamp);
sv_MoldIdentMinMovement.pConstBwdVis^.Pressure.rMinOutput := 0.1 * sv_MoldIdentMinMovement.prMaxPressureBwd^;
sv_MoldIdentMinMovement.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := DeviceIdMold;
evStartRequestData.MoveDir := cMoveBwd; 
evStartRequestData.MoveId := cMoveBwd;
SET_EVENT(evStartRequest, evStartRequestData); 


;#END_EDIT_BLOCK END_ACTION (*AMoldBack*)
ACTION AStopEjeMovement: #BEGIN_EDIT_BLOCK
evStopRequestData.DeviceId := DeviceIdEjector;  
evStopRequestData.MoveDir := cMoveBwd;  
evStopRequestData.MoveId := cMoveBwd;      
SET_EVENT(evStopRequest, evStopRequestData);
IF sv_GlobalIdentMinSpeedStatus.Status <> tnCalibState_None THEN
    sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Aborted;
END_IF;



;#END_EDIT_BLOCK END_ACTION (*AStopEjeMovement*)
ACTION AStopMoldMovement: #BEGIN_EDIT_BLOCK
evStopRequestData.DeviceId := DeviceIdMold;  
evStopRequestData.MoveDir := cMoveBwd;  
evStopRequestData.MoveId := cMoveBwd;      
SET_EVENT(evStopRequest, evStopRequestData);
IF sv_GlobalIdentMinSpeedStatus.Status <> tnCalibState_None THEN
    sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Aborted;
END_IF;



;#END_EDIT_BLOCK END_ACTION (*AStopMoldMovement*)
ACTION AAnyCoreActive: #BEGIN_EDIT_BLOCK
IF sv_bCoresActive THEN
   SET_ALARM(erCalibCoresActive);
END_IF;
sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Aborted;


;#END_EDIT_BLOCK END_ACTION (*AAnyCoreActive*)

(* exits *)

EXIT_TRANSITION E_NotSetupMode := #BEGIN_EDIT_BLOCK
sv_OperationMode <> nSetup
;#END_EDIT_BLOCK
PRIORITY 1 WITH  INITIAL_STEP S_RESET: END_STEP
END_TRANSITION
(* end sfc-code *)


END_ALGORITHM

POSTUPDATE_ALGORITHM pDataState ON PU_Task_13 WITH sv_DataState


VAR_TEMP
 i : DINT;
END_VAR

VAR
 bMDLoadingInProgress : BOOL (* loading of machine data in progress *);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//reset calib state after loading machine data

IF sv_DataState = nReadMachineData THEN
   //loading of machinedata in progress
   bMDLoadingInProgress := TRUE;
   RETURN;
END_IF;

IF sv_DataState = nReady AND bMDLoadingInProgress THEN
   FOR i := 1 TO sv_GlobalIdentMaxSpeedStatus.iMaxStep DO      
      //set state to tnCalibState_None
      sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.Status := tnCalibState_None;
   END_FOR;
   FOR i := 1 TO sv_GlobalIdentMinSpeedStatus.iMaxStep DO      
      //set state to tnCalibState_None
      sv_GlobalIdentMinSpeedStatus.pMovements[i]^.Status := tnCalibState_None;
   END_FOR;
   bMDLoadingInProgress := FALSE;
END_IF;




;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 152 @Pou 25 
@@@BEG_Comment@@@

@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
4 
@Var @RT(14)GET_SYNC_REFTO @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)SET_ALARM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)SET_EVENT @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)CHECK_REF @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
18 
@Var @RT(12)cCompEjector @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)102 @RT(17)Component Ejector 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)cCompMold @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)101 @RT(14)Component Mold 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)KSYS_Status_OK @RT(0) @T @T @DERIVED 0 @F @RT(11)KSYS_Status @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)cOptionHydraulic @RT(0) @T @F @DT @RT(5)DWORD @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(5)16#01 @RT(26)Hydraulic device, LSB is 1 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)tnCalibState_None @RT(0) @T @T @DERIVED 0 @F @RT(12)tnCalibState @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)tnCalibState_Running @RT(0) @T @T @DERIVED 0 @F @RT(12)tnCalibState @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(23)calibration in progress 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)tnCalibCommand_Stop @RT(0) @T @T @DERIVED 0 @F @RT(14)tnCalibCommand @F 
@T 
@BEG_Attrib 
0 @RT(1)2 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)tnCalibState_Aborted @RT(0) @T @T @DERIVED 0 @F @RT(12)tnCalibState @F 
@T 
@BEG_Attrib 
0 @RT(1)4 @RT(19)calibration aborted 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveFwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)12 @RT(16)movement forward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)cMoveNone @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(13)cMinMoveIdent @RT(4)None 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveBwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)11 @RT(17)movement backward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)cMoveDecompAftPlast @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)27 @RT(25)decompression after plast 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)tnCalibState_Error @RT(0) @T @T @DERIVED 0 @F @RT(12)tnCalibState @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(32)error occured during calibration 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)cCalibMovements @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)30 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)nSetup @RT(0) @T @T @DERIVED 0 @F @RT(15)tnOperationMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(36)Setup mode only for service engineer 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)tnCalibCommand_None @RT(0) @T @T @DERIVED 0 @F @RT(14)tnCalibCommand @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)tnCalibState_Done @RT(0) @T @T @DERIVED 0 @F @RT(12)tnCalibState @F 
@T 
@BEG_Attrib 
0 @RT(1)2 @RT(33)calibration finished successfully 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)tnCalibCommand_Start @RT(0) @T @T @DERIVED 0 @F @RT(14)tnCalibCommand @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(16)ABAutoIdentSpeed @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
76 
@Var @RT(28)sv_GlobalIdentMaxSpeedStatus @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(24)tsGlobalIdentSpeedStatus @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_EjectorIdentMaxMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tsIdentSpeedMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_MoldIdentMaxMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tsIdentSpeedMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(28)sv_InjectionIdentMaxMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tsIdentSpeedMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_NozzleIdentMaxMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tsIdentSpeedMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(28)sv_GlobalIdentMinSpeedStatus @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(24)tsGlobalIdentSpeedStatus @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_EjectorIdentMinMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tsIdentSpeedMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_MoldIdentMinMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tsIdentSpeedMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(28)sv_InjectionIdentMinMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tsIdentSpeedMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_NozzleIdentMinMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tsIdentSpeedMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_iPendingAlarms @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_OperationMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnOperationMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_bAutoIdentRunning @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(23)auto calibration active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_bCoresActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(11)sv_PumpData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tyPumpData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(7)TaskMid @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(8)TaskSlow @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)TaskInject @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)TaskAnalog @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)PU_Task_7 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)EV_Task_7 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(25)erCalibrationSpeedStopped @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(27)erSetupModeRequiredForCalib @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(18)erCalibCoresActive @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(24)evRedoIdentMaxSpeedStart @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tevRedoIdentSpeedEvent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(24)evRedoIdentMinSpeedStart @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tevRedoIdentSpeedEvent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(13)evStopRequest @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)tevStopRequest @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(14)evStartRequest @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tevStartRequest @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(15)DeviceIdEjector @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(33)(CompId:=cCompEjector,IndexId:=1) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)DeviceIdMold @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(30)(CompId:=cCompMold,IndexId:=1) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mActMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tpIdentSpeedMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mCalibCounter @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mbUseSingleMovement @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbCheckReady @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBCheckReady @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)evStartRequestData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tevStartRequestData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)evStopRequestData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)tevStopRequestData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)fbIdentWriteLog @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)FBIdentSpeedWriteLog @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)miFileCounter @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mbDeleteFiles @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mbLogFileSaved @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)TRUE @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)msFileName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mbRestartMeas @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)abSpeedMeasure @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(23)ABAutoIdentSpeedMeasure @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrRefVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrRefPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mrMaxLimitPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mrMinLimitPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mrMinPositionFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.2 @RT(13)20% of stroke @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mrMaxPositionFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.8 @RT(13)80% of stroke @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrMaxVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mrMaxPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mbVelocityLimitReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mbPressureLimitReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)miErrorNo @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)cIdentSpeedMaxSequence @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)100 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)cIdentSpeedMinSequence @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)200 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)cIdentSpeedMaxFwdIdent @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)101 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)cIdentSpeedMinFwdIdent @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)201 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)cIdentSpeedMaxBwdIdent @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)102 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)cIdentSpeedMinBwdIdent @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)202 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)cIdentSpeedMaxBwdInit @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)103 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)cIdentSpeedMinBwdInit @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)203 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)cIdentSpeedMaxFwdInit @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)104 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)cIdentSpeedMinFwdInit @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)204 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)cIdentSpeedMaxFwdStart @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)105 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)cIdentSpeedMinFwdStart @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)205 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)cIdentSpeedMaxBwdStart @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)106 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)cIdentSpeedMinBwdStart @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)206 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)cIdentSpeedMaxEnd @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)107 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)cIdentSpeedMinEnd @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)207 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mrBwdStopPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)0.05 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mprActPressure @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)mbprActPressureLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)PU_Task_13 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(12)sv_DataState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tnDataState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

28 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(6)paInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(7)TaskMid @T @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
7 
@Var @RT(1)j @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)k @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)Status @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSYS_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rpPosition @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(4)tmpM @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tpIdentSpeedMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)pOption @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(9)tOptionId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(13)pAlarmPending @STRUCTURED_TEXT 
@RT(0) @RT(17)sv_iPendingAlarms @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(20)fbTracePendingAlarms @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)FBTracePendingAlarms @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(8)aMeasure @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(12)rActPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(13)paMeasureFast @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(10)TaskInject @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(12)paMeasureMid @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(10)TaskAnalog @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(17)aStartMeasurement @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(16)aStopMeasurement @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(9)aWriteLog @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(9)sFileName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)file name movement @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)iFileCounter @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(24)actual ident cycle index @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)bDeleteFiles @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(16)delete old files @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(10)paWriteLog @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(17)aStartMovementFwd @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(17)aStartMovementBwd @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(16)aStopMovementFwd @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(16)aStopMovementBwd @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(18)aStopMovementError @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(13)sMovementName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(20)Movement information @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(19)aCalcMaxSpeedOutput @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
12 
@Var @RT(14)rMaxSpeedLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(36)Maximum speed limit of actual device @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)rActSpeedLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)Actual speed limit of actual device @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)rActMaxSpeed @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(22)Maximum measured speed @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)bPresLimitReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(38)Pressure limit reached during movement @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)bUsePressureMode @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(80)Use pressure to check maimum speed limit reached. Otherwise use actual  velocity @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)bMaxDetected @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(20)Speed limit detected @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(9)rRefSpeed @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(24)Speed limit for next try @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(9)rMaxSpeed @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(20)Identified max speed @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(19)rSpeedReachedFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)0.95 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rMaxActSpeed @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rMinActSpeed @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)rMinSpeedDifference @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)0.05 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(15)evaRedoMaxEvent @STRUCTURED_TEXT 
@RT(0) @RT(24)evRedoIdentMaxSpeedStart @RT(9)EV_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(20)evRedoIdentEventData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(26)tevRedoIdentSpeedEventData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(44)Event data to start max speed identification @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(9)paRedoMax @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(7)TaskMid @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(12)bIdentActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(19)paMaxSingleMovement @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(7)TaskMid @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
28 
@Var @RT(12)bMoveBwdDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)FALSE @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)bMoveFwdDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)FALSE @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)bMoveIdentDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)FALSE @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)sFileName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)iFileCounter @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(1)1 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)ConstVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)const output for ejector forward movement @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)ConstVisFwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)const output for ejector forward movement @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)ConstVisBwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)const output for ejector forward movement @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)bMaxFwdRetry @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)bMaxBwdRetry @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)bMaxFwdDetected @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)bMaxBwdDetected @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)sMoveName @RT(0) @T @F @DT @RT(10)STRING(32) @RT(0) @T @T @STRING 0 @F @RT(2)32 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)rMaxPressureLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)rRefSpeedLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)rSpeedLimitFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)rSpeedLimitBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)rMaxRefPressureLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)sWriteSpeedLimit @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)rVelocitSizeFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)1.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rStartFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.1 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rMinStopRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)1.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)rMinStrokeFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.5 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)bDelayTimeOffFwdLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)bDelayTimeOffBwdLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)dDelayTimeOffFwd @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)dDelayTimeOffBwd @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)dMinDelayTimeOff @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(6)T#25ms @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(17)pMaxCommandListen @STRUCTURED_TEXT 
@RT(0) @RT(72)sv_GlobalIdentMaxSpeedStatus.Command,sv_GlobalIdentMaxSpeedStatus.bStart @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(18)paMaxCalibSequence @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(7)TaskMid @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
6 
@Var @RT(1)j @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(12)tmpMovements @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)tyIdentSpeedMovements @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)iMaxMovements @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(4)tmpM @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tpIdentSpeedMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)ConstBwdVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(6)aRound @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
4 
@Var @RT(10)rActNumber @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(5)rStep @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)rRoundedNumber @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)rRealValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(19)aCalcMinSpeedOutput @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
12 
@Var @RT(6)bStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(58)Restart calculation of reference for min speed calibration @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)rMaxSpeedLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(36)Maximum speed limit of actual device @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)rActRefSpeed @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)Actual speed limit of actual device @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)rActMinSpeed @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(22)Minimum measured speed @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)bUnstable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(23)Measured speed unstable @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)bTimeOut @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)Timeout during movement aof actual device @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)bMinDetected @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(20)Speed limit detected @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(9)rRefSpeed @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(24)Speed limit for next try @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(9)rMinSpeed @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(21)Identified min output @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(12)rMaxRefSpeed @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rMinRefSpeed @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)rMFactorMaxMinLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.2 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(9)paRedoMin @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(7)TaskMid @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(12)bIdentActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(15)evaRedoMinEvent @STRUCTURED_TEXT 
@RT(0) @RT(24)evRedoIdentMinSpeedStart @RT(9)EV_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(20)evRedoIdentEventData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(26)tevRedoIdentSpeedEventData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(44)Event data to start min speed identification @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(19)paMinSingleMovement @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(7)TaskMid @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
39 
@Var @RT(12)bMoveBwdDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)FALSE @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)bMoveFwdDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)FALSE @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)bMoveIdentDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)FALSE @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)sFileName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)iFileCounter @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(1)1 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)ConstVisFwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)const output for ejector forward movement @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)ConstVisBwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)const output for ejector forward movement @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)bMinFwdRetry @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)bMinBwdRetry @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)bMinFwdDetected @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)bMinBwdDetected @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)sMoveName @RT(0) @T @F @DT @RT(10)STRING(32) @RT(0) @T @T @STRING 0 @F @RT(2)32 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)rMaxPressureLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(5)150.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)rRefSpeedLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)rSpeedLimitFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)rSpeedLimitBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)bTimeOut @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)bStopUnstable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)dMaxMoveTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)dMaxMoveTimeSaveFwd @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)dMaxMoveTimeSaveBwd @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)TimeOut @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)TON @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)rMoveStrokeTime @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rStartFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.1 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)rMaxRefPressureLimit @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)sWriteSpeedLimit @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)dMoveTimeLimit @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)T#2m @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)bMoveTimeLimited @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)dMoveTimeOffset @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)T#5s @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)rStartPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)rMinMovementPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)rVelocitSizeFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)1.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rMinStopRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)1.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)rMinStrokeFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)2.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)rMaxPressureFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)rMaxPressureBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)rPressureFactorFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)rPressureFactorBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)rPressureStep @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)5.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(17)pMinCommandListen @STRUCTURED_TEXT 
@RT(0) @RT(72)sv_GlobalIdentMinSpeedStatus.Command,sv_GlobalIdentMinSpeedStatus.bStart @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(18)paMinCalibSequence @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(7)TaskMid @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
6 
@Var @RT(1)j @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(12)tmpMovements @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)tyIdentSpeedMovements @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)iMaxMovements @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(4)tmpM @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tpIdentSpeedMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)ConstBwdVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(10)pDataState @STRUCTURED_TEXT 
@RT(0) @RT(12)sv_DataState @RT(10)PU_Task_13 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(20)bMDLoadingInProgress @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)loading of machine data in progress @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(62)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

i := 1;

rpPosition := GET_SYNC_REFTO('Ejector1.ai_Position', T#0s, Status);
IF Status = KSYS_Status_OK THEN
    sv_GlobalIdentMaxSpeedStatus.pMovements[i] := @sv_EjectorIdentMaxMovement;
    sv_GlobalIdentMinSpeedStatus.pMovements[i] := @sv_EjectorIdentMinMovement;
    i := i + 1; 
END_IF;

sv_GlobalIdentMaxSpeedStatus.pMovements[i] := @sv_MoldIdentMaxMovement;
sv_GlobalIdentMinSpeedStatus.pMovements[i] := @sv_MoldIdentMinMovement;
i := i + 1; 

pOption := GET_SYNC_REFTO('Nozzle1.sv_Options', T#0s, Status);
IF (Status = KSYS_Status_OK) AND ((pOption^ AND cOptionHydraulic) = cOptionHydraulic) THEN;
    //hydraulic nozzle -> check if ai_Position is available
    rpPosition := GET_SYNC_REFTO('Nozzle1.ai_Position', T#0s, Status);
    IF Status = KSYS_Status_OK THEN
        sv_GlobalIdentMaxSpeedStatus.pMovements[i] := @sv_NozzleIdentMaxMovement;
        sv_GlobalIdentMinSpeedStatus.pMovements[i] := @sv_NozzleIdentMinMovement;
        i := i + 1; 
    END_IF;
END_IF;

sv_GlobalIdentMaxSpeedStatus.pMovements[i] := @sv_InjectionIdentMaxMovement;
sv_GlobalIdentMinSpeedStatus.pMovements[i] := @sv_InjectionIdentMinMovement;
i := i + 1; 

(* sort them by iOrder *)
FOR k := 1 TO i - 2 DO
    FOR j := 1 TO i - 1 - k DO
        IF sv_GlobalIdentMaxSpeedStatus.pMovements[j]^.iOrder > sv_GlobalIdentMaxSpeedStatus.pMovements[j + 1]^.iOrder THEN
            tmpM := sv_GlobalIdentMaxSpeedStatus.pMovements[j];
            sv_GlobalIdentMaxSpeedStatus.pMovements[j] := sv_GlobalIdentMaxSpeedStatus.pMovements[j + 1];
            sv_GlobalIdentMaxSpeedStatus.pMovements[j + 1] := tmpM;
            tmpM := sv_GlobalIdentMinSpeedStatus.pMovements[j];
            sv_GlobalIdentMinSpeedStatus.pMovements[j] := sv_GlobalIdentMinSpeedStatus.pMovements[j + 1];
            sv_GlobalIdentMinSpeedStatus.pMovements[j + 1] := tmpM;
        END_IF;    
    END_FOR;    
END_FOR;

sv_GlobalIdentMaxSpeedStatus.iMaxStep := i - 1;
sv_GlobalIdentMinSpeedStatus.iMaxStep := i - 1;

sv_GlobalIdentMaxSpeedStatus.iCurrentStep := 0;
sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_None;
sv_GlobalIdentMaxSpeedStatus.bInitDone := TRUE;

sv_GlobalIdentMinSpeedStatus.iCurrentStep := 0;
sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_None;
sv_GlobalIdentMinSpeedStatus.bInitDone := TRUE;

STOP_PROCESS_ALGORITHM();



@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(20)
IF ((sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Running) OR (sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Running)) AND 
    (sv_iPendingAlarms <> 0) THEN
   
   dummy := Print('auto max. speed identification stopped because alarms of class 1/2/3 pending');
   
   //trace all pending alarms
   fbTracePendingAlarms();
   
   IF (sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Running) THEN
      sv_GlobalIdentMaxSpeedStatus.Command := tnCalibCommand_Stop;
      sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Aborted;
   ELSE
      sv_GlobalIdentMinSpeedStatus.Command := tnCalibCommand_Stop;
      sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Aborted;
   END_IF;

   SET_ALARM(Name := erCalibrationSpeedStopped,
             Param1 := miErrorNo);
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(15)
IF mbprActPressureLinked THEN
   rActPressure := mprActPressure^;
ELSE
   rActPressure := 0.0;
END_IF;
abSpeedMeasure.aMeasure(bRestart := mbRestartMeas,
                        rPosition := mActMovement^.prPosition^,
                        rRefVelocity := mrRefVelocity,
                        rActVelocity := mActMovement^.prActVelocity^,
                        rRefPressure := mrRefPressure,
                        rActPressure := rActPressure,
                        rMaxLimitPosition := mrMaxLimitPosition,
                        rMinLimitPosition := mrMinLimitPosition);
mbRestartMeas := FALSE;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(2)
aMeasure();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(2)
aMeasure();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(5)
mbRestartMeas := TRUE;
abSpeedMeasure.aReset();
abSpeedMeasure.aMeasure(bRestart := TRUE);
START_PROCESS_ALGORITHM(paMeasureMid);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(4)
STOP_PROCESS_ALGORITHM(paMeasureMid);
abSpeedMeasure.aCloseMeasure();


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(7)
mbLogFileSaved := FALSE;
msFileName := sFileName;
miFileCounter := iFileCounter;
mbDeleteFiles := bDeleteFiles;

START_PROCESS_ALGORITHM(paWriteLog);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(14)
fbIdentWriteLog(sFileName    := msFileName,
                iFileCounter := miFileCounter,
                bDeleteFiles := mbDeleteFiles,
                rMaxVelocity := mrMaxVelocity,
                rMaxPressure := mrMaxPressure,
                bVelocityLimitReached := mbVelocityLimitReached,
                bPressureLimitReached := mbPressureLimitReached);
IF fbIdentWriteLog.bDone THEN
   mbLogFileSaved := TRUE;
ELSE   
   mbLogFileSaved := FALSE;
END_IF;
STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(18)
IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMaxPositionFactor;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMinPositionFactor;
END_IF;
mActMovement^.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveFwd;
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := mActMovement^.MoveId;   
ELSE
   evStartRequestData.MoveId := cMoveFwd;
END_IF;

SET_EVENT(evStartRequest, evStartRequestData); 


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(18)
IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMinPositionFactor;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMaxPositionFactor;
END_IF;
mActMovement^.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveBwd; 
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := cMoveDecompAftPlast;
ELSE
   evStartRequestData.MoveId := cMoveBwd;
END_IF;

SET_EVENT(evStartRequest, evStartRequestData); 


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(11)
evStopRequestData.DeviceId := mActMovement^.DeviceId;
evStopRequestData.MoveDir := cMoveFwd; 
evStopRequestData.MoveId := cMoveFwd;
SET_EVENT(evStopRequest, evStopRequestData);
mActMovement^.pbMoveIdent^ := FALSE;
mActMovement^.prIdentPosition^ := 0.0;
mActMovement^.prStopRamp^ := 0.0;




@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(14)
evStopRequestData.DeviceId := mActMovement^.DeviceId;
evStopRequestData.MoveDir := cMoveBwd; 
IF mActMovement^.MoveId > cMoveNone THEN
   evStopRequestData.MoveId := cMoveDecompAftPlast;
ELSE
   evStopRequestData.MoveId := cMoveBwd;
END_IF;
SET_EVENT(evStopRequest, evStopRequestData);
mActMovement^.pbMoveIdent^ := FALSE;
mActMovement^.prIdentPosition^ := 0.0;
mActMovement^.prStopRamp^ := 0.0;



@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(7)
sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Aborted;
mActMovement^.Status := tnCalibState_Error;

dummy := Print('Calib movement "%s" aborted.', sMovementName);



@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(63)
IF (bUsePressureMode) THEN
   IF (rMaxActSpeed = 0.0) THEN
      rMaxActSpeed := rMaxSpeedLimit;
   END_IF;
   IF (bPresLimitReached) THEN
      // reduce refernce value
      rMaxActSpeed := rActSpeedLimit;
      IF (ABS(rMaxActSpeed - rMinActSpeed) < rMinSpeedDifference * rMaxSpeedLimit) THEN
         bMaxDetected := TRUE;
         rMaxSpeed := rMinActSpeed;
         rMinActSpeed := 0.0;
         rMaxActSpeed := 0.0;
      ELSE   
         bMaxDetected := FALSE;
         rRefSpeed := 0.5 * (rMaxActSpeed + rMinActSpeed);
      END_IF;   
   ELSE
      // ccompare with old value
      IF (rActSpeedLimit = rMaxSpeedLimit) THEN // maximum used at start
         // maximum with tolerance reached   
         bMaxDetected := TRUE;
         rMaxSpeed := rMaxSpeedLimit;
         rMinActSpeed := 0.0;
         rMaxActSpeed := 0.0;
      ELSE
         // increase
         rMinActSpeed := rActSpeedLimit;
         IF (ABS(rMaxActSpeed - rMinActSpeed) < rMinSpeedDifference * rMaxSpeedLimit) THEN
            bMaxDetected := TRUE;
            rMaxSpeed := rMinActSpeed;
            rMinActSpeed := 0.0;
            rMaxActSpeed := 0.0;
         ELSE
            rRefSpeed := 0.5 * (rMaxActSpeed + rMinActSpeed);
         END_IF;
      END_IF;
   END_IF;   
ELSE
   IF (rActSpeedLimit = rMaxSpeedLimit) THEN // maximum used at start
      IF (rActMaxSpeed > rSpeedReachedFactor * rActSpeedLimit)  THEN
      // maximum with tolerance reached   
         bMaxDetected := TRUE;
         rMaxSpeed := rMaxSpeedLimit;
      ELSE
      // actual speed lower than maximum with tolerance
         bMaxDetected := FALSE;
         rRefSpeed := rActMaxSpeed;
         rMaxActSpeed := rActMaxSpeed;
      END_IF;
   ELSE
      IF (rActMaxSpeed > rSpeedReachedFactor * rActSpeedLimit) THEN
      // reference speed with tolerance reached
         bMaxDetected := TRUE;
         rMaxSpeed := rRefSpeed;
      ELSE
      // actual speed lower than reference speed with tolerance reached
      // check calibration of pump/valve   
         bMaxDetected := TRUE;
         rMaxSpeed := rRefSpeed;
      END_IF;
   END_IF;   
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(4)

START_PROCESS_ALGORITHM(paRedoMax);


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(26)
bIdentActive := FALSE;
FOR i:= 1 TO cCalibMovements DO
   IF CHECK_REF(sv_GlobalIdentMaxSpeedStatus.pMovements[i]^) THEN
      IF sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.bRedo THEN
         mActMovement := sv_GlobalIdentMaxSpeedStatus.pMovements[i];
         bIdentActive := TRUE;
         sv_GlobalIdentMaxSpeedStatus.iCurrentStep :=  i;
         mCalibCounter := i;
         IF sv_OperationMode = nSetup THEN
            mbUseSingleMovement := TRUE;
            START_PROCESS_ALGORITHM(paMaxSingleMovement);
         ELSE
            sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.bRedo := FALSE;
            SET_ALARM(erSetupModeRequiredForCalib);
         END_IF;
         EXIT;
      END_IF;
   END_IF;
END_FOR;
IF ((NOT bIdentActive) AND (sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Running)) THEN
   sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Aborted;
END_IF;
       

STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
42 49 48 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 39 
@Step @RT(7)S_RESET @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@Trans @RT(7)Trans47 @F @T @F @F @T @T @TL(2)
mbLogFileSaved

@RT(7)Trans47 @F 
@Step @RT(6)S_STOP @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(9)AStopSelf @F @T @RT(1)P @RT(0) @F @F @T @TL(12)
sv_GlobalIdentMaxSpeedStatus.Command := tnCalibCommand_None;
sv_bAutoIdentRunning := FALSE;
mActMovement^.bRedo := FALSE;
mActMovement^.prStopRamp^ := 0.0;
mActMovement^.pConstFwdVis^ := ConstVisFwd;
mActMovement^.pConstBwdVis^ := ConstVisBwd;

//release memory
abSpeedMeasure.aEnd();

STOP_PROCESS_ALGORITHM();

@F 

@Trans @RT(8)TRestart @F @T @F @F @T @T @TL(2)
TRUE

@RT(8)TRestart @F 
@Step @RT(6)S_INIT @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(7)Action3 @F @T @RT(1)P @RT(0) @F @F @T @TL(43)
miErrorNo := 0;

ConstVisFwd := mActMovement^.pConstFwdVis^;
ConstVisBwd := mActMovement^.pConstBwdVis^;

sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Running;
mActMovement^.Status := tnCalibState_Running;
sMoveName := mActMovement^.sName;

abSpeedMeasure.aInit();

bMaxFwdRetry := FALSE;
bMaxBwdRetry := FALSE;

IF (mActMovement^.rMaxPositionLimitFactor > mActMovement^.rMinPositionLimitFactor) AND
   (mActMovement^.rMinPositionLimitFactor > 0.0) AND (mActMovement^.rMaxPositionLimitFactor < 1.0) THEN
   mrMaxPositionFactor := mActMovement^.rMaxPositionLimitFactor;
   mrMinPositionFactor := mActMovement^.rMinPositionLimitFactor;
ELSE // use deafult values
   mrMaxPositionFactor := 0.8;
   mrMinPositionFactor := 0.2;
END_IF;

mprActPressure := sv_PumpData[mActMovement^.DeviceId.IndexId].prActSysPressure;
IF CHECK_REF(mprActPressure^) THEN
   mbprActPressureLinked := TRUE;
ELSE
   mbprActPressureLinked := FALSE;
END_IF;

IF CHECK_REF(mActMovement^.pdDelayTimeOffFwd^) THEN
   bDelayTimeOffFwdLinked := TRUE;
   dDelayTimeOffFwd := mActMovement^.pdDelayTimeOffFwd^;
ELSE
   bDelayTimeOffFwdLinked := FALSE;
END_IF;
IF CHECK_REF(mActMovement^.pdDelayTimeOffBwd^) THEN
   bDelayTimeOffBwdLinked := TRUE;
   dDelayTimeOffBwd := mActMovement^.pdDelayTimeOffBwd^;
ELSE
   bDelayTimeOffBwdLinked := FALSE;
END_IF;

@F 

@Trans @RT(13)TMoveStartBwd @F @T @F @F @T @T @TL(3)
TRUE


@RT(13)TMoveStartBwd @F 
@Step @RT(14)S_MoveStartBwd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(13)AMoveStartBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(4)
bMoveBwdDone := FALSE;
miErrorNo := cIdentSpeedMaxBwdInit;
aStartMovementBwd();

@F 
@Acb @RT(23)ACheckMoveStartBwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveBwdDone := TRUE;
END_IF;

@F 
@Acb @RT(18)AMoveStartBwdReady @F @T @RT(2)P0 @RT(0) @F @F @T @TL(2)
aStopMovementBwd();

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(8)TInitBwd @F @T @F @F @T @T @TL(2)
bMoveBwdDone

@RT(8)TInitBwd @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(17)TStopMoveStartBwd @F @T @F @F @T @F @TL(5)
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE

@RT(17)TStopMoveStartBwd @F 
@Step @RT(18)S_StopMoveStartBwd @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(17)AStopMoveStartBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Fwd: Bwd to initial position'));

@F 

@Trans @RT(6)TReset @F @T @F @F @T @F @TL(2)
TRUE

@RT(6)TReset @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(22)S_CHECK_ALARMS_INITBWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(11)TStartIdent @F @T @F @F @T @T @TL(2)
S_CHECK_ALARMS_INITBWD.T > T#100ms

@RT(11)TStartIdent @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(12)TStopInitBwd @F @T @F @F @T @F @TL(2)
sv_iPendingAlarms <> 0

@RT(12)TStopInitBwd @F 
@Goto @RT(18)S_StopMoveStartBwd @F @F 


@Step @RT(15)S_INITCALIB_FWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(13)aInitIdentFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(18)
iFileCounter := 1;
IF (CHECK_REF(mActMovement^.prSizeFactorFwd^)) THEN
   IF (mActMovement^.prSizeFactorFwd^ > 0.0) THEN
      rVelocitSizeFactor := mActMovement^.prSizeFactorFwd^;        
   END_IF;
ELSE
   rVelocitSizeFactor := 1.0;
END_IF;
rRefSpeedLimit := mActMovement^.prVelocityLimitFwd^;
rMaxPressureLimit := mActMovement^.prMaxPressureFwd^;
IF CHECK_REF(mActMovement^.prMaxPressureFwdHydr^) THEN
   rMaxRefPressureLimit := mActMovement^.prMaxPressureFwdHydr^;
ELSE   
   rMaxRefPressureLimit := rMaxPressureLimit;
END_IF; 

dummy := Print('Calib max speed %s Fwd started', sMoveName);

@F 

@Trans @RT(7)TDelay1 @F @T @F @F @T @T @TL(2)
S_INITCALIB_FWD.T>T#1s

@RT(7)TDelay1 @F 
@Step @RT(11)S_CALIB_FWD @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 4 
@Acb @RT(8)ADoCalib @F @T @RT(1)P @RT(0) @F @F @T @TL(52)
(* start calibration *)
// save actual settings
ConstVis := mActMovement^.pConstFwdVis^;

mActMovement^.pConstFwdVis^.Velocity.Output.rOutputValue := rRefSpeedLimit * rVelocitSizeFactor;
mActMovement^.pConstFwdVis^.Velocity.rMinOutput := 0.0;
mActMovement^.pConstFwdVis^.Pressure.Output.rOutputValue := MAX(mActMovement^.pConstFwdVis^.Pressure.Output.rOutputValue, rMaxPressureLimit);
mActMovement^.pConstFwdVis^.Pressure.Output.rRamp := MAX(1.0e9,ConstVis.Pressure.Output.rRamp);
IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMaxPositionFactor;
   mrMinLimitPosition := rStartFactor * mActMovement^.prIdentPosition^ + (1.0 - rStartFactor) * mActMovement^.prPosition^;
   IF (mActMovement^.prIdentPosition^ - mActMovement^.prPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit  * rRefSpeedLimit/ ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstFwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMaxLimitPosition := mActMovement^.prIdentPosition^;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMinPositionFactor;
   mrMaxLimitPosition := (1.0 - rStartFactor) * mActMovement^.prPosition^ + rStartFactor * mActMovement^.prIdentPosition^;
   IF (mActMovement^.prPosition^ - mActMovement^.prIdentPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstFwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMinLimitPosition := mActMovement^.prIdentPosition^;
END_IF;
mActMovement^.pbMoveIdent^ := TRUE;
bMoveIdentDone := FALSE;

bMaxFwdDetected := FALSE;

mrRefVelocity := rRefSpeedLimit;
mrRefPressure := rMaxRefPressureLimit;
mbRestartMeas := TRUE;

IF bDelayTimeOffFwdLinked THEN
   mActMovement^.pdDelayTimeOffFwd^ := MAX(mActMovement^.pdDelayTimeOffFwd^, dMinDelayTimeOff);
END_IF;
IF bDelayTimeOffBwdLinked THEN
   mActMovement^.pdDelayTimeOffBwd^ := MAX(mActMovement^.pdDelayTimeOffBwd^, dMinDelayTimeOff);
END_IF;

aStartMeasurement();

sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
dummy := Print('Calib max output: act. max speed: %s', sWriteSpeedLimit);
miErrorNo := cIdentSpeedMaxFwdIdent;


@F 
@Acb @RT(17)AStartMovementFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(9)
evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveFwd;
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := mActMovement^.MoveId;   
ELSE
   evStartRequestData.MoveId := cMoveFwd;
END_IF;
SET_EVENT(evStartRequest, evStartRequestData); 

@F 
@Acb @RT(25)ACheckActMovementFwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveIdentDone := TRUE;      
END_IF;

@F 
@Acb @RT(16)AStopMovementFwd @F @T @RT(2)P0 @RT(0) @F @F @T @TL(15)
aStopMeasurement();
aStopMovementFwd();

mActMovement^.pConstFwdVis^ := ConstVis;
mActMovement^.prStopRamp^ := 0.0;

IF bDelayTimeOffFwdLinked THEN
   mActMovement^.pdDelayTimeOffFwd^ := dDelayTimeOffFwd;
END_IF;
IF bDelayTimeOffBwdLinked THEN
   mActMovement^.pdDelayTimeOffBwd^ := dDelayTimeOffBwd;
END_IF;



@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(17)TMoveIdentFwdDone @F @T @F @F @T @T @TL(2)
bMoveIdentDone

@RT(17)TMoveIdentFwdDone @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(13)TStopIdentFwd @F @T @F @F @T @F @TL(5)
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE

@RT(13)TStopIdentFwd @F 
@Step @RT(14)S_StopIdentFwd @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(13)AStopIdentFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Fwd'));

@F 

@Trans @RT(7)TReset1 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)TReset1 @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(18)S_CHECK_ALARMS_FWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(14)TStartWriteFwd @F @T @F @F @T @T @TL(2)
S_CHECK_ALARMS_FWD.T > T#100ms

@RT(14)TStartWriteFwd @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(14)TStopIdentFwd2 @F @T @F @F @T @F @TL(2)
sv_iPendingAlarms <> 0

@RT(14)TStopIdentFwd2 @F 
@Goto @RT(14)S_StopIdentFwd @F @F 


@Step @RT(11)S_WRITE_FWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(9)AWriteFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(11)
abSpeedMeasure.aGetMaxValues(rMaxSpeed => mrMaxVelocity,
                             rMaxPressure => mrMaxPressure,
                             bPressureLimitReached => mbPressureLimitReached,
                             bSpeedLimitReached => mbVelocityLimitReached);
sFileName := CONCAT(sMoveName,"_MAXSPEED_FWD_");
aWriteLog(sFileName := sFileName,
          iFileCounter := iFileCounter,
          bDeleteFiles := TRUE);
iFileCounter := iFileCounter + 1;


@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(9)TWriteFwd @F @T @F @F @T @T @TL(2)
mbLogFileSaved

@RT(9)TWriteFwd @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(16)TAbortedWriteFwd @F @T @F @F @T @F @TL(2)
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted

@RT(16)TAbortedWriteFwd @F 
@Step @RT(17)S_AbortedWriteFwd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(16)AAbortedWriteFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
mActMovement^.Status := tnCalibState_Error;


@F 

@Trans @RT(21)TResetAbortedWriteFwd @F @T @F @F @T @F @TL(2)
TRUE

@RT(21)TResetAbortedWriteFwd @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(20)S_CHECK_MAXSPEED_FWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(17)ACheckMaxSpeedFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(18)
aCalcMaxSpeedOutput(rMaxSpeedLimit := mActMovement^.prVelocityLimitFwd^,
                    rActSpeedLimit := rRefSpeedLimit,
                    rActMaxSpeed := abSpeedMeasure.aGetMaxValues.rMaxSpeed,
                    bPresLimitReached := abSpeedMeasure.aGetMaxValues.bPressureLimitReached,
                    bUsePressureMode := (mrMaxPressure > 0.0));
bMaxFwdDetected := aCalcMaxSpeedOutput.bMaxDetected;
IF (bMaxFwdDetected) THEN
   rSpeedLimitFwd := rRefSpeedLimit;
   dummy := Print('Calib max output %s Fwd finished: max speed fwd = %f$N', sMoveName, rSpeedLimitFwd);         
ELSE   
   IF abSpeedMeasure.aGetMaxValues.bPressureLimitReached THEN
      sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
      dummy := Print('Calib max output: pressure limit reached with act. max speed %s', sWriteSpeedLimit);
   END_IF;
   bMaxFwdRetry := TRUE;
   rRefSpeedLimit := aCalcMaxSpeedOutput.rRefSpeed;   
END_IF;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(15)TMaxFwdDetected @F @T @F @F @T @T @TL(2)
bMaxFwdDetected

@RT(15)TMaxFwdDetected @F 

@TransSeq @RT(4)tseq @F 6 
@Trans @RT(7)Trans15 @F @T @F @F @T @T @TL(2)
bMaxFwdRetry

@RT(7)Trans15 @F 
@Step @RT(13)S_MaxFwdRetry @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(20)AStartMovementFwdBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(4)
bMoveBwdDone := FALSE;
miErrorNo := cIdentSpeedMaxFwdStart;
aStartMovementBwd();

@F 
@Acb @RT(28)ACheckActMovementFwdBwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveBwdDone := TRUE;
END_IF;

@F 
@Acb @RT(19)AStopMovementFwdBwd @F @T @RT(2)P0 @RT(0) @F @F @T @TL(2)
aStopMovementBwd();

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(12)TMoveBwdDone @F @T @F @F @T @T @TL(2)
bMoveBwdDone

@RT(12)TMoveBwdDone @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(12)TStopMoveBwd @F @T @F @F @T @F @TL(6)
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE


@RT(12)TStopMoveBwd @F 
@Step @RT(13)S_StopMoveBwd @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(12)AStopMoveBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Fwd: Bwd to start position'));

@F 

@Trans @RT(7)TReset2 @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)TReset2 @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(23)S_CHECK_ALARMS_RETRYFWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(9)TRetryFwd @F @T @F @F @T @T @TL(2)
S_CHECK_ALARMS_RETRYFWD.T > T#1s

@RT(9)TRetryFwd @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(14)TStopIdentFwd4 @F @T @F @F @T @F @TL(2)
sv_iPendingAlarms <> 0

@RT(14)TStopIdentFwd4 @F 
@Goto @RT(13)S_StopMoveBwd @F @F 


@Goto @RT(11)S_CALIB_FWD @F @F 


@Step @RT(25)S_InitStartMovementBwdFwd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(24)AInitStartMovementBwdFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(4)
bMoveFwdDone := FALSE;
miErrorNo := cIdentSpeedMaxFwdInit;
aStartMovementFwd();

@F 
@Acb @RT(29)ACheckInitMovementBwdFwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveFwdDone := TRUE;
END_IF;

@F 
@Acb @RT(23)AStopInitMovementBwdFwd @F @T @RT(2)P0 @RT(0) @F @F @T @TL(2)
aStopMovementFwd();

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans35 @F @T @F @F @T @T @TL(2)
bMoveFwdDone

@RT(7)Trans35 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(16)TStopInitMoveFwd @F @T @F @F @T @F @TL(5)
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE

@RT(16)TStopInitMoveFwd @F 
@Step @RT(17)S_StopInitMoveFwd @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(16)AStopInitMoveFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Bwd: Fwd to initial position'));

@F 

@Trans @RT(17)TResetInitMoveFwd @F @T @F @F @T @T @TL(2)
TRUE

@RT(17)TResetInitMoveFwd @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(23)S_CHECK_ALARMS_STARTBWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(13)TStartInitBwd @F @T @F @F @T @T @TL(2)
S_CHECK_ALARMS_STARTBWD.T > T#100ms

@RT(13)TStartInitBwd @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(14)TStopIdentFwd3 @F @T @F @F @T @F @TL(2)
sv_iPendingAlarms <> 0

@RT(14)TStopIdentFwd3 @F 
@Goto @RT(17)S_StopInitMoveFwd @F @F 


@Step @RT(15)S_INITCALIB_BWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(13)AInitCalibBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(19)
iFileCounter := 1;
IF (CHECK_REF(mActMovement^.prSizeFactorBwd^)) THEN
   IF (mActMovement^.prSizeFactorBwd^ > 0.0) THEN
      rVelocitSizeFactor := mActMovement^.prSizeFactorBwd^;        
   END_IF;
ELSE
   rVelocitSizeFactor := 1.0;
END_IF;
rRefSpeedLimit := mActMovement^.prVelocityLimitBwd^;
rMaxPressureLimit := mActMovement^.prMaxPressureBwd^;
IF CHECK_REF(mActMovement^.prMaxPressureBwdHydr^) THEN
   rMaxRefPressureLimit := mActMovement^.prMaxPressureBwdHydr^;
ELSE   
   rMaxRefPressureLimit := mActMovement^.prMaxPressureFwd^;
END_IF; 

dummy := Print('Calib max speed %s Bwd started', sMoveName);


@F 

@Trans @RT(13)TInitCalibBwd @F @T @F @F @T @T @TL(2)
S_INITCALIB_BWD.T>T#1s

@RT(13)TInitCalibBwd @F 
@Step @RT(11)S_CALIB_BWD @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 4 
@Acb @RT(11)ADoCalibBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(50)
ConstVis := mActMovement^.pConstBwdVis^;

mActMovement^.pConstBwdVis^.Velocity.Output.rOutputValue := rRefSpeedLimit * rVelocitSizeFactor;
mActMovement^.pConstBwdVis^.Velocity.rMinOutput := 0.0;
mActMovement^.pConstBwdVis^.Pressure.Output.rOutputValue := MAX(mActMovement^.pConstBwdVis^.Pressure.Output.rOutputValue, rMaxPressureLimit);
mActMovement^.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e9,ConstVis.Pressure.Output.rRamp);
IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMinPositionFactor;
   mrMaxLimitPosition := rStartFactor * mActMovement^.prIdentPosition^ + (1.0 - rStartFactor) * mActMovement^.prPosition^;
   rMinStopRamp := rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   IF (mActMovement^.prPosition^ - mActMovement^.prIdentPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstBwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMinLimitPosition := mActMovement^.prIdentPosition^;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMaxPositionFactor;
   mrMinLimitPosition := rStartFactor * mActMovement^.prPosition^ + (1.0 - rStartFactor) * mActMovement^.prIdentPosition^;
   IF (mActMovement^.prIdentPosition^ - mActMovement^.prPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstBwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMaxLimitPosition := mActMovement^.prIdentPosition^;
END_IF;
mActMovement^.pbMoveIdent^ := TRUE;

bMoveIdentDone := FALSE;

mrRefVelocity := rRefSpeedLimit;
mrRefPressure := rMaxRefPressureLimit;
mbRestartMeas := TRUE;

IF bDelayTimeOffFwdLinked THEN
   mActMovement^.pdDelayTimeOffFwd^ := MAX(mActMovement^.pdDelayTimeOffFwd^, dMinDelayTimeOff);
END_IF;
IF bDelayTimeOffBwdLinked THEN
   mActMovement^.pdDelayTimeOffBwd^ := MAX(mActMovement^.pdDelayTimeOffBwd^, dMinDelayTimeOff);
END_IF;

aStartMeasurement();

sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
dummy := Print('Calib max output: act. max speed: %s', sWriteSpeedLimit);
miErrorNo := cIdentSpeedMaxBwdIdent;


@F 
@Acb @RT(17)AStartMovementBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(9)
evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveBwd;
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := cMoveDecompAftPlast;
ELSE
   evStartRequestData.MoveId := cMoveBwd;
END_IF;
SET_EVENT(evStartRequest, evStartRequestData); 

@F 
@Acb @RT(25)ACheckActMovementBwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveIdentDone := TRUE;      
END_IF;

@F 
@Acb @RT(16)AStopMovementBwd @F @T @RT(2)P0 @RT(0) @F @F @T @TL(15)
aStopMeasurement();
aStopMovementBwd();

mActMovement^.pConstBwdVis^ := ConstVis;
mActMovement^.prStopRamp^ := 0.0;

IF bDelayTimeOffFwdLinked THEN
   mActMovement^.pdDelayTimeOffFwd^ := dDelayTimeOffFwd;
END_IF;
IF bDelayTimeOffBwdLinked THEN
   mActMovement^.pdDelayTimeOffBwd^ := dDelayTimeOffBwd;
END_IF;



@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans14 @F @T @F @F @T @T @TL(2)
bMoveIdentDone

@RT(7)Trans14 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(13)TStopCalibBwd @F @T @F @F @T @F @TL(5)
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE

@RT(13)TStopCalibBwd @F 
@Step @RT(14)S_StopCalibBwd @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(13)AStopCalibBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Bwd'));

@F 

@Trans @RT(14)TResetCalibBwd @F @T @F @F @T @F @TL(2)
TRUE

@RT(14)TResetCalibBwd @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(18)S_CHECK_ALARMS_BWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(14)TStartWriteBwd @F @T @F @F @T @T @TL(2)
S_CHECK_ALARMS_BWD.T > T#100ms

@RT(14)TStartWriteBwd @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(14)TStopCalibBwd2 @F @T @F @F @T @F @TL(2)
sv_iPendingAlarms <> 0

@RT(14)TStopCalibBwd2 @F 
@Goto @RT(14)S_StopCalibBwd @F @F 


@Step @RT(11)S_WRITE_BWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(9)AWriteBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(11)
abSpeedMeasure.aGetMaxValues(rMaxSpeed => mrMaxVelocity,
                             rMaxPressure => mrMaxPressure,
                             bPressureLimitReached => mbPressureLimitReached,
                             bSpeedLimitReached => mbVelocityLimitReached);
sFileName := CONCAT(sMoveName,"_MAXSPEED_BWD_");
aWriteLog(sFileName := sFileName,
          iFileCounter := iFileCounter,
          bDeleteFiles := TRUE);
iFileCounter := iFileCounter + 1;


@F 

@Trans @RT(9)TWriteBwd @F @T @F @F @T @T @TL(2)
mbLogFileSaved

@RT(9)TWriteBwd @F 
@Step @RT(20)S_CHECK_MAXSPEED_BWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(17)ACheckMaxSpeedBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(18)
aCalcMaxSpeedOutput(rMaxSpeedLimit := mActMovement^.prVelocityLimitBwd^,
                    rActSpeedLimit := rRefSpeedLimit,
                    rActMaxSpeed := abSpeedMeasure.aGetMaxValues.rMaxSpeed,
                    bPresLimitReached := abSpeedMeasure.aGetMaxValues.bPressureLimitReached,
                    bUsePressureMode := (mrMaxPressure > 0.0));
bMaxBwdDetected := aCalcMaxSpeedOutput.bMaxDetected;
IF (bMaxBwdDetected) THEN
   rSpeedLimitBwd := rRefSpeedLimit;
   dummy := Print('Calib max output %s Bwd finished: max speed bwd = %f$N', sMoveName, rSpeedLimitBwd);           
ELSE   
   IF abSpeedMeasure.aGetMaxValues.bPressureLimitReached THEN
      sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
      dummy := Print('Calib max output: pressure limit reached with act. max speed %s', sWriteSpeedLimit);
   END_IF;
   bMaxBwdRetry := TRUE;
   rRefSpeedLimit := aCalcMaxSpeedOutput.rRefSpeed;
END_IF;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(15)TMaxBwdDetected @F @T @F @F @T @T @TL(2)
bMaxBwdDetected

@RT(15)TMaxBwdDetected @F 

@TransSeq @RT(4)tseq @F 6 
@Trans @RT(12)TMaxBwdRetry @F @T @F @F @T @T @TL(2)
bMaxBwdRetry

@RT(12)TMaxBwdRetry @F 
@Step @RT(13)S_MaxBwdRetry @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(20)AStartMovementBwdFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(4)
bMoveFwdDone := FALSE;
miErrorNo := cIdentSpeedMaxBwdStart;
aStartMovementFwd();

@F 
@Acb @RT(28)ACheckActMovementBwdFwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveFwdDone := TRUE;
END_IF;

@F 
@Acb @RT(19)AStopMovementBwdFwd @F @T @RT(2)P0 @RT(0) @F @F @T @TL(2)
aStopMovementFwd();

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(12)TMoveFwdDone @F @T @F @F @T @T @TL(2)
bMoveFwdDone

@RT(12)TMoveFwdDone @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(12)TStopMoveFwd @F @T @F @F @T @F @TL(6)
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE


@RT(12)TStopMoveFwd @F 
@Step @RT(13)S_StopMoveFwd @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(12)AStopMoveFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Bwd: Fwd to start position'));

@F 

@Trans @RT(9)TResetBwd @F @T @F @F @T @T @TL(2)
TRUE

@RT(9)TResetBwd @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(23)S_CHECK_ALARMS_RETRYBWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(9)TRetryBwd @F @T @F @F @T @T @TL(2)
S_CHECK_ALARMS_RETRYBWD.T > T#1s

@RT(9)TRetryBwd @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(14)TStopIdentBwd4 @F @T @F @F @T @F @TL(2)
sv_iPendingAlarms <> 0

@RT(14)TStopIdentBwd4 @F 
@Goto @RT(13)S_StopMoveFwd @F @F 


@Goto @RT(11)S_CALIB_BWD @F @F 


@Step @RT(12)S_MoveEndBwd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(11)AMoveEndBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(27)
bMoveBwdDone := FALSE;

IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mrBwdStopPosition;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ - mrBwdStopPosition;
END_IF;
mActMovement^.prStopRamp^ := 1.0e10;
mActMovement^.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e20,mActMovement^.pConstBwdVis^.Pressure.Output.rRamp);
mActMovement^.pConstBwdVis^.Pressure.rMinOutput := 0.1 * rMaxPressureLimit;
sv_EjectorIdentMinMovement.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e10, sv_EjectorIdentMinMovement.pConstBwdVis^.Pressure.Output.rRamp);
sv_EjectorIdentMinMovement.pConstBwdVis^.Pressure.rMinOutput := 0.1 * sv_EjectorIdentMinMovement.prMaxPressureBwd^;

mActMovement^.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveBwd; 
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := cMoveDecompAftPlast;
ELSE
   evStartRequestData.MoveId := cMoveBwd;
END_IF;
miErrorNo := cIdentSpeedMaxEnd;

SET_EVENT(evStartRequest, evStartRequestData); 


@F 
@Acb @RT(21)ACheckMoveEndBwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveBwdDone := TRUE;
END_IF;

@F 
@Acb @RT(16)AMoveEndBwdReady @F @T @RT(2)P0 @RT(0) @F @F @T @TL(2)
aStopMovementBwd();

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(15)TMoveEndBwdDone @F @T @F @F @T @T @TL(2)
bMoveBwdDone

@RT(15)TMoveEndBwdDone @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(15)TStopMoveEndBwd @F @T @F @F @T @F @TL(4)
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0

@RT(15)TStopMoveEndBwd @F 
@Step @RT(16)S_StopMoveEndBwd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(15)AStopMoveEndBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
aStopMovementError(sMovementName := CONCAT(sMoveName, ' max ident Bwd to end position'));

@F 

@Trans @RT(16)TResetMoveEndBwd @F @T @F @F @T @F @TL(2)
TRUE

@RT(16)TResetMoveEndBwd @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(6)S_Done @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(5)ADone @F @T @RT(1)P @RT(0) @F @F @T @TL(6)
mActMovement^.Status := tnCalibState_Done;
sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Done;

mActMovement^.prVelocityFwd^ := rSpeedLimitFwd;
mActMovement^.prVelocityBwd^ := rSpeedLimitBwd;

@F 

@Trans @RT(5)TDone @F @T @F @F @T @T @TL(2)
TRUE

@RT(5)TDone @F 
@Goto @RT(7)S_RESET @F @F 
@END_SfcData 
@SaActions 0 
@SaTrans 0 
@SaExits 0 
@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(35)
//stop all calibrations
// TEST
IF sv_GlobalIdentMaxSpeedStatus.Command = tnCalibCommand_Stop THEN
    sv_GlobalIdentMaxSpeedStatus.bStart := FALSE;
END_IF;
//
IF sv_GlobalIdentMaxSpeedStatus.Command = tnCalibCommand_Stop OR (NOT sv_GlobalIdentMaxSpeedStatus.bStart) THEN
    FOR i:= 1 TO cCalibMovements DO
        IF CHECK_REF(sv_GlobalIdentMaxSpeedStatus.pMovements[i]^) THEN
            IF sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.Status = tnCalibState_Running OR
               sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.bRedo THEN
                sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.Status := tnCalibState_Aborted;
                sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.bRedo := FALSE;//FIXME: check if needed
                sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Aborted;
                EXIT;
            END_IF;
        END_IF;
    END_FOR;
    IF (sv_GlobalIdentMaxSpeedStatus.Command = tnCalibCommand_Stop) THEN
       IF (sv_GlobalIdentMaxSpeedStatus.Status <> tnCalibState_Aborted) THEN
          sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_None;
       END_IF;
       
    END_IF;
ELSIF (sv_GlobalIdentMaxSpeedStatus.Command = tnCalibCommand_Start) OR (sv_GlobalIdentMaxSpeedStatus.bStart) THEN
    IF sv_OperationMode = nSetup THEN
        mbUseSingleMovement := FALSE;
        START_PROCESS_ALGORITHM(paMaxCalibSequence);
    ELSE
        sv_GlobalIdentMaxSpeedStatus.bStart := FALSE;
        SET_ALARM(erSetupModeRequiredForCalib);
    END_IF;
END_IF;
sv_GlobalIdentMaxSpeedStatus.Command := tnCalibCommand_None;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
18 18 17 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 15 
@Step @RT(7)S_RESET @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(6)AReset @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
sv_bAutoIdentRunning := FALSE;

@F 
@Acb @RT(14)AStopMovements @F @T @RT(1)N @RT(0) @F @F @T @TL(12)
(* stop all identification movements *)
FOR i:= 1 TO cCalibMovements DO
    IF CHECK_REF(sv_GlobalIdentMaxSpeedStatus.pMovements[i]^) THEN
        IF sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.Status = tnCalibState_Running OR
           sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.bRedo THEN
            sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.Status := tnCalibState_Aborted;
            sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.bRedo := FALSE;//FIXME: check if needed
            EXIT;
        END_IF;
    END_IF;
END_FOR;

@F 
@Acb @RT(9)AStopSelf @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
sv_GlobalIdentMaxSpeedStatus.bStart := FALSE;
STOP_PROCESS_ALGORITHM();

@F 

@Trans @RT(7)Trans50 @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)Trans50 @F 
@Step @RT(6)S_INIT @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(11)ASortCalibs @F @T @RT(1)P @RT(0) @F @F @T @TL(24)
sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Running;
miErrorNo := 0;

tmpMovements := sv_GlobalIdentMaxSpeedStatus.pMovements;

(* get number of movements *)
FOR i:= 1 TO cCalibMovements DO
    IF NOT CHECK_REF(tmpMovements[i]^)  THEN
        EXIT;
    END_IF;
END_FOR;
iMaxMovements := i -1;

(* sort them by iOrder *)
FOR i := 1 TO iMaxMovements -1 DO
    FOR j := 1 TO iMaxMovements - 1 - i +1 DO
        IF tmpMovements[j]^.iOrder > tmpMovements[j + 1]^.iOrder THEN
            tmpM := tmpMovements[j];
            tmpMovements[j] := tmpMovements[j + 1];
            tmpMovements[j + 1] := tmpM;
        END_IF;    
    END_FOR;    
END_FOR;

@F 
@Acb @RT(9)Action108 @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
mCalibCounter := 0;
sv_GlobalIdentMaxSpeedStatus.iCurrentStep := mCalibCounter;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans80 @F @T @F @F @T @T @TL(3)
NOT sv_bCoresActive AND
sv_iPendingAlarms = 0

@RT(7)Trans80 @T @TL(5)
Comment : Start with moving ejector and 
mold in backward position, check if any failure 
occured. 
After that start the calibration cycle, if no alarm is 
pending


@TransSeq @RT(4)tseq @F 4 
@Trans @RT(7)Trans87 @F @T @F @F @T @F @TL(3)
sv_bCoresActive OR 
sv_iPendingAlarms > 0

@RT(7)Trans87 @F 
@Step @RT(6)Step74 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(14)AAnyCoreActive @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(7)Trans88 @F @T @F @F @T @T @TL(3)
TRUE


@RT(7)Trans88 @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(6)Step19 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(12)ASignalStart @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
sv_bAutoIdentRunning := TRUE;

@F 

@Trans @RT(7)Trans18 @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)Trans18 @F 
@Step @RT(17)S_MoveEjectorBack @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(12)AEjectorBack @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(9)Action116 @F @T @RT(1)N @RT(0) @F @F @T @TL(2)
fbCheckReady(DeviceId := DeviceIdEjector)

@F 
@Acb @RT(17)AResetEjectorBack @F @T @RT(2)P0 @RT(0) @F @F @T @TL(7)
miErrorNo := 0;
sv_EjectorIdentMaxMovement.prIdentPosition^ := 0.0;
sv_EjectorIdentMaxMovement.prStopRamp^ := 0.0;
sv_EjectorIdentMaxMovement.pbMoveIdent^ := FALSE;
sv_EjectorIdentMaxMovement.pConstBwdVis^ := ConstBwdVis;


@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans72 @F @T @F @F @T @T @TL(3)
fbCheckReady.bReady AND
sv_iPendingAlarms = 0

@RT(7)Trans72 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(7)Trans83 @F @T @F @F @T @F @TL(4)
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0

@RT(7)Trans83 @F 
@Step @RT(13)S_StopEjector @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(16)AStopEjeMovement @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(7)Trans84 @F @T @F @F @T @T @TL(3)
TRUE


@RT(7)Trans84 @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(14)S_MoveMoldBack @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(9)AMoldBack @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(9)Action118 @F @T @RT(1)N @RT(0) @F @F @T @TL(2)
fbCheckReady(DeviceId := DeviceIdMold)

@F 
@Acb @RT(14)AResetMoldBack @F @T @RT(2)P0 @RT(0) @F @F @T @TL(7)
miErrorNo := 0;
sv_MoldIdentMaxMovement.prIdentPosition^ := 0.0;
sv_MoldIdentMaxMovement.prStopRamp^ := 0.0;
sv_MoldIdentMaxMovement.pbMoveIdent^ := FALSE;
sv_MoldIdentMaxMovement.pConstBwdVis^ := ConstBwdVis;


@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans81 @F @T @F @F @T @T @TL(3)
fbCheckReady.bReady AND
sv_iPendingAlarms = 0

@RT(7)Trans81 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(7)Trans85 @F @T @F @F @T @F @TL(4)
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0

@RT(7)Trans85 @F 
@Step @RT(10)S_StopMold @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(17)AStopMoldMovement @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(7)Trans86 @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)Trans86 @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(14)S_CALIB_SINGLE @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(19)AStartMovementStart @F @T @RT(1)P @RT(0) @F @F @T @TL(5)
IF mCalibCounter < iMaxMovements THEN
   mCalibCounter := mCalibCounter +1;
   tmpMovements[mCalibCounter]^.bRedo := TRUE;
END_IF;   

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(18)TCheckActMoveReady @F @T @F @F @T @T @TL(4)
tmpMovements[mCalibCounter]^.bRedo = FALSE AND
NOT(sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
    sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Error)

@RT(18)TCheckActMoveReady @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(11)TCheckError @F @T @F @F @T @F @TL(4)
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMaxSpeedStatus.Status = tnCalibState_Error OR 
iMaxMovements = 0

@RT(11)TCheckError @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(11)S_CHECKNEXT @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(9)TNextUnit @F @T @F @F @T @T @TL(2)
mCalibCounter < iMaxMovements

@RT(9)TNextUnit @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(10)TStopIdent @F @T @F @F @T @T @TL(2)
mCalibCounter >= iMaxMovements

@RT(10)TStopIdent @F 
@Step @RT(11)S_StopIdent @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(10)AStopIdent @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Done;

@F 

@Trans @RT(6)TReset @F @T @F @F @T @T @TL(2)
TRUE

@RT(6)TReset @F 
@Goto @RT(7)S_RESET @F @F 


@Goto @RT(14)S_CALIB_SINGLE @F @F 
@END_SfcData 
@SaActions 5 
@SaText @RT(12)AEjectorBack 1 @TL(20)
miErrorNo := cIdentSpeedMaxSequence;

IF sv_EjectorIdentMaxMovement.bPositionIncreasingFwd THEN
   sv_EjectorIdentMaxMovement.prIdentPosition^ := mrBwdStopPosition;
ELSE
   sv_EjectorIdentMaxMovement.prIdentPosition^ := sv_EjectorIdentMaxMovement.prStroke^ - mrBwdStopPosition;
END_IF;
sv_EjectorIdentMaxMovement.prStopRamp^ := 1.0e10;
ConstBwdVis := sv_EjectorIdentMaxMovement.pConstBwdVis^;
sv_EjectorIdentMaxMovement.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e10, sv_EjectorIdentMaxMovement.pConstBwdVis^.Pressure.Output.rRamp);
sv_EjectorIdentMaxMovement.pConstBwdVis^.Pressure.rMinOutput := 0.1 * sv_EjectorIdentMaxMovement.prMaxPressureBwd^;
sv_EjectorIdentMaxMovement.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := DeviceIdEjector;
evStartRequestData.MoveDir := cMoveBwd; 
evStartRequestData.MoveId := cMoveBwd;
SET_EVENT(evStartRequest, evStartRequestData);




@SaText @RT(9)AMoldBack 1 @TL(19)
miErrorNo := cIdentSpeedMaxSequence;

IF sv_MoldIdentMaxMovement.bPositionIncreasingFwd THEN
   sv_MoldIdentMaxMovement.prIdentPosition^ := mrBwdStopPosition;
ELSE
   sv_MoldIdentMaxMovement.prIdentPosition^ := sv_MoldIdentMaxMovement.prStroke^ - mrBwdStopPosition;
END_IF;
sv_MoldIdentMaxMovement.prStopRamp^ := 1.0e10;
ConstBwdVis := sv_MoldIdentMaxMovement.pConstBwdVis^;
sv_MoldIdentMaxMovement.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e10, sv_MoldIdentMaxMovement.pConstBwdVis^.Pressure.Output.rRamp);
sv_MoldIdentMaxMovement.pConstBwdVis^.Pressure.rMinOutput := 0.1 * sv_MoldIdentMaxMovement.prMaxPressureBwd^;
sv_MoldIdentMaxMovement.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := DeviceIdMold;
evStartRequestData.MoveDir := cMoveBwd; 
evStartRequestData.MoveId := cMoveBwd;
SET_EVENT(evStartRequest, evStartRequestData); 



@SaText @RT(16)AStopEjeMovement 1 @TL(9)
evStopRequestData.DeviceId := DeviceIdEjector;  
evStopRequestData.MoveDir := cMoveBwd;  
evStopRequestData.MoveId := cMoveBwd;      
SET_EVENT(evStopRequest, evStopRequestData);
IF sv_GlobalIdentMaxSpeedStatus.Status <> tnCalibState_None THEN
    sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Aborted;
END_IF;



@SaText @RT(17)AStopMoldMovement 1 @TL(9)
evStopRequestData.DeviceId := DeviceIdMold;  
evStopRequestData.MoveDir := cMoveBwd;  
evStopRequestData.MoveId := cMoveBwd;      
SET_EVENT(evStopRequest, evStopRequestData);
IF sv_GlobalIdentMaxSpeedStatus.Status <> tnCalibState_None THEN
    sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Aborted;
END_IF;



@SaText @RT(14)AAnyCoreActive 1 @TL(6)
IF sv_bCoresActive THEN
   SET_ALARM(erCalibCoresActive);
END_IF;
sv_GlobalIdentMaxSpeedStatus.Status := tnCalibState_Aborted;



@SaTrans 0 
@SaExits 1 
@SaExit @SaText @RT(14)E_NotSetupMode 1 @TL(2)
sv_OperationMode <> nSetup

@RT(7)S_RESET @RT(1)1 @F @F @SaSfc @RT(14)E_NotSetupMode 5 @RT(5)DUMMY 
@BEG_SfcData 2 
@ExitSeq @RT(4)sseq @F 3 
@Step @RT(8)unnamed1 @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@Trans @RT(8)unnamed3 @F @T @F @F @T @T @TL(2)


@RT(8)unnamed3 @F 
@Goto @RT(9)unlabeled @F @F 
@END_SfcData 

@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(2)
Coordinate sequential start of auto calib cycle
starts one auto calib movement after the other
@@@END_Comment@@@ 

@BEG_Body 
@TL(7)
IF (rStep > 0.0) THEN
   rRealValue := (0.999 + rActNumber / rStep);
   rRoundedNumber := DINT_TO_REAL(TRUNC_TO_DINT(rRealValue)) * rStep;
ELSE
   rRoundedNumber := rActNumber;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(39)
IF bStart THEN
   rMaxRefSpeed := rMaxSpeedLimit;
   rMinRefSpeed := 0.0;
END_IF;
IF (bUnstable OR bTimeOut) THEN
   // increase speed
   IF (rActRefSpeed >= rMFactorMaxMinLimit * rMaxSpeedLimit) THEN
      bMinDetected := TRUE;
      rMinSpeed := rActRefSpeed;
      RETURN;
   END_IF;      
   rMinRefSpeed := rActRefSpeed;
   bMinDetected := FALSE;
  IF (rMaxRefSpeed - rMinRefSpeed) < (0.0025 * rMaxSpeedLimit) THEN
  // difference to low to maximum - stop or increase maximum?    
      bMinDetected := TRUE;
      rMinSpeed := rMaxRefSpeed; 
   ELSIF (rMaxRefSpeed < rMaxSpeedLimit) AND (rMinRefSpeed > 0.0) THEN
      rRefSpeed := 0.5 * (rMaxRefSpeed + rMinRefSpeed);
      bMinDetected := FALSE;
   ELSE
      rRefSpeed := rActRefSpeed + 0.01 * rMaxSpeedLimit;
      IF (rRefSpeed >= rMaxSpeedLimit) THEN
         bMinDetected := TRUE;
         rMinSpeed := rMaxSpeedLimit;
      END_IF;
   END_IF;
ELSE
   // reduce speed
   rMaxRefSpeed := rActRefSpeed;
   IF (rMaxRefSpeed - rMinRefSpeed) < (0.0025 * rMaxSpeedLimit) THEN
      bMinDetected := TRUE;
      rMinSpeed := rActRefSpeed;
   ELSE
      bMinDetected := FALSE;
      rRefSpeed := 0.5 * (rMaxRefSpeed + rMinRefSpeed);
   END_IF;      
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(26)
bIdentActive := FALSE;
FOR i:= 1 TO cCalibMovements DO
   IF CHECK_REF(sv_GlobalIdentMinSpeedStatus.pMovements[i]^) THEN
      IF sv_GlobalIdentMinSpeedStatus.pMovements[i]^.bRedo THEN
         mActMovement := sv_GlobalIdentMinSpeedStatus.pMovements[i];
         bIdentActive := TRUE;
         sv_GlobalIdentMinSpeedStatus.iCurrentStep :=  i;
         mCalibCounter := i;
         IF sv_OperationMode = nSetup THEN
            mbUseSingleMovement := TRUE;
            START_PROCESS_ALGORITHM(paMinSingleMovement);
         ELSE
            sv_GlobalIdentMinSpeedStatus.pMovements[i]^.bRedo := FALSE;
            SET_ALARM(erSetupModeRequiredForCalib);
         END_IF;
         EXIT;
      END_IF;
   END_IF;
END_FOR;
IF ((NOT bIdentActive) AND (sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Running)) THEN
   sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Done;
END_IF;
       

STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(4)

START_PROCESS_ALGORITHM(paRedoMin);


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
44 51 50 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 39 
@Step @RT(7)S_RESET @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@Trans @RT(7)Trans47 @F @T @F @F @T @T @TL(2)
mbLogFileSaved

@RT(7)Trans47 @F 
@Step @RT(6)S_STOP @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(9)AStopSelf @F @T @RT(1)P @RT(0) @F @F @T @TL(18)
IF (sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted) THEN
   mActMovement^.prVelocityFwd^ := rSpeedLimitFwd;
   mActMovement^.prVelocityBwd^ := rSpeedLimitBwd;
END_IF;
sv_GlobalIdentMinSpeedStatus.Command := tnCalibCommand_None;
sv_bAutoIdentRunning := FALSE;
mActMovement^.bRedo := FALSE;
mActMovement^.pdMaxMoveTimeFwd^ := dMaxMoveTimeSaveFwd;
mActMovement^.pdMaxMoveTimeBwd^ := dMaxMoveTimeSaveBwd;
mActMovement^.prStopRamp^ := 0.0;
mActMovement^.pConstFwdVis^ := ConstVisFwd;
mActMovement^.pConstBwdVis^ := ConstVisBwd;

//release memory
abSpeedMeasure.aEnd();

STOP_PROCESS_ALGORITHM();

@F 

@Trans @RT(8)TRestart @F @T @F @F @T @T @TL(2)
TRUE

@RT(8)TRestart @F 
@Step @RT(6)S_INIT @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(7)Action3 @F @T @RT(1)P @RT(0) @F @F @T @TL(38)
miErrorNo := 0;

sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Running;
mActMovement^.Status := tnCalibState_Running;
sMoveName := mActMovement^.sName;

abSpeedMeasure.aInit();

bMinFwdRetry := FALSE;
bMinBwdRetry := FALSE;

dMaxMoveTimeSaveFwd := mActMovement^.pdMaxMoveTimeFwd^;
dMaxMoveTimeSaveBwd := mActMovement^.pdMaxMoveTimeBwd^;

ConstVisFwd := mActMovement^.pConstFwdVis^;
ConstVisBwd := mActMovement^.pConstBwdVis^;

rSpeedLimitFwd := mActMovement^.prVelocityFwd^;
rSpeedLimitBwd := mActMovement^.prVelocityBwd^;

IF (mActMovement^.rMaxPositionLimitFactor > mActMovement^.rMinPositionLimitFactor) AND
   (mActMovement^.rMinPositionLimitFactor > 0.0) AND (mActMovement^.rMaxPositionLimitFactor < 1.0) THEN
   mrMaxPositionFactor := mActMovement^.rMaxPositionLimitFactor;
   mrMinPositionFactor := mActMovement^.rMinPositionLimitFactor;
ELSE // use deafult values
   mrMaxPositionFactor := 0.8;
   mrMinPositionFactor := 0.2;
END_IF;

rMaxPressureFwd := 0.0;
rMaxPressureBwd := 0.0;
mprActPressure := sv_PumpData[mActMovement^.DeviceId.IndexId].prActSysPressure;
IF CHECK_REF(mprActPressure^) THEN
   mbprActPressureLinked := TRUE;
ELSE
   mbprActPressureLinked := FALSE;
END_IF;

@F 

@Trans @RT(13)TMoveStartBwd @F @T @F @F @T @T @TL(3)
TRUE


@RT(13)TMoveStartBwd @F 
@Step @RT(14)S_MoveStartBwd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(13)AMoveStartBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(4)
bMoveBwdDone := FALSE;
miErrorNo := cIdentSpeedMinBwdInit;
aStartMovementBwd();

@F 
@Acb @RT(23)ACheckMoveStartBwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveBwdDone := TRUE;
END_IF;

@F 
@Acb @RT(18)AMoveStartBwdReady @F @T @RT(2)P0 @RT(0) @F @F @T @TL(5)
aStopMovementBwd();




@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(8)TInitBwd @F @T @F @F @T @T @TL(2)
bMoveBwdDone

@RT(8)TInitBwd @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(17)TStopMoveStartBwd @F @T @F @F @T @F @TL(5)
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE

@RT(17)TStopMoveStartBwd @F 
@Step @RT(18)S_StopMoveStartBwd @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(22)AStopMoveErrorStartBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident Fwd: Bwd to initial position'));

@F 

@Trans @RT(6)TReset @F @T @F @F @T @F @TL(2)
TRUE

@RT(6)TReset @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(22)S_CHECK_ALARMS_INITBWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(11)TStartIdent @F @T @F @F @T @T @TL(2)
S_CHECK_ALARMS_INITBWD.T > T#100ms

@RT(11)TStartIdent @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(12)TStopInitBwd @F @T @F @F @T @F @TL(2)
sv_iPendingAlarms <> 0

@RT(12)TStopInitBwd @F 
@Goto @RT(18)S_StopMoveStartBwd @F @F 


@Step @RT(15)S_INITCALIB_FWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(13)aInitIdentFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(26)
iFileCounter := 1;
IF (CHECK_REF(mActMovement^.prSizeFactorFwd^)) THEN
   IF (mActMovement^.prSizeFactorFwd^ > 0.0) THEN
      rVelocitSizeFactor := mActMovement^.prSizeFactorFwd^;        
   END_IF;
ELSE
   rVelocitSizeFactor := 1.0;
END_IF;
rRefSpeedLimit := 0.01 * mActMovement^.prVelocityLimitFwd^;
rMaxPressureLimit := mActMovement^.prMaxPressureFwd^;
IF CHECK_REF(mActMovement^.prMaxPressureFwdHydr^) THEN
   rMaxRefPressureLimit := mActMovement^.prMaxPressureFwdHydr^;
   IF (rMaxRefPressureLimit > 0.0) THEN
      rPressureFactorFwd := rMaxPressureLimit / rMaxRefPressureLimit;
   ELSE      
      rPressureFactorFwd := 1.0;
   END_IF;
ELSE   
   rMaxRefPressureLimit := mActMovement^.prMaxPressureFwd^;
   rPressureFactorFwd := 1.0;
END_IF; 

aCalcMinSpeedOutput.bStart := TRUE;

dummy := Print('Calib min output %s Fwd started', sMoveName);

@F 

@Trans @RT(7)TDelay1 @F @T @F @F @T @T @TL(2)
S_INITCALIB_FWD.T>T#100ms

@RT(7)TDelay1 @F 
@Step @RT(11)S_CALIB_FWD @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 4 
@Acb @RT(8)ADoCalib @F @T @RT(1)P @RT(0) @F @F @T @TL(67)
// save actual settings
mActMovement^.pConstFwdVis^.Velocity.Output.rOutputValue := rRefSpeedLimit * rVelocitSizeFactor;
mActMovement^.pConstFwdVis^.Velocity.rMinOutput := 0.0;
mActMovement^.pConstFwdVis^.Pressure.Output.rOutputValue := MAX(mActMovement^.pConstFwdVis^.Pressure.Output.rOutputValue, rMaxPressureLimit);
mActMovement^.pConstFwdVis^.Pressure.Output.rRamp := MAX(1.0e10, ConstVisFwd.Pressure.Output.rRamp); 
IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMaxPositionFactor;
   mrMinLimitPosition := rStartFactor * mActMovement^.prIdentPosition^ + (1.0 - rStartFactor) * mActMovement^.prPosition^;
   IF (mActMovement^.prIdentPosition^ - mActMovement^.prPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit  * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstFwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMaxLimitPosition := mActMovement^.prIdentPosition^ - 0.5 * rRefSpeedLimit  * rRefSpeedLimit / mActMovement^.prStopRamp^;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMinPositionFactor;
   mrMaxLimitPosition := (1.0 - rStartFactor) * mActMovement^.prPosition^ + rStartFactor * mActMovement^.prIdentPosition^;
   IF (mActMovement^.prPosition^ - mActMovement^.prIdentPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit  * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstFwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMinLimitPosition := mActMovement^.prIdentPosition^ + 0.5 * rRefSpeedLimit  * rRefSpeedLimit / mActMovement^.prStopRamp^;
END_IF;
mActMovement^.pbMoveIdent^ := TRUE;
bMoveIdentDone := FALSE;

bMinFwdDetected := FALSE;

mrRefVelocity := rRefSpeedLimit;
mrRefPressure := rMaxRefPressureLimit;

aStartMeasurement();

bStopUnstable := FALSE;
bTimeOut := FALSE;
IF rRefSpeedLimit > 0.0 THEN
   rMoveStrokeTime := mActMovement^.prStroke^ / rRefSpeedLimit; 
ELSE
   rMoveStrokeTime := 0.0;
END_IF;
dMaxMoveTime := T#5s + LINT_TO_TIME(REAL_TO_LINT(rMoveStrokeTime*1.0e6));
IF (dMaxMoveTime > dMoveTimeLimit) THEN
   dMaxMoveTime := dMoveTimeLimit;
   bMoveTimeLimited := TRUE;
   rStartPosition := mActMovement^.prPosition^;
   IF (mActMovement^.bPositionIncreasingFwd) THEN
      rMinMovementPosition := rStartPosition + 0.1 * (mrMaxLimitPosition - mrMinLimitPosition);   
   ELSE;
      rMinMovementPosition := rStartPosition - 0.1 * (mrMaxLimitPosition - mrMinLimitPosition );      
   END_IF;
ELSE
   bMoveTimeLimited := FALSE;   
END_IF;
TimeOut(IN := FALSE,
        PT := dMaxMoveTime);
IF (mActMovement^.pdMaxMoveTimeFwd^ < dMaxMoveTime + dMoveTimeOffset) THEN
   mActMovement^.pdMaxMoveTimeFwd^ := dMaxMoveTime + dMoveTimeOffset;
END_IF;
mActMovement^.prVelocityFwd^ := rRefSpeedLimit;

sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
dummy := Print('Calib min output: act. min output: %s', sWriteSpeedLimit);
miErrorNo := cIdentSpeedMinFwdIdent;

@F 
@Acb @RT(17)AStartMovementFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(10)
evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveFwd;
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := mActMovement^.MoveId;   
ELSE
   evStartRequestData.MoveId := cMoveFwd;
END_IF;
SET_EVENT(evStartRequest, evStartRequestData); 


@F 
@Acb @RT(25)ACheckActMovementFwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(26)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);

TimeOut(IN := TRUE);
IF (fbCheckReady.bReady) THEN
   aStopMeasurement();
   aStopMovementFwd();
   bMoveIdentDone := TRUE;      
ELSIF (TimeOut.Q) THEN
   aStopMeasurement();
   aStopMovementFwd();
   IF (bMoveTimeLimited) AND
     ((mActMovement^.bPositionIncreasingFwd AND (mActMovement^.prPosition^ > rMinMovementPosition)) OR
      (NOT mActMovement^.bPositionIncreasingFwd AND (mActMovement^.prPosition^ < rMinMovementPosition))) THEN
      bMoveIdentDone := TRUE;
      dummy := Print('Calib min output: max move time reached with act. min output %s', sWriteSpeedLimit);   
   ELSE
      bTimeOut := TRUE;      
      dummy := Print('Calib min output: timeout with act. min output %s', sWriteSpeedLimit);   
   END_IF;
ELSIF (abSpeedMeasure.aMeasure.bSpeedUnStable) THEN
   aStopMeasurement();
   aStopMovementFwd();
   bStopUnstable := TRUE;
   dummy := Print('Calib min output: unstable speed with act. min output %s', sWriteSpeedLimit);   
END_IF;

@F 
@Acb @RT(16)AStopMovementFwd @F @T @RT(2)P0 @RT(0) @F @F @T @TL(8)
mActMovement^.prStopRamp^ := 0.0;
mActMovement^.pConstFwdVis^ := ConstVisFwd;
mActMovement^.pdMaxMoveTimeFwd^ := dMaxMoveTimeSaveFwd;


TimeOut(IN := FALSE);


@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(17)TMoveIdentFwdDone @F @T @F @F @T @T @TL(4)
bMoveIdentDone OR
bTimeOut OR
bStopUnstable

@RT(17)TMoveIdentFwdDone @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(13)TStopIdentFwd @F @T @F @F @T @F @TL(5)
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE

@RT(13)TStopIdentFwd @F 
@Step @RT(14)S_StopIdentFwd @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(13)AStopIdentFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
aStopMovementFwd();
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident Fwd'));

@F 

@Trans @RT(7)TReset1 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)TReset1 @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(18)S_CHECK_ALARMS_FWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(14)TStartWriteFwd @F @T @F @F @T @T @TL(2)
S_CHECK_ALARMS_FWD.T > T#100ms

@RT(14)TStartWriteFwd @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(14)TStopIdentFwd2 @F @T @F @F @T @F @TL(2)
sv_iPendingAlarms <> 0

@RT(14)TStopIdentFwd2 @F 
@Goto @RT(14)S_StopIdentFwd @F @F 


@Step @RT(11)S_WRITE_FWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(9)AWriteFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(14)
abSpeedMeasure.aGetMaxValues(rMaxSpeed => mrMaxVelocity,
                             rMaxPressure => mrMaxPressure,
                             bPressureLimitReached => mbPressureLimitReached,
                             bSpeedLimitReached => mbVelocityLimitReached);
IF mbprActPressureLinked THEN
   rMaxPressureFwd := MAX(rMaxPressureFwd,mrMaxPressure);
   dummy := Print('Calib min output: with act. min output %s max pressure %f needed', sWriteSpeedLimit, mrMaxPressure);           
END_IF;    
sFileName := CONCAT(sMoveName,"_MINSPEED_FWD_");
aWriteLog(sFileName := sFileName,
          iFileCounter := iFileCounter,
          bDeleteFiles := TRUE);
iFileCounter := iFileCounter + 1;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(9)TWriteFwd @F @T @F @F @T @T @TL(2)
mbLogFileSaved

@RT(9)TWriteFwd @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(16)TAbortedWriteFwd @F @T @F @F @T @F @TL(2)
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted

@RT(16)TAbortedWriteFwd @F 
@Step @RT(17)S_AbortedWriteFwd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(22)AStopMoveErrorWriteFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
mActMovement^.Status := tnCalibState_Error;


@F 

@Trans @RT(21)TResetAbortedWriteFwd @F @T @F @F @T @F @TL(2)
TRUE

@RT(21)TResetAbortedWriteFwd @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(20)S_CHECK_MINSPEED_FWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(17)ACheckMinSpeedFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(20)
aCalcMinSpeedOutput(rMaxSpeedLimit := mActMovement^.prVelocityLimitFwd^,
                    rActRefSpeed := rRefSpeedLimit,
                    rActMinSpeed := abSpeedMeasure.aGetMaxValues.rMaxSpeed,
                    bUnstable := abSpeedMeasure.aGetMaxValues.bSpeedLimitUnStable,
                    bTimeOut := bTimeOut);
bMinFwdDetected := aCalcMinSpeedOutput.bMinDetected;
IF (bMinFwdDetected) THEN
   rSpeedLimitFwd := aCalcMinSpeedOutput.rMinSpeed;
   dummy := Print('Calib min output %s Fwd finished: min output fwd = %f$N', sMoveName, rSpeedLimitFwd);   
ELSE   
   bMinFwdRetry := TRUE;
   rRefSpeedLimit := aCalcMinSpeedOutput.rRefSpeed;
   aCalcMinSpeedOutput.bStart := FALSE;
END_IF;

mActMovement^.pConstFwdVis^ := ConstVisFwd;
mActMovement^.prVelocityFwd^ := rSpeedLimitFwd;
mActMovement^.pdMaxMoveTimeFwd^ := dMaxMoveTimeSaveFwd;


@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(15)TMinFwdDetected @F @T @F @F @T @T @TL(2)
bMinFwdDetected

@RT(15)TMinFwdDetected @F 
@Step @RT(21)S_ReadyMinFwdDetected @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(20)AReadyMinFwdDetected @F @T @RT(1)N @RT(0) @F @F @T @TL(2)
fbCheckReady(DeviceId := mActMovement^.DeviceId);

@F 

@Trans @RT(20)TReadyMinFwdDetected @F @T @F @F @T @T @TL(2)
fbCheckReady.bReady

@RT(7)Trans49 @F 

@TransSeq @RT(4)tseq @F 8 
@Trans @RT(7)Trans15 @F @T @F @F @T @T @TL(2)
bMinFwdRetry

@RT(7)Trans15 @F 
@Step @RT(18)S_ReadyMinFwdRetry @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(17)AReadyMinFwdRetry @F @T @RT(1)N @RT(0) @F @F @T @TL(2)
fbCheckReady(DeviceId := mActMovement^.DeviceId);

@F 

@Trans @RT(17)TReadyMinFwdRetry @F @T @F @F @T @T @TL(2)
fbCheckReady.bReady

@RT(7)Trans49 @F 
@Step @RT(13)S_MinFwdRetry @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(20)AStartMovementFwdBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(4)
bMoveBwdDone := FALSE;
miErrorNo := cIdentSpeedMinFwdStart;
aStartMovementBwd();

@F 
@Acb @RT(28)ACheckActMovementFwdBwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveBwdDone := TRUE;
END_IF;

@F 
@Acb @RT(19)AStopMovementFwdBwd @F @T @RT(2)P0 @RT(0) @F @F @T @TL(3)
aStopMovementBwd();


@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(12)TMoveBwdDone @F @T @F @F @T @T @TL(2)
bMoveBwdDone

@RT(12)TMoveBwdDone @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(12)TStopMoveBwd @F @T @F @F @T @F @TL(6)
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE


@RT(12)TStopMoveBwd @F 
@Step @RT(13)S_StopMoveBwd @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(20)AStopMoveErrorBwdFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident Fwd: Bwd to start position'));

@F 

@Trans @RT(7)TReset2 @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)TReset2 @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(23)S_CHECK_ALARMS_RETRYFWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(9)TRetryFwd @F @T @F @F @T @T @TL(2)
S_CHECK_ALARMS_RETRYFWD.T > T#1s

@RT(9)TRetryFwd @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(14)TStopIdentFwd4 @F @T @F @F @T @F @TL(2)
sv_iPendingAlarms <> 0

@RT(14)TStopIdentFwd4 @F 
@Goto @RT(13)S_StopMoveBwd @F @F 


@Goto @RT(11)S_CALIB_FWD @F @F 


@Step @RT(25)S_InitStartMovementBwdFwd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(24)AInitStartMovementBwdFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(4)
bMoveFwdDone := FALSE;
miErrorNo := cIdentSpeedMinFwdInit;
aStartMovementFwd();

@F 
@Acb @RT(29)ACheckInitMovementBwdFwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveFwdDone := TRUE;
END_IF;

@F 
@Acb @RT(23)AStopInitMovementBwdFwd @F @T @RT(2)P0 @RT(0) @F @F @T @TL(2)
aStopMovementFwd();

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans35 @F @T @F @F @T @T @TL(2)
bMoveFwdDone

@RT(7)Trans35 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(16)TStopInitMoveFwd @F @T @F @F @T @F @TL(5)
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE

@RT(16)TStopInitMoveFwd @F 
@Step @RT(17)S_StopInitMoveFwd @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(21)AStopMoveErrorInitFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident Bwd: Fwd to initial position'));

@F 

@Trans @RT(17)TResetInitMoveFwd @F @T @F @F @T @T @TL(2)
TRUE

@RT(17)TResetInitMoveFwd @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(23)S_CHECK_ALARMS_STARTBWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(13)TStartInitBwd @F @T @F @F @T @T @TL(2)
S_CHECK_ALARMS_STARTBWD.T > T#100ms

@RT(13)TStartInitBwd @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(14)TStopIdentFwd3 @F @T @F @F @T @F @TL(2)
sv_iPendingAlarms <> 0

@RT(14)TStopIdentFwd3 @F 
@Goto @RT(17)S_StopInitMoveFwd @F @F 


@Step @RT(15)S_INITCALIB_BWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(13)AInitCalibBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(26)
iFileCounter := 1;
IF (CHECK_REF(mActMovement^.prSizeFactorBwd^)) THEN
   IF (mActMovement^.prSizeFactorBwd^ > 0.0) THEN
      rVelocitSizeFactor := mActMovement^.prSizeFactorBwd^;        
   END_IF;
ELSE
   rVelocitSizeFactor := 1.0;
END_IF;
rRefSpeedLimit := 0.01 * mActMovement^.prVelocityLimitBwd^;
rMaxPressureLimit := mActMovement^.prMaxPressureBwd^;
IF CHECK_REF(mActMovement^.prMaxPressureBwdHydr^) THEN
   rMaxRefPressureLimit := mActMovement^.prMaxPressureBwdHydr^;
   IF (rMaxRefPressureLimit > 0.0) THEN
      rPressureFactorBwd := rMaxPressureLimit / rMaxRefPressureLimit;
   ELSE      
      rPressureFactorBwd := 1.0;
   END_IF;   
ELSE   
   rMaxRefPressureLimit := mActMovement^.prMaxPressureFwd^;
   rPressureFactorBwd := 1.0;
END_IF; 

aCalcMinSpeedOutput.bStart := TRUE;

dummy := Print('Calib min output %s Bwd started', sMoveName);

@F 

@Trans @RT(13)TInitCalibBwd @F @T @F @F @T @T @TL(2)
S_INITCALIB_BWD.T>T#1s

@RT(13)TInitCalibBwd @F 
@Step @RT(11)S_CALIB_BWD @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 4 
@Acb @RT(11)ADoCalibBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(66)
mActMovement^.pConstBwdVis^.Velocity.Output.rOutputValue := rRefSpeedLimit * rVelocitSizeFactor;
mActMovement^.pConstBwdVis^.Velocity.rMinOutput := 0.0;
mActMovement^.pConstBwdVis^.Pressure.Output.rOutputValue := MAX(mActMovement^.pConstBwdVis^.Pressure.Output.rOutputValue, rMaxPressureLimit);
mActMovement^.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e10, ConstVisBwd.Pressure.Output.rRamp); 
IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMinPositionFactor;
   mrMaxLimitPosition := rStartFactor * mActMovement^.prIdentPosition^ + (1.0 - rStartFactor) * mActMovement^.prPosition^;
   IF (mActMovement^.prPosition^ - mActMovement^.prIdentPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit  * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstBwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMinLimitPosition := mActMovement^.prIdentPosition^ + 0.5 * rRefSpeedLimit  * rRefSpeedLimit / mActMovement^.prStopRamp^;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ * mrMaxPositionFactor;
   mrMinLimitPosition := rStartFactor * mActMovement^.prPosition^ + (1.0 - rStartFactor) * mActMovement^.prIdentPosition^;
   IF (mActMovement^.prIdentPosition^ - mActMovement^.prPosition^) > 0.0 THEN
      rMinStopRamp := rMinStrokeFactor * rRefSpeedLimit  * rRefSpeedLimit / ABS(mActMovement^.prIdentPosition^ - mActMovement^.prPosition^);
   ELSE
      rMinStopRamp := 0.0;
   END_IF;
   mActMovement^.prStopRamp^ := MAX(mActMovement^.pConstBwdVis^.Velocity.Output.rRamp, rMinStopRamp);
   mrMaxLimitPosition := mActMovement^.prIdentPosition^ - 0.5 * rRefSpeedLimit  * rRefSpeedLimit / mActMovement^.prStopRamp^;
END_IF;
mActMovement^.pbMoveIdent^ := TRUE;

bMoveIdentDone := FALSE;

mrRefVelocity := rRefSpeedLimit;
mrRefPressure := rMaxRefPressureLimit;

aStartMeasurement();

bStopUnstable := FALSE;
bTimeOut := FALSE;
IF rRefSpeedLimit > 0.0 THEN
   rMoveStrokeTime := mActMovement^.prStroke^ / rRefSpeedLimit; 
ELSE
   rMoveStrokeTime := 0.0;
END_IF;
dMaxMoveTime := T#5s + LINT_TO_TIME(REAL_TO_LINT(rMoveStrokeTime*1.0e6));
IF (dMaxMoveTime > dMoveTimeLimit) THEN
   dMaxMoveTime := dMoveTimeLimit;
   bMoveTimeLimited := TRUE;
   rStartPosition := mActMovement^.prPosition^;
   IF (mActMovement^.bPositionIncreasingFwd) THEN
      rMinMovementPosition := rStartPosition - 0.1 * (mrMaxLimitPosition - mrMinLimitPosition);   
   ELSE;
      rMinMovementPosition := rStartPosition + 0.1 * (mrMaxLimitPosition - mrMinLimitPosition );      
   END_IF;
ELSE
   bMoveTimeLimited := FALSE;   
END_IF;

TimeOut(IN := FALSE,
        PT := dMaxMoveTime);    
IF (mActMovement^.pdMaxMoveTimeBwd^ < dMaxMoveTime + dMoveTimeOffset) THEN
   mActMovement^.pdMaxMoveTimeBwd^ := dMaxMoveTime + dMoveTimeOffset;
END_IF;
mActMovement^.prVelocityBwd^ := rRefSpeedLimit;

sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
dummy := Print('Calib min output: act. min output: %s', sWriteSpeedLimit);
miErrorNo := cIdentSpeedMinBwdIdent;

@F 
@Acb @RT(17)AStartMovementBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(9)
evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveBwd;
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := cMoveDecompAftPlast;
ELSE
   evStartRequestData.MoveId := cMoveBwd;
END_IF;
SET_EVENT(evStartRequest, evStartRequestData); 

@F 
@Acb @RT(25)ACheckActMovementBwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(28)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);

TimeOut(IN :=TRUE);
IF fbCheckReady.bReady THEN
   aStopMeasurement();
   aStopMovementBwd();
   bMoveIdentDone := TRUE;      
ELSIF TimeOut.Q THEN
   aStopMeasurement();
   aStopMovementBwd();
   IF (bMoveTimeLimited) AND
     ((mActMovement^.bPositionIncreasingFwd AND (mActMovement^.prPosition^ < rMinMovementPosition)) OR
      (NOT mActMovement^.bPositionIncreasingFwd AND (mActMovement^.prPosition^ > rMinMovementPosition))) THEN
      bMoveIdentDone := TRUE;
      dummy := Print('Calib min output: max move time reached with act. min output %s', sWriteSpeedLimit);   
   ELSE
      bTimeOut := TRUE;      
      dummy := Print('Calib min output: timeout with act. min output %s', sWriteSpeedLimit);   
   END_IF;   
ELSIF (abSpeedMeasure.aMeasure.bSpeedUnStable) THEN
   aStopMeasurement();
   aStopMovementBwd();
   bStopUnstable := TRUE;
   sWriteSpeedLimit := REAL_TO_STRING(rRefSpeedLimit);
   dummy := Print('Calib min output: unstable speed with act. min output %s', sWriteSpeedLimit);   
END_IF;


@F 
@Acb @RT(16)AStopMovementBwd @F @T @RT(2)P0 @RT(0) @F @F @T @TL(5)
mActMovement^.pConstBwdVis^ := ConstVisBwd;
mActMovement^.pdMaxMoveTimeBwd^ := dMaxMoveTimeSaveBwd;

TimeOut(IN := FALSE);

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans14 @F @T @F @F @T @T @TL(4)
bMoveIdentDone OR
bTimeOut OR
bStopUnstable

@RT(7)Trans14 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(13)TStopCalibBwd @F @T @F @F @T @F @TL(5)
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE

@RT(13)TStopCalibBwd @F 
@Step @RT(14)S_StopCalibBwd @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(22)AStopMoveErrorCalibBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
aStopMovementBwd();
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident Bwd'));

@F 

@Trans @RT(14)TResetCalibBwd @F @T @F @F @T @F @TL(2)
TRUE

@RT(14)TResetCalibBwd @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(18)S_CHECK_ALARMS_BWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(14)TStartWriteBwd @F @T @F @F @T @T @TL(2)
S_CHECK_ALARMS_BWD.T > T#100ms

@RT(14)TStartWriteBwd @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(14)TStopIdentBwd2 @F @T @F @F @T @F @TL(2)
sv_iPendingAlarms <> 0

@RT(14)TStopCalibBwd2 @F 
@Goto @RT(14)S_StopCalibBwd @F @F 


@Step @RT(11)S_WRITE_BWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(9)AWriteBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(14)
abSpeedMeasure.aGetMaxValues(rMaxSpeed => mrMaxVelocity,
                             rMaxPressure => mrMaxPressure,
                             bPressureLimitReached => mbPressureLimitReached,
                             bSpeedLimitReached => mbVelocityLimitReached);
IF mbprActPressureLinked THEN
   rMaxPressureBwd := MAX(rMaxPressureBwd, mrMaxPressure);
   dummy := Print('Calib min output: with act. min output %s max pressure %f needed', sWriteSpeedLimit, mrMaxPressure);       
END_IF;    
sFileName := CONCAT(sMoveName,"_MINSPEED_BWD_");
aWriteLog(sFileName := sFileName,
          iFileCounter := iFileCounter,
          bDeleteFiles := TRUE);
iFileCounter := iFileCounter + 1;

@F 

@Trans @RT(9)TWriteBwd @F @T @F @F @T @T @TL(2)
mbLogFileSaved

@RT(9)TWriteBwd @F 
@Step @RT(20)S_CHECK_MINSPEED_BWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(17)ACheckMinSpeedBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(20)
aCalcMinSpeedOutput(rMaxSpeedLimit := mActMovement^.prVelocityLimitBwd^,
                    rActRefSpeed := rRefSpeedLimit,
                    rActMinSpeed := abSpeedMeasure.aGetMaxValues.rMaxSpeed,
                    bUnstable := abSpeedMeasure.aGetMaxValues.bSpeedLimitUnStable,
                    bTimeOut := bTimeOut);
bMinBwdDetected := aCalcMinSpeedOutput.bMinDetected;
IF (bMinBwdDetected) THEN
   rSpeedLimitBwd := aCalcMinSpeedOutput.rMinSpeed;
   dummy := Print('Calib min output %s Bwd finished: min output bwd = %f$N', sMoveName, rSpeedLimitBwd);
ELSE   
   bMinBwdRetry := TRUE;
   rRefSpeedLimit := aCalcMinSpeedOutput.rRefSpeed;
   aCalcMinSpeedOutput.bStart := FALSE;
END_IF;

mActMovement^.pConstBwdVis^ := ConstVisBwd;
mActMovement^.prVelocityBwd^ := rSpeedLimitBwd;
mActMovement^.pdMaxMoveTimeBwd^ := dMaxMoveTimeSaveBwd;


@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(15)TMaxBwdDetected @F @T @F @F @T @T @TL(2)
bMinBwdDetected

@RT(15)TMaxBwdDetected @F 

@TransSeq @RT(4)tseq @F 8 
@Trans @RT(12)TMaxBwdRetry @F @T @F @F @T @T @TL(2)
bMinBwdRetry

@RT(12)TMaxBwdRetry @F 
@Step @RT(18)S_ReadyMinBwdRetry @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(17)AReadyMinBwdRetry @F @T @RT(1)N @RT(0) @F @F @T @TL(2)
fbCheckReady(DeviceId := mActMovement^.DeviceId);

@F 

@Trans @RT(17)TReadyMinBwdRetry @F @T @F @F @T @T @TL(2)
fbCheckReady.bReady

@RT(7)Trans49 @F 
@Step @RT(13)S_MinBwdRetry @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(20)AStartMovementBwdFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(4)
bMoveFwdDone := FALSE;
miErrorNo := cIdentSpeedMinBwdStart;
aStartMovementFwd();

@F 
@Acb @RT(28)ACheckActMovementBwdFwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveFwdDone := TRUE;
END_IF;

@F 
@Acb @RT(19)AStopMovementBwdFwd @F @T @RT(2)P0 @RT(0) @F @F @T @TL(4)
aStopMovementFwd();



@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(12)TMoveFwdDone @F @T @F @F @T @T @TL(2)
bMoveFwdDone

@RT(12)TMoveFwdDone @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(12)TStopMoveFwd @F @T @F @F @T @F @TL(6)
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0
OR mActMovement^.bRedo = FALSE


@RT(12)TStopMoveFwd @F 
@Step @RT(13)S_StopMoveFwd @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(17)AStopMoveErrorFwd @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident Bwd: Fwd to start position'));

@F 

@Trans @RT(9)TResetBwd @F @T @F @F @T @T @TL(2)
TRUE

@RT(9)TResetBwd @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(23)S_CHECK_ALARMS_RETRYBWD @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(9)TRetryBwd @F @T @F @F @T @T @TL(2)
S_CHECK_ALARMS_RETRYBWD.T > T#1s

@RT(9)TRetryBwd @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(14)TStopIdentBwd4 @F @T @F @F @T @F @TL(2)
sv_iPendingAlarms <> 0

@RT(14)TStopIdentBwd4 @F 
@Goto @RT(13)S_StopMoveFwd @F @F 


@Goto @RT(11)S_CALIB_BWD @F @F 


@Step @RT(12)S_MoveEndBwd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(11)AMoveEndBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(23)
bMoveBwdDone := FALSE;

IF mActMovement^.bPositionIncreasingFwd THEN
   mActMovement^.prIdentPosition^ := mrBwdStopPosition;
ELSE
   mActMovement^.prIdentPosition^ := mActMovement^.prStroke^ - mrBwdStopPosition;
END_IF;
mActMovement^.prStopRamp^ := 1.0e10;
mActMovement^.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e20,mActMovement^.pConstBwdVis^.Pressure.Output.rRamp);
mActMovement^.pConstBwdVis^.Pressure.rMinOutput := 0.1 * rMaxPressureLimit;
mActMovement^.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := mActMovement^.DeviceId;
evStartRequestData.MoveDir := cMoveBwd; 
IF mActMovement^.MoveId > cMoveNone THEN
   evStartRequestData.MoveId := cMoveDecompAftPlast;
ELSE
   evStartRequestData.MoveId := cMoveBwd;
END_IF;
miErrorNo := cIdentSpeedMinEnd;
SET_EVENT(evStartRequest, evStartRequestData); 


@F 
@Acb @RT(21)ACheckMoveEndBwdReady @F @T @RT(1)N @RT(0) @F @F @T @TL(5)
fbCheckReady(DeviceId := evStartRequestData.DeviceId);
IF fbCheckReady.bReady THEN
   bMoveBwdDone := TRUE;
END_IF;

@F 
@Acb @RT(16)AMoveEndBwdReady @F @T @RT(2)P0 @RT(0) @F @F @T @TL(2)
aStopMovementBwd();

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(15)TMoveEndBwdDone @F @T @F @F @T @T @TL(2)
bMoveBwdDone

@RT(15)TMoveEndBwdDone @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(15)TStopMoveEndBwd @F @T @F @F @T @F @TL(4)
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0

@RT(15)TStopMoveEndBwd @F 
@Step @RT(16)S_StopMoveEndBwd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(20)AStopMoveErrorEndBwd @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
aStopMovementError(sMovementName := CONCAT(sMoveName, ' min ident: Bwd to end position'));

@F 

@Trans @RT(16)TResetMoveEndBwd @F @T @F @F @T @F @TL(2)
TRUE

@RT(16)TResetMoveEndBwd @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(6)S_Done @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(5)ADone @F @T @RT(1)P @RT(0) @F @F @T @TL(16)
mActMovement^.Status := tnCalibState_Done;
sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Done;

mActMovement^.prVelocityFwd^ := rSpeedLimitFwd;
mActMovement^.prVelocityBwd^ := rSpeedLimitBwd;
IF mbprActPressureLinked THEN
   IF CHECK_REF(mActMovement^.prIdentPressureFwd^) THEN
      aRound(rActNumber := rMaxPressureFwd, rStep := rPressureStep);
      mActMovement^.prIdentPressureFwd^ := MAX(mActMovement^.prIdentPressureFwd^, aRound.rRoundedNumber * rPressureFactorFwd);
   END_IF;
   IF CHECK_REF(mActMovement^.prIdentPressureBwd^) THEN
      aRound(rActNumber := rMaxPressureBwd, rStep := rPressureStep);
      mActMovement^.prIdentPressureBwd^ := MAX(mActMovement^.prIdentPressureBwd^, aRound.rRoundedNumber * rPressureFactorBwd);
   END_IF;
END_IF;   

@F 

@Trans @RT(5)TDone @F @T @F @F @T @T @TL(2)
TRUE

@RT(5)TDone @F 
@Goto @RT(7)S_RESET @F @F 
@END_SfcData 
@SaActions 0 
@SaTrans 0 
@SaExits 0 
@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(35)
//stop all calibrations
// TEST
IF sv_GlobalIdentMinSpeedStatus.Command = tnCalibCommand_Stop THEN
    sv_GlobalIdentMinSpeedStatus.bStart := FALSE;
END_IF;
//
IF sv_GlobalIdentMinSpeedStatus.Command = tnCalibCommand_Stop OR (NOT sv_GlobalIdentMinSpeedStatus.bStart) THEN
    FOR i:= 1 TO cCalibMovements DO
        IF CHECK_REF(sv_GlobalIdentMinSpeedStatus.pMovements[i]^) THEN
            IF sv_GlobalIdentMinSpeedStatus.pMovements[i]^.Status = tnCalibState_Running OR
               sv_GlobalIdentMinSpeedStatus.pMovements[i]^.bRedo THEN
                sv_GlobalIdentMinSpeedStatus.pMovements[i]^.Status := tnCalibState_Aborted;
                sv_GlobalIdentMinSpeedStatus.pMovements[i]^.bRedo := FALSE;//FIXME: check if needed
                sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Aborted;
                EXIT;
            END_IF;
        END_IF;
    END_FOR;
    IF (sv_GlobalIdentMinSpeedStatus.Command = tnCalibCommand_Stop) THEN
       IF (sv_GlobalIdentMinSpeedStatus.Status <> tnCalibState_Aborted) THEN
          sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_None;
       END_IF;
       
    END_IF;
ELSIF (sv_GlobalIdentMinSpeedStatus.Command = tnCalibCommand_Start) OR (sv_GlobalIdentMinSpeedStatus.bStart) THEN
    IF sv_OperationMode = nSetup THEN
        mbUseSingleMovement := FALSE;
        START_PROCESS_ALGORITHM(paMinCalibSequence);
    ELSE
        sv_GlobalIdentMinSpeedStatus.bStart := FALSE;
        SET_ALARM(erSetupModeRequiredForCalib);
    END_IF;
END_IF;
sv_GlobalIdentMinSpeedStatus.Command := tnCalibCommand_None;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
18 18 17 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 15 
@Step @RT(7)S_RESET @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(6)AReset @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
sv_bAutoIdentRunning := FALSE;

@F 
@Acb @RT(14)AStopMovements @F @T @RT(1)N @RT(0) @F @F @T @TL(12)
(* stop all identification movements *)
FOR i:= 1 TO cCalibMovements DO
    IF CHECK_REF(sv_GlobalIdentMinSpeedStatus.pMovements[i]^) THEN
        IF sv_GlobalIdentMinSpeedStatus.pMovements[i]^.Status = tnCalibState_Running OR
           sv_GlobalIdentMinSpeedStatus.pMovements[i]^.bRedo THEN
            sv_GlobalIdentMinSpeedStatus.pMovements[i]^.Status := tnCalibState_Aborted;
            sv_GlobalIdentMinSpeedStatus.pMovements[i]^.bRedo := FALSE;//FIXME: check if needed
            EXIT;
        END_IF;
    END_IF;
END_FOR;

@F 
@Acb @RT(9)AStopSelf @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
sv_GlobalIdentMinSpeedStatus.bStart := FALSE;
STOP_PROCESS_ALGORITHM();

@F 

@Trans @RT(7)Trans50 @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)Trans50 @F 
@Step @RT(6)S_INIT @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(11)ASortCalibs @F @T @RT(1)P @RT(0) @F @F @T @TL(24)
sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Running;
miErrorNo := 0;

tmpMovements := sv_GlobalIdentMinSpeedStatus.pMovements;

(* get number of movements *)
FOR i:= 1 TO cCalibMovements DO
    IF NOT CHECK_REF(tmpMovements[i]^)  THEN
        EXIT;
    END_IF;
END_FOR;
iMaxMovements := i -1;

(* sort them by iOrder *)
FOR i := 1 TO iMaxMovements -1 DO
    FOR j := 1 TO iMaxMovements - 1 - i +1 DO
        IF tmpMovements[j]^.iOrder > tmpMovements[j + 1]^.iOrder THEN
            tmpM := tmpMovements[j];
            tmpMovements[j] := tmpMovements[j + 1];
            tmpMovements[j + 1] := tmpM;
        END_IF;    
    END_FOR;    
END_FOR;

@F 
@Acb @RT(9)Action108 @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
mCalibCounter := 0;
sv_GlobalIdentMinSpeedStatus.iCurrentStep := mCalibCounter;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans80 @F @T @F @F @T @T @TL(3)
NOT sv_bCoresActive AND
sv_iPendingAlarms = 0

@RT(7)Trans80 @T @TL(5)
Comment : Start with moving ejector and 
mold in backward position, check if any failure 
occured. 
After that start the calibration cycle, if no alarm is 
pending


@TransSeq @RT(4)tseq @F 4 
@Trans @RT(7)Trans87 @F @T @F @F @T @F @TL(4)
sv_bCoresActive OR 
sv_iPendingAlarms > 0


@RT(7)Trans87 @F 
@Step @RT(6)Step74 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(14)AAnyCoreActive @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(7)Trans88 @F @T @F @F @T @T @TL(3)
TRUE


@RT(7)Trans88 @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(6)Step19 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(12)ASignalStart @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
sv_bAutoIdentRunning := TRUE;

@F 

@Trans @RT(7)Trans18 @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)Trans18 @F 
@Step @RT(17)S_MoveEjectorBack @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(12)AEjectorBack @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(9)Action116 @F @T @RT(1)N @RT(0) @F @F @T @TL(2)
fbCheckReady(DeviceId := DeviceIdEjector)

@F 
@Acb @RT(17)AResetEjectorBack @F @T @RT(2)P0 @RT(0) @F @F @T @TL(7)
miErrorNo := 0;
sv_EjectorIdentMinMovement.prIdentPosition^ := 0.0;
sv_EjectorIdentMinMovement.prStopRamp^ := 0.0;
sv_EjectorIdentMinMovement.pbMoveIdent^ := FALSE;
sv_EjectorIdentMinMovement.pConstBwdVis^ := ConstBwdVis;


@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans72 @F @T @F @F @T @T @TL(3)
fbCheckReady.bReady AND
sv_iPendingAlarms = 0

@RT(7)Trans72 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(7)Trans83 @F @T @F @F @T @F @TL(4)
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0

@RT(7)Trans83 @F 
@Step @RT(13)S_StopEjector @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(16)AStopEjeMovement @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(7)Trans84 @F @T @F @F @T @T @TL(3)
TRUE


@RT(7)Trans84 @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(14)S_MoveMoldBack @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(9)AMoldBack @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(9)Action118 @F @T @RT(1)N @RT(0) @F @F @T @TL(2)
fbCheckReady(DeviceId := DeviceIdMold)

@F 
@Acb @RT(14)AResetMoldBack @F @T @RT(2)P0 @RT(0) @F @F @T @TL(7)
miErrorNo := 0;
sv_MoldIdentMinMovement.prIdentPosition^ := 0.0;
sv_MoldIdentMinMovement.prStopRamp^ := 0.0;
sv_MoldIdentMinMovement.pbMoveIdent^ := FALSE;
sv_MoldIdentMinMovement.pConstBwdVis^ := ConstBwdVis;


@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans81 @F @T @F @F @T @T @TL(3)
fbCheckReady.bReady AND
sv_iPendingAlarms = 0

@RT(7)Trans81 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(7)Trans85 @F @T @F @F @T @F @TL(4)
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_None
OR sv_iPendingAlarms <> 0

@RT(7)Trans85 @F 
@Step @RT(10)S_StopMold @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(17)AStopMoldMovement @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(7)Trans86 @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)Trans86 @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(14)S_CALIB_SINGLE @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(19)AStartMovementStart @F @T @RT(1)P @RT(0) @F @F @T @TL(5)
IF mCalibCounter < iMaxMovements THEN
   mCalibCounter := mCalibCounter +1;
   tmpMovements[mCalibCounter]^.bRedo := TRUE;
END_IF;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(18)TCheckActMoveReady @F @T @F @F @T @T @TL(4)
tmpMovements[mCalibCounter]^.bRedo = FALSE AND
NOT(sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
    sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Error)

@RT(18)TCheckActMoveReady @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(11)TCheckError @F @T @F @F @T @F @TL(4)
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Aborted OR
sv_GlobalIdentMinSpeedStatus.Status = tnCalibState_Error OR 
iMaxMovements = 0

@RT(11)TCheckError @F 
@Goto @RT(7)S_RESET @F @F 


@Step @RT(11)S_CHECKNEXT @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(9)TNextUnit @F @T @F @F @T @T @TL(3)
mCalibCounter < iMaxMovements
//AND S_CHECKNEXT.T>T#3s

@RT(9)TNextUnit @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(10)TStopIdent @F @T @F @F @T @T @TL(2)
mCalibCounter >= iMaxMovements

@RT(10)TStopIdent @F 
@Step @RT(11)S_StopIdent @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(10)AStopIdent @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Done;

@F 

@Trans @RT(6)TReset @F @T @F @F @T @T @TL(2)
TRUE

@RT(6)TReset @F 
@Goto @RT(7)S_RESET @F @F 


@Goto @RT(14)S_CALIB_SINGLE @F @F 
@END_SfcData 
@SaActions 5 
@SaText @RT(12)AEjectorBack 1 @TL(20)
miErrorNo := cIdentSpeedMinSequence;

IF sv_EjectorIdentMinMovement.bPositionIncreasingFwd THEN
   sv_EjectorIdentMinMovement.prIdentPosition^ := mrBwdStopPosition;
ELSE
   sv_EjectorIdentMinMovement.prIdentPosition^ := sv_EjectorIdentMinMovement.prStroke^ - mrBwdStopPosition;
END_IF;
sv_EjectorIdentMinMovement.prStopRamp^ := 1.0e10;
ConstBwdVis := sv_EjectorIdentMinMovement.pConstBwdVis^;
sv_EjectorIdentMinMovement.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e10, sv_EjectorIdentMinMovement.pConstBwdVis^.Pressure.Output.rRamp);
sv_EjectorIdentMinMovement.pConstBwdVis^.Pressure.rMinOutput := 0.1 * sv_EjectorIdentMinMovement.prMaxPressureBwd^;
sv_EjectorIdentMinMovement.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := DeviceIdEjector;
evStartRequestData.MoveDir := cMoveBwd; 
evStartRequestData.MoveId := cMoveBwd;
SET_EVENT(evStartRequest, evStartRequestData);




@SaText @RT(9)AMoldBack 1 @TL(19)
miErrorNo := cIdentSpeedMinSequence;

IF sv_MoldIdentMinMovement.bPositionIncreasingFwd THEN
   sv_MoldIdentMinMovement.prIdentPosition^ := mrBwdStopPosition;
ELSE
   sv_MoldIdentMinMovement.prIdentPosition^ := sv_MoldIdentMinMovement.prStroke^ - mrBwdStopPosition;
END_IF;
sv_MoldIdentMinMovement.prStopRamp^ := 1.0e10;
ConstBwdVis := sv_MoldIdentMinMovement.pConstBwdVis^;
sv_MoldIdentMinMovement.pConstBwdVis^.Pressure.Output.rRamp := MAX(1.0e10, sv_MoldIdentMinMovement.pConstBwdVis^.Pressure.Output.rRamp);
sv_MoldIdentMinMovement.pConstBwdVis^.Pressure.rMinOutput := 0.1 * sv_MoldIdentMinMovement.prMaxPressureBwd^;
sv_MoldIdentMinMovement.pbMoveIdent^ := TRUE;

evStartRequestData.DeviceId := DeviceIdMold;
evStartRequestData.MoveDir := cMoveBwd; 
evStartRequestData.MoveId := cMoveBwd;
SET_EVENT(evStartRequest, evStartRequestData); 



@SaText @RT(16)AStopEjeMovement 1 @TL(10)
evStopRequestData.DeviceId := DeviceIdEjector;  
evStopRequestData.MoveDir := cMoveBwd;  
evStopRequestData.MoveId := cMoveBwd;      
SET_EVENT(evStopRequest, evStopRequestData);
IF sv_GlobalIdentMinSpeedStatus.Status <> tnCalibState_None THEN
    sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Aborted;
END_IF;




@SaText @RT(17)AStopMoldMovement 1 @TL(10)
evStopRequestData.DeviceId := DeviceIdMold;  
evStopRequestData.MoveDir := cMoveBwd;  
evStopRequestData.MoveId := cMoveBwd;      
SET_EVENT(evStopRequest, evStopRequestData);
IF sv_GlobalIdentMinSpeedStatus.Status <> tnCalibState_None THEN
    sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Aborted;
END_IF;




@SaText @RT(14)AAnyCoreActive 1 @TL(6)
IF sv_bCoresActive THEN
   SET_ALARM(erCalibCoresActive);
END_IF;
sv_GlobalIdentMinSpeedStatus.Status := tnCalibState_Aborted;



@SaTrans 0 
@SaExits 1 
@SaExit @SaText @RT(14)E_NotSetupMode 1 @TL(2)
sv_OperationMode <> nSetup

@RT(7)S_RESET @RT(1)1 @F @F @SaSfc @RT(14)E_NotSetupMode 5 @RT(5)DUMMY 
@BEG_SfcData 2 
@ExitSeq @RT(4)sseq @F 3 
@Step @RT(8)unnamed1 @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@Trans @RT(8)unnamed3 @F @T @F @F @T @T @TL(2)


@RT(8)unnamed3 @F 
@Goto @RT(9)unlabeled @F @F 
@END_SfcData 

@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(2)
Coordinate sequential start of auto calib cycle
starts one auto calib movement after the other
@@@END_Comment@@@ 

@BEG_Body 
@TL(27)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//reset calib state after loading machine data

IF sv_DataState = nReadMachineData THEN
   //loading of machinedata in progress
   bMDLoadingInProgress := TRUE;
   RETURN;
END_IF;

IF sv_DataState = nReady AND bMDLoadingInProgress THEN
   FOR i := 1 TO sv_GlobalIdentMaxSpeedStatus.iMaxStep DO      
      //set state to tnCalibState_None
      sv_GlobalIdentMaxSpeedStatus.pMovements[i]^.Status := tnCalibState_None;
   END_FOR;
   FOR i := 1 TO sv_GlobalIdentMinSpeedStatus.iMaxStep DO      
      //set state to tnCalibState_None
      sv_GlobalIdentMinSpeedStatus.pMovements[i]^.Status := tnCalibState_None;
   END_FOR;
   bMDLoadingInProgress := FALSE;
END_IF;



@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
