(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

processdata recorder
*)

IMPORT_OVER_LISTFILE
 FTimeToSec
, KCAT_GetHandle
, KCAT_GetValue
, STOP_PROCESS_ALGORITHM
, GET_SYNC_REFTO
, KCAT_AddValue
, KCAT_RemoveDir
, FGetCatConfigValueString
, CONVERT_LREAL_TO_LWORD
, cCompInjection
, cPDRMaxVars
, KCAT_Type_STRING
, cPDRMaxLines
, tsProcessDataRecorder
, tyyPDRProcessData
, tyyPDRProcessDataRaw
, tevMovementState
, tyPDRConfiguration
, KCAT_HandleData
, KCAT_Status
, tyPDRProcessDataReal
, tyPDRProcessDataRaw
, RTC
, tevMovementStateData
, KSYS_Status
, tsPDRVarRef

END_IMPORT

ALGORITHM_BLOCK ABProcessDataRecorder #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_ProcessDataRecorder : tsProcessDataRecorder;
 sv_iShotCounterAct : DINT;
END_VAR

SYSTEM_OBJECT
 PU_Task_3 : TASK;
 evMovementState : tevMovementState;
 TaskVis : TASK;
 PU_Task_7 : TASK;
END_OBJECT

VAR
 mActProcessData : tyyPDRProcessData;
 mActProcessDataRaw : tyyPDRProcessDataRaw;
 mpiTrigger : REFTO DINT;
 mpiTriggerPU : REFTO DINT;
 mevMovementState : tevMovementState;
 mRecorderConfiguration : tyPDRConfiguration;
 mWriteIdx : DINT;
 mReadIdx : DINT;
 mIdxLastPdrVar : DINT;
 miMode : DINT;
 mpiTriggerClient : REFTO DINT;
END_VAR

VAR CONSTANT
 cConfigNode : STRING(255) := 'Application.ProcessDataRecorder:0';
 cConfigNodeCfgFile : STRING(255) := 'CfgFile';
END_VAR

FUNCTION fReadConfigInt : BOOL
 #DUMMY_EDIT_BLOCK

VAR_INPUT
 name : STRING(255);
END_VAR

VAR_IN_OUT
 value : DINT;
END_VAR

VAR
 handleData : KCAT_HandleData;
 status : KCAT_Status;
END_VAR
#BEGIN_EDIT_BLOCK
fReadConfigInt := FALSE; 
handleData := KCAT_GetHandle(CONCAT(cConfigNode, ".", name));
IF (handleData.Status = KCAT_Status_OK) THEN
    status := KCAT_GetValue(handleData.Handle, value); 
    IF (status = KCAT_Status_OK) THEN
        fReadConfigInt := TRUE;
    END_IF;
END_IF;


;#END_EDIT_BLOCK END_FUNCTION

FUNCTION fReadConfigString : BOOL
 #DUMMY_EDIT_BLOCK

VAR_INPUT
 name : STRING(255);
END_VAR

VAR_IN_OUT
 value : STRING(255);
END_VAR

VAR
 handleData : KCAT_HandleData;
 status : KCAT_Status;
END_VAR
#BEGIN_EDIT_BLOCK
fReadConfigString := FALSE; 
handleData := KCAT_GetHandle(CONCAT(cConfigNode, ".", name));
IF (handleData.Status = KCAT_Status_OK) THEN
    status := KCAT_GetValue(handleData.Handle, value); 
    IF (status = KCAT_Status_OK) THEN
        fReadConfigString := TRUE;
    END_IF;
END_IF; 
   


;#END_EDIT_BLOCK END_FUNCTION

FUNCTION fReadOrAddConfigString : BOOL
 #DUMMY_EDIT_BLOCK

VAR_INPUT
 name : STRING(255);
END_VAR

VAR_IN_OUT
 value : STRING(255);
END_VAR

VAR_INPUT
 default : STRING(255);
END_VAR

VAR
 handleData : KCAT_HandleData;
 status : KCAT_Status;
END_VAR
#BEGIN_EDIT_BLOCK
fReadOrAddConfigString := fReadConfigString(name, value);

IF (NOT fReadOrAddConfigString) THEN
        value := default;        
 
        handleData := KCAT_GetHandle(cConfigNode);
        IF (handleData.Status <> KCAT_Status_OK) THEN
            handleData := KCAT_GetRoot();
            handleData := KCAT_AddDir(handleData.Handle, cConfigNode);
        END_IF;
        IF (handleData.Status = KCAT_Status_OK) THEN
            status := KCAT_AddValue(handleData.Handle, name, KCAT_Type_STRING, value);
            fReadOrAddConfigString := status = KCAT_Status_OK;
        END_IF;              
END_IF;
   


;#END_EDIT_BLOCK END_FUNCTION

ALGORITHM aSignalRead

#BEGIN_EDIT_BLOCK
IF (mpiTriggerClient^ = 0) THEN 
    IF (mReadIdx <> mWriteIdx) THEN
       IF (miMode = 0) THEN
           // sample mode REAL
          sv_ProcessDataRecorder.data := mActProcessData[mReadIdx + 1];
       ELSIF (miMode = 1) THEN 
           // sample mode Raw
          sv_ProcessDataRecorder.dataRaw := mActProcessDataRaw[mReadIdx + 1];
       END_IF;
       mReadIdx := (mReadIdx + 1) MOD cPDRMaxLines;
    END_IF;   
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aDoSample


VAR_INPUT
 iGroupId : DINT;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 b : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
IF (NOT sv_ProcessDataRecorder.bActivate) THEN
    RETURN;
END_IF;
IF (miMode = 0) THEN 
    // sample mode REAL
    FOR i := 1 TO mIdxLastPdrVar DO
        IF (mRecorderConfiguration[i].sampleGroup = iGroupId) THEN
            IF (mRecorderConfiguration[i].prReal <> EMPTY) THEN
                mActProcessData[mWriteIdx+1].yParameter[i] := mRecorderConfiguration[i].prReal^; 
            ELSIF (mRecorderConfiguration[i].pdTime <> EMPTY) THEN
                mActProcessData[mWriteIdx+1].yParameter[i] := FTimeToSec(mRecorderConfiguration[i].pdTime^);
            ELSIF (mRecorderConfiguration[i].piDInt <> EMPTY) THEN
                mActProcessData[mWriteIdx+1].yParameter[i] := DINT_TO_REAL(mRecorderConfiguration[i].piDInt^);
            END_IF;
        END_IF;
    END_FOR;
ELSIF (miMode = 1) THEN 
    // sample mode RAW
     FOR i := 1 TO mIdxLastPdrVar DO
        IF (mRecorderConfiguration[i].sampleGroup = iGroupId) THEN
            CASE (mRecorderConfiguration[i].nType) OF 
                cPDRVarTypeReal: 
                    b := CONVERT_LREAL_TO_LWORD(REAL_TO_LREAL(mRecorderConfiguration[i].prReal^), mActProcessDataRaw[mWriteIdx+1].yParameter[i]);

                cPDRVarTypeTime: 
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(TIME_TO_LINT(mRecorderConfiguration[i].pdTime^));
                
                cPDRVarTypeDInt: 
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(DINT_TO_LINT(mRecorderConfiguration[i].piDInt^));

                cPDRVarTypeLReal: 
                    b := CONVERT_LREAL_TO_LWORD(mRecorderConfiguration[i].prLReal^, mActProcessDataRaw[mWriteIdx+1].yParameter[i]);
                
                cPDRVarTypeBool: 
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(BOOL_TO_LINT(mRecorderConfiguration[i].pbBool^));

                cPDRVarTypeDT: 
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(DATE_TO_LINT(DT_TO_DATE(mRecorderConfiguration[i].pdDT^))+TIME_TO_LINT(TOD_TO_TIME(DT_TO_TOD(mRecorderConfiguration[i].pdDT^))));

                cPDRVarTypeSInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(SINT_TO_LINT(mRecorderConfiguration[i].piSInt^));

                cPDRVarTypeInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(INT_TO_LINT(mRecorderConfiguration[i].piInt^));

                cPDRVarTypeLInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(mRecorderConfiguration[i].piLInt^);

                cPDRVarTypeUSInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := USINT_TO_LWORD(mRecorderConfiguration[i].piUSInt^);
                
                cPDRVarTypeUInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := UINT_TO_LWORD(mRecorderConfiguration[i].piUInt^);

                cPDRVarTypeUDInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := UDINT_TO_LWORD(mRecorderConfiguration[i].piUDInt^);

                cPDRVarTypeULInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := ULINT_TO_LWORD(mRecorderConfiguration[i].piULInt^);

             END_CASE;
        END_IF;
    END_FOR; 
END_IF;

  


;#END_EDIT_BLOCK END_ALGORITHM

(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".


*)

POSTUPDATE_ALGORITHM pTriggerVariable ON PU_Task_3 WITH mpiTriggerPU^


VAR
 fbRtc : RTC;
 t : TIME;
 ts : TIME;
END_VAR

VAR CONSTANT
 emptyProcessData : tyPDRProcessDataReal;
 emptyProcessDataRaw : tyPDRProcessDataRaw;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

ts := GET_RUNTIME();
aDoSample(0);
fbRtc();

IF (miMode = 0) THEN
    // sample mode REAL
    mActProcessData[mWriteIdx+1].iTrigger := mpiTriggerPU^;
    mActProcessData[mWriteIdx+1].dTimeStamp := fbRtc.CDT;
    mWriteIdx := (mWriteIdx + 1) MOD cPDRMaxLines;
    mActProcessData[mWriteIdx + 1].yParameter := emptyProcessData; 
    mActProcessData[mWriteIdx + 1].iTrigger := 0; 
ELSIF (miMode = 1) THEN 
    // sample mode RAW
    mActProcessDataRaw[mWriteIdx+1].iTrigger := mpiTriggerPU^;
    mActProcessDataRaw[mWriteIdx+1].dTimeStamp := fbRtc.CDT;
    mWriteIdx := (mWriteIdx + 1) MOD cPDRMaxLines;
    mActProcessDataRaw[mWriteIdx + 1].yParameter := emptyProcessDataRaw; 
    mActProcessDataRaw[mWriteIdx + 1].iTrigger := 0; 
END_IF;

IF (mWriteIdx = mReadIdx) THEN
    mReadIdx := (mReadIdx + 1) MOD cPDRMaxLines;
END_IF;

aSignalRead();

t := GET_RUNTIME() - ts; 


;#END_EDIT_BLOCK END_ALGORITHM

(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

collects processdata: sample values at inject
*)

EVENT_ALGORITHM pInjectData ON PU_Task_3 WITH mevMovementState


VAR_INPUT
 evMovementStateData : tevMovementStateData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF ((evMovementStateData.DeviceId.CompId = cCompInjection)
   AND (evMovementStateData.DeviceId.IndexId = 1)
   AND (evMovementStateData.MoveId   = cMoveInject)
   AND (evMovementStateData.MoveDir  = cMoveFwd)
   AND (evMovementStateData.State  = nActive)) THEN 
    
    // copy data at inject time
    aDoSample(16);
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aInit


VAR_TEMP
 activate : DINT;
 i : DINT;
END_VAR

VAR
 b : BOOL;
 name : STRING(255);
 s : KSYS_Status;
 cnt : INT;
 cfgFile : STRING(255);
END_VAR
#BEGIN_EDIT_BLOCK
b := fReadOrAddConfigString(cConfigNodeCfgFile, cfgFile, 'workspace/data/pdr.cfg');

miMode := 0; 
b := fReadConfigInt("Mode", miMode);
b := fReadConfigInt("Activate", activate);
                         
IF (fReadConfigString("Trigger", name)) THEN
   mpiTrigger := GET_SYNC_REFTO(name, T#0s, s); 
END_IF;

IF (mpiTrigger = EMPTY) THEN
    mpiTrigger := @sv_iShotCounterAct;
END_IF;


FOR i := 1 TO cPDRMaxVars DO
   mRecorderConfiguration[i].nType := cPDRVarTypeNone; 
   IF (fReadConfigString(CONCAT("Var:", DINT_TO_STRING(i), ".Name"), name)) THEN
       
       /////////   R E A L   /////////    
       IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
          mRecorderConfiguration[i].prReal := GET_SYNC_REFTO(name, T#0s, s);
          IF (s = KSYS_Status_OK) THEN
             mRecorderConfiguration[i].nType := cPDRVarTypeReal;           
          END_IF;
       END_IF;
       /////////   T I M E   /////////    
       IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
          mRecorderConfiguration[i].pdTime := GET_SYNC_REFTO(name, T#0s, s);
          IF (s = KSYS_Status_OK) THEN
             mRecorderConfiguration[i].nType := cPDRVarTypeTime;           
          END_IF;
       END_IF;
       /////////   D I N T   /////////    
       IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
          mRecorderConfiguration[i].piDInt := GET_SYNC_REFTO(name, T#0s, s);
          IF (s = KSYS_Status_OK) THEN
             mRecorderConfiguration[i].nType := cPDRVarTypeDInt;           
          END_IF;
       END_IF;
       
       IF (miMode > 0) THEN
            /////////   L R E A L   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].prLReal := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeLReal;           
                END_IF;
            END_IF; 
            /////////   B O O L   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].pbBool := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeBool;           
                END_IF;
            END_IF;
            /////////   D A T E  &  T I M E   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].pdDT := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeDT;           
                END_IF;
            END_IF;
            /////////   S I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piSInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeSInt;           
                END_IF;
            END_IF;
            /////////   I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeInt;           
                END_IF;
            END_IF;
            /////////   L I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piLInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeLInt;           
                END_IF;
            END_IF;
            /////////   U S I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piUSInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeUSInt;           
                END_IF;
            END_IF;
                /////////   U I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piUInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeUInt;           
                END_IF;
            END_IF;
            /////////   U D I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piUDInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeUDInt;           
                END_IF;
            END_IF;
            /////////   U L I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piULInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeULInt;           
                END_IF;
            END_IF;
       END_IF;
       
       // Type found ... save last used index in configuration
       IF (mRecorderConfiguration[i].nType <> cPDRVarTypeNone) THEN 
          mIdxLastPdrVar := i;
       END_IF;           
                          
       cnt := cnt + 1; 
       b := fReadConfigInt(CONCAT("Var:", DINT_TO_STRING(i), ".SampleGroup"), mRecorderConfiguration[i].sampleGroup);
   END_IF;
   sv_ProcessDataRecorder.yActiveVariables[i] := mRecorderConfiguration[i].nType;    
END_FOR;             

IF (activate <> 0) THEN
    sv_ProcessDataRecorder.bActivate := TRUE; 
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paInit ON TaskVis(1) AUTOSTART

#BEGIN_EDIT_BLOCK
STOP_PROCESS_ALGORITHM();

aInit();


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pReadDone ON PU_Task_3 WITH mpiTriggerClient^

#BEGIN_EDIT_BLOCK
aSignalRead();


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pActivate ON PU_Task_7 WITH sv_ProcessDataRecorder.bActivate

#BEGIN_EDIT_BLOCK
IF (sv_ProcessDataRecorder.bActivate) THEN
   mpiTriggerPU := mpiTrigger; 
   mevMovementState := evMovementState;
   IF (miMode = 0) THEN
       // sample mode real
       mpiTriggerClient := @sv_ProcessDataRecorder.data.iTrigger;
   ELSIF (miMode = 1) THEN 
       // sample mode raw
       mpiTriggerClient := @sv_ProcessDataRecorder.dataRaw.iTrigger;
   END_IF;
ELSE
   mpiTriggerPU := EMPTY;
   mevMovementState := EMPTY;
   mpiTriggerClient := EMPTY;
END_IF;




;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pReload ON TaskVis WITH sv_ProcessDataRecorder.iReloadConfiguration


VAR_TEMP
 i : DINT;
END_VAR

VAR
 b : BOOL;
 s : KCAT_Status;
 handleData : KCAT_HandleData;
 cfgFile : STRING(255);
 workPath : STRING(255);
END_VAR

VAR CONSTANT
 emptyElem : tsPDRVarRef;
END_VAR
#BEGIN_EDIT_BLOCK
IF (sv_ProcessDataRecorder.iReloadConfiguration MOD 2 = 1) THEN
    sv_ProcessDataRecorder.bActivate := FALSE;

    cfgFile := "";
    b := fReadConfigString(cConfigNodeCfgFile, cfgFile);
    handleData := KCAT_GetHandle(cConfigNode);
    IF (handleData.Status = KCAT_Status_OK) THEN
        s := KCAT_RemoveDir(handleData.Handle);  
    END_IF;
    
    workPath := FGetCatConfigValueString("System.workPath", "/");
    
    FOR i := 1 TO cPDRMaxVars DO
        mRecorderConfiguration[i] := emptyElem;
    END_FOR;
    
    mWriteIdx := 0; 
    mReadIdx := 0;
    
    s := KCAT_Load(CONCAT(workPath, "/", cfgFile));

    aInit();
    
    IF (LEN(cfgFile) > 0) THEN
      b := fReadOrAddConfigString(cConfigNodeCfgFile, cfgFile, cfgFile);  
    END_IF;
    
    sv_ProcessDataRecorder.iReloadConfiguration := sv_ProcessDataRecorder.iReloadConfiguration + 1; 
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 68 @Pou 25 
@@@BEG_Comment@@@
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

processdata recorder
@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
9 
@Var @RT(10)FTimeToSec @RT(0) @T @T @DERIVED 0 @F @RT(8)FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)KCAT_GetHandle @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)KCAT_GetValue @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(22)STOP_PROCESS_ALGORITHM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)GET_SYNC_REFTO @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)KCAT_AddValue @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)KCAT_RemoveDir @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(24)FGetCatConfigValueString @RT(0) @T @T @DERIVED 0 @F @RT(8)FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(22)CONVERT_LREAL_TO_LWORD @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
4 
@Var @RT(14)cCompInjection @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)104 @RT(19)Component Injection 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)cPDRMaxVars @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)128 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)KCAT_Type_STRING @RT(0) @T @T @DERIVED 0 @F @RT(9)KCAT_Type @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)cPDRMaxLines @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)10 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(21)ABProcessDataRecorder @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
19 
@Var @RT(22)sv_ProcessDataRecorder @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)tsProcessDataRecorder @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_iShotCounterAct @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(9)PU_Task_3 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(15)mActProcessData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tyyPDRProcessData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mActProcessDataRaw @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tyyPDRProcessDataRaw @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)evMovementState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)tevMovementState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(11)cConfigNode @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(35)'Application.ProcessDataRecorder:0' @RT(0) @RT(0) 
@END_Attrib 
1 15 @F @F @F @F 

@Var @RT(18)cConfigNodeCfgFile @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(9)'CfgFile' @RT(0) @RT(0) 
@END_Attrib 
1 15 @F @F @F @F 

@Var @RT(10)mpiTrigger @RT(0) @T @T @REFTO 0 @T @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mpiTriggerPU @RT(0) @T @T @REFTO 0 @T @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)TaskVis @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(16)mevMovementState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)tevMovementState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mRecorderConfiguration @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)tyPDRConfiguration @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)mWriteIdx @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)mReadIdx @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)PU_Task_7 @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(14)mIdxLastPdrVar @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)miMode @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mpiTriggerClient @RT(0) @T @T @REFTO 0 @T @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

12 

@BEG_Export 

@BEG_Algo 
@FUNCTION @RT(14)fReadConfigInt @STRUCTURED_TEXT 
@RT(4)BOOL @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
4 
@Var @RT(4)name @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(5)value @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 2 @F @F @F @F 

@Var @RT(10)handleData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KCAT_HandleData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)status @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KCAT_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@FUNCTION @RT(17)fReadConfigString @STRUCTURED_TEXT 
@RT(4)BOOL @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
4 
@Var @RT(4)name @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(5)value @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 2 @F @F @F @F 

@Var @RT(10)handleData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KCAT_HandleData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)status @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KCAT_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@FUNCTION @RT(22)fReadOrAddConfigString @STRUCTURED_TEXT 
@RT(4)BOOL @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(4)name @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(5)value @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 2 @F @F @F @F 

@Var @RT(10)handleData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KCAT_HandleData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)status @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KCAT_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)default @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(11)aSignalRead @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(9)aDoSample @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(8)iGroupId @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(16)pTriggerVariable @STRUCTURED_TEXT 
@RT(0) @RT(13)mpiTriggerPU^ @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(16)emptyProcessData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tyPDRProcessDataReal @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 15 @F @F @F @F 

@Var @RT(19)emptyProcessDataRaw @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tyPDRProcessDataRaw @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 15 @F @F @F @F 

@Var @RT(5)fbRtc @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)RTC @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)t @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(2)ts @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(11)pInjectData @STRUCTURED_TEXT 
@RT(0) @RT(16)mevMovementState @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(19)evMovementStateData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tevMovementStateData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(5)aInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
7 
@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)activate @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(4)name @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)s @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSYS_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(3)cnt @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)cfgFile @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(6)paInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(10)TaskVis(1) @T @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(9)pReadDone @STRUCTURED_TEXT 
@RT(0) @RT(17)mpiTriggerClient^ @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(9)pActivate @STRUCTURED_TEXT 
@RT(0) @RT(32)sv_ProcessDataRecorder.bActivate @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(7)pReload @STRUCTURED_TEXT 
@RT(0) @RT(43)sv_ProcessDataRecorder.iReloadConfiguration @RT(7)TaskVis @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
7 
@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)s @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KCAT_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)handleData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KCAT_HandleData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)cfgFile @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(8)workPath @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)emptyElem @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tsPDRVarRef @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 15 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(9)
fReadConfigInt := FALSE; 
handleData := KCAT_GetHandle(CONCAT(cConfigNode, ".", name));
IF (handleData.Status = KCAT_Status_OK) THEN
    status := KCAT_GetValue(handleData.Handle, value); 
    IF (status = KCAT_Status_OK) THEN
        fReadConfigInt := TRUE;
    END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(10)
fReadConfigString := FALSE; 
handleData := KCAT_GetHandle(CONCAT(cConfigNode, ".", name));
IF (handleData.Status = KCAT_Status_OK) THEN
    status := KCAT_GetValue(handleData.Handle, value); 
    IF (status = KCAT_Status_OK) THEN
        fReadConfigString := TRUE;
    END_IF;
END_IF; 
   

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(17)
fReadOrAddConfigString := fReadConfigString(name, value);

IF (NOT fReadOrAddConfigString) THEN
        value := default;        
 
        handleData := KCAT_GetHandle(cConfigNode);
        IF (handleData.Status <> KCAT_Status_OK) THEN
            handleData := KCAT_GetRoot();
            handleData := KCAT_AddDir(handleData.Handle, cConfigNode);
        END_IF;
        IF (handleData.Status = KCAT_Status_OK) THEN
            status := KCAT_AddValue(handleData.Handle, name, KCAT_Type_STRING, value);
            fReadOrAddConfigString := status = KCAT_Status_OK;
        END_IF;              
END_IF;
   

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(14)
IF (mpiTriggerClient^ = 0) THEN 
    IF (mReadIdx <> mWriteIdx) THEN
       IF (miMode = 0) THEN
           // sample mode REAL
          sv_ProcessDataRecorder.data := mActProcessData[mReadIdx + 1];
       ELSIF (miMode = 1) THEN 
           // sample mode Raw
          sv_ProcessDataRecorder.dataRaw := mActProcessDataRaw[mReadIdx + 1];
       END_IF;
       mReadIdx := (mReadIdx + 1) MOD cPDRMaxLines;
    END_IF;   
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(67)
IF (NOT sv_ProcessDataRecorder.bActivate) THEN
    RETURN;
END_IF;
IF (miMode = 0) THEN 
    // sample mode REAL
    FOR i := 1 TO mIdxLastPdrVar DO
        IF (mRecorderConfiguration[i].sampleGroup = iGroupId) THEN
            IF (mRecorderConfiguration[i].prReal <> EMPTY) THEN
                mActProcessData[mWriteIdx+1].yParameter[i] := mRecorderConfiguration[i].prReal^; 
            ELSIF (mRecorderConfiguration[i].pdTime <> EMPTY) THEN
                mActProcessData[mWriteIdx+1].yParameter[i] := FTimeToSec(mRecorderConfiguration[i].pdTime^);
            ELSIF (mRecorderConfiguration[i].piDInt <> EMPTY) THEN
                mActProcessData[mWriteIdx+1].yParameter[i] := DINT_TO_REAL(mRecorderConfiguration[i].piDInt^);
            END_IF;
        END_IF;
    END_FOR;
ELSIF (miMode = 1) THEN 
    // sample mode RAW
     FOR i := 1 TO mIdxLastPdrVar DO
        IF (mRecorderConfiguration[i].sampleGroup = iGroupId) THEN
            CASE (mRecorderConfiguration[i].nType) OF 
                cPDRVarTypeReal: 
                    b := CONVERT_LREAL_TO_LWORD(REAL_TO_LREAL(mRecorderConfiguration[i].prReal^), mActProcessDataRaw[mWriteIdx+1].yParameter[i]);

                cPDRVarTypeTime: 
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(TIME_TO_LINT(mRecorderConfiguration[i].pdTime^));
                
                cPDRVarTypeDInt: 
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(DINT_TO_LINT(mRecorderConfiguration[i].piDInt^));

                cPDRVarTypeLReal: 
                    b := CONVERT_LREAL_TO_LWORD(mRecorderConfiguration[i].prLReal^, mActProcessDataRaw[mWriteIdx+1].yParameter[i]);
                
                cPDRVarTypeBool: 
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(BOOL_TO_LINT(mRecorderConfiguration[i].pbBool^));

                cPDRVarTypeDT: 
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(DATE_TO_LINT(DT_TO_DATE(mRecorderConfiguration[i].pdDT^))+TIME_TO_LINT(TOD_TO_TIME(DT_TO_TOD(mRecorderConfiguration[i].pdDT^))));

                cPDRVarTypeSInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(SINT_TO_LINT(mRecorderConfiguration[i].piSInt^));

                cPDRVarTypeInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(INT_TO_LINT(mRecorderConfiguration[i].piInt^));

                cPDRVarTypeLInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := LINT_TO_LWORD(mRecorderConfiguration[i].piLInt^);

                cPDRVarTypeUSInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := USINT_TO_LWORD(mRecorderConfiguration[i].piUSInt^);
                
                cPDRVarTypeUInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := UINT_TO_LWORD(mRecorderConfiguration[i].piUInt^);

                cPDRVarTypeUDInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := UDINT_TO_LWORD(mRecorderConfiguration[i].piUDInt^);

                cPDRVarTypeULInt:
                    mActProcessDataRaw[mWriteIdx+1].yParameter[i] := ULINT_TO_LWORD(mRecorderConfiguration[i].piULInt^);

             END_CASE;
        END_IF;
    END_FOR; 
END_IF;

  

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(33)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

ts := GET_RUNTIME();
aDoSample(0);
fbRtc();

IF (miMode = 0) THEN
    // sample mode REAL
    mActProcessData[mWriteIdx+1].iTrigger := mpiTriggerPU^;
    mActProcessData[mWriteIdx+1].dTimeStamp := fbRtc.CDT;
    mWriteIdx := (mWriteIdx + 1) MOD cPDRMaxLines;
    mActProcessData[mWriteIdx + 1].yParameter := emptyProcessData; 
    mActProcessData[mWriteIdx + 1].iTrigger := 0; 
ELSIF (miMode = 1) THEN 
    // sample mode RAW
    mActProcessDataRaw[mWriteIdx+1].iTrigger := mpiTriggerPU^;
    mActProcessDataRaw[mWriteIdx+1].dTimeStamp := fbRtc.CDT;
    mWriteIdx := (mWriteIdx + 1) MOD cPDRMaxLines;
    mActProcessDataRaw[mWriteIdx + 1].yParameter := emptyProcessDataRaw; 
    mActProcessDataRaw[mWriteIdx + 1].iTrigger := 0; 
END_IF;

IF (mWriteIdx = mReadIdx) THEN
    mReadIdx := (mReadIdx + 1) MOD cPDRMaxLines;
END_IF;

aSignalRead();

t := GET_RUNTIME() - ts; 

@END_Body 

@@@BEG_Comment@@@ 
@TL(11)
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".


@@@END_Comment@@@ 

@BEG_Body 
@TL(15)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF ((evMovementStateData.DeviceId.CompId = cCompInjection)
   AND (evMovementStateData.DeviceId.IndexId = 1)
   AND (evMovementStateData.MoveId   = cMoveInject)
   AND (evMovementStateData.MoveDir  = cMoveFwd)
   AND (evMovementStateData.State  = nActive)) THEN 
    
    // copy data at inject time
    aDoSample(16);
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(11)
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

collects processdata: sample values at inject
@@@END_Comment@@@ 

@BEG_Body 
@TL(130)
b := fReadOrAddConfigString(cConfigNodeCfgFile, cfgFile, 'workspace/data/pdr.cfg');

miMode := 0; 
b := fReadConfigInt("Mode", miMode);
b := fReadConfigInt("Activate", activate);
                         
IF (fReadConfigString("Trigger", name)) THEN
   mpiTrigger := GET_SYNC_REFTO(name, T#0s, s); 
END_IF;

IF (mpiTrigger = EMPTY) THEN
    mpiTrigger := @sv_iShotCounterAct;
END_IF;


FOR i := 1 TO cPDRMaxVars DO
   mRecorderConfiguration[i].nType := cPDRVarTypeNone; 
   IF (fReadConfigString(CONCAT("Var:", DINT_TO_STRING(i), ".Name"), name)) THEN
       
       /////////   R E A L   /////////    
       IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
          mRecorderConfiguration[i].prReal := GET_SYNC_REFTO(name, T#0s, s);
          IF (s = KSYS_Status_OK) THEN
             mRecorderConfiguration[i].nType := cPDRVarTypeReal;           
          END_IF;
       END_IF;
       /////////   T I M E   /////////    
       IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
          mRecorderConfiguration[i].pdTime := GET_SYNC_REFTO(name, T#0s, s);
          IF (s = KSYS_Status_OK) THEN
             mRecorderConfiguration[i].nType := cPDRVarTypeTime;           
          END_IF;
       END_IF;
       /////////   D I N T   /////////    
       IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
          mRecorderConfiguration[i].piDInt := GET_SYNC_REFTO(name, T#0s, s);
          IF (s = KSYS_Status_OK) THEN
             mRecorderConfiguration[i].nType := cPDRVarTypeDInt;           
          END_IF;
       END_IF;
       
       IF (miMode > 0) THEN
            /////////   L R E A L   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].prLReal := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeLReal;           
                END_IF;
            END_IF; 
            /////////   B O O L   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].pbBool := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeBool;           
                END_IF;
            END_IF;
            /////////   D A T E  &  T I M E   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].pdDT := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeDT;           
                END_IF;
            END_IF;
            /////////   S I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piSInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeSInt;           
                END_IF;
            END_IF;
            /////////   I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeInt;           
                END_IF;
            END_IF;
            /////////   L I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piLInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeLInt;           
                END_IF;
            END_IF;
            /////////   U S I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piUSInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeUSInt;           
                END_IF;
            END_IF;
                /////////   U I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piUInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeUInt;           
                END_IF;
            END_IF;
            /////////   U D I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piUDInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeUDInt;           
                END_IF;
            END_IF;
            /////////   U L I N T   /////////    
            IF (mRecorderConfiguration[i].nType = cPDRVarTypeNone) THEN 
                mRecorderConfiguration[i].piULInt := GET_SYNC_REFTO(name, T#0s, s);
                IF (s = KSYS_Status_OK) THEN
                    mRecorderConfiguration[i].nType := cPDRVarTypeULInt;           
                END_IF;
            END_IF;
       END_IF;
       
       // Type found ... save last used index in configuration
       IF (mRecorderConfiguration[i].nType <> cPDRVarTypeNone) THEN 
          mIdxLastPdrVar := i;
       END_IF;           
                          
       cnt := cnt + 1; 
       b := fReadConfigInt(CONCAT("Var:", DINT_TO_STRING(i), ".SampleGroup"), mRecorderConfiguration[i].sampleGroup);
   END_IF;
   sv_ProcessDataRecorder.yActiveVariables[i] := mRecorderConfiguration[i].nType;    
END_FOR;             

IF (activate <> 0) THEN
    sv_ProcessDataRecorder.bActivate := TRUE; 
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(4)
STOP_PROCESS_ALGORITHM();

aInit();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(2)
aSignalRead();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(18)
IF (sv_ProcessDataRecorder.bActivate) THEN
   mpiTriggerPU := mpiTrigger; 
   mevMovementState := evMovementState;
   IF (miMode = 0) THEN
       // sample mode real
       mpiTriggerClient := @sv_ProcessDataRecorder.data.iTrigger;
   ELSIF (miMode = 1) THEN 
       // sample mode raw
       mpiTriggerClient := @sv_ProcessDataRecorder.dataRaw.iTrigger;
   END_IF;
ELSE
   mpiTriggerPU := EMPTY;
   mevMovementState := EMPTY;
   mpiTriggerClient := EMPTY;
END_IF;



@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(31)
IF (sv_ProcessDataRecorder.iReloadConfiguration MOD 2 = 1) THEN
    sv_ProcessDataRecorder.bActivate := FALSE;

    cfgFile := "";
    b := fReadConfigString(cConfigNodeCfgFile, cfgFile);
    handleData := KCAT_GetHandle(cConfigNode);
    IF (handleData.Status = KCAT_Status_OK) THEN
        s := KCAT_RemoveDir(handleData.Handle);  
    END_IF;
    
    workPath := FGetCatConfigValueString("System.workPath", "/");
    
    FOR i := 1 TO cPDRMaxVars DO
        mRecorderConfiguration[i] := emptyElem;
    END_FOR;
    
    mWriteIdx := 0; 
    mReadIdx := 0;
    
    s := KCAT_Load(CONCAT(workPath, "/", cfgFile));

    aInit();
    
    IF (LEN(cfgFile) > 0) THEN
      b := fReadOrAddConfigString(cConfigNodeCfgFile, cfgFile, cfgFile);  
    END_IF;
    
    sv_ProcessDataRecorder.iReloadConfiguration := sv_ProcessDataRecorder.iReloadConfiguration + 1; 
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
