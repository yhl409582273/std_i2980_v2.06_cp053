(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".
*)

IMPORT_OVER_LISTFILE
 CHECK_REF
, SET_EVENT
, SET_ALARM
, RESET_ALARM
, cMaxParallelMovements
, cMaxODCSteps
, cMoveNone
, cMoveStartParallel
, cCompEjector
, cCompCentralCoordination
, cCompAirValve
, cMoveFwd
, cMoveStart
, cMoveBwd
, cMoveShake
, cMoveEndParallel
, cMoveEndSequence
, cCompODC
, cCompNone
, cMinCompId
, cMaxCompId
, cMaxDeviceIndex
, cMinMoveIdent
, cMaxMoveIdent
, cMoveIf
, cMoveElse
, cMoveStartParallelOpen
, cMoveEndParallelOpen
, cMoveAll
, FBLockUnlock
, FBDebugTrace
, FBDebugTrace2
, FBSetStepState
, KODC_Sequence
, tyODCSequenceInternal
, tyMovementRegisterList
, tyODCParallelInfo
, tevCheckLocklist
, tyStartCondInstanceData
, tsODCDeviceMovementList
, tyCheckCondInstanceData
, tyCheckCondHelpData
, tsTraceLevel
, tnOperationMode
, RTC
, tyIFConditionData
, tyLoopData
, tyIFConditionHelpData
, tyLoopHelpData
, tsGroupActiveData
, tyParallelOpenHelpData
, tsStartedMoveDataODCExtended
, tsMoveData
, tsDeviceId
, FBUpdateEditorProperties
, FBStopStartedMovements
, FBStopStartedManualMovements
, KODC_Step
, tsODCStepInternal
, tyODCDependencyArray
, tnMoveDirection
, FBCheckPosReached
, KSYS_Status
, FBInterpreterFindEndOfParallel
, FBGetMoveNumber
, tyNumberParseArray
, tsNumberParseElement
, tsODCStepPos
, tMoveIdent
, FBStartedMovementAdder
, FBMoveDescription
, FBStart
, FBCheckReady
, ABODCCheckDependencies
, tevCheckLocklistData
, FBStop

END_IMPORT

ALGORITHM_BLOCK ABInterpreter #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_ODCSequence : KODC_Sequence;
 sv_ODCSequenceInt : tyODCSequenceInternal;
 sv_MovementsAvailable : tyMovementRegisterList;
 sv_InterpreterParallelInfo : tyODCParallelInfo;
 sv_StartConditionInstanceData : tyStartCondInstanceData (* list with start condition params for all instances *);
 sv_ODCDeviceMovements : tsODCDeviceMovementList;
 sv_CheckConditionInstanceData : tyCheckCondInstanceData (* list with check condition params for all instances *);
 sv_bFALSE : BOOL;
 sv_TraceLevel : tsTraceLevel;
 sv_iUsedColumns : DINT;
 sv_iUsedRows : DINT;
 sv_OperationMode : tnOperationMode;
 sv_iDurationUpdateInTolerance : DINT;
 sv_rMoveDurationTolerance : REAL;
 sv_ConditionParameter : tyIFConditionData;
 sv_LoopParameter : tyLoopData (* array with data of all programmed loops *);
 sv_GroupActiveData : tsGroupActiveData;
 sv_StartedManualMovements : tsStartedMoveDataODCExtended;
END_VAR

SYSTEM_OBJECT
 evCheckLocklist : tevCheckLocklist;
 erMovementNotAvailable : ALARM;
 erWaitingForCheckCondition : ALARM;
 erCompNotInCorrectPosition : ALARM;
 erReadyAndNotPosReached : ALARM;
 erNoStepBwdIntoCondition : ALARM;
 erNoStepBwdIntoLoop : ALARM;
 erNoStepBwdOutOfLoop : ALARM;
END_OBJECT

VAR_EXTERNAL
 g_iAutoCycleLoopStartLine : DINT;
 g_iAutoCycleLoopEndLine : DINT;
 g_ParallelOpenHelpData : tyParallelOpenHelpData;
END_VAR

VAR
 fbLockUnlock : FBLockUnlock;
 fbDebugTrace : FBDebugTrace;
 fbDebugTrace2 : FBDebugTrace2;
 fbSetStepState : FBSetStepState;
 odcParallelInfo : tyODCParallelInfo;
 miEndRow : DINT (* where ODC stops executing *);
 dummy : DINT;
 mbFatalError : BOOL (* there was some error, interpreting is not allowed *);
 mbNormalError : BOOL (* there was some error, interpreting is not allowed *);
 mbActive : BOOL;
 mbFinished : BOOL;
 mCheckCondHelpData : tyCheckCondHelpData;
 fbRTC : RTC;
 mIFConditionHelpData : tyIFConditionHelpData;
 mLoopHelpData : tyLoopHelpData;
 mbStepMode : BOOL;
END_VAR

ALGORITHM aCorrectDuration


VAR_IN_OUT
 pMoveData : REFTO tsMoveData;
END_VAR

VAR_INPUT
 iColumn : DINT;
 DeviceId : tsDeviceId;
END_VAR

VAR
 dDuration : TIME;
 dActTime : DATE_AND_TIME;
 dMovementDelay : TIME;
 rTmp1 : REAL;
 rTmp2 : REAL;
 fbUpdateProperties : FBUpdateEditorProperties;
 bInitDone : BOOL;
 dCycleTime : TIME;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bInitDone THEN
   dCycleTime := GET_TASK_INTERVAL();
   bInitDone := TRUE;
END_IF;

//check duration
//get timestamp for new movement and duration of last movement
IF sv_OperationMode >= nHalfAutomatic AND CHECK_REF(pMoveData^.pdCalculatedDuration^) THEN
                  
   IF (pMoveData^.EditorData.MovementType <> nODCElementDuration) AND
      (pMoveData^.EditorData.MovementType <> nODCElementInstanceableDuration) THEN

      IF CHECK_REF (pMoveData^.pdStartDelaySet^) THEN
         dMovementDelay := pMoveData^.pdStartDelaySet^;
      ELSE
         dMovementDelay := t#0s;
      END_IF;
      
      fbRTC();
      dActTime := fbRTC.CDT;
      dDuration := dActTime - odcParallelInfo[iColumn].dStartTime - dMovementDelay;
       
      IF dDuration > t#1s THEN
         dDuration := dDuration + dCycleTime;
      END_IF; 
   
      IF (dDuration > MULTIME(pMoveData^.pdCalculatedDuration^, 1.0 + sv_rMoveDurationTolerance/100.0)) OR
         (dDuration < MULTIME(pMoveData^.pdCalculatedDuration^, 1.0 - sv_rMoveDurationTolerance/100.0)) THEN
         
         //duration out of tolerance
         IF sv_TraceLevel.bODCInterpreter THEN
            rTmp1 := LINT_TO_REAL(TIME_TO_LINT(pMoveData^.pdCalculatedDuration^))/1000000.0;
            rTmp2 := LINT_TO_REAL(TIME_TO_LINT(dDuration))/1000000.0;
            dummy := Print('correcting duration of %d.%d %d/%d from %f to %f',
                           DeviceId.CompId, DeviceId.IndexId,
                           pMoveData^.MoveDir, pMoveData^.MoveId,
                           rTmp1, rTmp2);
         END_IF; 
         
      ELSE
         //duration in tolerance
         sv_iDurationUpdateInTolerance := sv_iDurationUpdateInTolerance + 1;
      END_IF;
      
      //correct duration
      pMoveData^.pdCalculatedDuration^ := dDuration;
      
      IF pMoveData^.bInstanceable THEN
         //instanceable movement -> trigger editor update
         //for "normal" movement the update must be triggered in the according function unit
         fbUpdateProperties();
      END_IF;
   
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Clear the internal ODC sequence array sv_ODCSequenceInt.
Needed when the sequence is reinitialized to make sure no remanents of a old sequence are left.

Each element in the safety array is set to cODCNoDependency
*)

ALGORITHM aCheckConditionUnlock


VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//unlock all movements that were locked because of a check condition
FOR i := 1 TO cMaxCheckConditions DO
   IF mCheckCondHelpData[i].bMovementLocked THEN
      fbLockUnlock(DeviceId := mCheckCondHelpData[i].LockUnlockData.DeviceId,
                   MoveDir := mCheckCondHelpData[i].LockUnlockData.MoveDir,
                   MoveId := mCheckCondHelpData[i].LockUnlockData.MoveId,
                   Alarm := mCheckCondHelpData[i].LockUnlockData.Alarm,
                   Mode := nUnlock);
      
      mCheckCondHelpData[i].bMovementLocked := FALSE;
   END_IF;
END_FOR;



;#END_EDIT_BLOCK END_ALGORITHM

(*
Reset internal state of interpreter to initial values
*)

ALGORITHM aResetInterpreter


VAR_INPUT
 bExcludeActiveColumns : BOOL (* TRUE: do not reset active columns (possible with StartParallelOpen) *);
END_VAR

VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO sv_iUsedColumns DO
   IF (bExcludeActiveColumns AND odcParallelInfo[i].bColumnActive) THEN
      ; //do not reset active columns
   ELSE
      odcParallelInfo[i].bColumnActive := FALSE;
      odcParallelInfo[i].bStartSent := FALSE;
      odcParallelInfo[i].bStartConditionWarnPrinted := FALSE;
      odcParallelInfo[i].bSkipAlreadyPosReached := FALSE;
      odcParallelInfo[i].bActivatedChecked := FALSE;
      odcParallelInfo[i].bPosReachedArrayLinked := FALSE;
      odcParallelInfo[i].bMovementReadyArrayLinked := FALSE;
      odcParallelInfo[i].bDisabled := FALSE;
      odcParallelInfo[i].iRow := 0;
   END_IF;
END_FOR;

aCheckConditionUnlock();

//reset actual loop counters
FOR i := 1 TO cMaxLoops DO
   mLoopHelpData[i].iActCount := 0;
END_FOR;

FOR i := 1 TO cMaxIFConditions DO
   mIFConditionHelpData[i].iInternalCount := 0;
END_FOR;

FOR i := 1 TO cMaxIntermediateConditions DO
   sv_GroupActiveData.Group[i].bActive := FALSE;
END_FOR;
sv_GroupActiveData.iActiveGroups := 0;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Internal implementation to stop the interpreter.
This stops all movements started by ODC.
When a fatal error happens all started movements are stopped(even when not started by ODC)
*)

ALGORITHM aStopInterpreterInternal


VAR_INPUT
 bNormalError : BOOL;
 bFatalError : BOOL;
END_VAR

VAR
 fbStopStartedMovements : FBStopStartedMovements;
 fbStopStartedManualMovements : FBStopStartedManualMovements;
 DeviceIdAll : tsDeviceId;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbActive := FALSE;
IF bFatalError THEN
   // in case of a fatal error stop all movement
   // even if they were not started by us
   fbStopStartedMovements();
   mbFatalError := TRUE;
   
   (* lock all movements *)
   DeviceIdAll.CompId := cCompAll;
   DeviceIdAll.IndexId := cAllDevIndex;
   
   fbLockUnlock(DeviceId := DeviceIdAll,
                MoveDir  := cMoveAll,
                MoveId   := cMoveAll,
                Mode     := nLockAbort);
ELSIF bNormalError THEN
   fbStopStartedManualMovements();
   mbNormalError := TRUE;
ELSE
   fbStopStartedManualMovements();
END_IF;

aResetInterpreter(bExcludeActiveColumns := FALSE);
sv_InterpreterParallelInfo := odcParallelInfo;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aStopInterpreterFatal

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace('stopping interpreter because of a fatal error');   

aStopInterpreterInternal(bFatalError := TRUE, bNormalError := FALSE);


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aCheckActivated


VAR_INPUT
 DeviceId : tsDeviceId;
 MoveData : tsMoveData;
END_VAR

VAR_OUTPUT
 bActivated : BOOL;
END_VAR

VAR_TEMP
 iFuIndex : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bActivated := TRUE;

IF DeviceId.CompId = cCompODC THEN
   RETURN; ////// avoid that ODC movements are skipped during searching the next row
END_IF;
            
//check activation of device and movement
FOR iFuIndex := 1 TO sv_ODCDeviceMovements.iCount DO
   IF sv_ODCDeviceMovements.Devices[iFuIndex].DeviceId = DeviceId  THEN
      EXIT;
   END_IF;
END_FOR;

IF NOT sv_ODCDeviceMovements.Devices[iFuIndex].pbDeviceActivated^ THEN
   //device is not activated
   fbDebugTrace2(nODCInterpreter, CONCAT('skipping movement ',
                                       DINT_TO_STRING(DeviceId.CompId), '.',
                                       DINT_TO_STRING(DeviceId.IndexId), ' ',
                                       DINT_TO_STRING(MoveData.MoveId), '/',
                                       DINT_TO_STRING(MoveData.MoveDir),
                                       ' because device not activated'));
   bActivated := FALSE;

ELSIF CHECK_REF(MoveData.pbActivated^) AND NOT MoveData.pbActivated^ THEN
   //movement is not activated
   fbDebugTrace2(nODCInterpreter, CONCAT('skipping movement ',
                                       DINT_TO_STRING(DeviceId.CompId), '.',
                                       DINT_TO_STRING(DeviceId.IndexId), ' ',
                                       DINT_TO_STRING(MoveData.MoveId), '/',
                                       DINT_TO_STRING(MoveData.MoveDir),
                                       ' because of pbActivated'));
   bActivated := FALSE;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aIncreaseRow


VAR_INPUT
 iColumn : DINT;
 iEndRow : DINT;
END_VAR

VAR_TEMP
 iTmpLine : DINT;
 k : DINT;
END_VAR

VAR
 iStopEverythingCounter : DINT;
 iCount : INT;
 fbSetStepState : FBSetStepState;
 pMoveData : REFTO tsMoveData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

odcParallelInfo[iColumn].bStartSent := FALSE;
odcParallelInfo[iColumn].bStartConditionWarnPrinted := FALSE;
odcParallelInfo[iColumn].bActivatedChecked := FALSE;
odcParallelInfo[iColumn].bPosReachedArrayLinked := FALSE;
odcParallelInfo[iColumn].bMovementReadyArrayLinked := FALSE;

//get next line
//for saving cycle time several steps are handled directly during increasing the row
FOR iTmpLine := (odcParallelInfo[iColumn].iRow + 1) TO sv_iUsedRows DO
   fbDebugTrace2(nODCInterpreter, CONCAT('increasing IP of column ', DINT_TO_STRING(iColumn),
                                         ' to ', DINT_TO_STRING(iTmpLine)));
   
   fbSetStepState.StepPos.iRow := iTmpLine;
   fbSetStepState.StepPos.iColumn := iColumn;
   
   IF (sv_ODCSequence[iColumn][iTmpLine].iCompId = cCompODC) AND (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveEndSequence) THEN
      //end of sequence
      iStopEverythingCounter := 0;
      FOR k := 1 TO sv_iUsedColumns DO
         IF odcParallelInfo[k].bColumnActive THEN
            iStopEverythingCounter := iStopEverythingCounter + 1;      
         END_IF;
      END_FOR;
      (* deactivate self *)
      odcParallelInfo[iColumn].bColumnActive := FALSE;
      fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iTmpLine), '/',
                                             DINT_TO_STRING(iColumn), ' found ODC EndSequence'));
      IF iStopEverythingCounter > 1 THEN
         dummy := Print('found stop everything action but there are still parallel movements active!!');
         aStopInterpreterFatal();
         RETURN;
      END_IF;
      
      mbFinished := TRUE;
      
      //set step state to ready
      fbSetStepState(StepState := nStateReady);
      
      mbActive := FALSE;
      aResetInterpreter(bExcludeActiveColumns := TRUE);
      sv_InterpreterParallelInfo := odcParallelInfo;
   ELSIF sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveEndIf THEN
      // end_if
      iCount := sv_ODCSequence[iColumn][iTmpLine].iCount;
      mIFConditionHelpData[iCount].iInternalCount := (mIFConditionHelpData[iCount].iInternalCount + 1);
      fbSetStepState(StepState := nStateReady);
   ELSIF sv_ODCSequence[iColumn][iTmpLine].iCompId <> cCompODC AND
      ((sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveBeginSequence) OR (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveEndSequence)) THEN
      IF iEndRow <> 0 AND iTmpLine >= iEndRow THEN
         //do not skip over cMoveEndSequence if it is the last movement in a combined sequence
         //example mold open, core in after mold open sequence
         //otherwise we highlight the core movement on finishing the sequence because we think the movement after cMoveEndSequence is active
         odcParallelInfo[iColumn].iRow := iTmpLine;
         EXIT;   
      ELSE   
         //sequence bound -> execution not necessary
         fbSetStepState(StepState := nStateReady);
      END_IF;
   ELSIF sv_ODCSequence[iColumn][iTmpLine].iCompId = cCompNone AND sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveNone AND
      sv_ODCSequence[iColumn][iTmpLine].iMoveDir = cMoveNone THEN
      //empty step
      fbSetStepState(StepState := nStateReady);
      
      IF (iTmpLine = miEndRow) THEN
         //last step in this column: deactivate column
         odcParallelInfo[iColumn].bColumnActive := FALSE;
      END_IF;
   
   ELSIF sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveBeginGroup THEN
      //begin of group -> save start time of the group
      sv_GroupActiveData.iActiveGroups := sv_GroupActiveData.iActiveGroups + 1; 
      sv_GroupActiveData.Group[sv_ODCSequenceInt[iColumn][iTmpLine].iCount].bActive := TRUE;
      sv_GroupActiveData.Group[sv_ODCSequenceInt[iColumn][iTmpLine].iCount].dStartTime := fbRTC.CDT;         
      fbSetStepState(StepState := nStateReady);   
   ELSIF sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveEndGroup THEN         
      //end of group
      sv_GroupActiveData.Group[sv_ODCSequenceInt[iColumn][iTmpLine].iCount].bActive := FALSE;
      sv_GroupActiveData.iActiveGroups := sv_GroupActiveData.iActiveGroups - 1;
      fbSetStepState(StepState := nStateReady);         
   ELSIF (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveStartParallel) OR (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveStartParallelOpen) THEN
      //begin of parallel tree
      fbSetStepState(StepState := nStateReady);
      // new branches can only start to the right side
      FOR k := iColumn + 1 TO sv_iUsedColumns DO
         IF (sv_ODCSequence[k][iTmpLine].iMoveId = cMoveStartParallel) OR (sv_ODCSequence[k][iTmpLine].iMoveId = cMoveStartParallelOpen) THEN
            //only activate if not activated yet; this can happen, if more than two "StartParallel" or "StartParallelOpen" are in the same line
            IF NOT odcParallelInfo[k].bColumnActive THEN
               odcParallelInfo[k].bColumnActive := TRUE;
               odcParallelInfo[k].bStartSent := FALSE;
               odcParallelInfo[k].bStartConditionWarnPrinted := FALSE;
               odcParallelInfo[k].bSkipAlreadyPosReached := odcParallelInfo[iColumn].bSkipAlreadyPosReached; // copy to new columns
               odcParallelInfo[k].bActivatedChecked := FALSE;
               odcParallelInfo[k].iRow := iTmpLine;
               
               fbSetStepState.StepPos.iRow := iTmpLine;
               fbSetStepState.StepPos.iColumn := k;
               fbSetStepState(StepState := nStateActive);
         
               fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iTmpLine), '/', DINT_TO_STRING(iColumn),
                                                   ' activated column ', DINT_TO_STRING(k)));
            END_IF;            
         END_IF;   
      END_FOR;
     
   ELSE   
      //check if device / movement is activated
      pMoveData := sv_MovementsAvailable[sv_ODCSequenceInt[iColumn][iTmpLine].iMoveNumber].pMovementData;
      aCheckActivated.DeviceId.CompId  := sv_ODCSequence[iColumn][iTmpLine].iCompId;
      aCheckActivated.DeviceId.IndexId := INT_TO_DINT(sv_ODCSequence[iColumn][iTmpLine].iIndexId);
      aCheckActivated(MoveData := pMoveData^);
      
      IF aCheckActivated.bActivated THEN
         //next valid step found
         odcParallelInfo[iColumn].iRow := iTmpLine;
         IF mbStepMode THEN
            odcParallelInfo[iColumn].bDisabled := TRUE;
         ELSE
            odcParallelInfo[iColumn].bDisabled := FALSE;
            fbSetStepState(StepState := nStateActive);
         END_IF;
         
         odcParallelInfo[iColumn].bPosReachedArrayLinked := CHECK_REF(pMoveData^.InstanceData.pPosReachedArray^);
         odcParallelInfo[iColumn].bMovementReadyArrayLinked := CHECK_REF(pMoveData^.InstanceData.pMovementReadyArray^);
         odcParallelInfo[iColumn].bActivatedChecked := TRUE;
         odcParallelInfo[iColumn].bActivated := TRUE;
         EXIT;         
      END_IF;
   END_IF;   
END_FOR;

IF (iEndRow <> 0) AND (iTmpLine >= iEndRow) AND (odcParallelInfo[iColumn].bColumnActive) THEN
   // stop execution because the given limit is reached (iEndRow = 0: no limit set) 
   fbDebugTrace2(nODCInterpreter, CONCAT('stopping exceution because we reached our end position ',
                                          DINT_TO_STRING(iTmpLine), '/', DINT_TO_STRING(iColumn)));
   
   //deactivate own column
   odcParallelInfo[iColumn].bColumnActive := FALSE;
   sv_InterpreterParallelInfo := odcParallelInfo;
   mbFinished := TRUE;
   
   fbSetStepState.StepPos.iRow := iTmpLine;
   fbSetStepState.StepPos.iColumn := iColumn;
   fbSetStepState(StepState := nStateReady);
END_IF;      




;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aFindCheckCondition


VAR_INPUT
 Movement : KODC_Step (* requested movement *);
END_VAR

VAR_OUTPUT
 bFound : BOOL (* check condition for requested movement found *);
END_VAR

VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bFound := FALSE;

//find out if a check condition exists for the requested movement
FOR i := 1 TO cMaxCheckConditions DO
   IF Movement = sv_CheckConditionInstanceData[i].RelatedMovement OR 
      Movement = sv_CheckConditionInstanceData[i].MoveInEndPos THEN
      // check condition found
      bFound := TRUE;
      EXIT;
   END_IF;   
END_FOR;



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aStopInterpreterError

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, 'stopping interpreter because of a non fatal error');   

aStopInterpreterInternal(bFatalError := FALSE, bNormalError := TRUE);


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aStopInterpreterNormal

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, 'stopping interpreter because of a normal reason');   

aStopInterpreterInternal(bFatalError := FALSE, bNormalError := FALSE);


;#END_EDIT_BLOCK END_ALGORITHM

(*
Some sanity checks of the ODC sequence array.
*)

ALGORITHM aCheckSequenceSanity


VAR_OUTPUT
 bOK : BOOL (* Sanity checks passed *);
 bAutoCycleLoopFound : BOOL (* autocycle loop found in sequence *);
 iEndSequenceRow : DINT (* line number where ODC.EndSequence was found *);
 iNoOfStartParallel : DINT (* number of "StartParallel" steps in the sequence *);
END_VAR

VAR_TEMP
 iColumn : DINT;
 iRow : DINT;
 iEndParallelFound : DINT;
 iStartParallelFound : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, 'checking sanity of ODC array');   

bOK := FALSE;
bAutoCycleLoopFound := FALSE;
g_iAutoCycleLoopStartLine := 0;
g_iAutoCycleLoopEndLine := 0;
iEndSequenceRow := 1;
iNoOfStartParallel := 0;

// sanity check if there are more than 2 StartParallel/EndParallel points per line
// check if ODC movements are used on non ODC FUs
FOR iRow := 1 TO cMaxODCSteps DO
   iEndParallelFound := 0;
   iStartParallelFound := 0;
   FOR iColumn := 1 TO cMaxParallelMovements DO
      IF sv_ODCSequence[iColumn][iRow].iMoveId = cMoveEndParallel THEN
         iEndParallelFound := iEndParallelFound + 1;
         IF sv_ODCSequence[iColumn][iRow].iCompId <> cCompODC THEN
            dummy := Print('found a cMoveEndParallel movement on non ODC device %d/%d', sv_ODCSequence[iColumn][iRow].iCompId, sv_ODCSequence[iColumn][iRow].iIndexId);
            aStopInterpreterFatal();   
         END_IF;
      ELSIF sv_ODCSequence[iColumn][iRow].iMoveId = cMoveStartParallel THEN
         iStartParallelFound := iStartParallelFound + 1;
         iNoOfStartParallel := iNoOfStartParallel + 1;
         IF sv_ODCSequence[iColumn][iRow].iCompId <> cCompODC THEN
            dummy := Print('found a cMoveStartParallel movement on non ODC device %d/%d', sv_ODCSequence[iColumn][iRow].iCompId, sv_ODCSequence[iColumn][iRow].iIndexId);
            aStopInterpreterFatal();   
         END_IF;
      ELSIF sv_ODCSequence[iColumn][iRow].iMoveId = cMoveBeginLoop THEN
         IF sv_TraceLevel.bODCInterpreter THEN
            dummy := Print('**************** BEGIN LOOP found');
            dummy := Print('**************** Column:%d  Row: %d  iCount: %d',iColumn, iRow, sv_ODCSequence[iColumn][iRow].iCount);
         END_IF;
         IF (sv_LoopParameter[(sv_ODCSequence[iColumn][iRow].iCount)].sTextKey = 'TxtAutoCycleLoop') THEN
            IF sv_TraceLevel.bODCInterpreter THEN
               dummy := Print('**************** AUTOCYCLE LOOP found');
               dummy := Print('**************** Column:%d  Row: %d  iCount: %d',iColumn, iRow, sv_ODCSequence[iColumn][iRow].iCount);
            END_IF;
            g_iAutoCycleLoopStartLine := iRow;
            bAutoCycleLoopFound := TRUE;
         END_IF;        
      ELSIF sv_ODCSequence[iColumn][iRow].iMoveId = cMoveEndLoop THEN         
         IF sv_LoopParameter[sv_ODCSequence[iColumn,iRow].iCount].sTextKey = 'TxtAutoCycleLoop' THEN
            g_iAutoCycleLoopEndLine := iRow;
         END_IF;
      END_IF;
   END_FOR;

    IF iEndParallelFound = 1 THEN
      dummy := Print('only 1 EndParallel point found on line %d', iRow);
      aStopInterpreterFatal();
      RETURN;
   END_IF;
   IF iStartParallelFound = 1 THEN
      dummy := Print('only 1 StartParallel found on line %d', iRow);
      aStopInterpreterFatal();
      RETURN;
   END_IF;
   IF iEndParallelFound <> 0 AND iStartParallelFound <> 0 THEN
      dummy := Print('StartParallel/EndParallel mixed on line %d', iRow);
      aStopInterpreterFatal();
      RETURN;
   END_IF;

   IF (sv_ODCSequence[1][iRow].iCompId = cCompODC) AND (sv_ODCSequence[1][iRow].iMoveId = cMoveEndSequence) THEN
      iEndSequenceRow := iRow;
      IF sv_TraceLevel.bODCInterpreter THEN
         dummy := Print('Found END_SEQUENCE in line %d', iRow);
      END_IF;
      EXIT; //exit sanity check because sequence end found
   END_IF;
   
END_FOR;

bOK := TRUE;




;#END_EDIT_BLOCK END_ALGORITHM

(*
Clear the internal ODC sequence array sv_ODCSequenceInt.
Needed when the sequence is reinitialized to make sure no remanents of a old sequence are left.

Each element in the safety array is set to cODCNoDependency
*)

ALGORITHM aClearInternalSequence


VAR_TEMP
 iColumn : DINT;
 iRow : DINT;
 i : DINT;
END_VAR

VAR
 EmptyStep : tsODCStepInternal;
 EmptyDependency : tyODCDependencyArray;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, 'begin clearing internal ODC sequence');
(* we copy a whole struct at once, because it is faster *) 
FOR iColumn := 1 TO cMaxParallelMovements DO
   FOR iRow := 1 TO cMaxODCSteps DO
      sv_ODCSequenceInt[iColumn][iRow] := EmptyStep;
   END_FOR;
         
   g_ParallelOpenHelpData[iColumn].bParallelOpen := FALSE;
   g_ParallelOpenHelpData[iColumn].Dependency := EmptyDependency;
   g_ParallelOpenHelpData[iColumn].iStartParallelOpenLine := 0;   
END_FOR;

//unlock all movements that were locked because of a check condition
//before initializing the data
aCheckConditionUnlock();

//init structure with help data for check conditions
FOR i := 1 TO cMaxCheckConditions DO
   mCheckCondHelpData[i].bMovementLocked := FALSE;
   mCheckCondHelpData[i].MoveDirection := nMoveDirectionNo;
   mCheckCondHelpData[i].prActValue := EMPTY; 
   mCheckCondHelpData[i].pbPosReached := EMPTY;
   mCheckCondHelpData[i].LockUnlockData.Alarm.AlarmId := EMPTY;
   mCheckCondHelpData[i].LockUnlockData.Alarm.SubId[1] := 0;
   mCheckCondHelpData[i].LockUnlockData.Alarm.SubId[2] := 0;
   mCheckCondHelpData[i].LockUnlockData.Alarm.SubId[3] := 0;
   mCheckCondHelpData[i].AlarmMoveInEndPos.AlarmId := EMPTY;
   mCheckCondHelpData[i].AlarmMoveInEndPos.SubId[1] := 0;
   mCheckCondHelpData[i].AlarmMoveInEndPos.SubId[2] := 0;
   mCheckCondHelpData[i].AlarmMoveInEndPos.SubId[3] := 0;
END_FOR;

//init structure with help data for IF - conditions
FOR i := 1 TO cMaxIFConditions DO
   mIFConditionHelpData[1].Operator := nCompOperatorEqual;
   mIFConditionHelpData[i].pbVariable1 := EMPTY;
   mIFConditionHelpData[i].pbVariable2 := EMPTY;
   mIFConditionHelpData[i].prVariable1 := EMPTY;
   mIFConditionHelpData[i].prVariable2 := EMPTY;
   mIFConditionHelpData[i].piVariable1 := EMPTY;
   mIFConditionHelpData[i].piVariable2 := EMPTY;
   mIFConditionHelpData[i].bRealVar2Used := FALSE;
   mIFConditionHelpData[i].bDintVar2Used := FALSE;
   mIFConditionHelpData[i].rValue := 0.0;
   mIFConditionHelpData[i].iValue := 0;
END_FOR;

//init structure with help data for loops
FOR i := 1 TO cMaxLoops DO
   mLoopHelpData[i].Operator := nCompOperatorEqual;
   mLoopHelpData[i].pbVariable1 := EMPTY;
   mLoopHelpData[i].pbVariable2 := EMPTY;
   mLoopHelpData[i].prVariable1 := EMPTY;
   mLoopHelpData[i].prVariable2 := EMPTY;
   mLoopHelpData[i].piVariable1 := EMPTY;
   mLoopHelpData[i].piVariable2 := EMPTY;
   mLoopHelpData[i].bRealVar2Used := FALSE;
   mLoopHelpData[i].bDintVar2Used := FALSE;
   mLoopHelpData[i].rValue := 0.0;
   mLoopHelpData[i].iValue := 0;
   mLoopHelpData[i].bLoopCounter := FALSE;
   mLoopHelpData[i].iActCount := 0;
END_FOR;

fbDebugTrace2(nODCInterpreter,'finished clearing internal ODC sequence');



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aGetMovementData


VAR_INPUT
 Movement : KODC_Step;
END_VAR

VAR_OUTPUT
 Direction : tnMoveDirection (* movedirection (min to max, max to min) *);
 prActValue : REFTO REAL (* refto actual value of this movement *);
 pbReferenceCondition : REFTO BOOL (* refto actual value of this movement *);
END_VAR

VAR_TEMP
 i : DINT;
 k : DINT;
END_VAR

VAR
 DeviceId : tsDeviceId;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

Direction := nMoveDirectionNo;
prActValue := EMPTY;
pbReferenceCondition := EMPTY;
DeviceId.CompId := Movement.iCompId;
DeviceId.IndexId := INT_TO_DINT(Movement.iIndexId);

// get refto actvalue of related movement
FOR i := 1 TO sv_ODCDeviceMovements.iCount DO
   IF sv_ODCDeviceMovements.Devices[i].DeviceId = DeviceId THEN
      //device found -> save reference to actpos
      prActValue := sv_ODCDeviceMovements.Devices[i].AddDeviceInfo.prActValue;
      
      //get direction of the movement
      FOR k := 1 TO sv_ODCDeviceMovements.Devices[i].iNumberOfMovements DO
         IF (sv_ODCDeviceMovements.Devices[i].Movements[k]^.MoveDir = Movement.iMoveDir) AND 
            (sv_ODCDeviceMovements.Devices[i].Movements[k]^.MoveId = Movement.iMoveId) THEN
            Direction := sv_ODCDeviceMovements.Devices[i].Movements[k]^.EditorData.Direction;
            pbReferenceCondition := sv_ODCDeviceMovements.Devices[i].Movements[k]^.EditorData.pbReferenceCondition;
            RETURN;
         END_IF;
      END_FOR;
   END_IF;
END_FOR;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aGetLockUnlockData


VAR_INPUT
 iInstance : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//get all necessary data for lock/unlock
mCheckCondHelpData[iInstance].LockUnlockData.DeviceId.CompId := sv_CheckConditionInstanceData[iInstance].RelatedMovement.iCompId;
mCheckCondHelpData[iInstance].LockUnlockData.DeviceId.IndexId := INT_TO_DINT(sv_CheckConditionInstanceData[iInstance].RelatedMovement.iIndexId);
mCheckCondHelpData[iInstance].LockUnlockData.MoveId := sv_CheckConditionInstanceData[iInstance].RelatedMovement.iMoveId;
mCheckCondHelpData[iInstance].LockUnlockData.MoveDir := sv_CheckConditionInstanceData[iInstance].RelatedMovement.iMoveDir;   
mCheckCondHelpData[iInstance].LockUnlockData.Alarm.AlarmId := erWaitingForCheckCondition;
mCheckCondHelpData[iInstance].LockUnlockData.Alarm.SubId[1] := sv_CheckConditionInstanceData[iInstance].MoveInEndPos.iCompId;
mCheckCondHelpData[iInstance].LockUnlockData.Alarm.SubId[2] := INT_TO_DINT(sv_CheckConditionInstanceData[iInstance].MoveInEndPos.iIndexId);
mCheckCondHelpData[iInstance].LockUnlockData.Alarm.SubId[3] := sv_CheckConditionInstanceData[iInstance].MoveInEndPos.iMoveId;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aInitCheckConditionHelpData


VAR_TEMP
 i : DINT;
END_VAR

VAR
 DeviceId : tsDeviceId;
 fbCheckPosReached : FBCheckPosReached;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO cMaxCheckConditions DO
   IF sv_CheckConditionInstanceData[i].MoveInEndPos.iCompId > cCompNone THEN
      //get move direction and reference to act value of the related movement
      aGetMovementData(Movement := sv_CheckConditionInstanceData[i].RelatedMovement);
      mCheckCondHelpData[i].MoveDirection := aGetMovementData.Direction;
      mCheckCondHelpData[i].prActValue := aGetMovementData.prActValue;
      
      //get reference to posreached flag of the movement that must be in endposition
      DeviceId.CompId := sv_CheckConditionInstanceData[i].MoveInEndPos.iCompId;
      DeviceId.IndexId := INT_TO_DINT(sv_CheckConditionInstanceData[i].MoveInEndPos.iIndexId);
      fbCheckPosReached(DeviceId := DeviceId,
                        MoveDir := sv_CheckConditionInstanceData[i].MoveInEndPos.iMoveDir,
                        MoveId  := sv_CheckConditionInstanceData[i].MoveInEndPos.iMoveId);
      
      IF CHECK_REF(fbCheckPosReached.pbPosReached^) THEN
         mCheckCondHelpData[i].pbPosReached := fbCheckPosReached.pbPosReached;
         mCheckCondHelpData[i].AlarmMoveInEndPos := fbCheckPosReached.Alarm;
      ELSE
         //invalid posreached reference
         //set reference to sv_bFALSE to avoid nullpointer errors
         mCheckCondHelpData[i].pbPosReached := @sv_bFALSE;
         fbDebugTrace2(nODCInterpreter, CONCAT('invalid pbPosReached reference of checkcondition number ',
                                                DINT_TO_STRING(i)));
      END_IF;
         
      //get all necessary data for lock/unlock related movement
      aGetLockUnlockData(iInstance := i);
    
   END_IF;
END_FOR;





;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aInitIFConditionHelpData


VAR_TEMP
 i : DINT;
END_VAR

VAR
 state : KSYS_Status;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO cMaxIFConditions DO
   IF (sv_ConditionParameter[i].CompareOperator = nCompOperatorEqual) OR 
      (sv_ConditionParameter[i].CompareOperator = nCompOperatorNotEqual) THEN
      //get refto BOOL - values
      mIFConditionHelpData[i].pbVariable1 := GET_SYNC_REFTO(sv_ConditionParameter[i].sVariable1, T#0s, state);
      mIFConditionHelpData[i].pbVariable2 := GET_SYNC_REFTO(sv_ConditionParameter[i].sVariable2, T#0s, state);
   ELSIF (sv_ConditionParameter[i].CompareOperator = nCompOperatorModulo) THEN
      //get refto DINT - value
      mIFConditionHelpData[i].piVariable1 := GET_SYNC_REFTO(sv_ConditionParameter[i].sVariable1, T#0s, state);
      IF sv_ConditionParameter[i].sVariable2 <> '' THEN
         mIFConditionHelpData[i].piVariable2 := GET_SYNC_REFTO(sv_ConditionParameter[i].sVariable2, T#0s, state);
         mIFConditionHelpData[i].bDintVar2Used := TRUE;
      END_IF;
      mIFConditionHelpData[i].iValue := sv_ConditionParameter[i].iValue;
   ELSE
      //get refto REAL - value
      mIFConditionHelpData[i].prVariable1 := GET_SYNC_REFTO(sv_ConditionParameter[i].sVariable1, T#0s, state);
      IF sv_ConditionParameter[i].sVariable2 <> '' THEN
         mIFConditionHelpData[i].prVariable2 := GET_SYNC_REFTO(sv_ConditionParameter[i].sVariable2, T#0s, state);
         mIFConditionHelpData[i].bRealVar2Used := TRUE;
      END_IF;      
      mIFConditionHelpData[i].rValue := sv_ConditionParameter[i].rValue;
   END_IF;
   
   //copy operator
   mIFConditionHelpData[i].Operator := sv_ConditionParameter[i].CompareOperator;
END_FOR;





;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aInitLoopHelpData


VAR_TEMP
 i : DINT;
END_VAR

VAR
 state : KSYS_Status;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO cMaxLoops DO
   IF (sv_LoopParameter[i].CompareOperator = nCompOperatorEqual) OR 
      (sv_LoopParameter[i].CompareOperator = nCompOperatorNotEqual) THEN
      //get refto BOOL - values
      mLoopHelpData[i].pbVariable1 := GET_SYNC_REFTO(sv_LoopParameter[i].sVariable1, T#0s, state);
      mLoopHelpData[i].pbVariable2 := GET_SYNC_REFTO(sv_LoopParameter[i].sVariable2, T#0s, state);
   ELSIF (sv_LoopParameter[i].CompareOperator = nCompOperatorModulo) THEN
      //get refto DINT - value
      
      IF sv_LoopParameter[i].sVariable1 = 'system.sv_iLoopCounter' THEN
         //special case: loop counter
         mLoopHelpData[i].bLoopCounter := TRUE;
      ELSE      
         mLoopHelpData[i].piVariable1 := GET_SYNC_REFTO(sv_LoopParameter[i].sVariable1, T#0s, state);
         IF sv_LoopParameter[i].sVariable2 <> '' THEN
            mLoopHelpData[i].piVariable2 := GET_SYNC_REFTO(sv_LoopParameter[i].sVariable2, T#0s, state);
            mLoopHelpData[i].bDintVar2Used := TRUE;
         END_IF;
      END_IF;
      mLoopHelpData[i].iValue := sv_LoopParameter[i].iValue;
   ELSE
      //get refto REAL - value
      mLoopHelpData[i].prVariable1 := GET_SYNC_REFTO(sv_LoopParameter[i].sVariable1, T#0s, state);
      IF sv_LoopParameter[i].sVariable2 <> '' THEN
         mLoopHelpData[i].prVariable2 := GET_SYNC_REFTO(sv_LoopParameter[i].sVariable2, T#0s, state);
         mLoopHelpData[i].bRealVar2Used := TRUE;
      END_IF;      
      mLoopHelpData[i].rValue := sv_LoopParameter[i].rValue;
   END_IF;
   
   //copy operator
   mLoopHelpData[i].Operator := sv_LoopParameter[i].CompareOperator;
END_FOR;





;#END_EDIT_BLOCK END_ALGORITHM

(*
Generate sv_ODCSequenceInt from sv_ODCSequence.

Give each entry in the ODC array a number and write the position of its predecessor/successor.
This is necessary for dependency calculation
*)

ALGORITHM aCreateInternalSequence


VAR_OUTPUT
 bError : BOOL;
 iUsedColumns : DINT (* maximum usage of sequence array *);
 iUsedRows : DINT (* maximum usage of sequence array *);
END_VAR

VAR_TEMP
 m : DINT;
 k : DINT;
 iTmpCol : DINT;
 bChanged : BOOL (* need to write back changed step to sv_ODCSequence *);
 bInvalidStep : BOOL (* step is invalid because i has a strange movement/device ID *);
END_VAR

VAR
 fbInterpreterFindEndOfParallel : FBInterpreterFindEndOfParallel;
 fbGetMoveNumber : FBGetMoveNumber;
 ParseStack : tyNumberParseArray;
 CurrentParsePos : tsNumberParseElement;
 PrevPos : tsODCStepPos (* remember prev step for filling out PosPrevStep *);
 iCounter : DINT (* counter for sequential numbering *);
 iParseStackPointer : DINT;
 bEndLoop : BOOL (* end numbering loop *);
 bAddPrevNextInfo : BOOL (* write PosNextStep PosPrevStep variables for this step *);
 CurrentStep : KODC_Step;
 bContinueAfterLoopAdded : BOOL;
 fbSetStepState : FBSetStepState;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, 'numbering for safety calculation');

bError := FALSE;
iCounter := 1;
iTmpCol := 1;

iUsedColumns := 1;
iUsedRows := 1;
bContinueAfterLoopAdded := FALSE;

(* where we start parsing *)
ParseStack[1].iColumn := 1;
ParseStack[1].iRow := 1;
ParseStack[1].iRowEnd := cMaxODCSteps + 1;
ParseStack[1].bIgnoreStartParallel := FALSE;
iParseStackPointer := 1;
PrevPos.iColumn := -1;
PrevPos.iRow := -1;

bEndLoop := FALSE;

(* use parse a parse stack to traverse the array in a defined order
   the stack is responsible for remembering what to parse next.
   When a parallel branch is found all choices where to continue
   executing are pushed onto the stack in the right order.
   Then they are popped from the stack one by one and executed *)

(* execute one element from the stack *)
WHILE NOT bEndLoop DO
   IF iParseStackPointer < 1 THEN
      fbDebugTrace('parse stack underflow');
      aStopInterpreterFatal();
      bError := TRUE;
      RETURN;
   END_IF;
   CurrentParsePos := ParseStack[iParseStackPointer];
   iParseStackPointer := iParseStackPointer - 1;
   
   iTmpCol := CurrentParsePos.iColumn;
   iUsedColumns := MAX(iTmpCol, iUsedColumns);
   
   fbDebugTrace2(nODCInterpreter, CONCAT('started traversing ',
                                         DINT_TO_STRING(CurrentParsePos.iRow),
                                         '-',
                                         DINT_TO_STRING(CurrentParsePos.iRowEnd),
                                         ' col:',
                                         DINT_TO_STRING(CurrentParsePos.iColumn)));
    
   FOR k := CurrentParsePos.iRow TO cMaxODCSteps + 1 DO
      bAddPrevNextInfo := FALSE;
      IF k >= CurrentParsePos.iRowEnd THEN
         (* we finished our entry on the parse stack *)
         fbDebugTrace2(nODCInterpreter, CONCAT('finished traversing ',
                                               DINT_TO_STRING(CurrentParsePos.iRow),
                                               '-',
                                               DINT_TO_STRING(CurrentParsePos.iRowEnd),
                                               ' col:',
                                               DINT_TO_STRING(CurrentParsePos.iColumn)));

         IF iParseStackPointer <= 0 THEN
            (* The last entry in the parse stack was finished, but no step with *)
            (* iCompId = cCompODC AND iMoveId = cMoveEndSequence was found. *)
            fbDebugTrace('Parsing the sequence finished but no step "ODC End Sequence" was found.');
            aStopInterpreterFatal();
            bError := TRUE;
            RETURN;
         END_IF;

         EXIT;(* work on next stack element *)
      ELSIF k >= cMaxODCSteps + 1 THEN
         (* something went horribly wrong and we tried to parse elements after the end of the array *)
         (* this should never happen *)
         fbDebugTrace('Parsing the sequence failed. Out of bounds access detected.');
         aStopInterpreterFatal();
         bError := TRUE;
         RETURN;
      END_IF;
      
      CurrentStep := sv_ODCSequence[iTmpCol][k];
      bChanged := FALSE;
      
      (* fix up empty elements from builder so they are valid *)
      IF CurrentStep.iCompId = 0 THEN
         CurrentStep.iCompId := cCompNone;
         bChanged := TRUE;
      END_IF;
      IF CurrentStep.iIndexId = 0 THEN
         CurrentStep.iIndexId := 1;
         bChanged := TRUE;
      END_IF;
      IF CurrentStep.iMoveId = 0 THEN
         CurrentStep.iMoveId := cMoveNone;
         bChanged := TRUE;
      ELSIF CurrentStep.iMoveId = cMaxMoveIdent THEN
         //set MoveId to cMoveAll due to compatibility reasons
         CurrentStep.iMoveId := cMoveAll;
         bChanged := TRUE;
      END_IF;
      IF CurrentStep.iMoveDir = 0 THEN
         CurrentStep.iMoveDir := cMoveNone;
         bChanged := TRUE;
      ELSIF CurrentStep.iMoveDir = cMaxMoveIdent THEN
         //set MoveDir to cMoveAll due to compatibility reasons
         CurrentStep.iMoveDir := cMoveAll;
         bChanged := TRUE;
      END_IF;
      
      IF bChanged THEN
         (* write back valid value *)
         fbDebugTrace2(nODCInterpreter, CONCAT('writing back changed values to ',
                                               DINT_TO_STRING(iTmpCol),
                                               '/',
                                               DINT_TO_STRING(k))); 
         sv_ODCSequence[iTmpCol][k] := CurrentStep;
      END_IF;
      
      IF CurrentStep.iMoveId = cMoveStartParallel THEN
         (* search end of parallel movement *)
         (* in each column find a EP where the leftmost column is the current column *)
         IF CurrentParsePos.bIgnoreStartParallel THEN
            (* we want to give branch begin statements a number , but we don't want to go
               into a endless loop *)
            bAddPrevNextInfo := TRUE;
            CurrentParsePos.bIgnoreStartParallel := FALSE;
         ELSE
            fbInterpreterFindEndOfParallel(odcSequence := sv_ODCSequence, iColumn := iTmpCol, iLine := k);
               
            IF fbInterpreterFindEndOfParallel.iMaxLineOfBranch = 0 THEN
               fbDebugTrace('did not find end of parallel branch, what should we do here?');
               aStopInterpreterFatal();
               bError := TRUE;
               RETURN;
            END_IF;
               
            (* continue after EndParallel *)
            iParseStackPointer := iParseStackPointer + 1;
            //dummy := Print('***** increase parse stack pointer to %d',iParseStackPointer);
            ParseStack[iParseStackPointer].iColumn := iTmpCol;
            ParseStack[iParseStackPointer].iRow := fbInterpreterFindEndOfParallel.iMaxLineOfBranch + 1;
            ParseStack[iParseStackPointer].iRowEnd := CurrentParsePos.iRowEnd;
            ParseStack[iParseStackPointer].bIgnoreStartParallel := FALSE;
            
            fbDebugTrace2(nODCInterpreter, CONCAT('adding parse step (continue) ',
                                                  DINT_TO_STRING(ParseStack[iParseStackPointer].iRow),
                                                  '-',
                                                  DINT_TO_STRING(ParseStack[iParseStackPointer].iRowEnd),
                                                  ' col:',
                                                  DINT_TO_STRING(ParseStack[iParseStackPointer].iColumn)));

            (* add parallel branches from right to left *)
            FOR m := cMaxParallelMovements TO iTmpCol BY -1 DO
               IF sv_ODCSequence[m][k].iMoveId = cMoveStartParallel THEN
                  iParseStackPointer := iParseStackPointer + 1;
                  //dummy := Print('***** increase parse stack pointer to %d',iParseStackPointer);
                  ParseStack[iParseStackPointer].iColumn := m;
                  ParseStack[iParseStackPointer].iRow := k; (* start again at SP instruction, for giving it a number, but don't try to detect a branch start (we just did that) *)
                  ParseStack[iParseStackPointer].iRowEnd := fbInterpreterFindEndOfParallel.iMaxLineOfBranch + 1; (* also iterate over EP steps *)
                  ParseStack[iParseStackPointer].bIgnoreStartParallel := TRUE;
                  
                  fbDebugTrace2(nODCInterpreter, CONCAT('adding parse step (parallel) ',
                                                  DINT_TO_STRING(ParseStack[iParseStackPointer].iRow),
                                                  '-',
                                                  DINT_TO_STRING(ParseStack[iParseStackPointer].iRowEnd),
                                                  ' col:',
                                                  DINT_TO_STRING(ParseStack[iParseStackPointer].iColumn)));
                  
               END_IF;    
            END_FOR;
            EXIT; (* work on next stack element(probably left most branch) *)
         END_IF;
      ELSIF CurrentStep.iMoveId = cMoveEndSequence AND CurrentStep.iCompId = cCompODC THEN
         fbDebugTrace2(nODCInterpreter, 'found end');
         
         iUsedRows := k;
         bEndLoop := TRUE;
         bAddPrevNextInfo := TRUE;
         
         IF iTmpCol <> 1 THEN
            (* check if the end sequence marker is in a column other than the first *)
            (* this is not allowed *)
            fbDebugTrace(CONCAT('Found "ODC End Sequence" in column ', DINT_TO_STRING(iTmpCol), ' instead of column 1'));
            aStopInterpreterFatal();
            bError := TRUE;
            RETURN;
         ELSIF iParseStackPointer >= 1 THEN
            (* check if there is something left on parse stack, this should not happen *)
            (* unless the end sequence marker is placed in the middle of the sequence *)
            fbDebugTrace('Found "ODC End Sequence" in the middle of the sequence instead of at the end.');
            aStopInterpreterFatal();
            bError := TRUE;
            RETURN;
         END_IF;
      ELSIF CurrentStep.iMoveId = cMoveEndParallel THEN
         bAddPrevNextInfo := TRUE;
      ELSIF CurrentStep.iMoveId  = cMoveNone AND CurrentStep.iMoveDir = cMoveNone AND CurrentStep.iCompId  = cCompNone THEN
         ;(* empty step -> do not add prev/next info *)
      ELSIF (CurrentStep.iMoveId = cMoveStartParallelOpen) THEN
         g_ParallelOpenHelpData[iTmpCol].iStartParallelOpenLine := k;
         
         //dummy := Print('found start parallel open at line %d  column %d', k, iTmpCol);          
         IF CurrentParsePos.bIgnoreStartParallel THEN
            (* we want to give branch begin statements a number , but we don't want to go
               into a endless loop *)
            bAddPrevNextInfo := TRUE;
            CurrentParsePos.bIgnoreStartParallel := FALSE;
         ELSE         
            (* continue after End loop *)
            //attention: only add this once and not every time when a startparallel open is found!! 
            IF NOT bContinueAfterLoopAdded THEN
               iParseStackPointer := iParseStackPointer + 1;
               //dummy := Print('***** increase parse stack pointer to %d',iParseStackPointer);
               ParseStack[iParseStackPointer].iColumn := iTmpCol;
               ParseStack[iParseStackPointer].iRow := (g_iAutoCycleLoopEndLine + 1);
               ParseStack[iParseStackPointer].iRowEnd := cMaxODCSteps;
               ParseStack[iParseStackPointer].bIgnoreStartParallel := FALSE;
               
               fbDebugTrace2(nODCInterpreter, CONCAT('adding parse step (continue after end loop) ',
                                                   DINT_TO_STRING(ParseStack[iParseStackPointer].iRow),
                                                   '-',
                                                   DINT_TO_STRING(ParseStack[iParseStackPointer].iRowEnd),
                                                   ' col:',
                                                   DINT_TO_STRING(ParseStack[iParseStackPointer].iColumn)));
               bContinueAfterLoopAdded := TRUE;
            END_IF;
                                     
            (* add parallel branches from right to left *)
            FOR m := cMaxParallelMovements TO iTmpCol BY -1 DO 
               IF sv_ODCSequence[m][k].iMoveId = cMoveStartParallelOpen THEN
                  iParseStackPointer := iParseStackPointer + 1;
                  //dummy := Print('***** increase parse stack pointer to %d',iParseStackPointer);
                  ParseStack[iParseStackPointer].iColumn := m;
                  ParseStack[iParseStackPointer].iRow := k;                             
                  ParseStack[iParseStackPointer].iRowEnd := (g_iAutoCycleLoopEndLine +1); //use row which contains the end of autocycle loop as iEndRow
                  ParseStack[iParseStackPointer].bIgnoreStartParallel := TRUE;  
                  
                  fbDebugTrace2(nODCInterpreter, CONCAT('adding parse step (PARALLEL OPEN) ',
                                                   DINT_TO_STRING(ParseStack[iParseStackPointer].iRow),
                                                   '-',
                                                   DINT_TO_STRING(ParseStack[iParseStackPointer].iRowEnd),
                                                   ' col:',
                                                   DINT_TO_STRING(ParseStack[iParseStackPointer].iColumn)));
               END_IF;    
            END_FOR;      
            EXIT; (* work on next stack element*)             
         END_IF;
        
      ELSIF (CurrentStep.iMoveId = cMoveEndParallelOpen) THEN
         bAddPrevNextInfo := FALSE;
         //parsing of one line is not possible -> add all necessary informations for this "EndParallelOpen"
         //and the "EndParallelOpen" in the corresponding column directly         
         //dummy := Print('found end parallel open at line %d  column %d', k, iTmpCol);         
         fbGetMoveNumber.DeviceId.CompId  := CurrentStep.iCompId;
         fbGetMoveNumber.DeviceId.IndexId := INT_TO_DINT(CurrentStep.iIndexId);
         fbGetMoveNumber(MoveId := CurrentStep.iMoveId, MoveDir := CurrentStep.iMoveDir);
         sv_ODCSequenceInt[iTmpCol][k].iMoveNumber := fbGetMoveNumber.iMoveNumber;        
         sv_ODCSequenceInt[iTmpCol][k].iCount := INT_TO_DINT(CurrentStep.iCount);
         
         sv_ODCSequenceInt[iTmpCol][k].iSequentialNumber := iCounter;
         iCounter := iCounter + 1;
         
         (* link current step.PosPrevStep to last step *)
         sv_ODCSequenceInt[iTmpCol][k].PosPrevStep := PrevPos;
                        
         (* link prev step.PosNextStep to this step *)
         sv_ODCSequenceInt[PrevPos.iColumn][PrevPos.iRow].PosNextStep.iColumn := iTmpCol;
         sv_ODCSequenceInt[PrevPos.iColumn][PrevPos.iRow].PosNextStep.iRow := k;        
         PrevPos.iColumn := iTmpCol;
         PrevPos.iRow := k;
                  
         FOR m := 2 TO cMaxParallelMovements DO 
            IF sv_ODCSequence[m][k].iMoveId = cMoveEndParallelOpen THEN
               //dummy := Print('found end parallel open at line %d  column %d', k, m);                              
               sv_ODCSequenceInt[m][k].iMoveNumber := fbGetMoveNumber.iMoveNumber;
               sv_ODCSequenceInt[m][k].iCount := INT_TO_DINT(sv_ODCSequence[iTmpCol][k].iCount);
               
               sv_ODCSequenceInt[m][k].iSequentialNumber := iCounter;
               iCounter := iCounter + 1;
               
               sv_ODCSequenceInt[m][k].PosPrevStep := PrevPos;
               sv_ODCSequenceInt[PrevPos.iColumn][PrevPos.iRow].PosNextStep.iColumn := m;
               sv_ODCSequenceInt[PrevPos.iColumn][PrevPos.iRow].PosNextStep.iRow := k;
               
               PrevPos.iColumn := m;
               PrevPos.iRow := k;
               //do not exit because there can be more than one EndParallelOpen in this line
            END_IF;    
         END_FOR;
         
      ELSE
         (* normal movement *)
         bAddPrevNextInfo := TRUE;
      END_IF;
         
      (* add information for Prev and Next if needed *)
      IF bAddPrevNextInfo THEN
         bInvalidStep := FALSE;
         IF CurrentStep.iCompId < cMinCompId OR CurrentStep.iCompId > cMaxCompId OR
            CurrentStep.iIndexId < 0 OR INT_TO_DINT(CurrentStep.iIndexId) > cMaxDeviceIndex OR 
            CurrentStep.iMoveDir < cMinMoveIdent OR CurrentStep.iMoveDir > cMaxMoveIdent OR
            CurrentStep.iMoveId < cMinMoveIdent OR CurrentStep.iMoveId > cMaxMoveIdent THEN
            (* a invalid comp/move id will otherwise cause a "out of range" error
               when assigned to a subrange *)
            bInvalidStep := TRUE;
         END_IF;
         
         IF NOT bInvalidStep THEN
            fbGetMoveNumber.DeviceId.CompId  := CurrentStep.iCompId;
            fbGetMoveNumber.DeviceId.IndexId := INT_TO_DINT(CurrentStep.iIndexId);
            fbGetMoveNumber(MoveId := CurrentStep.iMoveId, MoveDir := CurrentStep.iMoveDir);
         END_IF;
         IF NOT bInvalidStep AND fbGetMoveNumber.bFound THEN
            sv_ODCSequenceInt[iTmpCol][k].iMoveNumber := fbGetMoveNumber.iMoveNumber;
            
            IF sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pMovementData^.pbActivated = EMPTY THEN
               fbDebugTrace(CONCAT('at pos: ',
                                   DINT_TO_STRING(k),
                                   '/',
                                   DINT_TO_STRING(iTmpCol),
                                   ' movement ',
                                   DINT_TO_STRING(CurrentStep.iCompId),
                                   '.',
                                   INT_TO_STRING(CurrentStep.iIndexId),
                                   ' ',
                                   DINT_TO_STRING(CurrentStep.iMoveId),
                                   '/',
                                   DINT_TO_STRING(CurrentStep.iMoveDir),
                                   ' has pbActivated not set'));
               // dependency analysis needs pbActivated to point to a valid SV
               // mabye this check can be loosened when dependency analysis can handle a EMPTY pbActivated
               aStopInterpreterFatal();
               bError := TRUE;
               RETURN;
            END_IF;
            
         ELSE // NOT bInvalidStep AND fbGetMoveNumber.bFound
            (* non existent movement *)
            sv_ODCSequenceInt[iTmpCol][k].iMoveNumber := 0;
            
            SET_ALARM(Name := erMovementNotAvailable,
                      SubID1 := CurrentStep.iCompId,
                      SubID2 := CurrentStep.iIndexId,
                      SubID3 := CurrentStep.iMoveId,
                      SubID4 := CurrentStep.iMoveDir);
            
            fbDebugTrace(CONCAT('at pos: ', DINT_TO_STRING(k), '/', DINT_TO_STRING(iTmpCol),
                                ' trying to number non existent/invalid movement ',
                                DINT_TO_STRING(CurrentStep.iCompId), '.',
                                INT_TO_STRING(CurrentStep.iIndexId), ' ',
                                DINT_TO_STRING(CurrentStep.iMoveId), '/',
                                DINT_TO_STRING(CurrentStep.iMoveDir)));
            
            fbSetStepState.StepPos.iColumn := iTmpCol;
            fbSetStepState.StepPos.iRow := k;
            fbSetStepState(StepState := nStateError);
            bError := TRUE;
            (* do not quit early -> internal array is filled and debug mask works *)
         END_IF;

         sv_ODCSequenceInt[iTmpCol][k].iCount := INT_TO_DINT(CurrentStep.iCount);
         
         IF sv_ODCSequenceInt[iTmpCol][k].iSequentialNumber <> 0 THEN
            fbDebugTrace('have already visited(numbered) this step, should not have happened');
            aStopInterpreterFatal();
            bError := TRUE;
            RETURN;
         ELSE
            sv_ODCSequenceInt[iTmpCol][k].iSequentialNumber := iCounter;
            iCounter := iCounter + 1;
            
            (* link current step.PosPrevStep to last step *)
            sv_ODCSequenceInt[iTmpCol][k].PosPrevStep := PrevPos;
                           
            (* link prev step.PosNextStep to this step *)
            IF PrevPos.iColumn <> -1 AND PrevPos.iRow <> -1 THEN
               sv_ODCSequenceInt[PrevPos.iColumn][PrevPos.iRow].PosNextStep.iColumn := iTmpCol;
               sv_ODCSequenceInt[PrevPos.iColumn][PrevPos.iRow].PosNextStep.iRow := k;
            END_IF;
            PrevPos.iColumn := iTmpCol;
            PrevPos.iRow := k;
            
            (* set PosNextStep of last step to -1,-1 *)
            IF bEndLoop THEN
               sv_ODCSequenceInt[iTmpCol][k].PosNextStep.iColumn := -1;
               sv_ODCSequenceInt[iTmpCol][k].PosNextStep.iRow := -1;
               EXIT;(* need to leave the inner loop after last step *) 
            END_IF;
         END_IF; // iSequentialNumber <> 0
      END_IF; // bAddPrevNextInfo
   END_FOR;
END_WHILE;

fbDebugTrace2(nODCInterpreter, CONCAT('max usage of array: ',
                                      DINT_TO_STRING(iUsedColumns),
                                      '/',
                                      DINT_TO_STRING(iUsedRows)));

//init data for all check conditions
aInitCheckConditionHelpData();

//init data for all IF conditions and loops
aInitIFConditionHelpData();
aInitLoopHelpData();


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aAddStartedManualMovement


VAR_INPUT
 DeviceId : tsDeviceId;
 StepPos : tsODCStepPos;
 MoveId : tMoveIdent;
 MoveDir : tMoveIdent;
 iInstance : DINT;
END_VAR

VAR_OUTPUT
 bOK : BOOL;
END_VAR

VAR
 fbStartedMovementAdder : FBStartedMovementAdder;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

(* this does not really belong to the interpreter
   maybe it can be moved to ABODC *)
fbStartedMovementAdder(DeviceId := DeviceId, MoveId := MoveId, MoveDir := MoveDir, StepPos := StepPos, iInstance := iInstance);
bOK := fbStartedMovementAdder.bOK;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Initialize the interpreter to start executing at a certain row/column

When used for combined movements also a end position can be set (iEndRow).
when iEndRow is 0 it means interpret until ODC1.EndSequence is found.
*)

ALGORITHM aInitInterpreter


VAR_INPUT
 iColumn : DINT (* Column where to start execution *);
 iRow : DINT (* Row where to start execution *);
 iEndRow : DINT (* Column where to stop execution *);
 bSkipAlreadyPosReached : BOOL (* Do not start movements wher PosReached is already TRUE before starting it *);
 bExcludeActiveColumns : BOOL (* do not reset / init active columns *);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, CONCAT('########## initializing interpreter to start at pos:',
                                       DINT_TO_STRING(iRow),
                                       '/',
                                       DINT_TO_STRING(iColumn),
                                       ' and stop at ',
                                       DINT_TO_STRING(iEndRow),
                                       ' skipPosReached:',
                                       BOOL_TO_STRING(bSkipAlreadyPosReached),
                                       ' exclude active columns:',
                                       BOOL_TO_STRING(bExcludeActiveColumns)));


IF mbFatalError THEN
   fbDebugTrace('can not initialize interpreter after fatal error, need to call aSetInitOK to clear error flag');
   RETURN;
END_IF;

aResetInterpreter(bExcludeActiveColumns := bExcludeActiveColumns);

IF iRow < 1 OR iRow > cMaxODCSteps OR iColumn < 1 OR iColumn > cMaxParallelMovements THEN
   (* error instruction pointer is wrong *)
   fbDebugTrace(CONCAT('trying start execution out of bounds ',
                       DINT_TO_STRING(iRow),
                       '/',
                       DINT_TO_STRING(iColumn)));
   aStopInterpreterFatal();
   RETURN;
END_IF;

IF iEndRow > cMaxODCSteps THEN
   (* error instruction end pointer is wrong *)
   (* 0 means execute until end *)
   fbDebugTrace(CONCAT('execution end pointer ',
                       DINT_TO_STRING(iEndRow),
                       '/',
                       DINT_TO_STRING(iColumn),
                      ' out of bounds'));
   aStopInterpreterFatal();
   RETURN;
END_IF;

(* only first column is active *)
odcParallelInfo[iColumn].bColumnActive := TRUE;
odcParallelInfo[iColumn].iRow := iRow;
odcParallelInfo[iColumn].bSkipAlreadyPosReached := bSkipAlreadyPosReached;
miEndRow := iEndRow;

mbFinished := FALSE;
mbNormalError := FALSE;
mbActive := TRUE;
sv_InterpreterParallelInfo := odcParallelInfo;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aCheckConditionsManual


VAR_INPUT
 Movement : KODC_Step (* requested movement *);
 bNoAlarms : BOOL (* TRUE: no alarms are set *);
END_VAR

VAR_OUTPUT
 bCheckConditionsOk : BOOL;
 iConditionsNotOk : DINT (* number of not fulfilled checkconditions *);
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 bTargetValueReached : BOOL;
 bRelevantCheckCondition : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bCheckConditionsOk := TRUE;
iConditionsNotOk := 0;

FOR i := 1 TO cMaxCheckConditions DO
   
   bRelevantCheckCondition := (Movement = sv_CheckConditionInstanceData[i].RelatedMovement) OR
                              (Movement = sv_CheckConditionInstanceData[i].MoveInEndPos);
   
   IF bRelevantCheckCondition THEN
      
      // check if value is reached
      IF mCheckCondHelpData[i].MoveDirection = nMoveDirectionMinToMax THEN
         bTargetValueReached := mCheckCondHelpData[i].prActValue^ >= sv_CheckConditionInstanceData[i].rValue;
      ELSIF mCheckCondHelpData[i].MoveDirection = nMoveDirectionMaxToMin THEN
         bTargetValueReached := mCheckCondHelpData[i].prActValue^ <= sv_CheckConditionInstanceData[i].rValue;
      END_IF;   
   
      IF Movement = sv_CheckConditionInstanceData[i].RelatedMovement THEN
         //check pos reached flag of movement in endposition as soon as target value is reached               
         IF bTargetValueReached THEN
            IF NOT mCheckCondHelpData[i].pbPosReached^ THEN
               IF NOT bNoAlarms THEN
                  SET_ALARM(Name := mCheckCondHelpData[i].AlarmMoveInEndPos.AlarmId,
                            SubID1 := mCheckCondHelpData[i].AlarmMoveInEndPos.SubId[1]);
               END_IF;               
               bCheckConditionsOk := FALSE;
               iConditionsNotOk := iConditionsNotOk + 1;
            END_IF;
         END_IF;
               
      ELSIF Movement = sv_CheckConditionInstanceData[i].MoveInEndPos THEN
         //check related movement
         IF bTargetValueReached THEN
            //value exceeded 
            IF NOT bNoAlarms THEN
               SET_ALARM(Name := erCompNotInCorrectPosition,
                     SubID1 := sv_CheckConditionInstanceData[i].RelatedMovement.iCompId,
                     SubID2 := sv_CheckConditionInstanceData[i].RelatedMovement.iIndexId);
            END_IF;            
            bCheckConditionsOk := FALSE;
            iConditionsNotOk := iConditionsNotOk + 1;
         END_IF;
      END_IF;
   END_IF;

END_FOR;



;#END_EDIT_BLOCK END_ALGORITHM

(*
check if a start condition is reached
*)

ALGORITHM aCheckStartConditionReached


VAR_INPUT
 iInstance : DINT (* instance of startcondition *);
END_VAR

VAR_OUTPUT
 bReached : BOOL (* start condition reached *);
END_VAR

VAR
 prActValue : REFTO REAL (* reference to actual value of the related movement *);
 pbReferenceCondition : REFTO BOOL;
 Direction : tnMoveDirection (* max to min or min to max *);
 RelatedMovement : KODC_Step;
 PrevRelatedMovement : KODC_Step (* data from last call of algorithm *);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

RelatedMovement := sv_StartConditionInstanceData[iInstance].RelatedMovement;
bReached := FALSE;

IF RelatedMovement <> PrevRelatedMovement THEN
   //only get new data if data of related movement changed   
   aGetMovementData(Movement := RelatedMovement);
   Direction := aGetMovementData.Direction;
   prActValue := aGetMovementData.prActValue;
   pbReferenceCondition := aGetMovementData.pbReferenceCondition;
END_IF;


// decide if start condition is reached
IF sv_StartConditionInstanceData[iInstance].bStartCondition THEN
   //boolean start condition reached flag
   IF (pbReferenceCondition <> EMPTY) THEN
      bReached := pbReferenceCondition^;
   END_IF;
ELSE   
   IF (prActValue <> EMPTY) THEN
      //no boolean flag -> check start condition reached according direction and value
      IF Direction = nMoveDirectionMinToMax THEN
         bReached := prActValue^ >= sv_StartConditionInstanceData[iInstance].rValue;
      ELSIF Direction = nMoveDirectionMaxToMin THEN
         bReached := prActValue^ <= sv_StartConditionInstanceData[iInstance].rValue;
      END_IF;
   END_IF;   
END_IF;

PrevRelatedMovement := RelatedMovement;


;#END_EDIT_BLOCK END_ALGORITHM

(*
check condition supervision
*)

ALGORITHM aCheckConditionSupervision


VAR_INPUT
 iInstance : DINT (* instance of startcondition *);
END_VAR

VAR_OUTPUT
 bContinue : BOOL (* check condition must not be called any more *);
END_VAR

VAR
 bTargetValueReached : BOOL;
 fbLockUnlock : FBLockUnlock;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bContinue := FALSE;

// check if value is reached
IF mCheckCondHelpData[iInstance].MoveDirection = nMoveDirectionMinToMax THEN
   bTargetValueReached := mCheckCondHelpData[iInstance].prActValue^ >= sv_CheckConditionInstanceData[iInstance].rValue;
ELSIF mCheckCondHelpData[iInstance].MoveDirection = nMoveDirectionMaxToMin THEN
   bTargetValueReached := mCheckCondHelpData[iInstance].prActValue^ <= sv_CheckConditionInstanceData[iInstance].rValue;
END_IF;

//supervision of check condition
//finished Movement reached the endposition before related movement reached the target value 
//-> continue
//related movement reached the target value and finished movement is not in endposition
//-> lock related movement untill endposition is reached and display a warning
IF bTargetValueReached THEN
   IF NOT mCheckCondHelpData[iInstance].pbPosReached^ THEN
      //target value reached and movement is not in endposition
      
      IF NOT mCheckCondHelpData[iInstance].bMovementLocked THEN
         //lock related movement         
         fbLockUnlock.DeviceId := mCheckCondHelpData[iInstance].LockUnlockData.DeviceId;
         fbLockUnlock.MoveDir := mCheckCondHelpData[iInstance].LockUnlockData.MoveDir;
         fbLockUnlock.MoveId := mCheckCondHelpData[iInstance].LockUnlockData.MoveId;
         fbLockUnlock.Alarm := mCheckCondHelpData[iInstance].LockUnlockData.Alarm;
         fbLockUnlock(Mode := nLockResume);
         
         mCheckCondHelpData[iInstance].bMovementLocked := TRUE;
      END_IF;
         
   ELSIF mCheckCondHelpData[iInstance].pbPosReached^ THEN
      //unlock movement and continue
      fbLockUnlock.DeviceId := mCheckCondHelpData[iInstance].LockUnlockData.DeviceId;
      fbLockUnlock.MoveDir := mCheckCondHelpData[iInstance].LockUnlockData.MoveDir;
      fbLockUnlock.MoveId := mCheckCondHelpData[iInstance].LockUnlockData.MoveId;
      fbLockUnlock.Alarm := mCheckCondHelpData[iInstance].LockUnlockData.Alarm;
      fbLockUnlock(Mode := nUnlock);
     
      mCheckCondHelpData[iInstance].bMovementLocked := FALSE;
      bContinue := TRUE;
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Check PosReached flag of a movement
If there is no valid reference of pbPosReached OR pbPosReached is FALSE,
an according message is traced (trace level: nODCInterpreter),
and the step state is set to nStateError
*)

ALGORITHM aCheckPosReached


VAR_INPUT
 DeviceId : tsDeviceId (* DeviceId of movement *);
 MoveId : tMoveIdent (* MoveId of movement *);
 MoveDir : tMoveIdent (* MoveDir of movement *);
 iColumn : DINT (* active column *);
 iRow : DINT (* active row *);
END_VAR

VAR_OUTPUT
 bPosReachedOk : BOOL (* posReached ok -> cycle can continue *);
END_VAR

VAR
 fbCheckPosReached : FBCheckPosReached;
 fbMoveDescription : FBMoveDescription;
 iMoveNr : DINT;
 iInstance : DINT;
 bPosNotReached : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bPosReachedOk := FALSE;
iMoveNr := sv_ODCSequenceInt[iColumn][iRow].iMoveNumber;

//check if movement is instanceable and according pos reached array is available
IF sv_MovementsAvailable[iMoveNr].pMovementData^.bInstanceable THEN
   IF CHECK_REF(sv_MovementsAvailable[iMoveNr].pMovementData^.InstanceData.pPosReachedArray^) THEN      
      iInstance := sv_ODCSequenceInt[iColumn][iRow].iCount;
      IF NOT sv_MovementsAvailable[iMoveNr].pMovementData^.InstanceData.pPosReachedArray^[iInstance] THEN
         //position not reached
         bPosNotReached := TRUE;
      END_IF;
   ELSE
      IF sv_MovementsAvailable[iMoveNr].pMovementData^.iSafetyIdentifier <> 0 THEN
         //movement is safety relevant and has no posReached variable
         bPosNotReached := TRUE;
      END_IF;      
   END_IF;
ELSE

   fbCheckPosReached(DeviceId := DeviceId,
                     MoveDir  := MoveDir,
                     MoveId   := MoveId);
   
   IF CHECK_REF(fbCheckPosReached.pbPosReached^) AND NOT fbCheckPosReached.pbPosReached^ THEN
      (* did not reach required position *)
      bPosNotReached := TRUE;
   ELSE
      IF NOT CHECK_REF(fbCheckPosReached.pbPosReached^) THEN
         fbMoveDescription(iMoveNr := iMoveNr);
         fbDebugTrace2(nODCInterpreter, CONCAT('movement ',fbMoveDescription.sDescription,' has no pos reached variable'));
         IF sv_MovementsAvailable[iMoveNr].pMovementData^.iSafetyIdentifier <> 0 THEN
            //movement is safety relevant and has no posReached variable
            bPosNotReached := TRUE;
         END_IF;
      END_IF;                     
   END_IF;
   
END_IF;

IF bPosNotReached THEN
   
   //trace warning and set step state to error
   fbMoveDescription(iMoveNr := iMoveNr);   
   fbDebugTrace2(nODCInterpreter, CONCAT('movement ',fbMoveDescription.sDescription,' finished, but pos reached is FALSE'));

   fbSetStepState.StepPos.iRow := iRow;
   fbSetStepState.StepPos.iColumn := iColumn;
   fbSetStepState(StepState := nStateError);
    
   //set according alarm
   IF (sv_OperationMode >= nHalfAutomatic) THEN
      IF (sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.AlarmId <> EMPTY) THEN
         SET_ALARM(Name := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.AlarmId,
                SubID1 := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.SubId[1],
                SubID2 := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.SubId[2],
                SubID3 := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.SubId[3],
                SubID4 := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.SubId[4],
                Param1 := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.Param1,
                Param2 := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.Param2);
      ELSE
         //display a default alarm to avoid stopp of autocycle without alarm
         SET_ALARM(Name := erReadyAndNotPosReached,
                   SubID1 := DeviceId.CompId,
                   SubID2 := DeviceId.IndexId,
                   SubID3 := MoveId);
      END_IF;
         
   END_IF;
       
   //stop interpreter
   aStopInterpreterError(); 
   bPosNotReached := FALSE;
ELSE
   //posReached information ok
   bPosReachedOk := TRUE;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aCheckIfCondition


VAR_INPUT
 iInstance : DINT (* instance of IF - condition *);
END_VAR

VAR_OUTPUT
 bConditionOk : BOOL (* TRUE: condition fullfilled *);
END_VAR

VAR
 var1 : DINT;
 var2 : DINT;
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bConditionOk := FALSE;

CASE mIFConditionHelpData[iInstance].Operator OF
   nCompOperatorEqual:
      bConditionOk := mIFConditionHelpData[iInstance].pbVariable1^ = mIFConditionHelpData[iInstance].pbVariable2^;
   
   nCompOperatorNotEqual:
      bConditionOk := mIFConditionHelpData[iInstance].pbVariable1^ <> mIFConditionHelpData[iInstance].pbVariable2^;
   
   nCompOperatorLowerThan:
      IF mIFConditionHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ < mIFConditionHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ < mIFConditionHelpData[iInstance].rValue;
      END_IF;      
   
   nCompOperatorLowerEqual:
      IF mIFConditionHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ <= mIFConditionHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ <= mIFConditionHelpData[iInstance].rValue;
      END_IF;
   
   nCompOperatorGreaterThan:
      IF mIFConditionHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ > mIFConditionHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ > mIFConditionHelpData[iInstance].rValue;
      END_IF;
   
   nCompOperatorGreaterEqual:
      IF mIFConditionHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ >= mIFConditionHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ >= mIFConditionHelpData[iInstance].rValue;
      END_IF;
   
   nCompOperatorModulo:
      var1 := mIFConditionHelpData[iInstance].piVariable1^;
      IF mIFConditionHelpData[iInstance].bDintVar2Used THEN
         var2 := mIFConditionHelpData[iInstance].piVariable2^;
      ELSE
         var2 := mIFConditionHelpData[iInstance].iValue;
      END_IF;
      i := MOD(var1, var2);
      bConditionOk := (i = 0);
   
ELSE
   ; //unknown operator
END_CASE;




;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aCheckLoopCondition


VAR_INPUT
 iInstance : DINT (* instance of IF - condition *);
END_VAR

VAR_OUTPUT
 bConditionOk : BOOL (* TRUE: condition fullfilled *);
END_VAR

VAR
 var1 : DINT;
 var2 : DINT;
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bConditionOk := FALSE;

CASE mLoopHelpData[iInstance].Operator OF
   nCompOperatorEqual:
      bConditionOk := mLoopHelpData[iInstance].pbVariable1^ = mLoopHelpData[iInstance].pbVariable2^;
   
   nCompOperatorNotEqual:
      bConditionOk := mLoopHelpData[iInstance].pbVariable1^ <> mLoopHelpData[iInstance].pbVariable2^;
   
   nCompOperatorLowerThan:
      IF mLoopHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ < mLoopHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ < mLoopHelpData[iInstance].rValue;
      END_IF;      
   
   nCompOperatorLowerEqual:
      IF mLoopHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ <= mLoopHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ <= mLoopHelpData[iInstance].rValue;
      END_IF;
   
   nCompOperatorGreaterThan:
      IF mLoopHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ > mLoopHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ > mLoopHelpData[iInstance].rValue;
      END_IF;
   
   nCompOperatorGreaterEqual:
      IF mLoopHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ >= mLoopHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ >= mLoopHelpData[iInstance].rValue;
      END_IF;
   
   nCompOperatorModulo:
      IF mLoopHelpData[iInstance].bLoopCounter THEN
         var1 := mLoopHelpData[iInstance].iActCount;
         var2 := sv_LoopParameter[iInstance].iValue; 
      ELSE   
         var1 := mLoopHelpData[iInstance].piVariable1^;
         IF mLoopHelpData[iInstance].bDintVar2Used THEN
            var2 := mLoopHelpData[iInstance].piVariable2^;
         ELSE
            var2 := mLoopHelpData[iInstance].iValue;
         END_IF;
      END_IF;
      
      IF var1 = 0 THEN
         bConditionOk := FALSE;
      ELSE
         i := MOD(var1, var2);
         bConditionOk := (i = 0);
      END_IF;
   
ELSE
   ; //unknown operator
END_CASE;




;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aGoToEndIf


VAR_INPUT
 iColumn : DINT;
END_VAR

VAR_TEMP
 iTmpLine : DINT;
END_VAR

VAR
 iCount : INT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR iTmpLine := (odcParallelInfo[iColumn].iRow + 1) TO sv_iUsedRows DO
   IF (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveEndIf) THEN
      
      iCount := sv_ODCSequence[iColumn][iTmpLine].iCount;
      mIFConditionHelpData[iCount].iInternalCount := (mIFConditionHelpData[iCount].iInternalCount + 1);
      
      //set step state to "ready"
      fbSetStepState.StepPos.iRow := iTmpLine;
      fbSetStepState.StepPos.iColumn := iColumn;         
      fbSetStepState(StepState := nStateReady);
      
      odcParallelInfo[iColumn].iRow := (iTmpLine + 1);
      odcParallelInfo[iColumn].bStartSent := FALSE;
      odcParallelInfo[iColumn].bStartConditionWarnPrinted := FALSE;
      odcParallelInfo[iColumn].bActivatedChecked := FALSE;
      odcParallelInfo[iColumn].bPosReachedArrayLinked := FALSE;
      odcParallelInfo[iColumn].bMovementReadyArrayLinked := FALSE;
      EXIT;
   END_IF;   
END_FOR;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aGoToEndLoop


VAR_INPUT
 iColumn : DINT;
 iInstance : DINT (* loop instance *);
END_VAR

VAR_TEMP
 iTmpLine : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR iTmpLine := (odcParallelInfo[iColumn].iRow + 1) TO sv_iUsedRows DO
   IF (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveEndLoop) AND (sv_ODCSequence[iColumn][iTmpLine].iCount = (DINT_TO_INT(iInstance))) THEN
      //set step state to "ready"
      fbSetStepState.StepPos.iRow := iTmpLine;
      fbSetStepState.StepPos.iColumn := iColumn;         
      fbSetStepState(StepState := nStateReady);
      
      odcParallelInfo[iColumn].iRow := (iTmpLine + 1);
      odcParallelInfo[iColumn].bStartSent := FALSE;
      odcParallelInfo[iColumn].bStartConditionWarnPrinted := FALSE;
      odcParallelInfo[iColumn].bActivatedChecked := FALSE;
      odcParallelInfo[iColumn].bPosReachedArrayLinked := FALSE;
      odcParallelInfo[iColumn].bMovementReadyArrayLinked := FALSE;
      EXIT;
   END_IF;   
END_FOR;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aGoToBeginLoop


VAR_INPUT
 iColumn : DINT;
 iInstance : DINT (* loop instance *);
END_VAR

VAR_TEMP
 iTmpLine : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR iTmpLine := (odcParallelInfo[iColumn].iRow - 1) TO 1 BY -1 DO
   IF (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveBeginLoop) AND (sv_ODCSequence[iColumn][iTmpLine].iCount = (DINT_TO_INT(iInstance))) THEN
      
      odcParallelInfo[iColumn].iRow := iTmpLine;
      odcParallelInfo[iColumn].bStartSent := FALSE;
      odcParallelInfo[iColumn].bStartConditionWarnPrinted := FALSE;
      odcParallelInfo[iColumn].bActivatedChecked := FALSE;
      odcParallelInfo[iColumn].bPosReachedArrayLinked := FALSE;
      odcParallelInfo[iColumn].bMovementReadyArrayLinked := FALSE;
      EXIT;
   ELSE
      //reset step states
      fbSetStepState.StepPos.iRow := iTmpLine;
      fbSetStepState.StepPos.iColumn := iColumn;         
      fbSetStepState(StepState := nStateDefault);
   END_IF;
END_FOR;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Interpret the 2 dimensional ODC array.
(Responsible for auto cycle and combined movements)

This needs to be called cyclically until aStatus.bActive = FALSE
This can happen when the interpreter has reached the end of the array/sequence
or when a error happens during interpreting.
*)

ALGORITHM aInterpret


VAR_TEMP
 i : DINT (* current step column *);
 k : DINT;
 iTmpRow : DINT;
END_VAR

VAR
 fbStart : FBStart;
 fbCheckReady : FBCheckReady;
 fbCheckPosReached : FBCheckPosReached;
 abODCCheckDependencies : ABODCCheckDependencies;
 iRow : DINT (* current step *);
 bConditionLinked : BOOL;
 MoveDir : tMoveIdent;
 MoveId : tMoveIdent (* current step *);
 DeviceId : tsDeviceId (* current step *);
 bIncreaseRow : BOOL (* increase row pointer after handling movement *);
 bJoinOK : BOOL;
 iJoinsInLine : DINT;
 evCheckLocklistEventData : tevCheckLocklistData;
 MoveData : REFTO tsMoveData;
 bNewSkipAlreadyPosReached : BOOL;
 iInstance : DINT;
 bGoToEndIf : BOOL (* go to end_if movement in this column *);
 bGoToEndLoop : BOOL;
 bGoToBeginLoop : BOOL;
 bMovementReady : BOOL;
 bAllParallelOpenColumnsReady : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//mbFinished removed because otherwise a parallel open tree will not finish
//at the end of the cycle
IF mbFatalError OR mbNormalError (* OR mbFinished *) OR NOT mbActive THEN
   (* do not try to interpret anything if there is a error *)
   RETURN;
END_IF;

fbRTC(EN := FALSE);

FOR i := 1 TO sv_iUsedColumns DO
   IF odcParallelInfo[i].bColumnActive AND NOT odcParallelInfo[i].bDisabled THEN
      (* only try to interpret if the column is active *)
      bIncreaseRow := FALSE;
      bGoToEndIf := FALSE;
      iRow := odcParallelInfo[i].iRow;
      IF iRow < 1 OR iRow > cMaxODCSteps THEN
         //error instruction pointer is wrong
         fbDebugTrace(CONCAT('trying to execute instructions that are out of bounds ',
                             DINT_TO_STRING(iRow), '/', DINT_TO_STRING(i)));
         aStopInterpreterFatal();
         RETURN;
      END_IF;
       
      MoveDir  := sv_ODCSequence[i][iRow].iMoveDir;
      MoveId   := sv_ODCSequence[i][iRow].iMoveId;
      DeviceId.CompId  := sv_ODCSequence[i][iRow].iCompId;
      DeviceId.IndexId := INT_TO_DINT(sv_ODCSequence[i][iRow].iIndexId);
    
      IF (MoveId = cMoveStartParallel) OR (MoveId = cMoveStartParallelOpen) THEN
         //StartParallel / StartParallelOpen must be handled although it is also checked in aIncreaseRow
         //reason / usecase: 
         //SP in column 1 activates column 2  => active step in column 2 will be a StartParallel step !
         bIncreaseRow := TRUE;
      ELSIF MoveId = cMoveEndParallel THEN        
         iJoinsInLine := 0;
         bJoinOK := TRUE;
         bNewSkipAlreadyPosReached := TRUE;
         FOR k := 1 TO sv_iUsedColumns DO
            IF sv_ODCSequence[k][iRow].iMoveId = cMoveEndParallel THEN
               IF iJoinsInLine = 0 AND i <> k THEN
               (* the first join point that is found is not the currently
                  active column, so we are not allowed to join here
                  need to wait for next cycle(and the left most column) to be able to join *)
                  //dummy := Print('at %d/%d can not join in this cycle', iRow, i);
                  bJoinOK := FALSE;
               END_IF;
                  
               iJoinsInLine := iJoinsInLine + 1;
               
               IF (odcParallelInfo[k].iRow <> iRow) AND odcParallelInfo[k].bColumnActive THEN
                  (* one branch not waiting at join point *)
                  bJoinOK := FALSE;
               ELSE
                  bNewSkipAlreadyPosReached := bNewSkipAlreadyPosReached AND odcParallelInfo[k].bSkipAlreadyPosReached;
               END_IF;
            END_IF; // sv_ODCSequence[k][iRow].iMoveId = cMoveEndParallel
         END_FOR;
         
         IF bJoinOK THEN
            (* join conditions OK -> deactivate all columns to the right *)
            bIncreaseRow := TRUE;
            odcParallelInfo[i].bSkipAlreadyPosReached := bNewSkipAlreadyPosReached;
            
            FOR k := 1 TO sv_iUsedColumns DO
               IF k <> i AND sv_ODCSequence[k][iRow].iMoveId = cMoveEndParallel THEN
                  fbSetStepState.StepPos.iRow := iRow;
                  fbSetStepState.StepPos.iColumn := k;
                  fbSetStepState(StepState := nStateReady);
                  (* found a join point on the same row -> we are able to join execution
                  left most branch remains active, right one is disabled *)
                  odcParallelInfo[k].bColumnActive := FALSE;
                  fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iRow), '/', DINT_TO_STRING(i),
                                                        ' join movement -> deactivating column ', DINT_TO_STRING(k)));

               END_IF;
            END_FOR;
         END_IF;
      ELSIF (MoveId = cMoveEndParallelOpen) THEN       
         //endparallelOpen found => check movements and deactivate column and increase row if conditions are ok         
         //search according EP open in this row and check it
         bAllParallelOpenColumnsReady := TRUE;
         FOR k := 2 TO sv_iUsedColumns DO
            IF sv_ODCSequence[k][iRow].iMoveId = cMoveEndParallelOpen THEN
               //check if this column is still active
               IF NOT odcParallelInfo[k].bColumnActive THEN
                  //column is not active (first cycle is active or all parallel open movements are done)
                  //reset step states of all elements in this column (beginning from actual line)
                  FOR iTmpRow := iRow TO miEndRow DO
                     fbSetStepState.StepPos.iColumn := k;
                     fbSetStepState.StepPos.iRow := iTmpRow;
                     fbSetStepState(StepState := nStateDefault);
                  END_FOR;                 
               ELSE
                  bAllParallelOpenColumnsReady := FALSE;
               END_IF;        
            END_IF;
         END_FOR;
         
         IF bAllParallelOpenColumnsReady THEN
            fbDebugTrace2(nODCInterpreter, CONCAT('found fulfilled EndParallelOpen in column ',
                                                 DINT_TO_STRING(i),' -> increase row'));
            bIncreaseRow := TRUE;
         END_IF;
         
      ELSIF (MoveId  = cMoveNone) AND (MoveDir = cMoveNone) AND (DeviceId.CompId = cCompNone) THEN
         bIncreaseRow := TRUE;
         fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iRow), '/',
                                               DINT_TO_STRING(i), ' empty movement'));
   
      ELSIF MoveId = cMoveBeginSequence OR MoveId = cMoveEndSequence THEN
         (* skip begin/end sequence markers *)
         bIncreaseRow := TRUE;
         
      ELSIF MoveId = cMoveStartCondition THEN
         (* start condition *)
         aCheckStartConditionReached(iInstance := sv_ODCSequenceInt[i][iRow].iCount);
         
         //check safety array of startcondition as long as start condition is not reached
         IF NOT aCheckStartConditionReached.bReached THEN
            abODCCheckDependencies.aCheck.StepPos.iColumn := i;
            abODCCheckDependencies.aCheck.StepPos.iRow := iRow;
            
            abODCCheckDependencies.aCheck(DeviceIdSelf := DeviceId);
            IF NOT abODCCheckDependencies.aCheck.bAllowed THEN
               fbDebugTrace2(nODCInterpreter, CONCAT('start condition at pos ', DINT_TO_STRING(iRow),
                                                     '/', DINT_TO_STRING(i),
                                                     ' not allowed by safety calculation'));
               aStopInterpreterError();
            END_IF;   
         END_IF;
         
         bIncreaseRow := aCheckStartConditionReached.bReached;
         
      ELSIF MoveId = cMoveCheckCondition THEN
         (* check condition *)
         aCheckConditionSupervision(iInstance := sv_ODCSequenceInt[i][iRow].iCount);
         bIncreaseRow := aCheckConditionSupervision.bContinue; 
      
      ELSIF (MoveId = cMoveIf) OR (MoveId = cMoveElse) THEN
         (* if or else *)
         aCheckIfCondition(iInstance := sv_ODCSequenceInt[i][iRow].iCount);         
         bIncreaseRow := TRUE;
         IF MoveId = cMoveIf THEN
            //programmed "if"
            bGoToEndIf := NOT aCheckIfCondition.bConditionOk;
         ELSE
            //programmed "else"
            bGoToEndIf := aCheckIfCondition.bConditionOk;
         END_IF;
      ELSIF (MoveId = cMoveBeginLoop) THEN
         //check loop condition
         iInstance := sv_ODCSequenceInt[i][iRow].iCount;
         aCheckLoopCondition(iInstance := iInstance);
         IF aCheckLoopCondition.bConditionOk THEN
            //leave the loop
            bGoToEndLoop := TRUE;
            bIncreaseRow := TRUE;
         ELSE
            //increase loop counter and go to next step
            mLoopHelpData[iInstance].iActCount := mLoopHelpData[iInstance].iActCount + 1;
            bGoToEndLoop := FALSE;
            bIncreaseRow := TRUE;
         END_IF;
      ELSIF (MoveId = cMoveEndLoop) THEN
         iInstance := sv_ODCSequenceInt[i][iRow].iCount;
         aCheckLoopCondition(iInstance := iInstance);
         IF NOT aCheckLoopCondition.bConditionOk AND NOT mbStepMode THEN
            //condition not ok -> go back to start of the loop
            //in step mode the loop is only executed once!
            bGoToBeginLoop := TRUE;
         ELSE
            //reset loop counter
            mLoopHelpData[iInstance].iActCount := 0;
            bGoToBeginLoop := FALSE;
         END_IF;
                 
         bIncreaseRow := TRUE;   
      ELSE
         // "normal movement"         
         (* Flags:
            bIsWaitStep           -> do not start, wait for pos reached
            NOT pbActivated       -> completely skip movement (do not start, do not wait)(checked once when step is activated)
            bContinueWithoutReady -> start, do not wait for ready/pos reached *)          
         
         MoveData := sv_MovementsAvailable[sv_ODCSequenceInt[i][iRow].iMoveNumber].pMovementData;
         
         //check if device/movement is activated
         IF NOT odcParallelInfo[i].bActivatedChecked THEN           
            aCheckActivated(DeviceId := DeviceId,
                            MoveData := MoveData^);
            
            odcParallelInfo[i].bActivated := aCheckActivated.bActivated;
            odcParallelInfo[i].bActivatedChecked := TRUE;
                       
            IF NOT odcParallelInfo[i].bActivated THEN
               //step not activated -> go to next line
               bIncreaseRow := TRUE;
            END_IF;
            
            //check if array with PosReached information is available (for instanceabale movements)
            odcParallelInfo[i].bPosReachedArrayLinked := CHECK_REF(MoveData^.InstanceData.pPosReachedArray^);
            odcParallelInfo[i].bMovementReadyArrayLinked := CHECK_REF(MoveData^.InstanceData.pMovementReadyArray^);
         END_IF; //bActivatedChecked
            
         IF odcParallelInfo[i].bActivated THEN
            (* step is activated *)
            IF odcParallelInfo[i].bSkipAlreadyPosReached THEN
               (* This flag is propagated to new parallel branches
                  and joined (AND) on end of parallel branch
                  Value TRUE:
                  We first check for pos reached
                  - Pos reached: go to the next step
                  - Pos not reached: start movement like we normally do and reset the flag
                    for the current branch
                  Value FALSE:
                  We act normally and start the movement *)
               
               IF odcParallelInfo[i].bPosReachedArrayLinked THEN
                  iInstance := sv_ODCSequenceInt[i][iRow].iCount;
                  IF MoveData^.InstanceData.pPosReachedArray^[iInstance] THEN
                     bIncreaseRow := TRUE;
                  END_IF;
               ELSE
                  fbCheckPosReached(DeviceId := DeviceId,
                                 MoveDir  := MoveDir,
                                 MoveId   := MoveId);
                  IF fbCheckPosReached.bPosReached THEN
                     bIncreaseRow := TRUE;
                  END_IF;
               END_IF;
               
               IF bIncreaseRow THEN
                  fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iRow), '/',
                                          DINT_TO_STRING(i), ' skipping movement ',
                                          DINT_TO_STRING(DeviceId.CompId), '.',
                                          DINT_TO_STRING(DeviceId.IndexId), ' ',
                                          DINT_TO_STRING(MoveId), '/',
                                          DINT_TO_STRING(MoveDir), ' pos:',
                                          DINT_TO_STRING(sv_ODCSequenceInt[i][iRow].iCount),
                                          ' because it already has PosReached TRUE'));
               ELSE
                  (* pos not reached -> start the movement
                  and continue normal execution from here *)
                  fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iRow), '/',
                                    DINT_TO_STRING(i), ' disable skipping PosReached movements ',
                                    DINT_TO_STRING(DeviceId.CompId), '.',
                                    DINT_TO_STRING(DeviceId.IndexId), ' ',
                                    DINT_TO_STRING(MoveId), '/',
                                    DINT_TO_STRING(MoveDir), ' pos:',
                                    DINT_TO_STRING(sv_ODCSequenceInt[i][iRow].iCount),
                                    ' because it has PosReached FALSE'));
                  odcParallelInfo[i].bSkipAlreadyPosReached := FALSE;
               END_IF;
                          
            END_IF;
            
            (* start the movement *)
            IF odcParallelInfo[i].bSkipAlreadyPosReached THEN
               (* bSkipAlreadyPosReached is still set -> the current movement already has PosReached TRUE *)
               (* -> we do not need to start it *)
               ;
            ELSIF MoveData^.bIsWaitStep THEN
               (* do not start movement, just wait for pos reached *)
               odcParallelInfo[i].bStartSent := TRUE;
            
            ELSIF NOT odcParallelInfo[i].bStartSent THEN
               bConditionLinked := CHECK_REF(MoveData^.pbStartConditionReached^);
               IF (bConditionLinked AND MoveData^.pbStartConditionReached^) OR NOT bConditionLinked THEN
                  // pbStartConditionReached reached or not linked -> start movement
                  
                  fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iRow), '/',
                                                         DINT_TO_STRING(i), ' checking dependencies for movement ',
                                                         DINT_TO_STRING(DeviceId.CompId), '.',
                                                         DINT_TO_STRING(DeviceId.IndexId), ' ',
                                                         DINT_TO_STRING(MoveId), '/',
                                                         DINT_TO_STRING(MoveDir)));
                  
                  abODCCheckDependencies.aCheck.StepPos.iColumn := i;
                  abODCCheckDependencies.aCheck.StepPos.iRow := iRow;
                  
                  abODCCheckDependencies.aCheck(DeviceIdSelf := DeviceId);
                  IF NOT abODCCheckDependencies.aCheck.bAllowed THEN
                     (* evCheckLocklist makes sure other alarms(caused by FBLockUnlock for this movement are also set *)
                     evCheckLocklistEventData.DeviceId := DeviceId;
                     evCheckLocklistEventData.MoveId   := MoveId;
                     evCheckLocklistEventData.MoveDir  := MoveDir;
                     fbDebugTrace2(nODCInterpreter, CONCAT('movement ', DINT_TO_STRING(MoveId),
                                                           '/', DINT_TO_STRING(MoveDir),
                                                           ' not allowed by safety calculation -> sending evCheckLocklist to view all other alarms'));
                     SET_EVENT(evCheckLocklist, evCheckLocklistEventData);
                     aStopInterpreterError();
                  ELSE // NOT abODCCheckDependencies.aCheck.bAllowed
                     (* dependencies OK *)
                     fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iRow), '/',
                                                            DINT_TO_STRING(i), ' starting movement ',
                                                            DINT_TO_STRING(DeviceId.CompId), '.',
                                                            DINT_TO_STRING(DeviceId.IndexId), ' ',
                                                            DINT_TO_STRING(MoveId), '/',
                                                            DINT_TO_STRING(MoveDir), ' ',
                                                            DINT_TO_STRING(sv_ODCSequenceInt[i][iRow].iCount)));
                    
                     aAddStartedManualMovement.StepPos.iColumn := i;
                     aAddStartedManualMovement.StepPos.iRow := iRow;
                     aAddStartedManualMovement(DeviceId := DeviceId,
                                                MoveId   := MoveId,
                                                MoveDir  := MoveDir,
                                                iInstance := sv_ODCSequenceInt[i][iRow].iCount);
                        
                        (* try to start the movement *)
                     IF aAddStartedManualMovement.bOK THEN
                        odcParallelInfo[i].bStartSent := TRUE;
                        
                        //save time when start event was sent
                        odcParallelInfo[i].dStartTime := fbRTC.CDT;
                     
                        fbStart(DeviceId := DeviceId,
                                 MoveDir  := MoveDir,
                                 MoveId   := MoveId,
                                 IntermediateCond := sv_ODCSequenceInt[i][iRow].iCount);
                     ELSE
                        aStopInterpreterError();
                     END_IF;
                  END_IF; // NOT fbODCCheckDependencies.bAllowed
                  
                  
               ELSE // (bConditionLinked AND MoveData^.pbStartConditionReached^) OR NOT bConditionLinked
                  IF NOT odcParallelInfo[i].bStartConditionWarnPrinted THEN
                     IF sv_TraceLevel.bODCInterpreter THEN
                        dummy := Print('at pos:%d/%d waiting for pbStartConditionReached before starting movement %d.%d %d/%d',
                                    iRow, i, DeviceId.CompId, DeviceId.IndexId, MoveId, MoveDir);
                     END_IF;
                     odcParallelInfo[i].bStartConditionWarnPrinted := TRUE;
                  END_IF;
               END_IF; // pbStartConditionReached^  
            END_IF; // NOT odcParallelInfo[i].bStartSent

            (* now wait for the movement to finish *)
            IF odcParallelInfo[i].bSkipAlreadyPosReached THEN
               ;            
            ELSIF MoveData^.bIsWaitStep THEN
               (* movement was never started, only wait for pos reached, not for ready
                  otherwise we have a problem when we wait for a certain pos reached
                  but we are still moving to another position
                  (example: mold close, wait for intermediate pos) *)
               IF odcParallelInfo[i].bPosReachedArrayLinked THEN
                  iInstance := sv_ODCSequenceInt[i][iRow].iCount;
                  bIncreaseRow := MoveData^.InstanceData.pPosReachedArray^[iInstance];
               ELSE               
                  fbCheckPosReached(DeviceId := DeviceId,
                                    MoveDir  := MoveDir,
                                    MoveId   := MoveId);
                  IF fbCheckPosReached.bPosReached THEN
                     bIncreaseRow := TRUE;
                  END_IF;
               END_IF;
               
            ELSIF odcParallelInfo[i].bStartSent THEN
               (* start event was sent -> we can now wait for the movement to finish *)
               IF MoveData^.bContinueWithoutReady THEN
                  (* do not wait for the movement to finish, continue immediately
                     useful for air valves *)
                  bIncreaseRow := TRUE;
               ELSE   
                  (* normal movement
                     check if the movement is finished(ready),
                     and if pos is reached(when the movement has a pos reached variable) *)
                  IF MoveData^.bInstanceable AND odcParallelInfo[i].bMovementReadyArrayLinked THEN
                     iInstance := sv_ODCSequenceInt[i][iRow].iCount;
                     bMovementReady := MoveData^.InstanceData.pMovementReadyArray^[iInstance];
                  ELSE
                     fbCheckReady(DeviceId := DeviceId);
                     bMovementReady := fbCheckReady.bReady;
                  END_IF;
                  
                  IF bMovementReady THEN
                     aCheckPosReached(DeviceId := DeviceId,
                                      MoveId := MoveId,
                                      MoveDir := MoveDir,
                                      iColumn := i,
                                      iRow := iRow);
                     
                     IF aCheckPosReached.bPosReachedOk THEN
                        // everything ok -> correct duration and go to next row
                        aCorrectDuration(pMoveData := MoveData,
                                         iColumn := i,
                                         DeviceId := DeviceId);
                     
                        bIncreaseRow := TRUE;
                     END_IF;
                     
                  END_IF; // check ready
               END_IF; // MoveData^.bContinueWithoutReady
            END_IF; // start condition reached
         END_IF; // step activated
      END_IF; //movement ID
    
      IF bIncreaseRow THEN
         // set step state to Ready
         IF sv_ODCSequenceInt[i][odcParallelInfo[i].iRow].StepState <> nStateError THEN
            // do not reset steps with error flag
            IF NOT CHECK_REF(MoveData^) OR NOT MoveData^.bContinueWithoutReady THEN
               fbSetStepState.StepPos.iRow := odcParallelInfo[i].iRow;
               fbSetStepState.StepPos.iColumn := i;         
               fbSetStepState(StepState := nStateReady);
            END_IF;           
         END_IF;         
         
         IF bGoToEndIf THEN
            aGoToEndIf(iColumn := i);
         ELSIF bGoToBeginLoop THEN
            bGoToBeginLoop := FALSE;
            aGoToBeginLoop(iColumn := i, iInstance := sv_ODCSequenceInt[i][iRow].iCount);            
         ELSIF bGoToEndLoop THEN
            bGoToEndLoop := FALSE;
            aGoToEndLoop(iColumn := i, iInstance := sv_ODCSequenceInt[i][iRow].iCount);
         ELSE
            aIncreaseRow(iColumn := i, iEndRow := miEndRow);
         END_IF;        
      END_IF;
   END_IF; //odcParallelInfo[i].bColumnActive
END_FOR;

//interesting for HMI to see state of the interpreter
sv_InterpreterParallelInfo := odcParallelInfo;




;#END_EDIT_BLOCK END_ALGORITHM

(*
Search a Movement in the ODC array by DeviceId, MoveId and MovedDir
and return the position in the array.

If bAllowNonMatchingId is TRUE only DeviceId and MoveDir need to match.
But it still tries to get the best match(MoveId equals)

If IntermediateCond is <> 0, it is also checked against iCount when checking for exact match.

When a movement is found bFound is TRUE and StepPos contains the position
of the movement in the ODC array
*)

ALGORITHM aFindLabel


VAR_INPUT
 DeviceId : tsDeviceId (* DeviceId of the movement to search for *);
 MoveId : tMoveIdent (* MoveId of the movement to search for *);
 MoveDir : tMoveIdent (* MoveDir of the movement to search for *);
 IntermediateCond : DINT (* Intermediate condition to search for *);
 bAllowNonMatchingId : BOOL (* Also return a match if MoveId is different *);
 SearchStartPos : tsODCStepPos (* startposition for searching *);
END_VAR

VAR_OUTPUT
 StepPos : tsODCStepPos (* Position in ODC array wher the movement was found *);
 bFound : BOOL (* TRUE if a movement was found *);
END_VAR

VAR_TEMP
 iTmpRow : DINT;
 iTmpColumn : DINT;
 iSearchColumn : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bFound := FALSE;
StepPos.iColumn := 0;
StepPos.iRow := 0;

FOR iTmpRow := SearchStartPos.iRow TO sv_iUsedRows DO
   
   IF iTmpRow = SearchStartPos.iRow THEN
      //start searching in the given column
      iSearchColumn := SearchStartPos.iColumn;
   ELSE
      //start searching in the first column
      iSearchColumn := 1;
   END_IF;
   
   FOR iTmpColumn := iSearchColumn TO sv_iUsedColumns DO
      IF sv_ODCSequence[iTmpColumn][iTmpRow].iCompId = DeviceId.CompId AND
         INT_TO_DINT(sv_ODCSequence[iTmpColumn][iTmpRow].iIndexId) = DeviceId.IndexId THEN
         IF sv_ODCSequence[iTmpColumn][iTmpRow].iMoveId = MoveId AND
            sv_ODCSequence[iTmpColumn][iTmpRow].iMoveDir = MoveDir AND 
            (IntermediateCond = 0 OR // do not care about intermediate condion if we don't search for it?
                                     // FIXME check flag in MoveData instead?? 
             INT_TO_DINT(sv_ODCSequence[iTmpColumn][iTmpRow].iCount) = IntermediateCond) THEN
            fbDebugTrace2(nODCInterpreter, CONCAT('found exact match of MoveId ',
                                                  DINT_TO_STRING(DeviceId.CompId),
                                                  '.',
                                                  DINT_TO_STRING(DeviceId.IndexId),
                                                  ' ',
                                                  DINT_TO_STRING(MoveId),
                                                  '/',
                                                  DINT_TO_STRING(MoveDir),
                                                  ' ',
                                                  DINT_TO_STRING(IntermediateCond),
                                                  ' at pos:',
                                                  DINT_TO_STRING(iTmpRow),
                                                  '/',
                                                  DINT_TO_STRING(iTmpColumn)));

            StepPos.iColumn := iTmpColumn;
            StepPos.iRow := iTmpRow;
            bFound := TRUE;
            RETURN;
               
         ELSIF bAllowNonMatchingId AND sv_ODCSequence[iTmpColumn][iTmpRow].iMoveDir = MoveDir THEN
            fbDebugTrace2(nODCInterpreter, CONCAT('found NON exact match of MoveId ',
                                                  DINT_TO_STRING(DeviceId.CompId),
                                                  '.',
                                                  DINT_TO_STRING(DeviceId.IndexId),
                                                  ' ',
                                                  DINT_TO_STRING(MoveId),
                                                  '/',
                                                  DINT_TO_STRING(MoveDir),
                                                  ' ',
                                                  DINT_TO_STRING(IntermediateCond),
                                                  ' at pos:',
                                                  DINT_TO_STRING(iTmpRow),
                                                  '/',
                                                  DINT_TO_STRING(iTmpColumn)));
            StepPos.iColumn := iTmpColumn;
            StepPos.iRow := iTmpRow;
            bFound := TRUE;
         END_IF;    
      END_IF;
   END_FOR;
END_FOR;

IF NOT bFound THEN
   fbDebugTrace2(nODCInterpreter, CONCAT('movement ',
                                          DINT_TO_STRING(DeviceId.CompId),
                                          '.',
                                          DINT_TO_STRING(DeviceId.IndexId),
                                          ' ',
                                          DINT_TO_STRING(MoveId),
                                          '/',
                                          DINT_TO_STRING(MoveDir),
                                          ' ',
                                          DINT_TO_STRING(IntermediateCond),
                                          ' not found in auto cycle'));
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Notify the Interpreter that the array has been reinitialized
(this clears the fatal error flag)
*)

ALGORITHM aSetInitOK


VAR
 DeviceIdAll : tsDeviceId;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbFatalError THEN
   mbFatalError := FALSE;

   (* unlock all movements locked by aStopInterpreterInternal *)
   DeviceIdAll.CompId := cCompAll;
   DeviceIdAll.IndexId := cAllDevIndex;
   
   fbLockUnlock(DeviceId := DeviceIdAll,
               MoveDir  := cMoveAll,
               MoveId   := cMoveAll,
               Mode     := nUnlock);
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Actual status of the interpreter.
*)

ALGORITHM aStatus


VAR_OUTPUT
 bActive : BOOL (* Interpreter is currently executing a ODC array *);
 bError : BOOL (* Interpreter is stopped, because a error happened during interpreting *);
 bFinished : BOOL (* Interpreter is stopped, because it reached the end of the array *);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bError := mbFatalError OR mbNormalError;
bFinished := mbFinished;
bActive := mbActive;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aInterruptSequence


VAR_TEMP
 i : DINT;
END_VAR

VAR
 StartedMovements : tsStartedMoveDataODCExtended;
 fbStop : FBStop;
 iMoveNr : DINT;
 fbGetMoveNumber : FBGetMoveNumber;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbStepMode := TRUE;

//stop started movements
StartedMovements := sv_StartedManualMovements;
FOR i := 1 TO StartedMovements.iStartedMovements DO
   
   //get move number
   fbGetMoveNumber(DeviceId := StartedMovements.MoveData[i].DeviceId,
                   MoveId := StartedMovements.MoveData[i].MoveId,
                   MoveDir := StartedMovements.MoveData[i].MoveDir,
                   iMoveNumber => iMoveNr);
   
   IF NOT sv_MovementsAvailable[iMoveNr].pMovementData^.bFinishAtInterrupt THEN
      //stop movement
      fbStop(DeviceId := StartedMovements.MoveData[i].DeviceId);
   ELSE
      //movement should finish
      //increase number of active row because otherwise this movement is started
      //again when stepping fwd
      aIncreaseRow(iColumn := StartedMovements.MoveData[i].StepPos.iColumn,
                   iEndRow := miEndRow);
   END_IF;
   
END_FOR;

//disable steps
FOR i := 1 TO cMaxParallelMovements DO
   IF odcParallelInfo[i].bColumnActive THEN
      odcParallelInfo[i].bDisabled := TRUE;
   END_IF;     
END_FOR;

mbActive := FALSE;

sv_InterpreterParallelInfo := odcParallelInfo;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aContinueSequence


VAR_TEMP
 i : DINT;
END_VAR

VAR
 fbSetStepState : FBSetStepState;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//reset relevant flags
FOR i := 1 TO cMaxParallelMovements DO
   IF odcParallelInfo[i].bColumnActive THEN
      odcParallelInfo[i].bStartSent := FALSE;
      odcParallelInfo[i].bStartConditionWarnPrinted := FALSE;
      odcParallelInfo[i].bActivatedChecked := FALSE;
      odcParallelInfo[i].bDisabled := FALSE;
   
      //set step state to "active"
      fbSetStepState.StepPos.iColumn := i;
      fbSetStepState.StepPos.iRow := odcParallelInfo[i].iRow;
      fbSetStepState(StepState := nStateActive);
   END_IF;
     
END_FOR;

mbActive := TRUE;
mbStepMode := FALSE;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aEnableNextStep


VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//enable steps
FOR i := 1 TO cMaxParallelMovements DO
   IF odcParallelInfo[i].bColumnActive THEN
      odcParallelInfo[i].bDisabled := FALSE;
      odcParallelInfo[i].bStartSent := FALSE;
      odcParallelInfo[i].bStartConditionWarnPrinted := FALSE;
      odcParallelInfo[i].bActivatedChecked := FALSE;
      
      //set step state to "active"
      fbSetStepState.StepPos.iColumn := i;
      fbSetStepState.StepPos.iRow := odcParallelInfo[i].iRow;
      fbSetStepState(StepState := nStateActive);
   END_IF;
     
END_FOR;

mbActive := TRUE;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aResetStepMode

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbStepMode := FALSE;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aDecreaseRow


VAR_INPUT
 bStartInActualLine : BOOL (* TRUE: start in actual line; FALSE: start in (actual line - 1) *);
 iColumn : DINT;
 iEndRow : DINT;
END_VAR

VAR_OUTPUT
 iNewActivatedColumn : DINT;
END_VAR

VAR_TEMP
 iTmpLine : DINT;
 iTmpColumn : DINT;
 x : DINT;
 iLine : DINT;
END_VAR

VAR
 iMoveId : tMoveIdent;
 fbSetStepState : FBSetStepState;
 bParallelTreeReady : BOOL;
 bOk : BOOL;
 bContinueDecreasing : BOOL;
 iStartRow : DINT;
 iCount : INT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF bStartInActualLine THEN
   iStartRow := odcParallelInfo[iColumn].iRow;
ELSE
   iStartRow := (odcParallelInfo[iColumn].iRow - 1);
END_IF;

//reset step state of actually active step
fbSetStepState.StepPos.iColumn := iColumn;
fbSetStepState.StepPos.iRow := odcParallelInfo[iColumn].iRow;
fbSetStepState(StepState := nStateDefault); 

iNewActivatedColumn := 0;

//get next line with a "real" movement
FOR iTmpLine := iStartRow TO iEndRow BY -1 DO
   fbDebugTrace2(nODCInterpreter, CONCAT('decreasing IP of column ', DINT_TO_STRING(iColumn),
                                         ' to ', DINT_TO_STRING(iTmpLine)));
   
   iMoveId := sv_ODCSequence[iColumn][iTmpLine].iMoveId;
   
   IF (iMoveId = cMoveEndIf) THEN
      // end_if => check if this "if" instance is active or already completely executed
      iCount := sv_ODCSequence[iColumn][iTmpLine].iCount;
      IF (mIFConditionHelpData[iCount].iInternalCount < 2) THEN
         //if or else tree is active
         //set active line in this column to begin of this "if" or "else"
         //so that stepping bwd can continue before this "if / else"         
         FOR iLine := (iTmpLine - 1) TO 1 BY -1 DO
            IF ((sv_ODCSequence[iColumn][iLine].iMoveId = cMoveIf) OR (sv_ODCSequence[iColumn][iLine].iMoveId = cMoveElse)) AND
               (sv_ODCSequence[iColumn][iLine].iCount = iCount) THEN                              
               odcParallelInfo[iColumn].iRow := (iLine - 1);  //set row to "start parallel" step            
               EXIT;
            END_IF;   
         END_FOR;
         mIFConditionHelpData[iCount].iInternalCount := (mIFConditionHelpData[iCount].iInternalCount - 1);
      ELSE
         //condition completely executed -> do not allow stepping into
         odcParallelInfo[iColumn].iRow := (iTmpLine + 1); //set row to "end parallel" step
         odcParallelInfo[iColumn].bDisabled := TRUE;
         SET_ALARM(Name := erNoStepBwdIntoCondition);
      END_IF;
            
      EXIT;
   ELSIF (iMoveId = cMoveEndLoop) THEN   
      // end loop => stop stepping bwd here
      odcParallelInfo[iColumn].iRow := iTmpLine; //set row to "end loop" step
      odcParallelInfo[iColumn].bDisabled := TRUE;
      SET_ALARM(Name := erNoStepBwdIntoLoop);
      EXIT;
   ELSIF (iMoveId = cMoveBeginLoop) THEN
      // begin of loop => stop stepping bwd here (do not modify line number) 
      odcParallelInfo[iColumn].bDisabled := TRUE;
      SET_ALARM(Name := erNoStepBwdOutOfLoop);
      EXIT;   
   ELSIF (iMoveId = cMoveBeginSequence) OR (iMoveId = cMoveEndSequence) THEN
      ; // begin or end sequence
   ELSIF (iMoveId = cMoveNone) OR (iMoveId = cMoveBeginGroup) OR (iMoveId = cMoveEndGroup) THEN
      ; //empty step or begin group / end group   
   ELSIF (iMoveId = cMoveIf) OR (iMoveId = cMoveElse) THEN  
      ; //if , else
   ELSIF iMoveId = cMoveEndParallelOpen THEN
      ; //no special action necessary   
   ELSIF iMoveId = cMoveEndParallel THEN
      //get according column and activate it
      FOR iTmpColumn := (iColumn + 1) TO sv_iUsedColumns DO
         IF sv_ODCSequence[iTmpColumn][iTmpLine].iMoveId = cMoveEndParallel THEN
            odcParallelInfo[iTmpColumn].bColumnActive := TRUE;
            odcParallelInfo[iTmpColumn].iRow := (iTmpLine + 1); //necessary to handle more end parallel in one line
            odcParallelInfo[iTmpColumn].bDisabled := TRUE;
            iNewActivatedColumn := iTmpColumn;
            EXIT;
         END_IF;
      END_FOR;
   ELSIF (iMoveId = cMoveStartParallel) OR (iMoveId = cMoveStartParallelOpen) THEN
      bContinueDecreasing := FALSE;
      FOR iTmpColumn := 1 TO sv_iUsedColumns DO
         IF (sv_ODCSequence[iTmpColumn][iTmpLine].iMoveId = cMoveStartParallel) OR
            (sv_ODCSequence[iTmpColumn][iTmpLine].iMoveId = cMoveStartParallelOpen) THEN
            
            //start parallel or start parallel open found
            IF iTmpColumn < iColumn THEN
               //SP left to actual column found
               //-> deactivate actual column and set line number
               odcParallelInfo[iColumn].iRow := iTmpLine;
               odcParallelInfo[iColumn].bDisabled := FALSE;
               odcParallelInfo[iColumn].bColumnActive := FALSE;
               IF sv_TraceLevel.bODCInterpreter THEN
                  dummy := Print('aDecreaseRow: deactivate column %d ',iColumn);
               END_IF;
            ELSE
               //SP is the most left one in this line
               //-> all SP to the right must be deactivated and their active row must be equal            
               bOk := TRUE;
               FOR x := (iTmpColumn + 1) TO sv_iUsedColumns DO
                  //only consider SP entries
                  IF (sv_ODCSequence[x][iTmpLine].iMoveId = cMoveStartParallel) OR
                     (sv_ODCSequence[x][iTmpLine].iMoveId = cMoveStartParallelOpen) THEN
                     bParallelTreeReady := NOT odcParallelInfo[x].bColumnActive AND (odcParallelInfo[x].iRow = iTmpLine);
                     bOk := bOk AND bParallelTreeReady;
                  END_IF;                  
               END_FOR;
               
               IF bOk THEN
                  //all parallel trees ready -> decrease line of this column so that it can continue
                  bContinueDecreasing := TRUE;
               ELSE                  
                  //column still active -> wait in this line
                  odcParallelInfo[iColumn].iRow := iTmpLine;
                  odcParallelInfo[iColumn].bDisabled := TRUE;
                  bContinueDecreasing := FALSE;
               END_IF;
            END_IF;
            
            EXIT; //exit inner loop
         END_IF;
      END_FOR; 
     
      IF NOT bContinueDecreasing THEN
         EXIT;  // exit outer loop
      END_IF;
   ELSE   
      //valid step found -> set line number and disable this step
      IF sv_TraceLevel.bODCInterpreter THEN
         dummy := Print('///////// set active row of column %d to %d ////////////',iColumn, iTmpLine);
      END_IF;
      odcParallelInfo[iColumn].iRow := iTmpLine;
      odcParallelInfo[iColumn].bDisabled := TRUE;      
      EXIT;
   END_IF;
END_FOR;

odcParallelInfo[iColumn].bStartSent := FALSE;
odcParallelInfo[iColumn].bStartConditionWarnPrinted := FALSE;
odcParallelInfo[iColumn].bActivatedChecked := FALSE;
odcParallelInfo[iColumn].bPosReachedArrayLinked := FALSE;
odcParallelInfo[iColumn].bMovementReadyArrayLinked := FALSE;

sv_InterpreterParallelInfo[iColumn] := odcParallelInfo[iColumn];


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 96 @Pou 25 
@@@BEG_Comment@@@
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".
@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
4 
@Var @RT(9)CHECK_REF @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)SET_EVENT @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)SET_ALARM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)RESET_ALARM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
25 
@Var @RT(21)cMaxParallelMovements @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(1)6 @RT(62)maximum number of columns in odc array (<=cMaxActiveMovements) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)cMaxODCSteps @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)100 @RT(35)maximum number of rows in odc array 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)cMoveNone @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(13)cMinMoveIdent @RT(4)None 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)cMoveStartParallel @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)45 @RT(34)dummy movement for "StartParallel" 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)cCompEjector @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)102 @RT(17)Component Ejector 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(24)cCompCentralCoordination @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)106 @RT(29)Component CentralCoordination 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)cCompAirValve @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)118 @RT(19)Component Air Valve 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveFwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)12 @RT(16)movement forward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)cMoveStart @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)19 @RT(19)start (eg Airvalve) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveBwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)11 @RT(17)movement backward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)cMoveShake @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)18 @RT(51)shaking movement (for example ejector vibrate mode) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)cMoveEndParallel @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)46 @RT(32)dummy movement for "EndParallel" 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)cMoveEndSequence @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)44 @RT(36)dummy movement for end of a sequence 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cCompODC @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)136 @RT(13)Component ODC 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)cCompNone @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(10)cMinCompId @RT(4)None 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)cMinCompId @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)100 @RT(21)minimum Component ID  
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)cMaxCompId @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)250 @RT(21)maximum Component ID  
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)cMaxDeviceIndex @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)10 @RT(39)maximum number of devices per component 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)cMinMoveIdent @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(32)lower limit for MoveId / MoveDir 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)cMaxMoveIdent @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)600 @RT(32)upper limit for MoveId / MoveDir 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)cMoveIf @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(1)2 @RT(2)IF 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)cMoveElse @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(4)ELSE 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(22)cMoveStartParallelOpen @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(1)9 @RT(17)StartParallelOpen 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)cMoveEndParallelOpen @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)10 @RT(15)EndParallelOpen 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveAll @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)100 @RT(32)all movements (for evLockUnlock) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(13)ABInterpreter @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
45 
@Var @RT(12)fbLockUnlock @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBLockUnlock @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbDebugTrace @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBDebugTrace @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)fbDebugTrace2 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)FBDebugTrace2 @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)fbSetStepState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)FBSetStepState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)sv_ODCSequence @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)KODC_Sequence @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_ODCSequenceInt @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)tyODCSequenceInternal @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_MovementsAvailable @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tyMovementRegisterList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_InterpreterParallelInfo @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tyODCParallelInfo @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)evCheckLocklist @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(16)tevCheckLocklist @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(15)odcParallelInfo @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tyODCParallelInfo @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)miEndRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(25)where ODC stops executing @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)mbFatalError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(49)there was some error, interpreting is not allowed @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mbNormalError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(49)there was some error, interpreting is not allowed @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)mbActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)mbFinished @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(29)sv_StartConditionInstanceData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(23)tyStartCondInstanceData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(50)list with start condition params for all instances @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_ODCDeviceMovements @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(23)tsODCDeviceMovementList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(29)sv_CheckConditionInstanceData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(23)tyCheckCondInstanceData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(50)list with check condition params for all instances @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)erMovementNotAvailable @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(18)mCheckCondHelpData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tyCheckCondHelpData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(26)erWaitingForCheckCondition @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)sv_bFALSE @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)erCompNotInCorrectPosition @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(13)sv_TraceLevel @RT(0) @T @T @DERIVED 0 @F @RT(12)tsTraceLevel @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_iUsedColumns @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_iUsedRows @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_OperationMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnOperationMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(5)fbRTC @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)RTC @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(29)sv_iDurationUpdateInTolerance @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_rMoveDurationTolerance @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_ConditionParameter @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tyIFConditionData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LoopParameter @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tyLoopData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(39)array with data of all programmed loops @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)mIFConditionHelpData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)tyIFConditionHelpData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mLoopHelpData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)tyLoopHelpData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)sv_GroupActiveData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tsGroupActiveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)g_iAutoCycleLoopStartLine @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(23)g_iAutoCycleLoopEndLine @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(22)g_ParallelOpenHelpData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tyParallelOpenHelpData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(23)erReadyAndNotPosReached @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(25)sv_StartedManualMovements @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(28)tsStartedMoveDataODCExtended @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)mbStepMode @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(24)erNoStepBwdIntoCondition @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(19)erNoStepBwdIntoLoop @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(20)erNoStepBwdOutOfLoop @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

38 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(16)aCorrectDuration @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
11 
@Var @RT(9)pMoveData @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 2 @F @F @F @F 

@Var @RT(7)iColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)dDuration @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)dActTime @RT(0) @T @F @DT @RT(13)DATE_AND_TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)dMovementDelay @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(5)rTmp1 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)rTmp2 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)fbUpdateProperties @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(24)FBUpdateEditorProperties @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)dCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(21)aCheckConditionUnlock @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(17)aResetInterpreter @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(21)bExcludeActiveColumns @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(67)TRUE: do not reset active columns (possible with StartParallelOpen) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(24)aStopInterpreterInternal @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(12)bNormalError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)bFatalError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(22)fbStopStartedMovements @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)FBStopStartedMovements @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(28)fbStopStartedManualMovements @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(28)FBStopStartedManualMovements @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)DeviceIdAll @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(21)aStopInterpreterFatal @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(15)aCheckActivated @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
4 
@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)MoveData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)bActivated @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(8)iFuIndex @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(12)aIncreaseRow @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
8 
@Var @RT(7)iColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)iTmpLine @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(7)iEndRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(22)iStopEverythingCounter @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)k @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(6)iCount @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)fbSetStepState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)FBSetStepState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)pMoveData @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(19)aFindCheckCondition @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(8)Movement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KODC_Step @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)requested movement @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)bFound @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(44)check condition for requested movement found @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(21)aStopInterpreterError @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(22)aStopInterpreterNormal @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(20)aCheckSequenceSanity @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
8 
@Var @RT(3)bOK @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(20)Sanity checks passed @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(7)iColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(4)iRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(17)iEndParallelFound @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(19)iStartParallelFound @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(19)bAutoCycleLoopFound @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(32)autocycle loop found in sequence @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(15)iEndSequenceRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(43)line number where ODC.EndSequence was found @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(18)iNoOfStartParallel @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(47)number of "StartParallel" steps in the sequence @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(22)aClearInternalSequence @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(7)iColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(4)iRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(9)EmptyStep @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tsODCStepInternal @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(15)EmptyDependency @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tyODCDependencyArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(16)aGetMovementData @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
7 
@Var @RT(8)Movement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KODC_Step @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)Direction @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnMoveDirection @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(38)movedirection (min to max, max to min) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)prActValue @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)refto actual value of this movement @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(20)pbReferenceCondition @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)refto actual value of this movement @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)k @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(18)aGetLockUnlockData @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(9)iInstance @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(27)aInitCheckConditionHelpData @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)fbCheckPosReached @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)FBCheckPosReached @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(24)aInitIFConditionHelpData @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(5)state @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSYS_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(17)aInitLoopHelpData @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(5)state @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSYS_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(23)aCreateInternalSequence @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
20 
@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(12)iUsedColumns @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(31)maximum usage of sequence array @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(9)iUsedRows @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(31)maximum usage of sequence array @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(30)fbInterpreterFindEndOfParallel @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(30)FBInterpreterFindEndOfParallel @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)fbGetMoveNumber @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)FBGetMoveNumber @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)ParseStack @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)tyNumberParseArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)CurrentParsePos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tsNumberParseElement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)PrevPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsODCStepPos @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(46)remember prev step for filling out PosPrevStep @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)iCounter @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(32)counter for sequential numbering @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)iParseStackPointer @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)bEndLoop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)end numbering loop @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)bAddPrevNextInfo @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(53)write PosNextStep PosPrevStep variables for this step @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)m @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)k @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(7)iTmpCol @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(11)CurrentStep @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KODC_Step @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)bChanged @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(49)need to write back changed step to sv_ODCSequence @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(12)bInvalidStep @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(58)step is invalid because i has a strange movement/device ID @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(23)bContinueAfterLoopAdded @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)fbSetStepState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)FBSetStepState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(25)aAddStartedManualMovement @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
7 
@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)StepPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsODCStepPos @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)MoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)MoveDir @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)iInstance @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(3)bOK @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(22)fbStartedMovementAdder @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)FBStartedMovementAdder @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(16)aInitInterpreter @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(7)iColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(31)Column where to start execution @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(4)iRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(28)Row where to start execution @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)iEndRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(30)Column where to stop execution @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(22)bSkipAlreadyPosReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(73)Do not start movements wher PosReached is already TRUE before starting it @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(21)bExcludeActiveColumns @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(34)do not reset / init active columns @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(22)aCheckConditionsManual @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
7 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(8)Movement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KODC_Step @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)requested movement @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)bTargetValueReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bNoAlarms @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(23)TRUE: no alarms are set @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)bCheckConditionsOk @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(23)bRelevantCheckCondition @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)iConditionsNotOk @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(39)number of not fulfilled checkconditions @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(27)aCheckStartConditionReached @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
7 
@Var @RT(9)iInstance @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)instance of startcondition @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)bReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(23)start condition reached @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)prActValue @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(49)reference to actual value of the related movement @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)pbReferenceCondition @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)Direction @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnMoveDirection @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(24)max to min or min to max @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)RelatedMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KODC_Step @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)PrevRelatedMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KODC_Step @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(32)data from last call of algorithm @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(26)aCheckConditionSupervision @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
4 
@Var @RT(9)iInstance @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)instance of startcondition @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)bContinue @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(43)check condition must not be called any more @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(19)bTargetValueReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbLockUnlock @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBLockUnlock @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(16)aCheckPosReached @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
11 
@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(20)DeviceId of movement @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)MoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)MoveId of movement @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)MoveDir @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(19)MoveDir of movement @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)iColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(13)active column @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(4)iRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(10)active row @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)fbCheckPosReached @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)FBCheckPosReached @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)fbMoveDescription @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)FBMoveDescription @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)iMoveNr @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)iInstance @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)bPosNotReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)bPosReachedOk @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)posReached ok -> cycle can continue @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(17)aCheckIfCondition @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(9)iInstance @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)instance of IF - condition @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)bConditionOk @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)TRUE: condition fullfilled @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(4)var1 @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(4)var2 @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(19)aCheckLoopCondition @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(9)iInstance @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)instance of IF - condition @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)bConditionOk @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)TRUE: condition fullfilled @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(4)var1 @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(4)var2 @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(10)aGoToEndIf @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(7)iColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)iTmpLine @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(6)iCount @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(12)aGoToEndLoop @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(7)iColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)iTmpLine @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(9)iInstance @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(13)loop instance @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(14)aGoToBeginLoop @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(7)iColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)iTmpLine @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(9)iInstance @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(13)loop instance @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(10)aInterpret @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
24 
@Var @RT(7)fbStart @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(7)FBStart @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbCheckReady @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBCheckReady @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)fbCheckPosReached @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)FBCheckPosReached @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)abODCCheckDependencies @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)ABODCCheckDependencies @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(19)current step column @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)k @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(4)iRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(12)current step @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)bConditionLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)MoveDir @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)MoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(12)current step @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(12)current step @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)bIncreaseRow @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(44)increase row pointer after handling movement @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)bJoinOK @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)iJoinsInLine @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(24)evCheckLocklistEventData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tevCheckLocklistData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)MoveData @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(25)bNewSkipAlreadyPosReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)iInstance @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)bGoToEndIf @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(36)go to end_if movement in this column @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)bGoToEndLoop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)bGoToBeginLoop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)iTmpRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(14)bMovementReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(28)bAllParallelOpenColumnsReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(10)aFindLabel @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
11 
@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(38)DeviceId of the movement to search for @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)MoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(36)MoveId of the movement to search for @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)MoveDir @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(37)MoveDir of the movement to search for @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)IntermediateCond @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(36)Intermediate condition to search for @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)bAllowNonMatchingId @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(42)Also return a match if MoveId is different @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)SearchStartPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsODCStepPos @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(27)startposition for searching @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)StepPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsODCStepPos @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(49)Position in ODC array wher the movement was found @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(6)bFound @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(28)TRUE if a movement was found @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(7)iTmpRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(10)iTmpColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(13)iSearchColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(10)aSetInitOK @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(11)DeviceIdAll @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(7)aStatus @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(7)bActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(46)Interpreter is currently executing a ODC array @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(68)Interpreter is stopped, because a error happened during interpreting @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(9)bFinished @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(63)Interpreter is stopped, because it reached the end of the array @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(18)aInterruptSequence @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(16)StartedMovements @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(28)tsStartedMoveDataODCExtended @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)fbStop @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(6)FBStop @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(7)iMoveNr @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)fbGetMoveNumber @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)FBGetMoveNumber @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(17)aContinueSequence @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(14)fbSetStepState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)FBSetStepState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(15)aEnableNextStep @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(14)aResetStepMode @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(12)aDecreaseRow @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
15 
@Var @RT(18)bStartInActualLine @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(61)TRUE: start in actual line; FALSE: start in (actual line - 1) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)iColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)iTmpLine @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(7)iEndRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)iMoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)iNewActivatedColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)iTmpColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(14)fbSetStepState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)FBSetStepState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)bParallelTreeReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(3)bOk @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)x @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(19)bContinueDecreasing @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)iStartRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)iCount @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)iLine @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(61)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bInitDone THEN
   dCycleTime := GET_TASK_INTERVAL();
   bInitDone := TRUE;
END_IF;

//check duration
//get timestamp for new movement and duration of last movement
IF sv_OperationMode >= nHalfAutomatic AND CHECK_REF(pMoveData^.pdCalculatedDuration^) THEN
                  
   IF (pMoveData^.EditorData.MovementType <> nODCElementDuration) AND
      (pMoveData^.EditorData.MovementType <> nODCElementInstanceableDuration) THEN

      IF CHECK_REF (pMoveData^.pdStartDelaySet^) THEN
         dMovementDelay := pMoveData^.pdStartDelaySet^;
      ELSE
         dMovementDelay := t#0s;
      END_IF;
      
      fbRTC();
      dActTime := fbRTC.CDT;
      dDuration := dActTime - odcParallelInfo[iColumn].dStartTime - dMovementDelay;
       
      IF dDuration > t#1s THEN
         dDuration := dDuration + dCycleTime;
      END_IF; 
   
      IF (dDuration > MULTIME(pMoveData^.pdCalculatedDuration^, 1.0 + sv_rMoveDurationTolerance/100.0)) OR
         (dDuration < MULTIME(pMoveData^.pdCalculatedDuration^, 1.0 - sv_rMoveDurationTolerance/100.0)) THEN
         
         //duration out of tolerance
         IF sv_TraceLevel.bODCInterpreter THEN
            rTmp1 := LINT_TO_REAL(TIME_TO_LINT(pMoveData^.pdCalculatedDuration^))/1000000.0;
            rTmp2 := LINT_TO_REAL(TIME_TO_LINT(dDuration))/1000000.0;
            dummy := Print('correcting duration of %d.%d %d/%d from %f to %f',
                           DeviceId.CompId, DeviceId.IndexId,
                           pMoveData^.MoveDir, pMoveData^.MoveId,
                           rTmp1, rTmp2);
         END_IF; 
         
      ELSE
         //duration in tolerance
         sv_iDurationUpdateInTolerance := sv_iDurationUpdateInTolerance + 1;
      END_IF;
      
      //correct duration
      pMoveData^.pdCalculatedDuration^ := dDuration;
      
      IF pMoveData^.bInstanceable THEN
         //instanceable movement -> trigger editor update
         //for "normal" movement the update must be triggered in the according function unit
         fbUpdateProperties();
      END_IF;
   
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(19)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//unlock all movements that were locked because of a check condition
FOR i := 1 TO cMaxCheckConditions DO
   IF mCheckCondHelpData[i].bMovementLocked THEN
      fbLockUnlock(DeviceId := mCheckCondHelpData[i].LockUnlockData.DeviceId,
                   MoveDir := mCheckCondHelpData[i].LockUnlockData.MoveDir,
                   MoveId := mCheckCondHelpData[i].LockUnlockData.MoveId,
                   Alarm := mCheckCondHelpData[i].LockUnlockData.Alarm,
                   Mode := nUnlock);
      
      mCheckCondHelpData[i].bMovementLocked := FALSE;
   END_IF;
END_FOR;


@END_Body 

@@@BEG_Comment@@@ 
@TL(4)
Clear the internal ODC sequence array sv_ODCSequenceInt.
Needed when the sequence is reinitialized to make sure no remanents of a old sequence are left.

Each element in the safety array is set to cODCNoDependency
@@@END_Comment@@@ 

@BEG_Body 
@TL(37)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO sv_iUsedColumns DO
   IF (bExcludeActiveColumns AND odcParallelInfo[i].bColumnActive) THEN
      ; //do not reset active columns
   ELSE
      odcParallelInfo[i].bColumnActive := FALSE;
      odcParallelInfo[i].bStartSent := FALSE;
      odcParallelInfo[i].bStartConditionWarnPrinted := FALSE;
      odcParallelInfo[i].bSkipAlreadyPosReached := FALSE;
      odcParallelInfo[i].bActivatedChecked := FALSE;
      odcParallelInfo[i].bPosReachedArrayLinked := FALSE;
      odcParallelInfo[i].bMovementReadyArrayLinked := FALSE;
      odcParallelInfo[i].bDisabled := FALSE;
      odcParallelInfo[i].iRow := 0;
   END_IF;
END_FOR;

aCheckConditionUnlock();

//reset actual loop counters
FOR i := 1 TO cMaxLoops DO
   mLoopHelpData[i].iActCount := 0;
END_FOR;

FOR i := 1 TO cMaxIFConditions DO
   mIFConditionHelpData[i].iInternalCount := 0;
END_FOR;

FOR i := 1 TO cMaxIntermediateConditions DO
   sv_GroupActiveData.Group[i].bActive := FALSE;
END_FOR;
sv_GroupActiveData.iActiveGroups := 0;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
Reset internal state of interpreter to initial values
@@@END_Comment@@@ 

@BEG_Body 
@TL(30)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbActive := FALSE;
IF bFatalError THEN
   // in case of a fatal error stop all movement
   // even if they were not started by us
   fbStopStartedMovements();
   mbFatalError := TRUE;
   
   (* lock all movements *)
   DeviceIdAll.CompId := cCompAll;
   DeviceIdAll.IndexId := cAllDevIndex;
   
   fbLockUnlock(DeviceId := DeviceIdAll,
                MoveDir  := cMoveAll,
                MoveId   := cMoveAll,
                Mode     := nLockAbort);
ELSIF bNormalError THEN
   fbStopStartedManualMovements();
   mbNormalError := TRUE;
ELSE
   fbStopStartedManualMovements();
END_IF;

aResetInterpreter(bExcludeActiveColumns := FALSE);
sv_InterpreterParallelInfo := odcParallelInfo;

@END_Body 

@@@BEG_Comment@@@ 
@TL(3)
Internal implementation to stop the interpreter.
This stops all movements started by ODC.
When a fatal error happens all started movements are stopped(even when not started by ODC)
@@@END_Comment@@@ 

@BEG_Body 
@TL(9)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace('stopping interpreter because of a fatal error');   

aStopInterpreterInternal(bFatalError := TRUE, bNormalError := FALSE);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(39)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bActivated := TRUE;

IF DeviceId.CompId = cCompODC THEN
   RETURN; ////// avoid that ODC movements are skipped during searching the next row
END_IF;
            
//check activation of device and movement
FOR iFuIndex := 1 TO sv_ODCDeviceMovements.iCount DO
   IF sv_ODCDeviceMovements.Devices[iFuIndex].DeviceId = DeviceId  THEN
      EXIT;
   END_IF;
END_FOR;

IF NOT sv_ODCDeviceMovements.Devices[iFuIndex].pbDeviceActivated^ THEN
   //device is not activated
   fbDebugTrace2(nODCInterpreter, CONCAT('skipping movement ',
                                       DINT_TO_STRING(DeviceId.CompId), '.',
                                       DINT_TO_STRING(DeviceId.IndexId), ' ',
                                       DINT_TO_STRING(MoveData.MoveId), '/',
                                       DINT_TO_STRING(MoveData.MoveDir),
                                       ' because device not activated'));
   bActivated := FALSE;

ELSIF CHECK_REF(MoveData.pbActivated^) AND NOT MoveData.pbActivated^ THEN
   //movement is not activated
   fbDebugTrace2(nODCInterpreter, CONCAT('skipping movement ',
                                       DINT_TO_STRING(DeviceId.CompId), '.',
                                       DINT_TO_STRING(DeviceId.IndexId), ' ',
                                       DINT_TO_STRING(MoveData.MoveId), '/',
                                       DINT_TO_STRING(MoveData.MoveDir),
                                       ' because of pbActivated'));
   bActivated := FALSE;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(152)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

odcParallelInfo[iColumn].bStartSent := FALSE;
odcParallelInfo[iColumn].bStartConditionWarnPrinted := FALSE;
odcParallelInfo[iColumn].bActivatedChecked := FALSE;
odcParallelInfo[iColumn].bPosReachedArrayLinked := FALSE;
odcParallelInfo[iColumn].bMovementReadyArrayLinked := FALSE;

//get next line
//for saving cycle time several steps are handled directly during increasing the row
FOR iTmpLine := (odcParallelInfo[iColumn].iRow + 1) TO sv_iUsedRows DO
   fbDebugTrace2(nODCInterpreter, CONCAT('increasing IP of column ', DINT_TO_STRING(iColumn),
                                         ' to ', DINT_TO_STRING(iTmpLine)));
   
   fbSetStepState.StepPos.iRow := iTmpLine;
   fbSetStepState.StepPos.iColumn := iColumn;
   
   IF (sv_ODCSequence[iColumn][iTmpLine].iCompId = cCompODC) AND (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveEndSequence) THEN
      //end of sequence
      iStopEverythingCounter := 0;
      FOR k := 1 TO sv_iUsedColumns DO
         IF odcParallelInfo[k].bColumnActive THEN
            iStopEverythingCounter := iStopEverythingCounter + 1;      
         END_IF;
      END_FOR;
      (* deactivate self *)
      odcParallelInfo[iColumn].bColumnActive := FALSE;
      fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iTmpLine), '/',
                                             DINT_TO_STRING(iColumn), ' found ODC EndSequence'));
      IF iStopEverythingCounter > 1 THEN
         dummy := Print('found stop everything action but there are still parallel movements active!!');
         aStopInterpreterFatal();
         RETURN;
      END_IF;
      
      mbFinished := TRUE;
      
      //set step state to ready
      fbSetStepState(StepState := nStateReady);
      
      mbActive := FALSE;
      aResetInterpreter(bExcludeActiveColumns := TRUE);
      sv_InterpreterParallelInfo := odcParallelInfo;
   ELSIF sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveEndIf THEN
      // end_if
      iCount := sv_ODCSequence[iColumn][iTmpLine].iCount;
      mIFConditionHelpData[iCount].iInternalCount := (mIFConditionHelpData[iCount].iInternalCount + 1);
      fbSetStepState(StepState := nStateReady);
   ELSIF sv_ODCSequence[iColumn][iTmpLine].iCompId <> cCompODC AND
      ((sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveBeginSequence) OR (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveEndSequence)) THEN
      IF iEndRow <> 0 AND iTmpLine >= iEndRow THEN
         //do not skip over cMoveEndSequence if it is the last movement in a combined sequence
         //example mold open, core in after mold open sequence
         //otherwise we highlight the core movement on finishing the sequence because we think the movement after cMoveEndSequence is active
         odcParallelInfo[iColumn].iRow := iTmpLine;
         EXIT;   
      ELSE   
         //sequence bound -> execution not necessary
         fbSetStepState(StepState := nStateReady);
      END_IF;
   ELSIF sv_ODCSequence[iColumn][iTmpLine].iCompId = cCompNone AND sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveNone AND
      sv_ODCSequence[iColumn][iTmpLine].iMoveDir = cMoveNone THEN
      //empty step
      fbSetStepState(StepState := nStateReady);
      
      IF (iTmpLine = miEndRow) THEN
         //last step in this column: deactivate column
         odcParallelInfo[iColumn].bColumnActive := FALSE;
      END_IF;
   
   ELSIF sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveBeginGroup THEN
      //begin of group -> save start time of the group
      sv_GroupActiveData.iActiveGroups := sv_GroupActiveData.iActiveGroups + 1; 
      sv_GroupActiveData.Group[sv_ODCSequenceInt[iColumn][iTmpLine].iCount].bActive := TRUE;
      sv_GroupActiveData.Group[sv_ODCSequenceInt[iColumn][iTmpLine].iCount].dStartTime := fbRTC.CDT;         
      fbSetStepState(StepState := nStateReady);   
   ELSIF sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveEndGroup THEN         
      //end of group
      sv_GroupActiveData.Group[sv_ODCSequenceInt[iColumn][iTmpLine].iCount].bActive := FALSE;
      sv_GroupActiveData.iActiveGroups := sv_GroupActiveData.iActiveGroups - 1;
      fbSetStepState(StepState := nStateReady);         
   ELSIF (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveStartParallel) OR (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveStartParallelOpen) THEN
      //begin of parallel tree
      fbSetStepState(StepState := nStateReady);
      // new branches can only start to the right side
      FOR k := iColumn + 1 TO sv_iUsedColumns DO
         IF (sv_ODCSequence[k][iTmpLine].iMoveId = cMoveStartParallel) OR (sv_ODCSequence[k][iTmpLine].iMoveId = cMoveStartParallelOpen) THEN
            //only activate if not activated yet; this can happen, if more than two "StartParallel" or "StartParallelOpen" are in the same line
            IF NOT odcParallelInfo[k].bColumnActive THEN
               odcParallelInfo[k].bColumnActive := TRUE;
               odcParallelInfo[k].bStartSent := FALSE;
               odcParallelInfo[k].bStartConditionWarnPrinted := FALSE;
               odcParallelInfo[k].bSkipAlreadyPosReached := odcParallelInfo[iColumn].bSkipAlreadyPosReached; // copy to new columns
               odcParallelInfo[k].bActivatedChecked := FALSE;
               odcParallelInfo[k].iRow := iTmpLine;
               
               fbSetStepState.StepPos.iRow := iTmpLine;
               fbSetStepState.StepPos.iColumn := k;
               fbSetStepState(StepState := nStateActive);
         
               fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iTmpLine), '/', DINT_TO_STRING(iColumn),
                                                   ' activated column ', DINT_TO_STRING(k)));
            END_IF;            
         END_IF;   
      END_FOR;
     
   ELSE   
      //check if device / movement is activated
      pMoveData := sv_MovementsAvailable[sv_ODCSequenceInt[iColumn][iTmpLine].iMoveNumber].pMovementData;
      aCheckActivated.DeviceId.CompId  := sv_ODCSequence[iColumn][iTmpLine].iCompId;
      aCheckActivated.DeviceId.IndexId := INT_TO_DINT(sv_ODCSequence[iColumn][iTmpLine].iIndexId);
      aCheckActivated(MoveData := pMoveData^);
      
      IF aCheckActivated.bActivated THEN
         //next valid step found
         odcParallelInfo[iColumn].iRow := iTmpLine;
         IF mbStepMode THEN
            odcParallelInfo[iColumn].bDisabled := TRUE;
         ELSE
            odcParallelInfo[iColumn].bDisabled := FALSE;
            fbSetStepState(StepState := nStateActive);
         END_IF;
         
         odcParallelInfo[iColumn].bPosReachedArrayLinked := CHECK_REF(pMoveData^.InstanceData.pPosReachedArray^);
         odcParallelInfo[iColumn].bMovementReadyArrayLinked := CHECK_REF(pMoveData^.InstanceData.pMovementReadyArray^);
         odcParallelInfo[iColumn].bActivatedChecked := TRUE;
         odcParallelInfo[iColumn].bActivated := TRUE;
         EXIT;         
      END_IF;
   END_IF;   
END_FOR;

IF (iEndRow <> 0) AND (iTmpLine >= iEndRow) AND (odcParallelInfo[iColumn].bColumnActive) THEN
   // stop execution because the given limit is reached (iEndRow = 0: no limit set) 
   fbDebugTrace2(nODCInterpreter, CONCAT('stopping exceution because we reached our end position ',
                                          DINT_TO_STRING(iTmpLine), '/', DINT_TO_STRING(iColumn)));
   
   //deactivate own column
   odcParallelInfo[iColumn].bColumnActive := FALSE;
   sv_InterpreterParallelInfo := odcParallelInfo;
   mbFinished := TRUE;
   
   fbSetStepState.StepPos.iRow := iTmpLine;
   fbSetStepState.StepPos.iColumn := iColumn;
   fbSetStepState(StepState := nStateReady);
END_IF;      



@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(18)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bFound := FALSE;

//find out if a check condition exists for the requested movement
FOR i := 1 TO cMaxCheckConditions DO
   IF Movement = sv_CheckConditionInstanceData[i].RelatedMovement OR 
      Movement = sv_CheckConditionInstanceData[i].MoveInEndPos THEN
      // check condition found
      bFound := TRUE;
      EXIT;
   END_IF;   
END_FOR;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(9)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, 'stopping interpreter because of a non fatal error');   

aStopInterpreterInternal(bFatalError := FALSE, bNormalError := TRUE);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(9)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, 'stopping interpreter because of a normal reason');   

aStopInterpreterInternal(bFatalError := FALSE, bNormalError := FALSE);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(83)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, 'checking sanity of ODC array');   

bOK := FALSE;
bAutoCycleLoopFound := FALSE;
g_iAutoCycleLoopStartLine := 0;
g_iAutoCycleLoopEndLine := 0;
iEndSequenceRow := 1;
iNoOfStartParallel := 0;

// sanity check if there are more than 2 StartParallel/EndParallel points per line
// check if ODC movements are used on non ODC FUs
FOR iRow := 1 TO cMaxODCSteps DO
   iEndParallelFound := 0;
   iStartParallelFound := 0;
   FOR iColumn := 1 TO cMaxParallelMovements DO
      IF sv_ODCSequence[iColumn][iRow].iMoveId = cMoveEndParallel THEN
         iEndParallelFound := iEndParallelFound + 1;
         IF sv_ODCSequence[iColumn][iRow].iCompId <> cCompODC THEN
            dummy := Print('found a cMoveEndParallel movement on non ODC device %d/%d', sv_ODCSequence[iColumn][iRow].iCompId, sv_ODCSequence[iColumn][iRow].iIndexId);
            aStopInterpreterFatal();   
         END_IF;
      ELSIF sv_ODCSequence[iColumn][iRow].iMoveId = cMoveStartParallel THEN
         iStartParallelFound := iStartParallelFound + 1;
         iNoOfStartParallel := iNoOfStartParallel + 1;
         IF sv_ODCSequence[iColumn][iRow].iCompId <> cCompODC THEN
            dummy := Print('found a cMoveStartParallel movement on non ODC device %d/%d', sv_ODCSequence[iColumn][iRow].iCompId, sv_ODCSequence[iColumn][iRow].iIndexId);
            aStopInterpreterFatal();   
         END_IF;
      ELSIF sv_ODCSequence[iColumn][iRow].iMoveId = cMoveBeginLoop THEN
         IF sv_TraceLevel.bODCInterpreter THEN
            dummy := Print('**************** BEGIN LOOP found');
            dummy := Print('**************** Column:%d  Row: %d  iCount: %d',iColumn, iRow, sv_ODCSequence[iColumn][iRow].iCount);
         END_IF;
         IF (sv_LoopParameter[(sv_ODCSequence[iColumn][iRow].iCount)].sTextKey = 'TxtAutoCycleLoop') THEN
            IF sv_TraceLevel.bODCInterpreter THEN
               dummy := Print('**************** AUTOCYCLE LOOP found');
               dummy := Print('**************** Column:%d  Row: %d  iCount: %d',iColumn, iRow, sv_ODCSequence[iColumn][iRow].iCount);
            END_IF;
            g_iAutoCycleLoopStartLine := iRow;
            bAutoCycleLoopFound := TRUE;
         END_IF;        
      ELSIF sv_ODCSequence[iColumn][iRow].iMoveId = cMoveEndLoop THEN         
         IF sv_LoopParameter[sv_ODCSequence[iColumn,iRow].iCount].sTextKey = 'TxtAutoCycleLoop' THEN
            g_iAutoCycleLoopEndLine := iRow;
         END_IF;
      END_IF;
   END_FOR;

    IF iEndParallelFound = 1 THEN
      dummy := Print('only 1 EndParallel point found on line %d', iRow);
      aStopInterpreterFatal();
      RETURN;
   END_IF;
   IF iStartParallelFound = 1 THEN
      dummy := Print('only 1 StartParallel found on line %d', iRow);
      aStopInterpreterFatal();
      RETURN;
   END_IF;
   IF iEndParallelFound <> 0 AND iStartParallelFound <> 0 THEN
      dummy := Print('StartParallel/EndParallel mixed on line %d', iRow);
      aStopInterpreterFatal();
      RETURN;
   END_IF;

   IF (sv_ODCSequence[1][iRow].iCompId = cCompODC) AND (sv_ODCSequence[1][iRow].iMoveId = cMoveEndSequence) THEN
      iEndSequenceRow := iRow;
      IF sv_TraceLevel.bODCInterpreter THEN
         dummy := Print('Found END_SEQUENCE in line %d', iRow);
      END_IF;
      EXIT; //exit sanity check because sequence end found
   END_IF;
   
END_FOR;

bOK := TRUE;



@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
Some sanity checks of the ODC sequence array.
@@@END_Comment@@@ 

@BEG_Body 
@TL(72)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, 'begin clearing internal ODC sequence');
(* we copy a whole struct at once, because it is faster *) 
FOR iColumn := 1 TO cMaxParallelMovements DO
   FOR iRow := 1 TO cMaxODCSteps DO
      sv_ODCSequenceInt[iColumn][iRow] := EmptyStep;
   END_FOR;
         
   g_ParallelOpenHelpData[iColumn].bParallelOpen := FALSE;
   g_ParallelOpenHelpData[iColumn].Dependency := EmptyDependency;
   g_ParallelOpenHelpData[iColumn].iStartParallelOpenLine := 0;   
END_FOR;

//unlock all movements that were locked because of a check condition
//before initializing the data
aCheckConditionUnlock();

//init structure with help data for check conditions
FOR i := 1 TO cMaxCheckConditions DO
   mCheckCondHelpData[i].bMovementLocked := FALSE;
   mCheckCondHelpData[i].MoveDirection := nMoveDirectionNo;
   mCheckCondHelpData[i].prActValue := EMPTY; 
   mCheckCondHelpData[i].pbPosReached := EMPTY;
   mCheckCondHelpData[i].LockUnlockData.Alarm.AlarmId := EMPTY;
   mCheckCondHelpData[i].LockUnlockData.Alarm.SubId[1] := 0;
   mCheckCondHelpData[i].LockUnlockData.Alarm.SubId[2] := 0;
   mCheckCondHelpData[i].LockUnlockData.Alarm.SubId[3] := 0;
   mCheckCondHelpData[i].AlarmMoveInEndPos.AlarmId := EMPTY;
   mCheckCondHelpData[i].AlarmMoveInEndPos.SubId[1] := 0;
   mCheckCondHelpData[i].AlarmMoveInEndPos.SubId[2] := 0;
   mCheckCondHelpData[i].AlarmMoveInEndPos.SubId[3] := 0;
END_FOR;

//init structure with help data for IF - conditions
FOR i := 1 TO cMaxIFConditions DO
   mIFConditionHelpData[1].Operator := nCompOperatorEqual;
   mIFConditionHelpData[i].pbVariable1 := EMPTY;
   mIFConditionHelpData[i].pbVariable2 := EMPTY;
   mIFConditionHelpData[i].prVariable1 := EMPTY;
   mIFConditionHelpData[i].prVariable2 := EMPTY;
   mIFConditionHelpData[i].piVariable1 := EMPTY;
   mIFConditionHelpData[i].piVariable2 := EMPTY;
   mIFConditionHelpData[i].bRealVar2Used := FALSE;
   mIFConditionHelpData[i].bDintVar2Used := FALSE;
   mIFConditionHelpData[i].rValue := 0.0;
   mIFConditionHelpData[i].iValue := 0;
END_FOR;

//init structure with help data for loops
FOR i := 1 TO cMaxLoops DO
   mLoopHelpData[i].Operator := nCompOperatorEqual;
   mLoopHelpData[i].pbVariable1 := EMPTY;
   mLoopHelpData[i].pbVariable2 := EMPTY;
   mLoopHelpData[i].prVariable1 := EMPTY;
   mLoopHelpData[i].prVariable2 := EMPTY;
   mLoopHelpData[i].piVariable1 := EMPTY;
   mLoopHelpData[i].piVariable2 := EMPTY;
   mLoopHelpData[i].bRealVar2Used := FALSE;
   mLoopHelpData[i].bDintVar2Used := FALSE;
   mLoopHelpData[i].rValue := 0.0;
   mLoopHelpData[i].iValue := 0;
   mLoopHelpData[i].bLoopCounter := FALSE;
   mLoopHelpData[i].iActCount := 0;
END_FOR;

fbDebugTrace2(nODCInterpreter,'finished clearing internal ODC sequence');


@END_Body 

@@@BEG_Comment@@@ 
@TL(4)
Clear the internal ODC sequence array sv_ODCSequenceInt.
Needed when the sequence is reinitialized to make sure no remanents of a old sequence are left.

Each element in the safety array is set to cODCNoDependency
@@@END_Comment@@@ 

@BEG_Body 
@TL(29)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

Direction := nMoveDirectionNo;
prActValue := EMPTY;
pbReferenceCondition := EMPTY;
DeviceId.CompId := Movement.iCompId;
DeviceId.IndexId := INT_TO_DINT(Movement.iIndexId);

// get refto actvalue of related movement
FOR i := 1 TO sv_ODCDeviceMovements.iCount DO
   IF sv_ODCDeviceMovements.Devices[i].DeviceId = DeviceId THEN
      //device found -> save reference to actpos
      prActValue := sv_ODCDeviceMovements.Devices[i].AddDeviceInfo.prActValue;
      
      //get direction of the movement
      FOR k := 1 TO sv_ODCDeviceMovements.Devices[i].iNumberOfMovements DO
         IF (sv_ODCDeviceMovements.Devices[i].Movements[k]^.MoveDir = Movement.iMoveDir) AND 
            (sv_ODCDeviceMovements.Devices[i].Movements[k]^.MoveId = Movement.iMoveId) THEN
            Direction := sv_ODCDeviceMovements.Devices[i].Movements[k]^.EditorData.Direction;
            pbReferenceCondition := sv_ODCDeviceMovements.Devices[i].Movements[k]^.EditorData.pbReferenceCondition;
            RETURN;
         END_IF;
      END_FOR;
   END_IF;
END_FOR;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(15)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//get all necessary data for lock/unlock
mCheckCondHelpData[iInstance].LockUnlockData.DeviceId.CompId := sv_CheckConditionInstanceData[iInstance].RelatedMovement.iCompId;
mCheckCondHelpData[iInstance].LockUnlockData.DeviceId.IndexId := INT_TO_DINT(sv_CheckConditionInstanceData[iInstance].RelatedMovement.iIndexId);
mCheckCondHelpData[iInstance].LockUnlockData.MoveId := sv_CheckConditionInstanceData[iInstance].RelatedMovement.iMoveId;
mCheckCondHelpData[iInstance].LockUnlockData.MoveDir := sv_CheckConditionInstanceData[iInstance].RelatedMovement.iMoveDir;   
mCheckCondHelpData[iInstance].LockUnlockData.Alarm.AlarmId := erWaitingForCheckCondition;
mCheckCondHelpData[iInstance].LockUnlockData.Alarm.SubId[1] := sv_CheckConditionInstanceData[iInstance].MoveInEndPos.iCompId;
mCheckCondHelpData[iInstance].LockUnlockData.Alarm.SubId[2] := INT_TO_DINT(sv_CheckConditionInstanceData[iInstance].MoveInEndPos.iIndexId);
mCheckCondHelpData[iInstance].LockUnlockData.Alarm.SubId[3] := sv_CheckConditionInstanceData[iInstance].MoveInEndPos.iMoveId;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(39)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO cMaxCheckConditions DO
   IF sv_CheckConditionInstanceData[i].MoveInEndPos.iCompId > cCompNone THEN
      //get move direction and reference to act value of the related movement
      aGetMovementData(Movement := sv_CheckConditionInstanceData[i].RelatedMovement);
      mCheckCondHelpData[i].MoveDirection := aGetMovementData.Direction;
      mCheckCondHelpData[i].prActValue := aGetMovementData.prActValue;
      
      //get reference to posreached flag of the movement that must be in endposition
      DeviceId.CompId := sv_CheckConditionInstanceData[i].MoveInEndPos.iCompId;
      DeviceId.IndexId := INT_TO_DINT(sv_CheckConditionInstanceData[i].MoveInEndPos.iIndexId);
      fbCheckPosReached(DeviceId := DeviceId,
                        MoveDir := sv_CheckConditionInstanceData[i].MoveInEndPos.iMoveDir,
                        MoveId  := sv_CheckConditionInstanceData[i].MoveInEndPos.iMoveId);
      
      IF CHECK_REF(fbCheckPosReached.pbPosReached^) THEN
         mCheckCondHelpData[i].pbPosReached := fbCheckPosReached.pbPosReached;
         mCheckCondHelpData[i].AlarmMoveInEndPos := fbCheckPosReached.Alarm;
      ELSE
         //invalid posreached reference
         //set reference to sv_bFALSE to avoid nullpointer errors
         mCheckCondHelpData[i].pbPosReached := @sv_bFALSE;
         fbDebugTrace2(nODCInterpreter, CONCAT('invalid pbPosReached reference of checkcondition number ',
                                                DINT_TO_STRING(i)));
      END_IF;
         
      //get all necessary data for lock/unlock related movement
      aGetLockUnlockData(iInstance := i);
    
   END_IF;
END_FOR;




@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(36)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO cMaxIFConditions DO
   IF (sv_ConditionParameter[i].CompareOperator = nCompOperatorEqual) OR 
      (sv_ConditionParameter[i].CompareOperator = nCompOperatorNotEqual) THEN
      //get refto BOOL - values
      mIFConditionHelpData[i].pbVariable1 := GET_SYNC_REFTO(sv_ConditionParameter[i].sVariable1, T#0s, state);
      mIFConditionHelpData[i].pbVariable2 := GET_SYNC_REFTO(sv_ConditionParameter[i].sVariable2, T#0s, state);
   ELSIF (sv_ConditionParameter[i].CompareOperator = nCompOperatorModulo) THEN
      //get refto DINT - value
      mIFConditionHelpData[i].piVariable1 := GET_SYNC_REFTO(sv_ConditionParameter[i].sVariable1, T#0s, state);
      IF sv_ConditionParameter[i].sVariable2 <> '' THEN
         mIFConditionHelpData[i].piVariable2 := GET_SYNC_REFTO(sv_ConditionParameter[i].sVariable2, T#0s, state);
         mIFConditionHelpData[i].bDintVar2Used := TRUE;
      END_IF;
      mIFConditionHelpData[i].iValue := sv_ConditionParameter[i].iValue;
   ELSE
      //get refto REAL - value
      mIFConditionHelpData[i].prVariable1 := GET_SYNC_REFTO(sv_ConditionParameter[i].sVariable1, T#0s, state);
      IF sv_ConditionParameter[i].sVariable2 <> '' THEN
         mIFConditionHelpData[i].prVariable2 := GET_SYNC_REFTO(sv_ConditionParameter[i].sVariable2, T#0s, state);
         mIFConditionHelpData[i].bRealVar2Used := TRUE;
      END_IF;      
      mIFConditionHelpData[i].rValue := sv_ConditionParameter[i].rValue;
   END_IF;
   
   //copy operator
   mIFConditionHelpData[i].Operator := sv_ConditionParameter[i].CompareOperator;
END_FOR;




@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(42)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO cMaxLoops DO
   IF (sv_LoopParameter[i].CompareOperator = nCompOperatorEqual) OR 
      (sv_LoopParameter[i].CompareOperator = nCompOperatorNotEqual) THEN
      //get refto BOOL - values
      mLoopHelpData[i].pbVariable1 := GET_SYNC_REFTO(sv_LoopParameter[i].sVariable1, T#0s, state);
      mLoopHelpData[i].pbVariable2 := GET_SYNC_REFTO(sv_LoopParameter[i].sVariable2, T#0s, state);
   ELSIF (sv_LoopParameter[i].CompareOperator = nCompOperatorModulo) THEN
      //get refto DINT - value
      
      IF sv_LoopParameter[i].sVariable1 = 'system.sv_iLoopCounter' THEN
         //special case: loop counter
         mLoopHelpData[i].bLoopCounter := TRUE;
      ELSE      
         mLoopHelpData[i].piVariable1 := GET_SYNC_REFTO(sv_LoopParameter[i].sVariable1, T#0s, state);
         IF sv_LoopParameter[i].sVariable2 <> '' THEN
            mLoopHelpData[i].piVariable2 := GET_SYNC_REFTO(sv_LoopParameter[i].sVariable2, T#0s, state);
            mLoopHelpData[i].bDintVar2Used := TRUE;
         END_IF;
      END_IF;
      mLoopHelpData[i].iValue := sv_LoopParameter[i].iValue;
   ELSE
      //get refto REAL - value
      mLoopHelpData[i].prVariable1 := GET_SYNC_REFTO(sv_LoopParameter[i].sVariable1, T#0s, state);
      IF sv_LoopParameter[i].sVariable2 <> '' THEN
         mLoopHelpData[i].prVariable2 := GET_SYNC_REFTO(sv_LoopParameter[i].sVariable2, T#0s, state);
         mLoopHelpData[i].bRealVar2Used := TRUE;
      END_IF;      
      mLoopHelpData[i].rValue := sv_LoopParameter[i].rValue;
   END_IF;
   
   //copy operator
   mLoopHelpData[i].Operator := sv_LoopParameter[i].CompareOperator;
END_FOR;




@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(408)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, 'numbering for safety calculation');

bError := FALSE;
iCounter := 1;
iTmpCol := 1;

iUsedColumns := 1;
iUsedRows := 1;
bContinueAfterLoopAdded := FALSE;

(* where we start parsing *)
ParseStack[1].iColumn := 1;
ParseStack[1].iRow := 1;
ParseStack[1].iRowEnd := cMaxODCSteps + 1;
ParseStack[1].bIgnoreStartParallel := FALSE;
iParseStackPointer := 1;
PrevPos.iColumn := -1;
PrevPos.iRow := -1;

bEndLoop := FALSE;

(* use parse a parse stack to traverse the array in a defined order
   the stack is responsible for remembering what to parse next.
   When a parallel branch is found all choices where to continue
   executing are pushed onto the stack in the right order.
   Then they are popped from the stack one by one and executed *)

(* execute one element from the stack *)
WHILE NOT bEndLoop DO
   IF iParseStackPointer < 1 THEN
      fbDebugTrace('parse stack underflow');
      aStopInterpreterFatal();
      bError := TRUE;
      RETURN;
   END_IF;
   CurrentParsePos := ParseStack[iParseStackPointer];
   iParseStackPointer := iParseStackPointer - 1;
   
   iTmpCol := CurrentParsePos.iColumn;
   iUsedColumns := MAX(iTmpCol, iUsedColumns);
   
   fbDebugTrace2(nODCInterpreter, CONCAT('started traversing ',
                                         DINT_TO_STRING(CurrentParsePos.iRow),
                                         '-',
                                         DINT_TO_STRING(CurrentParsePos.iRowEnd),
                                         ' col:',
                                         DINT_TO_STRING(CurrentParsePos.iColumn)));
    
   FOR k := CurrentParsePos.iRow TO cMaxODCSteps + 1 DO
      bAddPrevNextInfo := FALSE;
      IF k >= CurrentParsePos.iRowEnd THEN
         (* we finished our entry on the parse stack *)
         fbDebugTrace2(nODCInterpreter, CONCAT('finished traversing ',
                                               DINT_TO_STRING(CurrentParsePos.iRow),
                                               '-',
                                               DINT_TO_STRING(CurrentParsePos.iRowEnd),
                                               ' col:',
                                               DINT_TO_STRING(CurrentParsePos.iColumn)));

         IF iParseStackPointer <= 0 THEN
            (* The last entry in the parse stack was finished, but no step with *)
            (* iCompId = cCompODC AND iMoveId = cMoveEndSequence was found. *)
            fbDebugTrace('Parsing the sequence finished but no step "ODC End Sequence" was found.');
            aStopInterpreterFatal();
            bError := TRUE;
            RETURN;
         END_IF;

         EXIT;(* work on next stack element *)
      ELSIF k >= cMaxODCSteps + 1 THEN
         (* something went horribly wrong and we tried to parse elements after the end of the array *)
         (* this should never happen *)
         fbDebugTrace('Parsing the sequence failed. Out of bounds access detected.');
         aStopInterpreterFatal();
         bError := TRUE;
         RETURN;
      END_IF;
      
      CurrentStep := sv_ODCSequence[iTmpCol][k];
      bChanged := FALSE;
      
      (* fix up empty elements from builder so they are valid *)
      IF CurrentStep.iCompId = 0 THEN
         CurrentStep.iCompId := cCompNone;
         bChanged := TRUE;
      END_IF;
      IF CurrentStep.iIndexId = 0 THEN
         CurrentStep.iIndexId := 1;
         bChanged := TRUE;
      END_IF;
      IF CurrentStep.iMoveId = 0 THEN
         CurrentStep.iMoveId := cMoveNone;
         bChanged := TRUE;
      ELSIF CurrentStep.iMoveId = cMaxMoveIdent THEN
         //set MoveId to cMoveAll due to compatibility reasons
         CurrentStep.iMoveId := cMoveAll;
         bChanged := TRUE;
      END_IF;
      IF CurrentStep.iMoveDir = 0 THEN
         CurrentStep.iMoveDir := cMoveNone;
         bChanged := TRUE;
      ELSIF CurrentStep.iMoveDir = cMaxMoveIdent THEN
         //set MoveDir to cMoveAll due to compatibility reasons
         CurrentStep.iMoveDir := cMoveAll;
         bChanged := TRUE;
      END_IF;
      
      IF bChanged THEN
         (* write back valid value *)
         fbDebugTrace2(nODCInterpreter, CONCAT('writing back changed values to ',
                                               DINT_TO_STRING(iTmpCol),
                                               '/',
                                               DINT_TO_STRING(k))); 
         sv_ODCSequence[iTmpCol][k] := CurrentStep;
      END_IF;
      
      IF CurrentStep.iMoveId = cMoveStartParallel THEN
         (* search end of parallel movement *)
         (* in each column find a EP where the leftmost column is the current column *)
         IF CurrentParsePos.bIgnoreStartParallel THEN
            (* we want to give branch begin statements a number , but we don't want to go
               into a endless loop *)
            bAddPrevNextInfo := TRUE;
            CurrentParsePos.bIgnoreStartParallel := FALSE;
         ELSE
            fbInterpreterFindEndOfParallel(odcSequence := sv_ODCSequence, iColumn := iTmpCol, iLine := k);
               
            IF fbInterpreterFindEndOfParallel.iMaxLineOfBranch = 0 THEN
               fbDebugTrace('did not find end of parallel branch, what should we do here?');
               aStopInterpreterFatal();
               bError := TRUE;
               RETURN;
            END_IF;
               
            (* continue after EndParallel *)
            iParseStackPointer := iParseStackPointer + 1;
            //dummy := Print('***** increase parse stack pointer to %d',iParseStackPointer);
            ParseStack[iParseStackPointer].iColumn := iTmpCol;
            ParseStack[iParseStackPointer].iRow := fbInterpreterFindEndOfParallel.iMaxLineOfBranch + 1;
            ParseStack[iParseStackPointer].iRowEnd := CurrentParsePos.iRowEnd;
            ParseStack[iParseStackPointer].bIgnoreStartParallel := FALSE;
            
            fbDebugTrace2(nODCInterpreter, CONCAT('adding parse step (continue) ',
                                                  DINT_TO_STRING(ParseStack[iParseStackPointer].iRow),
                                                  '-',
                                                  DINT_TO_STRING(ParseStack[iParseStackPointer].iRowEnd),
                                                  ' col:',
                                                  DINT_TO_STRING(ParseStack[iParseStackPointer].iColumn)));

            (* add parallel branches from right to left *)
            FOR m := cMaxParallelMovements TO iTmpCol BY -1 DO
               IF sv_ODCSequence[m][k].iMoveId = cMoveStartParallel THEN
                  iParseStackPointer := iParseStackPointer + 1;
                  //dummy := Print('***** increase parse stack pointer to %d',iParseStackPointer);
                  ParseStack[iParseStackPointer].iColumn := m;
                  ParseStack[iParseStackPointer].iRow := k; (* start again at SP instruction, for giving it a number, but don't try to detect a branch start (we just did that) *)
                  ParseStack[iParseStackPointer].iRowEnd := fbInterpreterFindEndOfParallel.iMaxLineOfBranch + 1; (* also iterate over EP steps *)
                  ParseStack[iParseStackPointer].bIgnoreStartParallel := TRUE;
                  
                  fbDebugTrace2(nODCInterpreter, CONCAT('adding parse step (parallel) ',
                                                  DINT_TO_STRING(ParseStack[iParseStackPointer].iRow),
                                                  '-',
                                                  DINT_TO_STRING(ParseStack[iParseStackPointer].iRowEnd),
                                                  ' col:',
                                                  DINT_TO_STRING(ParseStack[iParseStackPointer].iColumn)));
                  
               END_IF;    
            END_FOR;
            EXIT; (* work on next stack element(probably left most branch) *)
         END_IF;
      ELSIF CurrentStep.iMoveId = cMoveEndSequence AND CurrentStep.iCompId = cCompODC THEN
         fbDebugTrace2(nODCInterpreter, 'found end');
         
         iUsedRows := k;
         bEndLoop := TRUE;
         bAddPrevNextInfo := TRUE;
         
         IF iTmpCol <> 1 THEN
            (* check if the end sequence marker is in a column other than the first *)
            (* this is not allowed *)
            fbDebugTrace(CONCAT('Found "ODC End Sequence" in column ', DINT_TO_STRING(iTmpCol), ' instead of column 1'));
            aStopInterpreterFatal();
            bError := TRUE;
            RETURN;
         ELSIF iParseStackPointer >= 1 THEN
            (* check if there is something left on parse stack, this should not happen *)
            (* unless the end sequence marker is placed in the middle of the sequence *)
            fbDebugTrace('Found "ODC End Sequence" in the middle of the sequence instead of at the end.');
            aStopInterpreterFatal();
            bError := TRUE;
            RETURN;
         END_IF;
      ELSIF CurrentStep.iMoveId = cMoveEndParallel THEN
         bAddPrevNextInfo := TRUE;
      ELSIF CurrentStep.iMoveId  = cMoveNone AND CurrentStep.iMoveDir = cMoveNone AND CurrentStep.iCompId  = cCompNone THEN
         ;(* empty step -> do not add prev/next info *)
      ELSIF (CurrentStep.iMoveId = cMoveStartParallelOpen) THEN
         g_ParallelOpenHelpData[iTmpCol].iStartParallelOpenLine := k;
         
         //dummy := Print('found start parallel open at line %d  column %d', k, iTmpCol);          
         IF CurrentParsePos.bIgnoreStartParallel THEN
            (* we want to give branch begin statements a number , but we don't want to go
               into a endless loop *)
            bAddPrevNextInfo := TRUE;
            CurrentParsePos.bIgnoreStartParallel := FALSE;
         ELSE         
            (* continue after End loop *)
            //attention: only add this once and not every time when a startparallel open is found!! 
            IF NOT bContinueAfterLoopAdded THEN
               iParseStackPointer := iParseStackPointer + 1;
               //dummy := Print('***** increase parse stack pointer to %d',iParseStackPointer);
               ParseStack[iParseStackPointer].iColumn := iTmpCol;
               ParseStack[iParseStackPointer].iRow := (g_iAutoCycleLoopEndLine + 1);
               ParseStack[iParseStackPointer].iRowEnd := cMaxODCSteps;
               ParseStack[iParseStackPointer].bIgnoreStartParallel := FALSE;
               
               fbDebugTrace2(nODCInterpreter, CONCAT('adding parse step (continue after end loop) ',
                                                   DINT_TO_STRING(ParseStack[iParseStackPointer].iRow),
                                                   '-',
                                                   DINT_TO_STRING(ParseStack[iParseStackPointer].iRowEnd),
                                                   ' col:',
                                                   DINT_TO_STRING(ParseStack[iParseStackPointer].iColumn)));
               bContinueAfterLoopAdded := TRUE;
            END_IF;
                                     
            (* add parallel branches from right to left *)
            FOR m := cMaxParallelMovements TO iTmpCol BY -1 DO 
               IF sv_ODCSequence[m][k].iMoveId = cMoveStartParallelOpen THEN
                  iParseStackPointer := iParseStackPointer + 1;
                  //dummy := Print('***** increase parse stack pointer to %d',iParseStackPointer);
                  ParseStack[iParseStackPointer].iColumn := m;
                  ParseStack[iParseStackPointer].iRow := k;                             
                  ParseStack[iParseStackPointer].iRowEnd := (g_iAutoCycleLoopEndLine +1); //use row which contains the end of autocycle loop as iEndRow
                  ParseStack[iParseStackPointer].bIgnoreStartParallel := TRUE;  
                  
                  fbDebugTrace2(nODCInterpreter, CONCAT('adding parse step (PARALLEL OPEN) ',
                                                   DINT_TO_STRING(ParseStack[iParseStackPointer].iRow),
                                                   '-',
                                                   DINT_TO_STRING(ParseStack[iParseStackPointer].iRowEnd),
                                                   ' col:',
                                                   DINT_TO_STRING(ParseStack[iParseStackPointer].iColumn)));
               END_IF;    
            END_FOR;      
            EXIT; (* work on next stack element*)             
         END_IF;
        
      ELSIF (CurrentStep.iMoveId = cMoveEndParallelOpen) THEN
         bAddPrevNextInfo := FALSE;
         //parsing of one line is not possible -> add all necessary informations for this "EndParallelOpen"
         //and the "EndParallelOpen" in the corresponding column directly         
         //dummy := Print('found end parallel open at line %d  column %d', k, iTmpCol);         
         fbGetMoveNumber.DeviceId.CompId  := CurrentStep.iCompId;
         fbGetMoveNumber.DeviceId.IndexId := INT_TO_DINT(CurrentStep.iIndexId);
         fbGetMoveNumber(MoveId := CurrentStep.iMoveId, MoveDir := CurrentStep.iMoveDir);
         sv_ODCSequenceInt[iTmpCol][k].iMoveNumber := fbGetMoveNumber.iMoveNumber;        
         sv_ODCSequenceInt[iTmpCol][k].iCount := INT_TO_DINT(CurrentStep.iCount);
         
         sv_ODCSequenceInt[iTmpCol][k].iSequentialNumber := iCounter;
         iCounter := iCounter + 1;
         
         (* link current step.PosPrevStep to last step *)
         sv_ODCSequenceInt[iTmpCol][k].PosPrevStep := PrevPos;
                        
         (* link prev step.PosNextStep to this step *)
         sv_ODCSequenceInt[PrevPos.iColumn][PrevPos.iRow].PosNextStep.iColumn := iTmpCol;
         sv_ODCSequenceInt[PrevPos.iColumn][PrevPos.iRow].PosNextStep.iRow := k;        
         PrevPos.iColumn := iTmpCol;
         PrevPos.iRow := k;
                  
         FOR m := 2 TO cMaxParallelMovements DO 
            IF sv_ODCSequence[m][k].iMoveId = cMoveEndParallelOpen THEN
               //dummy := Print('found end parallel open at line %d  column %d', k, m);                              
               sv_ODCSequenceInt[m][k].iMoveNumber := fbGetMoveNumber.iMoveNumber;
               sv_ODCSequenceInt[m][k].iCount := INT_TO_DINT(sv_ODCSequence[iTmpCol][k].iCount);
               
               sv_ODCSequenceInt[m][k].iSequentialNumber := iCounter;
               iCounter := iCounter + 1;
               
               sv_ODCSequenceInt[m][k].PosPrevStep := PrevPos;
               sv_ODCSequenceInt[PrevPos.iColumn][PrevPos.iRow].PosNextStep.iColumn := m;
               sv_ODCSequenceInt[PrevPos.iColumn][PrevPos.iRow].PosNextStep.iRow := k;
               
               PrevPos.iColumn := m;
               PrevPos.iRow := k;
               //do not exit because there can be more than one EndParallelOpen in this line
            END_IF;    
         END_FOR;
         
      ELSE
         (* normal movement *)
         bAddPrevNextInfo := TRUE;
      END_IF;
         
      (* add information for Prev and Next if needed *)
      IF bAddPrevNextInfo THEN
         bInvalidStep := FALSE;
         IF CurrentStep.iCompId < cMinCompId OR CurrentStep.iCompId > cMaxCompId OR
            CurrentStep.iIndexId < 0 OR INT_TO_DINT(CurrentStep.iIndexId) > cMaxDeviceIndex OR 
            CurrentStep.iMoveDir < cMinMoveIdent OR CurrentStep.iMoveDir > cMaxMoveIdent OR
            CurrentStep.iMoveId < cMinMoveIdent OR CurrentStep.iMoveId > cMaxMoveIdent THEN
            (* a invalid comp/move id will otherwise cause a "out of range" error
               when assigned to a subrange *)
            bInvalidStep := TRUE;
         END_IF;
         
         IF NOT bInvalidStep THEN
            fbGetMoveNumber.DeviceId.CompId  := CurrentStep.iCompId;
            fbGetMoveNumber.DeviceId.IndexId := INT_TO_DINT(CurrentStep.iIndexId);
            fbGetMoveNumber(MoveId := CurrentStep.iMoveId, MoveDir := CurrentStep.iMoveDir);
         END_IF;
         IF NOT bInvalidStep AND fbGetMoveNumber.bFound THEN
            sv_ODCSequenceInt[iTmpCol][k].iMoveNumber := fbGetMoveNumber.iMoveNumber;
            
            IF sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pMovementData^.pbActivated = EMPTY THEN
               fbDebugTrace(CONCAT('at pos: ',
                                   DINT_TO_STRING(k),
                                   '/',
                                   DINT_TO_STRING(iTmpCol),
                                   ' movement ',
                                   DINT_TO_STRING(CurrentStep.iCompId),
                                   '.',
                                   INT_TO_STRING(CurrentStep.iIndexId),
                                   ' ',
                                   DINT_TO_STRING(CurrentStep.iMoveId),
                                   '/',
                                   DINT_TO_STRING(CurrentStep.iMoveDir),
                                   ' has pbActivated not set'));
               // dependency analysis needs pbActivated to point to a valid SV
               // mabye this check can be loosened when dependency analysis can handle a EMPTY pbActivated
               aStopInterpreterFatal();
               bError := TRUE;
               RETURN;
            END_IF;
            
         ELSE // NOT bInvalidStep AND fbGetMoveNumber.bFound
            (* non existent movement *)
            sv_ODCSequenceInt[iTmpCol][k].iMoveNumber := 0;
            
            SET_ALARM(Name := erMovementNotAvailable,
                      SubID1 := CurrentStep.iCompId,
                      SubID2 := CurrentStep.iIndexId,
                      SubID3 := CurrentStep.iMoveId,
                      SubID4 := CurrentStep.iMoveDir);
            
            fbDebugTrace(CONCAT('at pos: ', DINT_TO_STRING(k), '/', DINT_TO_STRING(iTmpCol),
                                ' trying to number non existent/invalid movement ',
                                DINT_TO_STRING(CurrentStep.iCompId), '.',
                                INT_TO_STRING(CurrentStep.iIndexId), ' ',
                                DINT_TO_STRING(CurrentStep.iMoveId), '/',
                                DINT_TO_STRING(CurrentStep.iMoveDir)));
            
            fbSetStepState.StepPos.iColumn := iTmpCol;
            fbSetStepState.StepPos.iRow := k;
            fbSetStepState(StepState := nStateError);
            bError := TRUE;
            (* do not quit early -> internal array is filled and debug mask works *)
         END_IF;

         sv_ODCSequenceInt[iTmpCol][k].iCount := INT_TO_DINT(CurrentStep.iCount);
         
         IF sv_ODCSequenceInt[iTmpCol][k].iSequentialNumber <> 0 THEN
            fbDebugTrace('have already visited(numbered) this step, should not have happened');
            aStopInterpreterFatal();
            bError := TRUE;
            RETURN;
         ELSE
            sv_ODCSequenceInt[iTmpCol][k].iSequentialNumber := iCounter;
            iCounter := iCounter + 1;
            
            (* link current step.PosPrevStep to last step *)
            sv_ODCSequenceInt[iTmpCol][k].PosPrevStep := PrevPos;
                           
            (* link prev step.PosNextStep to this step *)
            IF PrevPos.iColumn <> -1 AND PrevPos.iRow <> -1 THEN
               sv_ODCSequenceInt[PrevPos.iColumn][PrevPos.iRow].PosNextStep.iColumn := iTmpCol;
               sv_ODCSequenceInt[PrevPos.iColumn][PrevPos.iRow].PosNextStep.iRow := k;
            END_IF;
            PrevPos.iColumn := iTmpCol;
            PrevPos.iRow := k;
            
            (* set PosNextStep of last step to -1,-1 *)
            IF bEndLoop THEN
               sv_ODCSequenceInt[iTmpCol][k].PosNextStep.iColumn := -1;
               sv_ODCSequenceInt[iTmpCol][k].PosNextStep.iRow := -1;
               EXIT;(* need to leave the inner loop after last step *) 
            END_IF;
         END_IF; // iSequentialNumber <> 0
      END_IF; // bAddPrevNextInfo
   END_FOR;
END_WHILE;

fbDebugTrace2(nODCInterpreter, CONCAT('max usage of array: ',
                                      DINT_TO_STRING(iUsedColumns),
                                      '/',
                                      DINT_TO_STRING(iUsedRows)));

//init data for all check conditions
aInitCheckConditionHelpData();

//init data for all IF conditions and loops
aInitIFConditionHelpData();
aInitLoopHelpData();

@END_Body 

@@@BEG_Comment@@@ 
@TL(4)
Generate sv_ODCSequenceInt from sv_ODCSequence.

Give each entry in the ODC array a number and write the position of its predecessor/successor.
This is necessary for dependency calculation
@@@END_Comment@@@ 

@BEG_Body 
@TL(10)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

(* this does not really belong to the interpreter
   maybe it can be moved to ABODC *)
fbStartedMovementAdder(DeviceId := DeviceId, MoveId := MoveId, MoveDir := MoveDir, StepPos := StepPos, iInstance := iInstance);
bOK := fbStartedMovementAdder.bOK;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(57)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, CONCAT('########## initializing interpreter to start at pos:',
                                       DINT_TO_STRING(iRow),
                                       '/',
                                       DINT_TO_STRING(iColumn),
                                       ' and stop at ',
                                       DINT_TO_STRING(iEndRow),
                                       ' skipPosReached:',
                                       BOOL_TO_STRING(bSkipAlreadyPosReached),
                                       ' exclude active columns:',
                                       BOOL_TO_STRING(bExcludeActiveColumns)));


IF mbFatalError THEN
   fbDebugTrace('can not initialize interpreter after fatal error, need to call aSetInitOK to clear error flag');
   RETURN;
END_IF;

aResetInterpreter(bExcludeActiveColumns := bExcludeActiveColumns);

IF iRow < 1 OR iRow > cMaxODCSteps OR iColumn < 1 OR iColumn > cMaxParallelMovements THEN
   (* error instruction pointer is wrong *)
   fbDebugTrace(CONCAT('trying start execution out of bounds ',
                       DINT_TO_STRING(iRow),
                       '/',
                       DINT_TO_STRING(iColumn)));
   aStopInterpreterFatal();
   RETURN;
END_IF;

IF iEndRow > cMaxODCSteps THEN
   (* error instruction end pointer is wrong *)
   (* 0 means execute until end *)
   fbDebugTrace(CONCAT('execution end pointer ',
                       DINT_TO_STRING(iEndRow),
                       '/',
                       DINT_TO_STRING(iColumn),
                      ' out of bounds'));
   aStopInterpreterFatal();
   RETURN;
END_IF;

(* only first column is active *)
odcParallelInfo[iColumn].bColumnActive := TRUE;
odcParallelInfo[iColumn].iRow := iRow;
odcParallelInfo[iColumn].bSkipAlreadyPosReached := bSkipAlreadyPosReached;
miEndRow := iEndRow;

mbFinished := FALSE;
mbNormalError := FALSE;
mbActive := TRUE;
sv_InterpreterParallelInfo := odcParallelInfo;

@END_Body 

@@@BEG_Comment@@@ 
@TL(4)
Initialize the interpreter to start executing at a certain row/column

When used for combined movements also a end position can be set (iEndRow).
when iEndRow is 0 it means interpret until ODC1.EndSequence is found.
@@@END_Comment@@@ 

@BEG_Body 
@TL(53)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bCheckConditionsOk := TRUE;
iConditionsNotOk := 0;

FOR i := 1 TO cMaxCheckConditions DO
   
   bRelevantCheckCondition := (Movement = sv_CheckConditionInstanceData[i].RelatedMovement) OR
                              (Movement = sv_CheckConditionInstanceData[i].MoveInEndPos);
   
   IF bRelevantCheckCondition THEN
      
      // check if value is reached
      IF mCheckCondHelpData[i].MoveDirection = nMoveDirectionMinToMax THEN
         bTargetValueReached := mCheckCondHelpData[i].prActValue^ >= sv_CheckConditionInstanceData[i].rValue;
      ELSIF mCheckCondHelpData[i].MoveDirection = nMoveDirectionMaxToMin THEN
         bTargetValueReached := mCheckCondHelpData[i].prActValue^ <= sv_CheckConditionInstanceData[i].rValue;
      END_IF;   
   
      IF Movement = sv_CheckConditionInstanceData[i].RelatedMovement THEN
         //check pos reached flag of movement in endposition as soon as target value is reached               
         IF bTargetValueReached THEN
            IF NOT mCheckCondHelpData[i].pbPosReached^ THEN
               IF NOT bNoAlarms THEN
                  SET_ALARM(Name := mCheckCondHelpData[i].AlarmMoveInEndPos.AlarmId,
                            SubID1 := mCheckCondHelpData[i].AlarmMoveInEndPos.SubId[1]);
               END_IF;               
               bCheckConditionsOk := FALSE;
               iConditionsNotOk := iConditionsNotOk + 1;
            END_IF;
         END_IF;
               
      ELSIF Movement = sv_CheckConditionInstanceData[i].MoveInEndPos THEN
         //check related movement
         IF bTargetValueReached THEN
            //value exceeded 
            IF NOT bNoAlarms THEN
               SET_ALARM(Name := erCompNotInCorrectPosition,
                     SubID1 := sv_CheckConditionInstanceData[i].RelatedMovement.iCompId,
                     SubID2 := sv_CheckConditionInstanceData[i].RelatedMovement.iIndexId);
            END_IF;            
            bCheckConditionsOk := FALSE;
            iConditionsNotOk := iConditionsNotOk + 1;
         END_IF;
      END_IF;
   END_IF;

END_FOR;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(36)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

RelatedMovement := sv_StartConditionInstanceData[iInstance].RelatedMovement;
bReached := FALSE;

IF RelatedMovement <> PrevRelatedMovement THEN
   //only get new data if data of related movement changed   
   aGetMovementData(Movement := RelatedMovement);
   Direction := aGetMovementData.Direction;
   prActValue := aGetMovementData.prActValue;
   pbReferenceCondition := aGetMovementData.pbReferenceCondition;
END_IF;


// decide if start condition is reached
IF sv_StartConditionInstanceData[iInstance].bStartCondition THEN
   //boolean start condition reached flag
   IF (pbReferenceCondition <> EMPTY) THEN
      bReached := pbReferenceCondition^;
   END_IF;
ELSE   
   IF (prActValue <> EMPTY) THEN
      //no boolean flag -> check start condition reached according direction and value
      IF Direction = nMoveDirectionMinToMax THEN
         bReached := prActValue^ >= sv_StartConditionInstanceData[iInstance].rValue;
      ELSIF Direction = nMoveDirectionMaxToMin THEN
         bReached := prActValue^ <= sv_StartConditionInstanceData[iInstance].rValue;
      END_IF;
   END_IF;   
END_IF;

PrevRelatedMovement := RelatedMovement;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
check if a start condition is reached
@@@END_Comment@@@ 

@BEG_Body 
@TL(47)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bContinue := FALSE;

// check if value is reached
IF mCheckCondHelpData[iInstance].MoveDirection = nMoveDirectionMinToMax THEN
   bTargetValueReached := mCheckCondHelpData[iInstance].prActValue^ >= sv_CheckConditionInstanceData[iInstance].rValue;
ELSIF mCheckCondHelpData[iInstance].MoveDirection = nMoveDirectionMaxToMin THEN
   bTargetValueReached := mCheckCondHelpData[iInstance].prActValue^ <= sv_CheckConditionInstanceData[iInstance].rValue;
END_IF;

//supervision of check condition
//finished Movement reached the endposition before related movement reached the target value 
//-> continue
//related movement reached the target value and finished movement is not in endposition
//-> lock related movement untill endposition is reached and display a warning
IF bTargetValueReached THEN
   IF NOT mCheckCondHelpData[iInstance].pbPosReached^ THEN
      //target value reached and movement is not in endposition
      
      IF NOT mCheckCondHelpData[iInstance].bMovementLocked THEN
         //lock related movement         
         fbLockUnlock.DeviceId := mCheckCondHelpData[iInstance].LockUnlockData.DeviceId;
         fbLockUnlock.MoveDir := mCheckCondHelpData[iInstance].LockUnlockData.MoveDir;
         fbLockUnlock.MoveId := mCheckCondHelpData[iInstance].LockUnlockData.MoveId;
         fbLockUnlock.Alarm := mCheckCondHelpData[iInstance].LockUnlockData.Alarm;
         fbLockUnlock(Mode := nLockResume);
         
         mCheckCondHelpData[iInstance].bMovementLocked := TRUE;
      END_IF;
         
   ELSIF mCheckCondHelpData[iInstance].pbPosReached^ THEN
      //unlock movement and continue
      fbLockUnlock.DeviceId := mCheckCondHelpData[iInstance].LockUnlockData.DeviceId;
      fbLockUnlock.MoveDir := mCheckCondHelpData[iInstance].LockUnlockData.MoveDir;
      fbLockUnlock.MoveId := mCheckCondHelpData[iInstance].LockUnlockData.MoveId;
      fbLockUnlock.Alarm := mCheckCondHelpData[iInstance].LockUnlockData.Alarm;
      fbLockUnlock(Mode := nUnlock);
     
      mCheckCondHelpData[iInstance].bMovementLocked := FALSE;
      bContinue := TRUE;
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
check condition supervision
@@@END_Comment@@@ 

@BEG_Body 
@TL(82)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bPosReachedOk := FALSE;
iMoveNr := sv_ODCSequenceInt[iColumn][iRow].iMoveNumber;

//check if movement is instanceable and according pos reached array is available
IF sv_MovementsAvailable[iMoveNr].pMovementData^.bInstanceable THEN
   IF CHECK_REF(sv_MovementsAvailable[iMoveNr].pMovementData^.InstanceData.pPosReachedArray^) THEN      
      iInstance := sv_ODCSequenceInt[iColumn][iRow].iCount;
      IF NOT sv_MovementsAvailable[iMoveNr].pMovementData^.InstanceData.pPosReachedArray^[iInstance] THEN
         //position not reached
         bPosNotReached := TRUE;
      END_IF;
   ELSE
      IF sv_MovementsAvailable[iMoveNr].pMovementData^.iSafetyIdentifier <> 0 THEN
         //movement is safety relevant and has no posReached variable
         bPosNotReached := TRUE;
      END_IF;      
   END_IF;
ELSE

   fbCheckPosReached(DeviceId := DeviceId,
                     MoveDir  := MoveDir,
                     MoveId   := MoveId);
   
   IF CHECK_REF(fbCheckPosReached.pbPosReached^) AND NOT fbCheckPosReached.pbPosReached^ THEN
      (* did not reach required position *)
      bPosNotReached := TRUE;
   ELSE
      IF NOT CHECK_REF(fbCheckPosReached.pbPosReached^) THEN
         fbMoveDescription(iMoveNr := iMoveNr);
         fbDebugTrace2(nODCInterpreter, CONCAT('movement ',fbMoveDescription.sDescription,' has no pos reached variable'));
         IF sv_MovementsAvailable[iMoveNr].pMovementData^.iSafetyIdentifier <> 0 THEN
            //movement is safety relevant and has no posReached variable
            bPosNotReached := TRUE;
         END_IF;
      END_IF;                     
   END_IF;
   
END_IF;

IF bPosNotReached THEN
   
   //trace warning and set step state to error
   fbMoveDescription(iMoveNr := iMoveNr);   
   fbDebugTrace2(nODCInterpreter, CONCAT('movement ',fbMoveDescription.sDescription,' finished, but pos reached is FALSE'));

   fbSetStepState.StepPos.iRow := iRow;
   fbSetStepState.StepPos.iColumn := iColumn;
   fbSetStepState(StepState := nStateError);
    
   //set according alarm
   IF (sv_OperationMode >= nHalfAutomatic) THEN
      IF (sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.AlarmId <> EMPTY) THEN
         SET_ALARM(Name := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.AlarmId,
                SubID1 := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.SubId[1],
                SubID2 := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.SubId[2],
                SubID3 := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.SubId[3],
                SubID4 := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.SubId[4],
                Param1 := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.Param1,
                Param2 := sv_MovementsAvailable[iMoveNr].pMovementData^.Alarm.Param2);
      ELSE
         //display a default alarm to avoid stopp of autocycle without alarm
         SET_ALARM(Name := erReadyAndNotPosReached,
                   SubID1 := DeviceId.CompId,
                   SubID2 := DeviceId.IndexId,
                   SubID3 := MoveId);
      END_IF;
         
   END_IF;
       
   //stop interpreter
   aStopInterpreterError(); 
   bPosNotReached := FALSE;
ELSE
   //posReached information ok
   bPosReachedOk := TRUE;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(4)
Check PosReached flag of a movement
If there is no valid reference of pbPosReached OR pbPosReached is FALSE,
an according message is traced (trace level: nODCInterpreter),
and the step state is set to nStateError
@@@END_Comment@@@ 

@BEG_Body 
@TL(58)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bConditionOk := FALSE;

CASE mIFConditionHelpData[iInstance].Operator OF
   nCompOperatorEqual:
      bConditionOk := mIFConditionHelpData[iInstance].pbVariable1^ = mIFConditionHelpData[iInstance].pbVariable2^;
   
   nCompOperatorNotEqual:
      bConditionOk := mIFConditionHelpData[iInstance].pbVariable1^ <> mIFConditionHelpData[iInstance].pbVariable2^;
   
   nCompOperatorLowerThan:
      IF mIFConditionHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ < mIFConditionHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ < mIFConditionHelpData[iInstance].rValue;
      END_IF;      
   
   nCompOperatorLowerEqual:
      IF mIFConditionHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ <= mIFConditionHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ <= mIFConditionHelpData[iInstance].rValue;
      END_IF;
   
   nCompOperatorGreaterThan:
      IF mIFConditionHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ > mIFConditionHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ > mIFConditionHelpData[iInstance].rValue;
      END_IF;
   
   nCompOperatorGreaterEqual:
      IF mIFConditionHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ >= mIFConditionHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mIFConditionHelpData[iInstance].prVariable1^ >= mIFConditionHelpData[iInstance].rValue;
      END_IF;
   
   nCompOperatorModulo:
      var1 := mIFConditionHelpData[iInstance].piVariable1^;
      IF mIFConditionHelpData[iInstance].bDintVar2Used THEN
         var2 := mIFConditionHelpData[iInstance].piVariable2^;
      ELSE
         var2 := mIFConditionHelpData[iInstance].iValue;
      END_IF;
      i := MOD(var1, var2);
      bConditionOk := (i = 0);
   
ELSE
   ; //unknown operator
END_CASE;



@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(68)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bConditionOk := FALSE;

CASE mLoopHelpData[iInstance].Operator OF
   nCompOperatorEqual:
      bConditionOk := mLoopHelpData[iInstance].pbVariable1^ = mLoopHelpData[iInstance].pbVariable2^;
   
   nCompOperatorNotEqual:
      bConditionOk := mLoopHelpData[iInstance].pbVariable1^ <> mLoopHelpData[iInstance].pbVariable2^;
   
   nCompOperatorLowerThan:
      IF mLoopHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ < mLoopHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ < mLoopHelpData[iInstance].rValue;
      END_IF;      
   
   nCompOperatorLowerEqual:
      IF mLoopHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ <= mLoopHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ <= mLoopHelpData[iInstance].rValue;
      END_IF;
   
   nCompOperatorGreaterThan:
      IF mLoopHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ > mLoopHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ > mLoopHelpData[iInstance].rValue;
      END_IF;
   
   nCompOperatorGreaterEqual:
      IF mLoopHelpData[iInstance].bRealVar2Used THEN
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ >= mLoopHelpData[iInstance].prVariable2^;
      ELSE
         bConditionOk := mLoopHelpData[iInstance].prVariable1^ >= mLoopHelpData[iInstance].rValue;
      END_IF;
   
   nCompOperatorModulo:
      IF mLoopHelpData[iInstance].bLoopCounter THEN
         var1 := mLoopHelpData[iInstance].iActCount;
         var2 := sv_LoopParameter[iInstance].iValue; 
      ELSE   
         var1 := mLoopHelpData[iInstance].piVariable1^;
         IF mLoopHelpData[iInstance].bDintVar2Used THEN
            var2 := mLoopHelpData[iInstance].piVariable2^;
         ELSE
            var2 := mLoopHelpData[iInstance].iValue;
         END_IF;
      END_IF;
      
      IF var1 = 0 THEN
         bConditionOk := FALSE;
      ELSE
         i := MOD(var1, var2);
         bConditionOk := (i = 0);
      END_IF;
   
ELSE
   ; //unknown operator
END_CASE;



@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(26)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR iTmpLine := (odcParallelInfo[iColumn].iRow + 1) TO sv_iUsedRows DO
   IF (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveEndIf) THEN
      
      iCount := sv_ODCSequence[iColumn][iTmpLine].iCount;
      mIFConditionHelpData[iCount].iInternalCount := (mIFConditionHelpData[iCount].iInternalCount + 1);
      
      //set step state to "ready"
      fbSetStepState.StepPos.iRow := iTmpLine;
      fbSetStepState.StepPos.iColumn := iColumn;         
      fbSetStepState(StepState := nStateReady);
      
      odcParallelInfo[iColumn].iRow := (iTmpLine + 1);
      odcParallelInfo[iColumn].bStartSent := FALSE;
      odcParallelInfo[iColumn].bStartConditionWarnPrinted := FALSE;
      odcParallelInfo[iColumn].bActivatedChecked := FALSE;
      odcParallelInfo[iColumn].bPosReachedArrayLinked := FALSE;
      odcParallelInfo[iColumn].bMovementReadyArrayLinked := FALSE;
      EXIT;
   END_IF;   
END_FOR;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(22)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR iTmpLine := (odcParallelInfo[iColumn].iRow + 1) TO sv_iUsedRows DO
   IF (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveEndLoop) AND (sv_ODCSequence[iColumn][iTmpLine].iCount = (DINT_TO_INT(iInstance))) THEN
      //set step state to "ready"
      fbSetStepState.StepPos.iRow := iTmpLine;
      fbSetStepState.StepPos.iColumn := iColumn;         
      fbSetStepState(StepState := nStateReady);
      
      odcParallelInfo[iColumn].iRow := (iTmpLine + 1);
      odcParallelInfo[iColumn].bStartSent := FALSE;
      odcParallelInfo[iColumn].bStartConditionWarnPrinted := FALSE;
      odcParallelInfo[iColumn].bActivatedChecked := FALSE;
      odcParallelInfo[iColumn].bPosReachedArrayLinked := FALSE;
      odcParallelInfo[iColumn].bMovementReadyArrayLinked := FALSE;
      EXIT;
   END_IF;   
END_FOR;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(23)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR iTmpLine := (odcParallelInfo[iColumn].iRow - 1) TO 1 BY -1 DO
   IF (sv_ODCSequence[iColumn][iTmpLine].iMoveId = cMoveBeginLoop) AND (sv_ODCSequence[iColumn][iTmpLine].iCount = (DINT_TO_INT(iInstance))) THEN
      
      odcParallelInfo[iColumn].iRow := iTmpLine;
      odcParallelInfo[iColumn].bStartSent := FALSE;
      odcParallelInfo[iColumn].bStartConditionWarnPrinted := FALSE;
      odcParallelInfo[iColumn].bActivatedChecked := FALSE;
      odcParallelInfo[iColumn].bPosReachedArrayLinked := FALSE;
      odcParallelInfo[iColumn].bMovementReadyArrayLinked := FALSE;
      EXIT;
   ELSE
      //reset step states
      fbSetStepState.StepPos.iRow := iTmpLine;
      fbSetStepState.StepPos.iColumn := iColumn;         
      fbSetStepState(StepState := nStateDefault);
   END_IF;
END_FOR;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(432)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//mbFinished removed because otherwise a parallel open tree will not finish
//at the end of the cycle
IF mbFatalError OR mbNormalError (* OR mbFinished *) OR NOT mbActive THEN
   (* do not try to interpret anything if there is a error *)
   RETURN;
END_IF;

fbRTC(EN := FALSE);

FOR i := 1 TO sv_iUsedColumns DO
   IF odcParallelInfo[i].bColumnActive AND NOT odcParallelInfo[i].bDisabled THEN
      (* only try to interpret if the column is active *)
      bIncreaseRow := FALSE;
      bGoToEndIf := FALSE;
      iRow := odcParallelInfo[i].iRow;
      IF iRow < 1 OR iRow > cMaxODCSteps THEN
         //error instruction pointer is wrong
         fbDebugTrace(CONCAT('trying to execute instructions that are out of bounds ',
                             DINT_TO_STRING(iRow), '/', DINT_TO_STRING(i)));
         aStopInterpreterFatal();
         RETURN;
      END_IF;
       
      MoveDir  := sv_ODCSequence[i][iRow].iMoveDir;
      MoveId   := sv_ODCSequence[i][iRow].iMoveId;
      DeviceId.CompId  := sv_ODCSequence[i][iRow].iCompId;
      DeviceId.IndexId := INT_TO_DINT(sv_ODCSequence[i][iRow].iIndexId);
    
      IF (MoveId = cMoveStartParallel) OR (MoveId = cMoveStartParallelOpen) THEN
         //StartParallel / StartParallelOpen must be handled although it is also checked in aIncreaseRow
         //reason / usecase: 
         //SP in column 1 activates column 2  => active step in column 2 will be a StartParallel step !
         bIncreaseRow := TRUE;
      ELSIF MoveId = cMoveEndParallel THEN        
         iJoinsInLine := 0;
         bJoinOK := TRUE;
         bNewSkipAlreadyPosReached := TRUE;
         FOR k := 1 TO sv_iUsedColumns DO
            IF sv_ODCSequence[k][iRow].iMoveId = cMoveEndParallel THEN
               IF iJoinsInLine = 0 AND i <> k THEN
               (* the first join point that is found is not the currently
                  active column, so we are not allowed to join here
                  need to wait for next cycle(and the left most column) to be able to join *)
                  //dummy := Print('at %d/%d can not join in this cycle', iRow, i);
                  bJoinOK := FALSE;
               END_IF;
                  
               iJoinsInLine := iJoinsInLine + 1;
               
               IF (odcParallelInfo[k].iRow <> iRow) AND odcParallelInfo[k].bColumnActive THEN
                  (* one branch not waiting at join point *)
                  bJoinOK := FALSE;
               ELSE
                  bNewSkipAlreadyPosReached := bNewSkipAlreadyPosReached AND odcParallelInfo[k].bSkipAlreadyPosReached;
               END_IF;
            END_IF; // sv_ODCSequence[k][iRow].iMoveId = cMoveEndParallel
         END_FOR;
         
         IF bJoinOK THEN
            (* join conditions OK -> deactivate all columns to the right *)
            bIncreaseRow := TRUE;
            odcParallelInfo[i].bSkipAlreadyPosReached := bNewSkipAlreadyPosReached;
            
            FOR k := 1 TO sv_iUsedColumns DO
               IF k <> i AND sv_ODCSequence[k][iRow].iMoveId = cMoveEndParallel THEN
                  fbSetStepState.StepPos.iRow := iRow;
                  fbSetStepState.StepPos.iColumn := k;
                  fbSetStepState(StepState := nStateReady);
                  (* found a join point on the same row -> we are able to join execution
                  left most branch remains active, right one is disabled *)
                  odcParallelInfo[k].bColumnActive := FALSE;
                  fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iRow), '/', DINT_TO_STRING(i),
                                                        ' join movement -> deactivating column ', DINT_TO_STRING(k)));

               END_IF;
            END_FOR;
         END_IF;
      ELSIF (MoveId = cMoveEndParallelOpen) THEN       
         //endparallelOpen found => check movements and deactivate column and increase row if conditions are ok         
         //search according EP open in this row and check it
         bAllParallelOpenColumnsReady := TRUE;
         FOR k := 2 TO sv_iUsedColumns DO
            IF sv_ODCSequence[k][iRow].iMoveId = cMoveEndParallelOpen THEN
               //check if this column is still active
               IF NOT odcParallelInfo[k].bColumnActive THEN
                  //column is not active (first cycle is active or all parallel open movements are done)
                  //reset step states of all elements in this column (beginning from actual line)
                  FOR iTmpRow := iRow TO miEndRow DO
                     fbSetStepState.StepPos.iColumn := k;
                     fbSetStepState.StepPos.iRow := iTmpRow;
                     fbSetStepState(StepState := nStateDefault);
                  END_FOR;                 
               ELSE
                  bAllParallelOpenColumnsReady := FALSE;
               END_IF;        
            END_IF;
         END_FOR;
         
         IF bAllParallelOpenColumnsReady THEN
            fbDebugTrace2(nODCInterpreter, CONCAT('found fulfilled EndParallelOpen in column ',
                                                 DINT_TO_STRING(i),' -> increase row'));
            bIncreaseRow := TRUE;
         END_IF;
         
      ELSIF (MoveId  = cMoveNone) AND (MoveDir = cMoveNone) AND (DeviceId.CompId = cCompNone) THEN
         bIncreaseRow := TRUE;
         fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iRow), '/',
                                               DINT_TO_STRING(i), ' empty movement'));
   
      ELSIF MoveId = cMoveBeginSequence OR MoveId = cMoveEndSequence THEN
         (* skip begin/end sequence markers *)
         bIncreaseRow := TRUE;
         
      ELSIF MoveId = cMoveStartCondition THEN
         (* start condition *)
         aCheckStartConditionReached(iInstance := sv_ODCSequenceInt[i][iRow].iCount);
         
         //check safety array of startcondition as long as start condition is not reached
         IF NOT aCheckStartConditionReached.bReached THEN
            abODCCheckDependencies.aCheck.StepPos.iColumn := i;
            abODCCheckDependencies.aCheck.StepPos.iRow := iRow;
            
            abODCCheckDependencies.aCheck(DeviceIdSelf := DeviceId);
            IF NOT abODCCheckDependencies.aCheck.bAllowed THEN
               fbDebugTrace2(nODCInterpreter, CONCAT('start condition at pos ', DINT_TO_STRING(iRow),
                                                     '/', DINT_TO_STRING(i),
                                                     ' not allowed by safety calculation'));
               aStopInterpreterError();
            END_IF;   
         END_IF;
         
         bIncreaseRow := aCheckStartConditionReached.bReached;
         
      ELSIF MoveId = cMoveCheckCondition THEN
         (* check condition *)
         aCheckConditionSupervision(iInstance := sv_ODCSequenceInt[i][iRow].iCount);
         bIncreaseRow := aCheckConditionSupervision.bContinue; 
      
      ELSIF (MoveId = cMoveIf) OR (MoveId = cMoveElse) THEN
         (* if or else *)
         aCheckIfCondition(iInstance := sv_ODCSequenceInt[i][iRow].iCount);         
         bIncreaseRow := TRUE;
         IF MoveId = cMoveIf THEN
            //programmed "if"
            bGoToEndIf := NOT aCheckIfCondition.bConditionOk;
         ELSE
            //programmed "else"
            bGoToEndIf := aCheckIfCondition.bConditionOk;
         END_IF;
      ELSIF (MoveId = cMoveBeginLoop) THEN
         //check loop condition
         iInstance := sv_ODCSequenceInt[i][iRow].iCount;
         aCheckLoopCondition(iInstance := iInstance);
         IF aCheckLoopCondition.bConditionOk THEN
            //leave the loop
            bGoToEndLoop := TRUE;
            bIncreaseRow := TRUE;
         ELSE
            //increase loop counter and go to next step
            mLoopHelpData[iInstance].iActCount := mLoopHelpData[iInstance].iActCount + 1;
            bGoToEndLoop := FALSE;
            bIncreaseRow := TRUE;
         END_IF;
      ELSIF (MoveId = cMoveEndLoop) THEN
         iInstance := sv_ODCSequenceInt[i][iRow].iCount;
         aCheckLoopCondition(iInstance := iInstance);
         IF NOT aCheckLoopCondition.bConditionOk AND NOT mbStepMode THEN
            //condition not ok -> go back to start of the loop
            //in step mode the loop is only executed once!
            bGoToBeginLoop := TRUE;
         ELSE
            //reset loop counter
            mLoopHelpData[iInstance].iActCount := 0;
            bGoToBeginLoop := FALSE;
         END_IF;
                 
         bIncreaseRow := TRUE;   
      ELSE
         // "normal movement"         
         (* Flags:
            bIsWaitStep           -> do not start, wait for pos reached
            NOT pbActivated       -> completely skip movement (do not start, do not wait)(checked once when step is activated)
            bContinueWithoutReady -> start, do not wait for ready/pos reached *)          
         
         MoveData := sv_MovementsAvailable[sv_ODCSequenceInt[i][iRow].iMoveNumber].pMovementData;
         
         //check if device/movement is activated
         IF NOT odcParallelInfo[i].bActivatedChecked THEN           
            aCheckActivated(DeviceId := DeviceId,
                            MoveData := MoveData^);
            
            odcParallelInfo[i].bActivated := aCheckActivated.bActivated;
            odcParallelInfo[i].bActivatedChecked := TRUE;
                       
            IF NOT odcParallelInfo[i].bActivated THEN
               //step not activated -> go to next line
               bIncreaseRow := TRUE;
            END_IF;
            
            //check if array with PosReached information is available (for instanceabale movements)
            odcParallelInfo[i].bPosReachedArrayLinked := CHECK_REF(MoveData^.InstanceData.pPosReachedArray^);
            odcParallelInfo[i].bMovementReadyArrayLinked := CHECK_REF(MoveData^.InstanceData.pMovementReadyArray^);
         END_IF; //bActivatedChecked
            
         IF odcParallelInfo[i].bActivated THEN
            (* step is activated *)
            IF odcParallelInfo[i].bSkipAlreadyPosReached THEN
               (* This flag is propagated to new parallel branches
                  and joined (AND) on end of parallel branch
                  Value TRUE:
                  We first check for pos reached
                  - Pos reached: go to the next step
                  - Pos not reached: start movement like we normally do and reset the flag
                    for the current branch
                  Value FALSE:
                  We act normally and start the movement *)
               
               IF odcParallelInfo[i].bPosReachedArrayLinked THEN
                  iInstance := sv_ODCSequenceInt[i][iRow].iCount;
                  IF MoveData^.InstanceData.pPosReachedArray^[iInstance] THEN
                     bIncreaseRow := TRUE;
                  END_IF;
               ELSE
                  fbCheckPosReached(DeviceId := DeviceId,
                                 MoveDir  := MoveDir,
                                 MoveId   := MoveId);
                  IF fbCheckPosReached.bPosReached THEN
                     bIncreaseRow := TRUE;
                  END_IF;
               END_IF;
               
               IF bIncreaseRow THEN
                  fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iRow), '/',
                                          DINT_TO_STRING(i), ' skipping movement ',
                                          DINT_TO_STRING(DeviceId.CompId), '.',
                                          DINT_TO_STRING(DeviceId.IndexId), ' ',
                                          DINT_TO_STRING(MoveId), '/',
                                          DINT_TO_STRING(MoveDir), ' pos:',
                                          DINT_TO_STRING(sv_ODCSequenceInt[i][iRow].iCount),
                                          ' because it already has PosReached TRUE'));
               ELSE
                  (* pos not reached -> start the movement
                  and continue normal execution from here *)
                  fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iRow), '/',
                                    DINT_TO_STRING(i), ' disable skipping PosReached movements ',
                                    DINT_TO_STRING(DeviceId.CompId), '.',
                                    DINT_TO_STRING(DeviceId.IndexId), ' ',
                                    DINT_TO_STRING(MoveId), '/',
                                    DINT_TO_STRING(MoveDir), ' pos:',
                                    DINT_TO_STRING(sv_ODCSequenceInt[i][iRow].iCount),
                                    ' because it has PosReached FALSE'));
                  odcParallelInfo[i].bSkipAlreadyPosReached := FALSE;
               END_IF;
                          
            END_IF;
            
            (* start the movement *)
            IF odcParallelInfo[i].bSkipAlreadyPosReached THEN
               (* bSkipAlreadyPosReached is still set -> the current movement already has PosReached TRUE *)
               (* -> we do not need to start it *)
               ;
            ELSIF MoveData^.bIsWaitStep THEN
               (* do not start movement, just wait for pos reached *)
               odcParallelInfo[i].bStartSent := TRUE;
            
            ELSIF NOT odcParallelInfo[i].bStartSent THEN
               bConditionLinked := CHECK_REF(MoveData^.pbStartConditionReached^);
               IF (bConditionLinked AND MoveData^.pbStartConditionReached^) OR NOT bConditionLinked THEN
                  // pbStartConditionReached reached or not linked -> start movement
                  
                  fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iRow), '/',
                                                         DINT_TO_STRING(i), ' checking dependencies for movement ',
                                                         DINT_TO_STRING(DeviceId.CompId), '.',
                                                         DINT_TO_STRING(DeviceId.IndexId), ' ',
                                                         DINT_TO_STRING(MoveId), '/',
                                                         DINT_TO_STRING(MoveDir)));
                  
                  abODCCheckDependencies.aCheck.StepPos.iColumn := i;
                  abODCCheckDependencies.aCheck.StepPos.iRow := iRow;
                  
                  abODCCheckDependencies.aCheck(DeviceIdSelf := DeviceId);
                  IF NOT abODCCheckDependencies.aCheck.bAllowed THEN
                     (* evCheckLocklist makes sure other alarms(caused by FBLockUnlock for this movement are also set *)
                     evCheckLocklistEventData.DeviceId := DeviceId;
                     evCheckLocklistEventData.MoveId   := MoveId;
                     evCheckLocklistEventData.MoveDir  := MoveDir;
                     fbDebugTrace2(nODCInterpreter, CONCAT('movement ', DINT_TO_STRING(MoveId),
                                                           '/', DINT_TO_STRING(MoveDir),
                                                           ' not allowed by safety calculation -> sending evCheckLocklist to view all other alarms'));
                     SET_EVENT(evCheckLocklist, evCheckLocklistEventData);
                     aStopInterpreterError();
                  ELSE // NOT abODCCheckDependencies.aCheck.bAllowed
                     (* dependencies OK *)
                     fbDebugTrace2(nODCInterpreter, CONCAT('at pos:', DINT_TO_STRING(iRow), '/',
                                                            DINT_TO_STRING(i), ' starting movement ',
                                                            DINT_TO_STRING(DeviceId.CompId), '.',
                                                            DINT_TO_STRING(DeviceId.IndexId), ' ',
                                                            DINT_TO_STRING(MoveId), '/',
                                                            DINT_TO_STRING(MoveDir), ' ',
                                                            DINT_TO_STRING(sv_ODCSequenceInt[i][iRow].iCount)));
                    
                     aAddStartedManualMovement.StepPos.iColumn := i;
                     aAddStartedManualMovement.StepPos.iRow := iRow;
                     aAddStartedManualMovement(DeviceId := DeviceId,
                                                MoveId   := MoveId,
                                                MoveDir  := MoveDir,
                                                iInstance := sv_ODCSequenceInt[i][iRow].iCount);
                        
                        (* try to start the movement *)
                     IF aAddStartedManualMovement.bOK THEN
                        odcParallelInfo[i].bStartSent := TRUE;
                        
                        //save time when start event was sent
                        odcParallelInfo[i].dStartTime := fbRTC.CDT;
                     
                        fbStart(DeviceId := DeviceId,
                                 MoveDir  := MoveDir,
                                 MoveId   := MoveId,
                                 IntermediateCond := sv_ODCSequenceInt[i][iRow].iCount);
                     ELSE
                        aStopInterpreterError();
                     END_IF;
                  END_IF; // NOT fbODCCheckDependencies.bAllowed
                  
                  
               ELSE // (bConditionLinked AND MoveData^.pbStartConditionReached^) OR NOT bConditionLinked
                  IF NOT odcParallelInfo[i].bStartConditionWarnPrinted THEN
                     IF sv_TraceLevel.bODCInterpreter THEN
                        dummy := Print('at pos:%d/%d waiting for pbStartConditionReached before starting movement %d.%d %d/%d',
                                    iRow, i, DeviceId.CompId, DeviceId.IndexId, MoveId, MoveDir);
                     END_IF;
                     odcParallelInfo[i].bStartConditionWarnPrinted := TRUE;
                  END_IF;
               END_IF; // pbStartConditionReached^  
            END_IF; // NOT odcParallelInfo[i].bStartSent

            (* now wait for the movement to finish *)
            IF odcParallelInfo[i].bSkipAlreadyPosReached THEN
               ;            
            ELSIF MoveData^.bIsWaitStep THEN
               (* movement was never started, only wait for pos reached, not for ready
                  otherwise we have a problem when we wait for a certain pos reached
                  but we are still moving to another position
                  (example: mold close, wait for intermediate pos) *)
               IF odcParallelInfo[i].bPosReachedArrayLinked THEN
                  iInstance := sv_ODCSequenceInt[i][iRow].iCount;
                  bIncreaseRow := MoveData^.InstanceData.pPosReachedArray^[iInstance];
               ELSE               
                  fbCheckPosReached(DeviceId := DeviceId,
                                    MoveDir  := MoveDir,
                                    MoveId   := MoveId);
                  IF fbCheckPosReached.bPosReached THEN
                     bIncreaseRow := TRUE;
                  END_IF;
               END_IF;
               
            ELSIF odcParallelInfo[i].bStartSent THEN
               (* start event was sent -> we can now wait for the movement to finish *)
               IF MoveData^.bContinueWithoutReady THEN
                  (* do not wait for the movement to finish, continue immediately
                     useful for air valves *)
                  bIncreaseRow := TRUE;
               ELSE   
                  (* normal movement
                     check if the movement is finished(ready),
                     and if pos is reached(when the movement has a pos reached variable) *)
                  IF MoveData^.bInstanceable AND odcParallelInfo[i].bMovementReadyArrayLinked THEN
                     iInstance := sv_ODCSequenceInt[i][iRow].iCount;
                     bMovementReady := MoveData^.InstanceData.pMovementReadyArray^[iInstance];
                  ELSE
                     fbCheckReady(DeviceId := DeviceId);
                     bMovementReady := fbCheckReady.bReady;
                  END_IF;
                  
                  IF bMovementReady THEN
                     aCheckPosReached(DeviceId := DeviceId,
                                      MoveId := MoveId,
                                      MoveDir := MoveDir,
                                      iColumn := i,
                                      iRow := iRow);
                     
                     IF aCheckPosReached.bPosReachedOk THEN
                        // everything ok -> correct duration and go to next row
                        aCorrectDuration(pMoveData := MoveData,
                                         iColumn := i,
                                         DeviceId := DeviceId);
                     
                        bIncreaseRow := TRUE;
                     END_IF;
                     
                  END_IF; // check ready
               END_IF; // MoveData^.bContinueWithoutReady
            END_IF; // start condition reached
         END_IF; // step activated
      END_IF; //movement ID
    
      IF bIncreaseRow THEN
         // set step state to Ready
         IF sv_ODCSequenceInt[i][odcParallelInfo[i].iRow].StepState <> nStateError THEN
            // do not reset steps with error flag
            IF NOT CHECK_REF(MoveData^) OR NOT MoveData^.bContinueWithoutReady THEN
               fbSetStepState.StepPos.iRow := odcParallelInfo[i].iRow;
               fbSetStepState.StepPos.iColumn := i;         
               fbSetStepState(StepState := nStateReady);
            END_IF;           
         END_IF;         
         
         IF bGoToEndIf THEN
            aGoToEndIf(iColumn := i);
         ELSIF bGoToBeginLoop THEN
            bGoToBeginLoop := FALSE;
            aGoToBeginLoop(iColumn := i, iInstance := sv_ODCSequenceInt[i][iRow].iCount);            
         ELSIF bGoToEndLoop THEN
            bGoToEndLoop := FALSE;
            aGoToEndLoop(iColumn := i, iInstance := sv_ODCSequenceInt[i][iRow].iCount);
         ELSE
            aIncreaseRow(iColumn := i, iEndRow := miEndRow);
         END_IF;        
      END_IF;
   END_IF; //odcParallelInfo[i].bColumnActive
END_FOR;

//interesting for HMI to see state of the interpreter
sv_InterpreterParallelInfo := odcParallelInfo;



@END_Body 

@@@BEG_Comment@@@ 
@TL(6)
Interpret the 2 dimensional ODC array.
(Responsible for auto cycle and combined movements)

This needs to be called cyclically until aStatus.bActive = FALSE
This can happen when the interpreter has reached the end of the array/sequence
or when a error happens during interpreting.
@@@END_Comment@@@ 

@BEG_Body 
@TL(84)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bFound := FALSE;
StepPos.iColumn := 0;
StepPos.iRow := 0;

FOR iTmpRow := SearchStartPos.iRow TO sv_iUsedRows DO
   
   IF iTmpRow = SearchStartPos.iRow THEN
      //start searching in the given column
      iSearchColumn := SearchStartPos.iColumn;
   ELSE
      //start searching in the first column
      iSearchColumn := 1;
   END_IF;
   
   FOR iTmpColumn := iSearchColumn TO sv_iUsedColumns DO
      IF sv_ODCSequence[iTmpColumn][iTmpRow].iCompId = DeviceId.CompId AND
         INT_TO_DINT(sv_ODCSequence[iTmpColumn][iTmpRow].iIndexId) = DeviceId.IndexId THEN
         IF sv_ODCSequence[iTmpColumn][iTmpRow].iMoveId = MoveId AND
            sv_ODCSequence[iTmpColumn][iTmpRow].iMoveDir = MoveDir AND 
            (IntermediateCond = 0 OR // do not care about intermediate condion if we don't search for it?
                                     // FIXME check flag in MoveData instead?? 
             INT_TO_DINT(sv_ODCSequence[iTmpColumn][iTmpRow].iCount) = IntermediateCond) THEN
            fbDebugTrace2(nODCInterpreter, CONCAT('found exact match of MoveId ',
                                                  DINT_TO_STRING(DeviceId.CompId),
                                                  '.',
                                                  DINT_TO_STRING(DeviceId.IndexId),
                                                  ' ',
                                                  DINT_TO_STRING(MoveId),
                                                  '/',
                                                  DINT_TO_STRING(MoveDir),
                                                  ' ',
                                                  DINT_TO_STRING(IntermediateCond),
                                                  ' at pos:',
                                                  DINT_TO_STRING(iTmpRow),
                                                  '/',
                                                  DINT_TO_STRING(iTmpColumn)));

            StepPos.iColumn := iTmpColumn;
            StepPos.iRow := iTmpRow;
            bFound := TRUE;
            RETURN;
               
         ELSIF bAllowNonMatchingId AND sv_ODCSequence[iTmpColumn][iTmpRow].iMoveDir = MoveDir THEN
            fbDebugTrace2(nODCInterpreter, CONCAT('found NON exact match of MoveId ',
                                                  DINT_TO_STRING(DeviceId.CompId),
                                                  '.',
                                                  DINT_TO_STRING(DeviceId.IndexId),
                                                  ' ',
                                                  DINT_TO_STRING(MoveId),
                                                  '/',
                                                  DINT_TO_STRING(MoveDir),
                                                  ' ',
                                                  DINT_TO_STRING(IntermediateCond),
                                                  ' at pos:',
                                                  DINT_TO_STRING(iTmpRow),
                                                  '/',
                                                  DINT_TO_STRING(iTmpColumn)));
            StepPos.iColumn := iTmpColumn;
            StepPos.iRow := iTmpRow;
            bFound := TRUE;
         END_IF;    
      END_IF;
   END_FOR;
END_FOR;

IF NOT bFound THEN
   fbDebugTrace2(nODCInterpreter, CONCAT('movement ',
                                          DINT_TO_STRING(DeviceId.CompId),
                                          '.',
                                          DINT_TO_STRING(DeviceId.IndexId),
                                          ' ',
                                          DINT_TO_STRING(MoveId),
                                          '/',
                                          DINT_TO_STRING(MoveDir),
                                          ' ',
                                          DINT_TO_STRING(IntermediateCond),
                                          ' not found in auto cycle'));
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(10)
Search a Movement in the ODC array by DeviceId, MoveId and MovedDir
and return the position in the array.

If bAllowNonMatchingId is TRUE only DeviceId and MoveDir need to match.
But it still tries to get the best match(MoveId equals)

If IntermediateCond is <> 0, it is also checked against iCount when checking for exact match.

When a movement is found bFound is TRUE and StepPos contains the position
of the movement in the ODC array
@@@END_Comment@@@ 

@BEG_Body 
@TL(18)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbFatalError THEN
   mbFatalError := FALSE;

   (* unlock all movements locked by aStopInterpreterInternal *)
   DeviceIdAll.CompId := cCompAll;
   DeviceIdAll.IndexId := cAllDevIndex;
   
   fbLockUnlock(DeviceId := DeviceIdAll,
               MoveDir  := cMoveAll,
               MoveId   := cMoveAll,
               Mode     := nUnlock);
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
Notify the Interpreter that the array has been reinitialized
(this clears the fatal error flag)
@@@END_Comment@@@ 

@BEG_Body 
@TL(9)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bError := mbFatalError OR mbNormalError;
bFinished := mbFinished;
bActive := mbActive;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
Actual status of the interpreter.
@@@END_Comment@@@ 

@BEG_Body 
@TL(41)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbStepMode := TRUE;

//stop started movements
StartedMovements := sv_StartedManualMovements;
FOR i := 1 TO StartedMovements.iStartedMovements DO
   
   //get move number
   fbGetMoveNumber(DeviceId := StartedMovements.MoveData[i].DeviceId,
                   MoveId := StartedMovements.MoveData[i].MoveId,
                   MoveDir := StartedMovements.MoveData[i].MoveDir,
                   iMoveNumber => iMoveNr);
   
   IF NOT sv_MovementsAvailable[iMoveNr].pMovementData^.bFinishAtInterrupt THEN
      //stop movement
      fbStop(DeviceId := StartedMovements.MoveData[i].DeviceId);
   ELSE
      //movement should finish
      //increase number of active row because otherwise this movement is started
      //again when stepping fwd
      aIncreaseRow(iColumn := StartedMovements.MoveData[i].StepPos.iColumn,
                   iEndRow := miEndRow);
   END_IF;
   
END_FOR;

//disable steps
FOR i := 1 TO cMaxParallelMovements DO
   IF odcParallelInfo[i].bColumnActive THEN
      odcParallelInfo[i].bDisabled := TRUE;
   END_IF;     
END_FOR;

mbActive := FALSE;

sv_InterpreterParallelInfo := odcParallelInfo;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(24)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//reset relevant flags
FOR i := 1 TO cMaxParallelMovements DO
   IF odcParallelInfo[i].bColumnActive THEN
      odcParallelInfo[i].bStartSent := FALSE;
      odcParallelInfo[i].bStartConditionWarnPrinted := FALSE;
      odcParallelInfo[i].bActivatedChecked := FALSE;
      odcParallelInfo[i].bDisabled := FALSE;
   
      //set step state to "active"
      fbSetStepState.StepPos.iColumn := i;
      fbSetStepState.StepPos.iRow := odcParallelInfo[i].iRow;
      fbSetStepState(StepState := nStateActive);
   END_IF;
     
END_FOR;

mbActive := TRUE;
mbStepMode := FALSE;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(23)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//enable steps
FOR i := 1 TO cMaxParallelMovements DO
   IF odcParallelInfo[i].bColumnActive THEN
      odcParallelInfo[i].bDisabled := FALSE;
      odcParallelInfo[i].bStartSent := FALSE;
      odcParallelInfo[i].bStartConditionWarnPrinted := FALSE;
      odcParallelInfo[i].bActivatedChecked := FALSE;
      
      //set step state to "active"
      fbSetStepState.StepPos.iColumn := i;
      fbSetStepState.StepPos.iRow := odcParallelInfo[i].iRow;
      fbSetStepState(StepState := nStateActive);
   END_IF;
     
END_FOR;

mbActive := TRUE;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mbStepMode := FALSE;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(144)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF bStartInActualLine THEN
   iStartRow := odcParallelInfo[iColumn].iRow;
ELSE
   iStartRow := (odcParallelInfo[iColumn].iRow - 1);
END_IF;

//reset step state of actually active step
fbSetStepState.StepPos.iColumn := iColumn;
fbSetStepState.StepPos.iRow := odcParallelInfo[iColumn].iRow;
fbSetStepState(StepState := nStateDefault); 

iNewActivatedColumn := 0;

//get next line with a "real" movement
FOR iTmpLine := iStartRow TO iEndRow BY -1 DO
   fbDebugTrace2(nODCInterpreter, CONCAT('decreasing IP of column ', DINT_TO_STRING(iColumn),
                                         ' to ', DINT_TO_STRING(iTmpLine)));
   
   iMoveId := sv_ODCSequence[iColumn][iTmpLine].iMoveId;
   
   IF (iMoveId = cMoveEndIf) THEN
      // end_if => check if this "if" instance is active or already completely executed
      iCount := sv_ODCSequence[iColumn][iTmpLine].iCount;
      IF (mIFConditionHelpData[iCount].iInternalCount < 2) THEN
         //if or else tree is active
         //set active line in this column to begin of this "if" or "else"
         //so that stepping bwd can continue before this "if / else"         
         FOR iLine := (iTmpLine - 1) TO 1 BY -1 DO
            IF ((sv_ODCSequence[iColumn][iLine].iMoveId = cMoveIf) OR (sv_ODCSequence[iColumn][iLine].iMoveId = cMoveElse)) AND
               (sv_ODCSequence[iColumn][iLine].iCount = iCount) THEN                              
               odcParallelInfo[iColumn].iRow := (iLine - 1);  //set row to "start parallel" step            
               EXIT;
            END_IF;   
         END_FOR;
         mIFConditionHelpData[iCount].iInternalCount := (mIFConditionHelpData[iCount].iInternalCount - 1);
      ELSE
         //condition completely executed -> do not allow stepping into
         odcParallelInfo[iColumn].iRow := (iTmpLine + 1); //set row to "end parallel" step
         odcParallelInfo[iColumn].bDisabled := TRUE;
         SET_ALARM(Name := erNoStepBwdIntoCondition);
      END_IF;
            
      EXIT;
   ELSIF (iMoveId = cMoveEndLoop) THEN   
      // end loop => stop stepping bwd here
      odcParallelInfo[iColumn].iRow := iTmpLine; //set row to "end loop" step
      odcParallelInfo[iColumn].bDisabled := TRUE;
      SET_ALARM(Name := erNoStepBwdIntoLoop);
      EXIT;
   ELSIF (iMoveId = cMoveBeginLoop) THEN
      // begin of loop => stop stepping bwd here (do not modify line number) 
      odcParallelInfo[iColumn].bDisabled := TRUE;
      SET_ALARM(Name := erNoStepBwdOutOfLoop);
      EXIT;   
   ELSIF (iMoveId = cMoveBeginSequence) OR (iMoveId = cMoveEndSequence) THEN
      ; // begin or end sequence
   ELSIF (iMoveId = cMoveNone) OR (iMoveId = cMoveBeginGroup) OR (iMoveId = cMoveEndGroup) THEN
      ; //empty step or begin group / end group   
   ELSIF (iMoveId = cMoveIf) OR (iMoveId = cMoveElse) THEN  
      ; //if , else
   ELSIF iMoveId = cMoveEndParallelOpen THEN
      ; //no special action necessary   
   ELSIF iMoveId = cMoveEndParallel THEN
      //get according column and activate it
      FOR iTmpColumn := (iColumn + 1) TO sv_iUsedColumns DO
         IF sv_ODCSequence[iTmpColumn][iTmpLine].iMoveId = cMoveEndParallel THEN
            odcParallelInfo[iTmpColumn].bColumnActive := TRUE;
            odcParallelInfo[iTmpColumn].iRow := (iTmpLine + 1); //necessary to handle more end parallel in one line
            odcParallelInfo[iTmpColumn].bDisabled := TRUE;
            iNewActivatedColumn := iTmpColumn;
            EXIT;
         END_IF;
      END_FOR;
   ELSIF (iMoveId = cMoveStartParallel) OR (iMoveId = cMoveStartParallelOpen) THEN
      bContinueDecreasing := FALSE;
      FOR iTmpColumn := 1 TO sv_iUsedColumns DO
         IF (sv_ODCSequence[iTmpColumn][iTmpLine].iMoveId = cMoveStartParallel) OR
            (sv_ODCSequence[iTmpColumn][iTmpLine].iMoveId = cMoveStartParallelOpen) THEN
            
            //start parallel or start parallel open found
            IF iTmpColumn < iColumn THEN
               //SP left to actual column found
               //-> deactivate actual column and set line number
               odcParallelInfo[iColumn].iRow := iTmpLine;
               odcParallelInfo[iColumn].bDisabled := FALSE;
               odcParallelInfo[iColumn].bColumnActive := FALSE;
               IF sv_TraceLevel.bODCInterpreter THEN
                  dummy := Print('aDecreaseRow: deactivate column %d ',iColumn);
               END_IF;
            ELSE
               //SP is the most left one in this line
               //-> all SP to the right must be deactivated and their active row must be equal            
               bOk := TRUE;
               FOR x := (iTmpColumn + 1) TO sv_iUsedColumns DO
                  //only consider SP entries
                  IF (sv_ODCSequence[x][iTmpLine].iMoveId = cMoveStartParallel) OR
                     (sv_ODCSequence[x][iTmpLine].iMoveId = cMoveStartParallelOpen) THEN
                     bParallelTreeReady := NOT odcParallelInfo[x].bColumnActive AND (odcParallelInfo[x].iRow = iTmpLine);
                     bOk := bOk AND bParallelTreeReady;
                  END_IF;                  
               END_FOR;
               
               IF bOk THEN
                  //all parallel trees ready -> decrease line of this column so that it can continue
                  bContinueDecreasing := TRUE;
               ELSE                  
                  //column still active -> wait in this line
                  odcParallelInfo[iColumn].iRow := iTmpLine;
                  odcParallelInfo[iColumn].bDisabled := TRUE;
                  bContinueDecreasing := FALSE;
               END_IF;
            END_IF;
            
            EXIT; //exit inner loop
         END_IF;
      END_FOR; 
     
      IF NOT bContinueDecreasing THEN
         EXIT;  // exit outer loop
      END_IF;
   ELSE   
      //valid step found -> set line number and disable this step
      IF sv_TraceLevel.bODCInterpreter THEN
         dummy := Print('///////// set active row of column %d to %d ////////////',iColumn, iTmpLine);
      END_IF;
      odcParallelInfo[iColumn].iRow := iTmpLine;
      odcParallelInfo[iColumn].bDisabled := TRUE;      
      EXIT;
   END_IF;
END_FOR;

odcParallelInfo[iColumn].bStartSent := FALSE;
odcParallelInfo[iColumn].bStartConditionWarnPrinted := FALSE;
odcParallelInfo[iColumn].bActivatedChecked := FALSE;
odcParallelInfo[iColumn].bPosReachedArrayLinked := FALSE;
odcParallelInfo[iColumn].bMovementReadyArrayLinked := FALSE;

sv_InterpreterParallelInfo[iColumn] := odcParallelInfo[iColumn];

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
@@@BEG_Password@@@
NGhzZm9kYzQ=
@@@END_Password@@@
