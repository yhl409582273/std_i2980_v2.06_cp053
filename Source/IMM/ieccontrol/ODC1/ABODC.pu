(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".


*)

IMPORT_OVER_LISTFILE
 SET_ALARM
, START_PROCESS_ALGORITHM
, CHECK_REF
, STOP_PROCESS_ALGORITHM
, FCreateODCVersion
, SET_EVENT
, FGetCatConfigValueString
, cMinMoveIdent
, cCompMold
, cCompEjector
, cMoveBeginSequence
, cMoveEndSequence
, cCompInjection
, cMoveFwd
, cMoveBwd
, cMoveStartParallel
, cMoveEndParallel
, cMoveCooling
, cMoveShake
, cMoveOut
, cMoveNone
, cODCDependencyDontCare
, cCompCore
, cMoveFwdInterPos
, cMaxDeviceMovements
, cMaxODCSteps
, cCompNone
, cMovePlast
, cTimeOutSempahore
, cMaxStartConditions
, cCompOperationMode
, cMoveIncreaseShotCounter
, cMaxMoveDevicesRegistered
, cCycleTimeArraySize
, cAllDevIndex
, cMoveStartCondition
, cMinCompId
, ABInterpreter
, KODC_Builder
, FBGetMoveNumber
, FBAutoManual
, FBDebugTrace
, tsGlbSafetyData
, FBDebugTrace2
, KRTOS_Semaphore
, KODC_Sequence
, tyODCSequenceInternal
, KODC_Movements
, tnOperationMode
, tsStartedMoveDataODCExtended
, tyMovementRegisterList
, tsStartedMoveData
, tsODCDeviceMovementList
, tyODCSequenceBackup
, tnDataState
, tevStopRequest
, tevStartedStopped
, tevStartRequest
, ALARM_EVENT
, tsStartedMoveInfo
, tnODCRecalcMode
, KRTOS_Status
, tyStartCondInstanceData
, tevCheckLocklist
, tsTraceLevel
, tyStartConditionPosArray
, tsDeviceId
, tsActiveSequence
, tyLoopData
, tyODCParallelInfo
, tyStepBwdMovements
, tsSequenceDimension
, tevModifyCycleStartCondition
, tevCycleStart
, tyCycleTime
, ABSequDependencies
, RTC
, KODC_Step
, FBLockUnlock
, FBSetStepState
, tsODCStepPos
, ABODCCheckDependencies
, tMoveIdent
, FBStart
, tevCheckLocklistData
, tevStartRequestData
, tevStopRequestData
, FBStop
, FBCheckPosReached
, tevStartedStoppedData
, tsStartedMoveInfoODCExtended
, ABWaitCycleStart
, KSWO_Status
, ALARM_EVENT_DATA
, tyODCDependencyArray
, TON
, tevModifyCycleStartCondData
, FBAddDependency

END_IMPORT

ALGORITHM_BLOCK ABODC #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_ODCSequence : KODC_Sequence;
 sv_ODCSequenceInt : tyODCSequenceInternal;
 sv_ODCMovements : KODC_Movements;
 sv_dCycleDelaySet : TIME;
 sv_dCycleDelayAct : TIME;
 sv_bFirstCycle : BOOL;
 sv_bInitDone : BOOL;
 sv_bCombinedMovementsInManual : BOOL;
 sv_OperationMode : tnOperationMode;
 sv_StartedManualMovements : tsStartedMoveDataODCExtended;
 sv_MovementsAvailable : tyMovementRegisterList;
 sv_bODCFilesChanged : BOOL;
 sv_bProgramSwitchChanged : BOOL;
 sv_bActivationChanged : BOOL;
 sv_StartedMovements : tsStartedMoveData;
 sv_ODCDeviceMovements : tsODCDeviceMovementList (* list of all devices that registered movements for the ODC *);
 sv_iMovementsAvailable : DINT;
 sv_bAutoCycleRunning : BOOL;
 sv_dMaxCycleTime : TIME;
 sv_dCycleTime : TIME;
 sv_dCycleTimeMachine : TIME (* act. cylce time machine *);
 sv_ODCSequenceGenerateTime : DATE_AND_TIME;
 sv_ODCSequenceBackup : tyODCSequenceBackup;
 sv_iODCSequenceAct : DINT;
 sv_iSequenceToRestore : DINT;
 sv_ODCDescriptionPath : STRING(255);
 sv_DataState : tnDataState;
 sv_iODCSequenceUpdated : DINT;
 sv_iUsedRows : DINT;
 sv_iUsedColumns : DINT;
 sv_iInitOK : DINT (* 0 nothing initialized, 10 sequence array initialized, 20 sequence array + safety initialized *);
 sv_iActiveEditors : DINT;
 sv_StartConditionInstanceData : tyStartCondInstanceData (* list with start condition params for all instances *);
 sv_bUseProgramSwitches : BOOL (* TRUE: create sequence by using program switches; FALSE: use sequence from ODC editor *);
 sv_TraceLevel : tsTraceLevel;
 sv_dCalculatedCycleTime : TIME (* calculated cycle time (written by machine sequencer) *);
 sv_iEditorPropertiesChanged : DINT;
 sv_dAllowedCycleDeviation : TIME;
 sv_dLastCycleTime : TIME;
 sv_bTRUE : BOOL;
 sv_bODCCombinedMoveActive : BOOL (* TRUE: combined movement (for example closing sequence) is active (only in manual mode!) *);
 sv_DeviceId : tsDeviceId;
 sv_bOverrideCoreSafety : BOOL;
 sv_bOverrideEjectorSafety : BOOL;
 sv_ActiveSequence : tsActiveSequence;
 sv_LoopParameter : tyLoopData (* array with data of all programmed loops *);
 sv_InterpreterParallelInfo : tyODCParallelInfo (* internal state information of the interpreter, useful for HMI *);
 sv_bSequenceInterruption : BOOL (* TRUE: sequence is interrupted *);
 di_StepFwd : BOOL;
 di_StepBwd : BOOL;
 sv_bStepBwdActive : BOOL (* TRUE: stepping bwd is active *);
 sv_SequenceDimension : tsSequenceDimension (* contains the maximum size of the sequence array *);
 sv_bRecalcPendingOrActive : BOOL (* The ODC wants to recalc the sequence or a recalc is currently active. Any evStartRequest sent at this time can potentially be ignored if recalculation is already active. *);
END_VAR

SYSTEM_OBJECT
 evStopRequest : tevStopRequest;
 evStartedStopped : tevStartedStopped;
 evStartRequest : tevStartRequest;
 evAlarmFinishCycleAndStop : ALARM_EVENT;
 erODCInitFailed : ALARM;
 erCycleTimeExceeded : ALARM;
 EV_Task_3 : TASK;
 EV_Task_7 : TASK;
 PU_Task_3 : TASK;
 PU_Task_7 : TASK;
 TaskAnalog : TASK;
 TaskMid : TASK;
 erAssert : ALARM;
 TaskSlow : TASK;
 erCompNotInCorrectPosition : ALARM;
 erTeachModeActive : ALARM;
 evCheckLocklist : tevCheckLocklist;
 TaskSequencer : TASK;
 erMovementDuringActiveSequence : ALARM;
 erSequenceDuringActiveMovement : ALARM;
 erMachineSequenceNotCreated : ALARM;
 PU_Task_13 : TASK;
 erNoInverseMovement : ALARM;
 erTooManyStartParallel : ALARM;
 TaskInject : TASK;
 evModifyCycleStartCondition : tevModifyCycleStartCondition;
 evNewCycleStarted : tevCycleStart;
END_OBJECT

VAR_GLOBAL
 MovementsSema : KRTOS_Semaphore (* protects sv_StartedManualMovements *);
END_VAR

VAR_EXTERNAL
 g_SafetyData : tsGlbSafetyData;
 g_iAutoCycleLoopStartLine : DINT;
 g_iAutoCycleLoopEndLine : DINT;
 g_iODCMoveDevicesRegistered : DINT (* number of registered devices with ODC movements  *);
END_VAR

VAR
 abInterpreter : ABInterpreter;
 abKODC_Builder : KODC_Builder;
 fbGetMoveNumber : FBGetMoveNumber;
 fbAutoManual : FBAutoManual;
 fbDebugTrace : FBDebugTrace;
 fbDebugTrace2 : FBDebugTrace2;
 dummy : DINT;
 dummy2 : BOOL;
 mStartedCombinedMovement : tsStartedMoveInfo;
 mRecalcMode : tnODCRecalcMode (* currently active recalc mode, set by aDoPendingRecalc when the ODC decided to start recalculation of the sequence *);
 Status : KRTOS_Status;
 mbStopCycle : BOOL;
 mbStopAfterCycle : BOOL;
 mbCycleTimeRunning : BOOL;
 mbCycleTimeMachineRunning : BOOL (* condition for cycle time machine *);
 mbSequenceChanged : BOOL (* the ODC sequence array possibly changed->need to backup when first started *);
 mbIgnoreProgramSwitchChange : BOOL (* ignore program switch or activation changes during mold data loading *);
 mPendingRecalc : tnODCRecalcMode (* recalculations requested by aSetPendingRecalc but not started yet *);
 mbRecalcActive : BOOL;
 mbEjeBwdAtCycleStart : BOOL (* info if ejector must be bwd at the beginning of the cycle (taken from safety array of first step) *);
 miIndexEjectorInSafetyArray : DINT;
 mStartConditionPosArray : tyStartConditionPosArray (* array with information about the position of each start condition in the internal sequence *);
 mActiveStepBwdMovements : tyStepBwdMovements (* ArrayIndex = column number! *);
 mbResetCycleTime : BOOL;
 mbResetCycleTimeMachine : BOOL;
END_VAR

ALGORITHM aIsAnyColumnActive


VAR_OUTPUT
 bActive : BOOL;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bActive := FALSE;
FOR i := 2 TO sv_iUsedColumns DO
   IF sv_InterpreterParallelInfo[i].bColumnActive THEN
      bActive := TRUE;
      EXIT;
   END_IF;
END_FOR;



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aCheckCycleTime


VAR
 CycleTimeArray : tyCycleTime;
 i : DINT := 1;
 dSum : TIME;
 dAverageCycleTime : TIME;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

CycleTimeArray[i] := sv_dCycleTime;
dSum := dSum + CycleTimeArray[i];
i := i + 1;

IF i > cCycleTimeArraySize THEN      
   //check if cycletime of last x - cycles is stable
   dAverageCycleTime := dSum / cCycleTimeArraySize;
        
   //-> check deviation between average cycle time and calculated cycle time
   IF (SUB_TIME(dAverageCycleTime, sv_dCalculatedCycleTime)) > sv_dAllowedCycleDeviation THEN
      sv_iEditorPropertiesChanged := sv_iEditorPropertiesChanged + 1;
   END_IF;
     
   i := 1;
   dSum := t#0s;
END_IF;
  
   
   


;#END_EDIT_BLOCK END_ALGORITHM

(*
Back up the current sequence (sv_ODCSequence)
A backup is only written when sv_ODCSequence is not equal to the last backup
*)

PROCESS_ALGORITHM paBackupSequence ON TaskSlow

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT mbSequenceChanged THEN
   fbDebugTrace2(nODCInterpreter, 'no sequence backup written as sequence did NOT change');
   STOP_PROCESS_ALGORITHM();
   RETURN;
END_IF;

mbSequenceChanged := FALSE;

IF sv_ODCSequenceBackup[sv_iODCSequenceAct].Sequence = sv_ODCSequence THEN
   fbDebugTrace2(nODCInterpreter, 'ODC sequences equal, doing nothing');
   STOP_PROCESS_ALGORITHM();
   RETURN;
END_IF;
fbDebugTrace2(nODCInterpreter, 'ODC sequences different, making backup');

sv_iODCSequenceAct := sv_iODCSequenceAct + 1;
IF sv_iODCSequenceAct > cODCSequenceBackupCount THEN
   sv_iODCSequenceAct := 1;
END_IF;

//FIXME: maybe do in smaller steps to avoid blocking the system for a long time
fbDebugTrace2(nODCInterpreter, CONCAT('saving new ODC sequence in history at pos ', DINT_TO_STRING(sv_iODCSequenceAct)));

sv_ODCSequenceBackup[sv_iODCSequenceAct].Sequence := sv_ODCSequence;
sv_ODCSequenceBackup[sv_iODCSequenceAct].Date := sv_ODCSequenceGenerateTime;
fbDebugTrace2(nODCInterpreter, 'saving backup done');

STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

(*
Queue a recalculation of the ODC sequence

nODCRecalcReloadFiles reload the ODC files from the CF + nODCRecalcCylce
nODCRecalcCylce       recalculate the cycle(because a program switch changed) + nODCRecalcSafety
nODCRecalcSafety      recalculate safety only(a movement was disabled)
*)

ALGORITHM aSetPendingRecalc


VAR_INPUT
 RecalcMode : tnODCRecalcMode (* How much of the ODC array to recalculate *);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF RecalcMode > mPendingRecalc THEN
   mPendingRecalc := RecalcMode;
   sv_bRecalcPendingOrActive := TRUE;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Start a pending recalculation of the ODC sequence

If bStartedRecalc is TRUE then a pending recalculation was started.

To find out when recalculation finishes wait until mbRecalcActive is FALSE again
*)

ALGORITHM aDoPendingRecalc


VAR_OUTPUT
 bStartedRecalc : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bStartedRecalc := FALSE;

IF mPendingRecalc = nODCRecalcNone THEN
   RETURN;
END_IF;

IF mbRecalcActive THEN
   fbDebugTrace('another ODC recalc is already active, new recalc will be executed later');
   RETURN;
END_IF;

IF mPendingRecalc > mRecalcMode THEN
   mRecalcMode := mPendingRecalc;    
END_IF;
// mRecalcMode will be reset after the recalc finished successfully
// but keeps the value if an error occured
// this way we can be sure the right recalc mode is used when
// the first recalc with nODCRecalcCylce fails and the second recalc with only nODCRecalcSafety succeeds
// the cycle is recalculated, and not only safety

mPendingRecalc := nODCRecalcNone;

IF mRecalcMode = nODCRecalcReloadFiles THEN
   fbDebugTrace2(nODCInterpreter, 'start initializing ODC array WITH reading new files');
ELSIF mRecalcMode = nODCRecalcCylce THEN
   fbDebugTrace2(nODCInterpreter, 'start initializing ODC array WITHOUT reading new files');
ELSIF mRecalcMode = nODCRecalcSafety THEN
   fbDebugTrace2(nODCInterpreter, 'start initializing ODC dependency array');
ELSIF mRecalcMode = nODCRecalcInternal THEN
   fbDebugTrace2(nODCInterpreter, 'start initializing internal ODC array');      
ELSE
   fbDebugTrace2(nODCInterpreter, 'NOT starting initialization of ODC because we got a strange reason');
   RETURN;
END_IF;

bStartedRecalc := TRUE;
mbRecalcActive := TRUE; //set flag immediately, do not wait for PA, which might be delayed a bit because it is low prio
START_PROCESS_ALGORITHM(paInitSequence);


;#END_EDIT_BLOCK END_ALGORITHM

(*
Does the (re)initialisation of the ODC sequence and saves
the sequence generation time

*)

PROCESS_ALGORITHM paInitSequence ON TaskMid


VAR_TEMP
 iTmpRow : DINT;
 iTmpCol : DINT;
 iMove : DINT;
 iDevice : DINT;
 k : DINT;
 i : DINT;
 iTmpCol2 : DINT (* column *);
 iTmpRow2 : DINT (* line *);
END_VAR

VAR
 iCalledInit : DINT;
 iCalledCreate : DINT;
 bInitDone : BOOL;
 abSequDependencies : ABSequDependencies;
 fbRTC : RTC;
 bError : BOOL;
 RecalcMode : tnODCRecalcMode;
 sPath : STRING(255);
 bFirstCall : BOOL;
 sWorkPath : STRING(255);
 iInstance : DINT;
 fbLockUnlockAll : FBLockUnlock := (DeviceId:=(CompId:=cCompAll,IndexId:=cAllDevIndex),MoveDir:=cMoveAll,MoveId:=cMoveAll);
 DeviceId : tsDeviceId;
 bTryAgain : BOOL;
 FailedRecalc : tnODCRecalcMode;
 iCount : INT;
 iOrigEndLine : DINT;
 StepBeginLoop : KODC_Step := (iCompId:=cCompODC,iMoveDir:=cMoveNone,iMoveId:=cMoveBeginLoop,iIndexId:=1,iCount:=1);
 StepEndLoop : KODC_Step := (iCompId:=cCompODC,iMoveDir:=cMoveNone,iMoveId:=cMoveEndLoop,iIndexId:=1,iCount:=1);
 bAddLoop : BOOL;
 iTmp : DINT;
 DeviceIdEjector1 : tsDeviceId := (CompId:=cCompEjector,IndexId:=1);
 DependencyEjectorBwd : LWORD (* dependency which represents "ejector bwd" *);
 bInit : BOOL;
 iNoOfStartParallel : DINT;
END_VAR

VAR CONSTANT
 EmptySequenceEntry : KODC_Step := (iCompId:=cCompNone,iMoveDir:=cMoveNone,iMoveId:=cMoveNone,iIndexId:=1,iCount:=0);
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP SStart:
AStart (P);
AInitAdditionalMoveData (P);
AResetProgrammedInSequence (P);
END_STEP

ACTION AStart: #BEGIN_EDIT_BLOCK
fbDebugTrace2(nODCInterpreter, 'starting initialisation of ODC sequence');

RESET_ALARM(Name := erODCInitFailed);

RecalcMode := mRecalcMode;
FailedRecalc := mRecalcMode;  //remember in case of failed recalc so we can repeat
mRecalcMode := nODCRecalcNone;

sv_iInitOK := 0;

(* lock all movements so nothing can happen during init *)
fbLockUnlockAll.Alarm.AlarmId := erMachineSequenceNotCreated;
fbLockUnlockAll(Mode := nLockAbort);

;#END_EDIT_BLOCK END_ACTION (*AStart*)

(* steps *)
STEP SError:
AError (N);
END_STEP

ACTION AError: #BEGIN_EDIT_BLOCK
fbDebugTrace('initializing ODC array NOT successful');   

(* set the generic erODCInitFailed ALARM which will block machine operation
   for detailed information other alarms are set which explain 1 or more problems
   of the ODC sequence *)
SET_ALARM(Name := erODCInitFailed);

mbRecalcActive := FALSE;

//reset mRecalcMode
//this way a failed recalc can not be replaced by a succeeding recalc
//of lower priority
mRecalcMode := FailedRecalc;

// indicate an update of the odc list so the hmi can react properly
sv_iODCSequenceUpdated := sv_iODCSequenceUpdated + 1;

//notify other code parts when recalc is finished (in this case unsuccessfully)
sv_bRecalcPendingOrActive := FALSE;

STOP_PROCESS_ALGORITHM();

;#END_EDIT_BLOCK END_ACTION (*AError*)
STEP Step28:
END_STEP

STEP SInitSequence:
AInit1 (P);
AInit2 (N);
END_STEP

ACTION AInit1: #BEGIN_EDIT_BLOCK
iCalledInit := 0;
iCalledCreate := 0;

IF NOT bFirstCall THEN
   sWorkPath := FGetCatConfigValueString('System.workPath', '/harddisk0/');
   bFirstCall := TRUE;
END_IF;

sPath := CONCAT(sWorkPath, sv_ODCDescriptionPath);
abKODC_Builder.Init(Movements := sv_ODCMovements, DescriptionFilePath := sPath, Execute := FALSE);

;#END_EDIT_BLOCK END_ACTION (*AInit1*)
ACTION AInit2: #BEGIN_EDIT_BLOCK
abKODC_Builder.Init(Execute := TRUE);
iCalledInit := iCalledInit + 1;

;#END_EDIT_BLOCK END_ACTION (*AInit2*)
STEP SInitSequenceDone:
AInit3 (P);
END_STEP

ACTION AInit3: #BEGIN_EDIT_BLOCK
IF abKODC_Builder.Init.Error AND abKODC_Builder.Init.Done THEN
   fbDebugTrace2(nODCInterpreter, 'ERROR init returned success and failure at the same time');
END_IF;

IF abKODC_Builder.Init.Done THEN
   fbDebugTrace2(nODCInterpreter, CONCAT('called init ',
                                         DINT_TO_STRING(iCalledInit),
                                         ' times then it returned success'));
ELSIF abKODC_Builder.Init.Error THEN    
   fbDebugTrace2(nODCInterpreter, CONCAT('called init ',
                                         DINT_TO_STRING(iCalledInit),
                                         ' times then it returned error'));
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AInit3*)
STEP Step16:
END_STEP

STEP SCreateSequence:
AClearSequence (P);
ACreateSequence1 (P);
ACreateSequence2 (N);
END_STEP

ACTION ACreateSequence1: #BEGIN_EDIT_BLOCK
fbDebugTrace2(nODCInterpreter, 'initialisation of ODC array');
(* WARNING: Columns and Rows must be <= the real size of the array
   otherwise the builder will write outside of the array
   and memory corruption will occur ! *)
abKODC_Builder.CreateSequence(Sequence := sv_ODCSequence, Columns := cMaxParallelMovements, Rows := cMaxODCSteps, Execute := FALSE);

;#END_EDIT_BLOCK END_ACTION (*ACreateSequence1*)
ACTION ACreateSequence2: #BEGIN_EDIT_BLOCK
abKODC_Builder.CreateSequence(Execute := TRUE);
iCalledCreate := iCalledCreate + 1;

;#END_EDIT_BLOCK END_ACTION (*ACreateSequence2*)
STEP SCreateSequenceDone:
ACreateSequence3 (P);
END_STEP

ACTION ACreateSequence3: #BEGIN_EDIT_BLOCK
IF abKODC_Builder.CreateSequence.Error AND abKODC_Builder.CreateSequence.Done THEN
   fbDebugTrace2(nODCInterpreter, 'ERROR CreateSequence returned success and failure at the same time');
END_IF;

IF abKODC_Builder.CreateSequence.Done THEN
   fbDebugTrace2(nODCInterpreter, CONCAT('called CreateSequence ',
                                         DINT_TO_STRING(iCalledCreate),
                                         ' times then it returned success'));
ELSIF abKODC_Builder.CreateSequence.Error THEN    
   fbDebugTrace2(nODCInterpreter, CONCAT('called CreateSequence ',
                                         DINT_TO_STRING(iCalledCreate),
                                         ' times then it returned error'));
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACreateSequence3*)
STEP SSanityCheckAndNumber:
ACheckSequenceDimension (P);
AInitEmptySteps (P);
ASanity (P);
END_STEP

ACTION ASanity: #BEGIN_EDIT_BLOCK
bError := FALSE;
abInterpreter.aCheckSequenceSanity();
IF NOT abInterpreter.aCheckSequenceSanity.bOK THEN
   fbDebugTrace('checking sanity of ODC array failed');
   bError := TRUE;
   RETURN;
END_IF;
bAddLoop := NOT abInterpreter.aCheckSequenceSanity.bAutoCycleLoopFound;
iNoOfStartParallel := abInterpreter.aCheckSequenceSanity.iNoOfStartParallel;

;#END_EDIT_BLOCK END_ACTION (*ASanity*)
STEP Step33:
END_STEP

STEP S_AddCycleLoop:
AInsertAutoCycleLoop (P);
END_STEP

STEP Step32:
ACreateInternalSequence (P);
END_STEP

ACTION ACreateInternalSequence: #BEGIN_EDIT_BLOCK
bError := FALSE;
abInterpreter.aClearInternalSequence();

abInterpreter.aCreateInternalSequence();
IF abInterpreter.aCreateInternalSequence.bError THEN
   fbDebugTrace('aCreateInternalSequence failed');
   bError := TRUE;
   RETURN;
END_IF;

sv_iUsedColumns := abInterpreter.aCreateInternalSequence.iUsedColumns;
sv_iUsedRows := abInterpreter.aCreateInternalSequence.iUsedRows;

// save sequence generation time
fbRTC(EN := FALSE);
sv_ODCSequenceGenerateTime := fbRTC.CDT;
mbSequenceChanged := TRUE;

;#END_EDIT_BLOCK END_ACTION (*ACreateInternalSequence*)
STEP Step26:
AInitSequenceOK (N);
END_STEP

ACTION AInitSequenceOK: #BEGIN_EDIT_BLOCK
sv_iInitOK := 10;

;#END_EDIT_BLOCK END_ACTION (*AInitSequenceOK*)
STEP SBeforeRecalcSafety:
END_STEP

STEP SRecalcSafety:
ACalcSeqDependencies (P);
ASetProgrammedInSequence (P);
END_STEP

ACTION ACalcSeqDependencies: #BEGIN_EDIT_BLOCK
IF iNoOfStartParallel <= cMaxStartParallel THEN
   RESET_ALARM(Name := erTooManyStartParallel);
   abSequDependencies.aCalc();
   IF abSequDependencies.aCalc.bError THEN
      bError := TRUE;
      fbDebugTrace('sequence dependency calculation returned a error');
   END_IF;
ELSE
   SET_ALARM(Name := erTooManyStartParallel);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACalcSeqDependencies*)
STEP S_Check_Pending_Recalc:
ACheckForPendingRecalc (P);
END_STEP

ACTION ACheckForPendingRecalc: #BEGIN_EDIT_BLOCK
bTryAgain := FALSE;
IF mPendingRecalc <> nODCRecalcNone THEN
   //recalc during creation of sequence requested
   //=> ignore result and start again
   mRecalcMode := mPendingRecalc;
   mPendingRecalc := nODCRecalcNone;
   bTryAgain := TRUE; 
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckForPendingRecalc*)
STEP SFinish:
ACheckEjeBwdAtCycleStart (P);
AFinish (N);
END_STEP

ACTION AFinish: #BEGIN_EDIT_BLOCK
(* array ok -> unlock all movements *)
fbLockUnlockAll.Alarm.AlarmId := erMachineSequenceNotCreated;
fbLockUnlockAll(Mode := nUnlock);

abInterpreter.aSetInitOK();
fbDebugTrace2(nODCInterpreter, 'initializing ODC array successful');   

mbRecalcActive := FALSE;

// indicate an update of the odc list so the hmi can react properly
sv_iInitOK := 20;
sv_iODCSequenceUpdated := sv_iODCSequenceUpdated + 1;

//notify other code parts when recalc is finished (and it is OK to send an evStartRequest)
sv_bRecalcPendingOrActive := FALSE;

STOP_PROCESS_ALGORITHM();

;#END_EDIT_BLOCK END_ACTION (*AFinish*)

(* transitions *)
TRANSITION Trans25 (* Trans25 *) FROM SError TO SStart :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans38 (* Trans38 *) FROM SStart TO Step28 :=  #BEGIN_EDIT_BLOCK
RecalcMode <> nODCRecalcInternal
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNewSequenceFromEditor (* Trans39 *) FROM SStart TO SSanityCheckAndNumber :=  #BEGIN_EDIT_BLOCK
RecalcMode = nODCRecalcInternal
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans13 (* Trans13 *) FROM Step28 TO Step16 :=  #BEGIN_EDIT_BLOCK
NOT (RecalcMode >= nODCRecalcReloadFiles)
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TRecalcReloadFiles (* Trans12 *) FROM Step28 TO SInitSequence :=  #BEGIN_EDIT_BLOCK
RecalcMode >= nODCRecalcReloadFiles
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans2 (* Trans2 *) FROM SInitSequence TO SInitSequenceDone :=  #BEGIN_EDIT_BLOCK
abKODC_Builder.Init.Done OR abKODC_Builder.Init.Error
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans11 (* Trans11 *) FROM SInitSequenceDone TO Step16 :=  #BEGIN_EDIT_BLOCK
NOT abKODC_Builder.Init.Error
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans26 (* Trans26 *) FROM SInitSequenceDone TO SError :=  #BEGIN_EDIT_BLOCK
abKODC_Builder.Init.Error
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans20 (* Trans20 *) FROM Step16 TO SBeforeRecalcSafety :=  #BEGIN_EDIT_BLOCK
NOT (RecalcMode >= nODCRecalcCylce)
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TRecalcCycle (* Trans19 *) FROM Step16 TO SCreateSequence :=  #BEGIN_EDIT_BLOCK
RecalcMode >= nODCRecalcCylce
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans4 (* Trans4 *) FROM SCreateSequence TO SCreateSequenceDone :=  #BEGIN_EDIT_BLOCK
abKODC_Builder.CreateSequence.Error OR abKODC_Builder.CreateSequence.Done
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans27 (* Trans27 *) FROM SCreateSequenceDone TO SSanityCheckAndNumber :=  #BEGIN_EDIT_BLOCK
NOT abKODC_Builder.CreateSequence.Error
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans28 (* Trans28 *) FROM SCreateSequenceDone TO SError :=  #BEGIN_EDIT_BLOCK
abKODC_Builder.CreateSequence.Error
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans46 (* Trans46 *) FROM SSanityCheckAndNumber TO Step33 :=  #BEGIN_EDIT_BLOCK
NOT bError
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans50 (* Trans50 *) FROM SSanityCheckAndNumber TO SError :=  #BEGIN_EDIT_BLOCK
bError
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans48 (* Trans48 *) FROM Step33 TO S_AddCycleLoop :=  #BEGIN_EDIT_BLOCK
bAddLoop
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TLoopAdded (* Trans50 *) FROM S_AddCycleLoop TO Step32 :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans49 (* Trans49 *) FROM Step33 TO Step32 :=  #BEGIN_EDIT_BLOCK
NOT bAddLoop
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans14 (* Trans14 *) FROM Step32 TO Step26 :=  #BEGIN_EDIT_BLOCK
NOT bError
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans36 (* Trans36 *) FROM Step26 TO SBeforeRecalcSafety :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans29 (* Trans29 *) FROM Step32 TO SError :=  #BEGIN_EDIT_BLOCK
bError
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans22 (* Trans22 *) FROM SBeforeRecalcSafety TO S_Check_Pending_Recalc :=  #BEGIN_EDIT_BLOCK
NOT (RecalcMode >= nODCRecalcSafety)
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TRecalcSafety (* Trans23 *) FROM SBeforeRecalcSafety TO SRecalcSafety :=  #BEGIN_EDIT_BLOCK
RecalcMode >= nODCRecalcSafety
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans24 (* Trans24 *) FROM SRecalcSafety TO S_Check_Pending_Recalc :=  #BEGIN_EDIT_BLOCK
NOT bError
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans30 (* Trans30 *) FROM SRecalcSafety TO SError :=  #BEGIN_EDIT_BLOCK
bError
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNoRecalc (* Trans44 *) FROM S_Check_Pending_Recalc TO SFinish :=  #BEGIN_EDIT_BLOCK
NOT bTryAgain
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TRecalc (* Trans45 *) FROM S_Check_Pending_Recalc TO SStart :=  #BEGIN_EDIT_BLOCK
bTryAgain
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans8 (* Trans8 *) FROM SFinish TO SStart :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION AClearSequence: #BEGIN_EDIT_BLOCK
(* make sure the array is clean
   important for testing when 2 different partially initialized
   arrays are used *)
FOR iTmpCol := 1 TO cMaxParallelMovements DO
   FOR iTmpRow := 1 TO cMaxODCSteps DO
      sv_ODCSequence[iTmpCol][iTmpRow] := EmptySequenceEntry;
   END_FOR;
END_FOR;

;#END_EDIT_BLOCK END_ACTION (*AClearSequence*)
ACTION AInitAdditionalMoveData: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
IF NOT bInitDone THEN
   
   //get FuIndex of all registered movements
   //fuIndex = index of the device in sv_ODCDeviceMovements
   FOR iMove := 1 TO sv_iMovementsAvailable DO
      FOR iDevice := 1 TO sv_ODCDeviceMovements.iCount DO
         IF sv_MovementsAvailable[iMove].DeviceId = sv_ODCDeviceMovements.Devices[iDevice].DeviceId THEN
            sv_MovementsAvailable[iMove].iFuIndex := iDevice;
            EXIT;
         END_IF;
      END_FOR;  
   END_FOR;
   
   //get number of default movement for every device in sv_ODCDeviceMovements
   FOR iDevice := 1 TO sv_ODCDeviceMovements.iCount DO
      DeviceId := sv_ODCDeviceMovements.Devices[iDevice].DeviceId;
      FOR iMove := 1 TO sv_iMovementsAvailable DO        
         IF sv_MovementsAvailable[iMove].DeviceId = DeviceId AND sv_MovementsAvailable[iMove].pMovementData^.bDefaultPos THEN
            //default movement found
            sv_ODCDeviceMovements.Devices[iDevice].iDefaultMoveNumber := iMove;
            EXIT;
         END_IF;
      END_FOR;   
   END_FOR;
   
   bInitDone := TRUE;
   
END_IF;

   

;#END_EDIT_BLOCK END_ACTION (*AInitAdditionalMoveData*)
ACTION AResetProgrammedInSequence: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF RecalcMode = nODCRecalcNone OR RecalcMode = nODCRecalcSafety THEN
   ;//no change in sequence
ELSE
   //sequence changed -> reset bProgrammedInSequence for all movements
   FOR iMove := 1 TO sv_iMovementsAvailable DO   
      sv_MovementsAvailable[iMove].pMovementData^.bProgrammedInSequence := FALSE;
      
      IF sv_MovementsAvailable[iMove].pMovementData^.bInstanceable AND
        CHECK_REF(sv_MovementsAvailable[iMove].pMovementData^.InstanceData.pProgrammedInSequenceArray^) THEN
         
         //movement instanceable -> init programmed in sequence for all instances
         FOR k:= 1 TO cMaxIntermediateConditions DO
            sv_MovementsAvailable[iMove].pMovementData^.InstanceData.pProgrammedInSequenceArray^[k] := FALSE;
         END_FOR;
                  
      END_IF;
   END_FOR;
   
   //reset array with start condition positions
   FOR i := 1 TO cMaxStartConditions DO
      mStartConditionPosArray[i].iColumn := 0;
      mStartConditionPosArray[i].iRow := 0;
   END_FOR;
END_IF;




;#END_EDIT_BLOCK END_ACTION (*AResetProgrammedInSequence*)
ACTION ASetProgrammedInSequence: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//set bProgrammedInSequence for all movements which are
//included in the created sequence
FOR iTmpRow := 1 TO sv_iUsedRows DO
   FOR iTmpCol := 1 TO sv_iUsedColumns DO
      iMove := sv_ODCSequenceInt[iTmpCol,iTmpRow].iMoveNumber;
      IF iMove >= cMoveNone THEN
         sv_MovementsAvailable[iMove].pMovementData^.bProgrammedInSequence := TRUE;
                  
         IF sv_MovementsAvailable[iMove].pMovementData^.bInstanceable AND 
           CHECK_REF(sv_MovementsAvailable[iMove].pMovementData^.InstanceData.pProgrammedInSequenceArray^) THEN
            //movement instanceable -> set programmed in sequence for according instance
            iInstance := sv_ODCSequenceInt[iTmpCol,iTmpRow].iCount;
            sv_MovementsAvailable[iMove].pMovementData^.InstanceData.pProgrammedInSequenceArray^[iInstance] := TRUE;
         END_IF;
         
      END_IF;
      
      //save position if step is a start condition
      IF sv_ODCSequence[iTmpCol,iTmpRow].iMoveId = cMoveStartCondition THEN
         iCount := sv_ODCSequence[iTmpCol, iTmpRow].iCount; 
         mStartConditionPosArray[iCount].iColumn := iTmpCol;
         mStartConditionPosArray[iCount].iRow := iTmpRow;
      END_IF;
      
   END_FOR;
END_FOR;

;#END_EDIT_BLOCK END_ACTION (*ASetProgrammedInSequence*)
ACTION ACheckEjeBwdAtCycleStart: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//get index of ejector 1 in sv_ODCDeviceMovements
//and also get dependency which represents "Ejector bwd"
IF NOT bInit THEN
   FOR i := 1 TO g_iODCMoveDevicesRegistered DO   
      IF sv_ODCDeviceMovements.Devices[i].DeviceId = DeviceIdEjector1 THEN
         miIndexEjectorInSafetyArray := i;
         
         //find ejector bwd movement
         FOR k := 1 TO sv_ODCDeviceMovements.Devices[miIndexEjectorInSafetyArray].iNumberOfMovements DO
            IF sv_ODCDeviceMovements.Devices[miIndexEjectorInSafetyArray].Movements[k]^.MoveId = cMoveBwd THEN
               
               //movement found in sv_ODCDeviceMovements -> set the according bit               
               DependencyEjectorBwd := cFirstBit;
               
               //first movement: shift right 0, second movement: shift right 1, ... 
               DependencyEjectorBwd := SHR(DependencyEjectorBwd, (k-1));
               EXIT;
            END_IF;
         END_FOR;
         
         EXIT;
      END_IF;
   END_FOR;
   bInit := TRUE;
END_IF;
   
//avoid problems if no ejector is available
mbEjeBwdAtCycleStart := FALSE;
IF miIndexEjectorInSafetyArray > 0 THEN   
   //check dependency array of first step and find out if ejector must be bwd
   IF sv_ODCSequenceInt[1,1].SafetyArray[miIndexEjectorInSafetyArray].Dependency = DependencyEjectorBwd THEN
      mbEjeBwdAtCycleStart := TRUE;
   END_IF;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckEjeBwdAtCycleStart*)
ACTION AInsertAutoCycleLoop: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bODCInterpreter THEN
   dummy := Print('No AutoCycleLoop found ----> add LOOP automatically');
END_IF;

iOrigEndLine := abInterpreter.aCheckSequenceSanity.iEndSequenceRow;
IF sv_TraceLevel.bODCInterpreter THEN
   dummy := Print('original end line: %d', iOrigEndLine);
END_IF;
   
//move line with ODC.EndSequence two lines down
//add ODC.EndLoop before ODC.EndSequence
//move the whole sequence one line down
//add ODC.BeginLoop in second line (first line is ODC.BeginSequence)
//fill sv_LoopData with correct values

FOR iTmpCol2 := 1 TO cMaxParallelMovements DO
   sv_ODCSequence[iTmpCol2,(iOrigEndLine+2)] := sv_ODCSequence[iTmpCol2, iOrigEndLine];
END_FOR;

 
IF sv_TraceLevel.bODCInterpreter THEN
   iTmp := iOrigEndLine +1;
   dummy := Print('Adding end loop in line %d', iTmp);
END_IF;

sv_ODCSequence[1,(iOrigEndLine+1)] := StepEndLoop;
g_iAutoCycleLoopEndLine := (iOrigEndLine+1);

FOR iTmpRow2 := iOrigEndLine TO 2 BY -1 DO
   FOR iTmpCol2 := 1 TO cMaxParallelMovements DO
      sv_ODCSequence[iTmpCol2,iTmpRow2] := sv_ODCSequence[iTmpCol2,(iTmpRow2-1)];
   END_FOR;
END_FOR;

IF sv_TraceLevel.bODCInterpreter THEN   
   dummy := Print('Adding begin loop in line 2');
END_IF;
sv_ODCSequence[1,2] := StepBeginLoop;
g_iAutoCycleLoopStartLine := 2;

sv_LoopParameter[1].sTextKey := 'TxtAutoCycleLoop';
sv_LoopParameter[1].sVariable1 := 'system.sv_bFALSE';
sv_LoopParameter[1].sVariable2 := 'system.sv_bTRUE';
sv_LoopParameter[1].CompareOperator := nCompOperatorEqual;

;#END_EDIT_BLOCK END_ACTION (*AInsertAutoCycleLoop*)
ACTION AInitEmptySteps: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//performance optimization:
//at empty steps the machine sequencer only sets iCompId to cMinCompId
//iMoveId, iMoveDir, ... are not changed and keep the "old" values
//=> this steps must be set to "empty" steps in the IEC code
FOR iTmpCol := 1 TO cMaxParallelMovements DO
   FOR iTmpRow := 1 TO cMaxODCSteps DO
      IF (sv_ODCSequence[iTmpCol][iTmpRow].iCompId = cMinCompId) AND (sv_ODCSequence[iTmpCol][iTmpRow].iMoveId <> cMoveNone) THEN
         //set the whole step to "Empty"
         sv_ODCSequence[iTmpCol][iTmpRow] := EmptySequenceEntry;
      END_IF;
   END_FOR;
END_FOR;

;#END_EDIT_BLOCK END_ACTION (*AInitEmptySteps*)
ACTION ACheckSequenceDimension: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (sv_SequenceDimension.iMaxColumns > 0) AND (sv_SequenceDimension.iMaxRows > 0) THEN
   
   IF sv_SequenceDimension.iMaxColumns < cMaxParallelMovements THEN
      //loaded sequence is smaller (lower number of columns) than the actual sequence
      //-> init the rest of the columns
      FOR iTmpCol := (sv_SequenceDimension.iMaxColumns + 1) TO cMaxParallelMovements DO
         FOR iTmpRow := 1 TO cMaxODCSteps DO
            sv_ODCSequence[iTmpCol][iTmpRow] := EmptySequenceEntry;
         END_FOR;
      END_FOR;
   END_IF;
   
   IF sv_SequenceDimension.iMaxRows < cMaxODCSteps THEN
      //loaded sequence is smaller (lower number of rows) than the actual sequence
      //-> init the rest of the rows
      FOR iTmpCol := 1 TO sv_SequenceDimension.iMaxColumns DO
         FOR iTmpRow := (sv_SequenceDimension.iMaxRows + 1) TO cMaxODCSteps DO
            sv_ODCSequence[iTmpCol][iTmpRow] := EmptySequenceEntry;
         END_FOR;
      END_FOR;
   END_IF;
ELSE   
   ;//loaded data does not contain the sequence dimension (=> data was created with a KePlast version < 01.38) 
   //Attention:
   //It is not possible to automatically assume that the sequence dimension is 6 columns and 100 rows
   //in this case, because maybe in some customer projects the sequence size was already increased in
   //KePlast versions < 01.38
END_IF;

//set dimension to actual implemented array size
sv_SequenceDimension.iMaxColumns := cMaxParallelMovements;
sv_SequenceDimension.iMaxRows := cMaxODCSteps;

;#END_EDIT_BLOCK END_ACTION (*ACheckSequenceDimension*)
(* end sfc-code *)


END_ALGORITHM

ALGORITHM aClearStepState


VAR_INPUT
 bExcludeActiveColumns : BOOL;
END_VAR

VAR_TEMP
 iTmpRow : DINT;
 iTmpColumn : DINT;
END_VAR

VAR
 fbSetStepState : FBSetStepState;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, 'begin clearing step state');

FOR iTmpRow := 1 TO sv_iUsedRows DO
   fbSetStepState.StepState := nStateDefault;
   fbSetStepState.StepPos.iRow := iTmpRow;
   
   FOR iTmpColumn := 1 TO sv_iUsedColumns DO
      fbSetStepState.StepPos.iColumn := iTmpColumn;
      
      IF NOT (bExcludeActiveColumns AND sv_InterpreterParallelInfo[iTmpColumn].bColumnActive) THEN
         //reset step state depending on bExcludeActiceColumns 
         fbSetStepState();
      END_IF;
      
   END_FOR;
END_FOR;

fbDebugTrace2(nODCInterpreter, 'finished clearing step state');


;#END_EDIT_BLOCK END_ALGORITHM

(*
Start a single movement (in response to evStartRequest)
*)

ALGORITHM aStartAndCheckConditions


VAR_INPUT
 StepPos : tsODCStepPos;
 bNoAlarms : BOOL (* TRUE: alarms of not fulfilled conditions are not set *);
END_VAR

VAR_OUTPUT
 bCheckConditionsOk : BOOL;
 bStartConditionOk : BOOL;
 bCheckConditionFound : BOOL;
 iStartConditionsNotOk : DINT (* number of not fulfilled startconditions *);
 iCheckConditionsNotOk : DINT (* number of not fulfilled checkconditions *);
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 abODCCheckDependencies : ABODCCheckDependencies;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// check if a start condition exists for the requested movement
bStartConditionOk := TRUE;
iStartConditionsNotOk := 0;
FOR i := 1 TO cMaxStartConditions DO
   IF sv_ODCSequence[StepPos.iColumn][StepPos.iRow] = sv_StartConditionInstanceData[i].DelayedMovement THEN
      // start condition found -> check if start condition is reached
      abInterpreter.aCheckStartConditionReached(iInstance := i);
      IF NOT abInterpreter.aCheckStartConditionReached.bReached THEN
         IF NOT bNoAlarms THEN
            // set alarm
            SET_ALARM(Name := erCompNotInCorrectPosition,
                      SubID1 := sv_StartConditionInstanceData[i].RelatedMovement.iCompId,
                      SubID2 := sv_StartConditionInstanceData[i].RelatedMovement.iIndexId);
         END_IF;         
         bStartConditionOk := FALSE;
         iStartConditionsNotOk := iStartConditionsNotOk + 1;
      END_IF;            
   ELSIF sv_ODCSequence[StepPos.iColumn][StepPos.iRow] = sv_StartConditionInstanceData[i].RelatedMovement THEN
      //also check if the requested movement is the "RelatedMovement" of a startcondition
      //for example: core in with startpos parallel to mold close
      //if mold close movement is requested, the core must be out until the start position for the core is reached
      
      //check if start condition is reached
      abInterpreter.aCheckStartConditionReached(iInstance := i);
      IF NOT abInterpreter.aCheckStartConditionReached.bReached THEN
         //check safety array
         abODCCheckDependencies.aCheck.StepPos.iColumn := mStartConditionPosArray[i].iColumn;
         abODCCheckDependencies.aCheck.StepPos.iRow := mStartConditionPosArray[i].iRow;
            
         abODCCheckDependencies.aCheck(DeviceIdSelf := sv_DeviceId, bNoAlarmsAndStepState := bNoAlarms);
         IF NOT abODCCheckDependencies.aCheck.bAllowed THEN
            fbDebugTrace2(nODCInterpreter, CONCAT('manual movement at pos ',
                                                   DINT_TO_STRING(StepPos.iRow),
                                                   '/',
                                                   DINT_TO_STRING(StepPos.iColumn),
                                                   ' not allowed because of related startcondition'));
            bStartConditionOk := FALSE;
            iStartConditionsNotOk := iStartConditionsNotOk + 1;
         END_IF;
      END_IF;
   END_IF;
END_FOR;


// check if a check condition exists for the requested movement
bCheckConditionsOk := TRUE;
bCheckConditionFound := FALSE;
iCheckConditionsNotOk := 0;
abInterpreter.aFindCheckCondition(Movement := sv_ODCSequence[StepPos.iColumn][StepPos.iRow],
                                    bFound => bCheckConditionFound); 

IF bCheckConditionFound THEN
   abInterpreter.aCheckConditionsManual(Movement := sv_ODCSequence[StepPos.iColumn][StepPos.iRow], bNoAlarms := bNoAlarms);
   bCheckConditionsOk := abInterpreter.aCheckConditionsManual.bCheckConditionsOk;
   iCheckConditionsNotOk := abInterpreter.aCheckConditionsManual.iConditionsNotOk;
END_IF;




;#END_EDIT_BLOCK END_ALGORITHM

(*
Start a single movement (in response to evStartRequest)

Basically the same movement can occur more than one time in the machine sequence.
If the requested movement is found in the sequence and all conditions are ok, this movement is started.
If one or more conditions (safety conditions, start conditions, check conditions) are not ok, the
algorithm continues searching because possibly the movement is found again and the conditions for this step are ok.

If the movement is not allowed, the movement position with the lowest number of not fulfilled conditions is marked (step state is set)
and tha according alarms are set


*)

ALGORITHM aStartSingleMovement


VAR_INPUT
 DeviceId : tsDeviceId;
 MoveDir : tMoveIdent;
 MoveId : tMoveIdent;
 IntermediateCond : DINT;
 bNeedCheckSafety : BOOL;
END_VAR

VAR_OUTPUT
 bStarted : BOOL;
END_VAR

VAR_TEMP
 StepPos : tsODCStepPos;
 evCheckLocklistEventData : tevCheckLocklistData;
END_VAR

VAR
 fbStart : FBStart;
 abODCCheckDependenciesStart : ABODCCheckDependencies;
 bStartConditionOk : BOOL;
 bCheckConditionsOk : BOOL;
 bCheckConditionFound : BOOL;
 fbSetStepState : FBSetStepState;
 bIgnoreConditions : BOOL;
 bSearchMovement : BOOL;
 bMovementFound : BOOL;
 bMovementAllowed : BOOL;
 TmpStepPos : tsODCStepPos;
 iTmpAlarmCount : DINT;
 StepPosLowestAlarms : tsODCStepPos;
 iAlarmCount : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bStarted := FALSE;
bMovementFound := FALSE;
bSearchMovement := TRUE;
iAlarmCount := 0;
TmpStepPos.iColumn := 1;
TmpStepPos.iRow := 1;

//core and ejector movements should be possible in "override" mode
//no matter if they are programmed in sequence or not
bIgnoreConditions := (((DeviceId.CompId = cCompCore) AND sv_bOverrideCoreSafety)) OR
                     (((DeviceId.CompId = cCompEjector) AND sv_bOverrideEjectorSafety));

WHILE bSearchMovement DO
   
   //search for the requested movement
   abInterpreter.aFindLabel.SearchStartPos := TmpStepPos;
   abInterpreter.aFindLabel(DeviceId := DeviceId, MoveId :=MoveId, MoveDir := MoveDir, IntermediateCond := IntermediateCond, bAllowNonMatchingId := FALSE);
   IF abInterpreter.aFindLabel.bFound THEN
      bMovementFound := TRUE;
      StepPos := abInterpreter.aFindLabel.StepPos;
   ELSE
      //movement not found in sequence
      bSearchMovement := FALSE;
      StepPos.iColumn := 0;
      StepPos.iRow := 0;
   END_IF;
         
   IF abInterpreter.aFindLabel.bFound OR NOT bNeedCheckSafety OR bIgnoreConditions THEN
      //check conditions for this movement
      abODCCheckDependenciesStart.aCheck(StepPos := StepPos, DeviceIdSelf := DeviceId, bNoAlarmsAndStepState := TRUE);
      
      // check existing start conditions and check conditions for the requested movement
      // attention: check is only necessary if sequence is programmed by editor 
      bStartConditionOk := TRUE;
      bCheckConditionsOk := TRUE;
      bCheckConditionFound := FALSE;
      
      IF NOT bIgnoreConditions THEN   
         IF NOT sv_bUseProgramSwitches AND bNeedCheckSafety AND abInterpreter.aFindLabel.bFound THEN
            aStartAndCheckConditions(StepPos := StepPos,
                                     bNoAlarms := TRUE,
                                     bStartConditionOk => bStartConditionOk,
                                     bCheckConditionsOk => bCheckConditionsOk,
                                     bCheckConditionFound => bCheckConditionFound);
         END_IF;
      END_IF;
   
      iTmpAlarmCount := 0;
      IF NOT abODCCheckDependenciesStart.aCheck.bAllowed THEN
         //safety conditions not ok => save number of not fulfilled conditions
         iTmpAlarmCount := abODCCheckDependenciesStart.aCheck.iNotOkCount;
      END_IF;
      
      IF NOT bStartConditionOk THEN
         //start conditions not ok => increment nummber of not fulfilled conditions
         iTmpAlarmCount := iTmpAlarmCount + aStartAndCheckConditions.iStartConditionsNotOk;
      END_IF;
           
      IF NOT bCheckConditionsOk THEN
         //check conditions not ok => increment nummber of not fulfilled conditions
         iTmpAlarmCount := iTmpAlarmCount + aStartAndCheckConditions.iCheckConditionsNotOk;
      END_IF;
            
      //everything OK -> start movement and exit loop      
      IF abODCCheckDependenciesStart.aCheck.bAllowed AND bStartConditionOk AND bCheckConditionsOk THEN
         //movement with correct condition found => start this movement
         abInterpreter.aAddStartedManualMovement(DeviceId := DeviceId, MoveId := MoveId, MoveDir := MoveDir, 
                                                 StepPos := StepPos, iInstance := IntermediateCond);
         IF abInterpreter.aAddStartedManualMovement.bOK THEN
            fbStart(DeviceId := DeviceId, MoveDir := MoveDir, MoveId := MoveId, IntermediateCond := IntermediateCond);
            bStarted := TRUE;
            
            //set step state to active
            IF (StepPos.iColumn <> 0) AND (StepPos.iRow <> 0) THEN
               fbSetStepState(StepPos := StepPos,
                              StepState := nStateActive);
            END_IF;
         END_IF;
         
         IF bCheckConditionFound THEN
            START_PROCESS_ALGORITHM(paCheckConditionsManual);
         END_IF;
         
         IF NOT abInterpreter.aFindLabel.bFound THEN
            fbDebugTrace2(nODCInterpreter, 'Manual Movement started anyway because it is not safety relevant');   
         END_IF;
         
         bSearchMovement := FALSE;
         bMovementAllowed := TRUE;
         RETURN; // ******  exit algorithm *******
      ELSE
         //check number of not fulfilled conditions
         IF (iAlarmCount = 0) OR (iTmpAlarmCount < iAlarmCount) THEN
            //save this step
            StepPosLowestAlarms := StepPos;
            iAlarmCount := iTmpAlarmCount;
            iTmpAlarmCount := 0;
         END_IF;
         
         //save this position (needed as startposition of next search)
         //attention: iColumn must be increased otherwise always the same step will be found
         TmpStepPos.iColumn := StepPos.iColumn + 1;
         TmpStepPos.iRow := StepPos.iRow;
         bMovementAllowed := FALSE;
      END_IF;
   END_IF;  //end_if aFindLabel.bFound
   
END_WHILE;

IF NOT bMovementFound THEN
   fbDebugTrace2(nODCInterpreter, 'Manual Movement not started because movement is safety relevant but not in ODC');
ELSIF NOT bMovementAllowed THEN   
   //use step which causes the lowest number of alarms   
   //call dependency check again to set the according alarms
   abODCCheckDependenciesStart.aCheck(StepPos := StepPosLowestAlarms, DeviceIdSelf := DeviceId, bNoAlarmsAndStepState := FALSE);
   
   //set alarms related to start and check conditions
   aStartAndCheckConditions(StepPos := StepPosLowestAlarms,
                            bNoAlarms := FALSE,
                            bStartConditionOk => bStartConditionOk,
                            bCheckConditionsOk => bCheckConditionsOk,
                            bCheckConditionFound => bCheckConditionFound);
   
   //set step state to error
   fbSetStepState(StepPos := StepPosLowestAlarms, StepState := nStateError); 
   
   //evCheckLocklist makes sure other alarms(caused by FBLockUnlock for this movement are also set *)
   fbDebugTrace2(nODCInterpreter, CONCAT('Manual Movement ', DINT_TO_STRING(MoveId),
                                          '/', DINT_TO_STRING(MoveDir),
                                          ' not started because safety conditions do not allow it -> sending evCheckLocklist to view all other alarms'));
   evCheckLocklistEventData.DeviceId := DeviceId;
   evCheckLocklistEventData.MoveId   := MoveId;
   evCheckLocklistEventData.MoveDir  := MoveDir;   
   SET_EVENT(evCheckLocklist, evCheckLocklistEventData);
   
   IF NOT bStartConditionOk THEN
      fbDebugTrace2(nODCInterpreter, 'Manual Movement not started because start condition not ok');
   END_IF;
   
   IF NOT bCheckConditionsOk THEN
      fbDebugTrace2(nODCInterpreter, 'Manual Movement not started because check condition not ok');
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Start a combined movement (in response to evStartRequest)
*)

ALGORITHM aStartCombinedMovement


VAR_INPUT
 DeviceId : tsDeviceId;
 MoveDir : tMoveIdent;
 MoveId : tMoveIdent;
END_VAR

VAR_OUTPUT
 bNotFound : BOOL;
END_VAR

VAR_TEMP
 StartPos : tsODCStepPos;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bNotFound := FALSE;

(* find start label *)
abInterpreter.aFindLabel.SearchStartPos.iColumn := 1;
abInterpreter.aFindLabel.SearchStartPos.iRow := 1;
abInterpreter.aFindLabel(DeviceId := DeviceId,
                         MoveId := cMoveBeginSequence,
                         MoveDir := MoveDir,
                         IntermediateCond := 0,
                         bAllowNonMatchingId := FALSE);
IF NOT abInterpreter.aFindLabel.bFound THEN
   fbDebugTrace2(nODCInterpreter, 'combined movement -> start label not found -> will try to start single movement');
   bNotFound := TRUE;
   RETURN;
END_IF;

StartPos := abInterpreter.aFindLabel.StepPos;

(* find end of label *)
abInterpreter.aFindLabel(DeviceId := DeviceId,
                         MoveId := cMoveEndSequence,
                         MoveDir := MoveDir,
                         IntermediateCond := 0,
                         bAllowNonMatchingId := FALSE);
IF NOT abInterpreter.aFindLabel.bFound THEN
   fbDebugTrace2(nODCInterpreter, 'combined movement -> end label not found -> will try to start single movement');
   bNotFound := TRUE;
   RETURN;
END_IF;

// save active sequence (for highlighting in machine sequencer)
sv_ActiveSequence.DeviceId := DeviceId;
sv_ActiveSequence.MoveDir := MoveDir;
sv_ActiveSequence.iCount :=  sv_ActiveSequence.iCount + 1;
sv_ActiveSequence.bActive := TRUE;

(* remember for later so we can stop combined movements *)
mStartedCombinedMovement.DeviceId := DeviceId;
mStartedCombinedMovement.MoveId   := MoveId;
mStartedCombinedMovement.MoveDir  := MoveDir;

abInterpreter.aInitInterpreter(iColumn := StartPos.iColumn,
                               iRow := StartPos.iRow,
                               iEndRow := abInterpreter.aFindLabel.StepPos.iRow,
                               bSkipAlreadyPosReached := TRUE,
                               bExcludeActiveColumns := FALSE);

(* paRunManualCombinedMovement stops itself when interpreter is not active anymore *)
START_PROCESS_ALGORITHM(paRunManualCombinedMovement);



;#END_EDIT_BLOCK END_ALGORITHM

(*
Handle evStartRequest(manual buttons)
start requests will be ignored in the following situations:
- sequence array not initialized completely 
  (startup or creation of new sequence in progress, creation of sequence failed)
- machine running in half or fullauto cycle
- teachmode in machine sequencer is active
*)

EVENT_ALGORITHM evaStartRequest ON EV_Task_3(23) WITH evStartRequest


VAR_INPUT
 evStartRequestData : tevStartRequestData;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 StartRequestData : tevStartRequestData;
 bCheckSafety : BOOL;
 iSafety : DINT;
 bCombined : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbRecalcActive THEN
   //Ignore start requests if a cycle recalc is active.
   //This flag is set by aDoPendingRecalc() before the low priority paInitSequence actually starts executing code
   //This is necessary to avoid problems where a recalc and a movement start happen at the same cycle
   fbDebugTrace2(nDeviceState, 'evStartRequest ignored because sequence is being recalculated');
   RETURN;
END_IF;

IF sv_iInitOK <> 20 THEN
   //ignore start requests if array is not initialized completely
   //this can happen during startup and during creation of a new sequence
   //or if creation of a sequence failed
   fbDebugTrace2(nDeviceState, 'evStartRequest ignored because sequence not initialized');
   RETURN; 
END_IF;

IF sv_OperationMode >= nHalfAutomatic THEN
   IF sv_bSequenceInterruption THEN
      //sequence is actually interrupted -> find out if it is allowed to start this movement
      fbGetMoveNumber(DeviceId := evStartRequestData.DeviceId,
                     MoveDir := evStartRequestData.MoveDir,
                     MoveId := evStartRequestData.MoveId);
      
      IF fbGetMoveNumber.bFound THEN
         IF sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pMovementData^.bAllowedDuringInterrupt THEN
            //try to start this movement
            aStartSingleMovement(DeviceId := evStartRequestData.DeviceId,
                                 MoveDir := evStartRequestData.MoveDir,
                                 MoveId := evStartRequestData.MoveId,
                                 IntermediateCond := evStartRequestData.IntermediateCond,
                                 bNeedCheckSafety := FALSE);
         END_IF;
      END_IF;        
   ELSE
      //ignore start requests if operation mode is half or full automatic
      fbDebugTrace2(nDeviceState, 'evStartRequest ignored because in half or full auto mode');
   END_IF;
   
   RETURN; // return here
END_IF;

IF sv_iActiveEditors > 0 THEN
   //teach mode active -> ignore start requests
   SET_ALARM(Name := erTeachModeActive);
   RETURN;
END_IF;    

StartRequestData := evStartRequestData;

// work with StartRequest
fbGetMoveNumber(DeviceId := StartRequestData.DeviceId,
                MoveDir := StartRequestData.MoveDir,
                MoveId := StartRequestData.MoveId);

IF fbGetMoveNumber.bFound THEN
   iSafety := sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pMovementData^.iSafetyIdentifier;
   (* FIXME: always set the intermediate condition to 0 when movement does not have intermediate conditions
      needed for searching the movement
   *)
   IF NOT sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pMovementData^.bInstanceable THEN
      StartRequestData.IntermediateCond := 0;
   END_IF;
ELSE
   fbDebugTrace2(nODCInterpreter, 'could not find movement -> assuming movement is safety relevant');
   iSafety := 1;
END_IF;

IF iSafety = 1 THEN
   bCheckSafety := TRUE;
   fbDebugTrace2(nODCInterpreter, 'movement is safety relevant (sequence safety and mold safety (safety editor)');
ELSIF iSafety = 3 THEN 
   bCheckSafety := TRUE;
   fbDebugTrace2(nODCInterpreter, 'movement is safety relevant (sequence safety only - no mold safety (safety editor)');
ELSIF iSafety = 2 THEN
   // only check pos reached of other movements, movement itself is not safety relevant
   bCheckSafety := TRUE;
   fbDebugTrace2(nODCInterpreter, 'movement is partially safety relevant');
ELSIF iSafety = 0 THEN    
   bCheckSafety := FALSE;
   fbDebugTrace2(nODCInterpreter, 'movement is NOT safety relevant');
ELSE
   bCheckSafety := TRUE;
   fbDebugTrace(CONCAT('strange safety relevance value ', DINT_TO_STRING(iSafety)));
END_IF;

abInterpreter.aStatus();
IF abInterpreter.aStatus.bActive THEN
   fbDebugTrace2(nODCInterpreter, 'manual movement not started because there is already a combined movement active');
   
   SET_ALARM(Name := erMovementDuringActiveSequence,
             SubID1 := StartRequestData.DeviceId.CompId,
             SubID2 := StartRequestData.MoveId,
             SubID3 := mStartedCombinedMovement.DeviceId.CompId,
             SubID4 := mStartedCombinedMovement.MoveId,
             Param1 := DINT_TO_STRING(StartRequestData.DeviceId.IndexId));
   RETURN;
END_IF;

(* Rules:
 * When a combined movement is active no other movement may be started
 * When any movement is active no combined movement may be started
 * Autopurge counts as 1 or more movementy so the above rule covers this already
   -> single movements are allowed during autopurge
 * When operation mode is setup, combined movement are never started(only single movemets *)

IF sv_bCombinedMovementsInManual AND (StartRequestData.MoveId = cMoveBeginSequence) THEN
   IF sv_OperationMode = nSetup THEN
      fbDebugTrace2(nODCInterpreter, 'starting a combined movement in setup mode is not allowed');
      RETURN;
   END_IF;
   bCombined := TRUE;
ELSIF sv_bCombinedMovementsInManual AND (sv_OperationMode = nManual) AND
   (* combined movements are not allowed in setup mode *)
   (StartRequestData.DeviceId.CompId = cCompMold AND
   ((StartRequestData.MoveDir = cMoveFwd OR
    StartRequestData.MoveDir = cMoveBwd))
   OR 
   (StartRequestData.DeviceId.CompId = cCompInjection AND  
   (StartRequestData.MoveId = cMoveInject OR
    StartRequestData.MoveId = cMoveCombinedPlast))) THEN
   //this check is for MoveId as plasticize, decompress and intrusion have MoveDir = cMoveBwd
   bCombined := TRUE;
ELSE
   bCombined := FALSE;
   
   //check if  requested device is activated
   FOR i := 1 TO sv_ODCDeviceMovements.iCount DO
      IF sv_ODCDeviceMovements.Devices[i].DeviceId = StartRequestData.DeviceId THEN
         IF NOT sv_ODCDeviceMovements.Devices[i].pbDeviceActivated^ THEN
            fbDebugTrace2(nODCInterpreter, 'start request ignored because device is not activated');
            RETURN;
         END_IF;       
         EXIT;
      END_IF;
   END_FOR;
END_IF;

IF sv_StartedMovements.iStartedMovements <> 0 AND bCombined THEN
   fbDebugTrace2(nODCInterpreter, 'combined manual movement not started because there is already a movement active');
   
   SET_ALARM(Name := erSequenceDuringActiveMovement,
             SubID1 := StartRequestData.DeviceId.CompId,
             SubID2 := StartRequestData.DeviceId.IndexId,
             SubID3 := StartRequestData.MoveId);
   RETURN;
END_IF;

(* back up sequence when a movement is started
   and the sequence has changed *)
START_PROCESS_ALGORITHM(paBackupSequence);

IF bCombined THEN
   fbDebugTrace2(nODCInterpreter, 'evStartRequest -> starting a combined movement');
   aClearStepState(FALSE);
   aStartCombinedMovement(DeviceId := StartRequestData.DeviceId,
                          MoveDir := StartRequestData.MoveDir,
                          MoveId := StartRequestData.MoveId);
END_IF;

IF NOT bCombined OR aStartCombinedMovement.bNotFound THEN
   (* if combined movement markers were not found start single movement *)
   IF (StartRequestData.MoveId = cMoveBeginSequence) THEN
      //do not try to start a single movement if a start request for
      //cMoveBeginSequence was received and this sequence was not found
      fbDebugTrace2(nODCInterpreter, 'requested combined movement not found');      
   ELSE
      fbDebugTrace2(nODCInterpreter, 'evStartRequest -> starting a single movement');
      aStartSingleMovement(DeviceId := StartRequestData.DeviceId,
                           MoveDir := StartRequestData.MoveDir,
                           MoveId := StartRequestData.MoveId,
                           IntermediateCond := StartRequestData.IntermediateCond,
                           bNeedCheckSafety := bCheckSafety);   
   END_IF;   
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Handle evStopRequest(manual buttons)
Stop single and combined movements
*)

EVENT_ALGORITHM evaStopRequest ON EV_Task_3 WITH evStopRequest


VAR_INPUT
 evStopRequestData : tevStopRequestData;
END_VAR

VAR
 fbStop : FBStop;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bInitDone THEN
   //ignore stop requests before sv_bInitDone
   fbDebugTrace2(nDeviceState, 'evStopRequest ignored because sv_bInitDone is not TRUE');
   RETURN;
END_IF;

IF (sv_OperationMode >= nHalfAutomatic) AND NOT sv_bSequenceInterruption THEN
   //ignore stop requests if operation mode is half or full automatic
   //stop requests for movements which were started during sequence interruption
   //must be handled
   fbDebugTrace2(nDeviceState, 'evStopRequest ignored because in half or full auto mode');
   RETURN;
END_IF;


abInterpreter.aStatus();
IF abInterpreter.aStatus.bActive THEN
   IF mStartedCombinedMovement.DeviceId = evStopRequestData.DeviceId AND
      mStartedCombinedMovement.MoveId = evStopRequestData.MoveId AND
      mStartedCombinedMovement.MoveDir = evStopRequestData.MoveDir THEN
      // we get a stop request for the combined movement
      // so stop it
      fbDebugTrace2(nDeviceState, 'evStopRequest while interpreter is active -> aStopInterpreterNormal()');
      abInterpreter.aStopInterpreterNormal();
      sv_ActiveSequence.bActive := FALSE;
   ELSE
      // we get a stop request for a single movement
      // but a combined movement is active
      // but no single movements are allowed during a combined movement
      // -> ignore the event
      fbDebugTrace2(nDeviceState, 'evStopRequest ignored because combined movement is active and device/movement does not match');
   END_IF;
ELSE
   fbDebugTrace2(nDeviceState, 'evStopRequest while interpreter is inactiveactive -> fbStop()');
   // it is also possible that the interpreter already finished the combined movement
   // we still send a evStop, but that does not cause ony problems
   fbStop(DeviceId := evStopRequestData.DeviceId);
   sv_ActiveSequence.bActive := FALSE;
END_IF;


// no movenumber available, clear all
g_SafetyData.MovementToActivate := 0;         


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aDecreaseLineNumber


VAR_INPUT
 DeviceId : tsDeviceId;
 MoveId : tMoveIdent;
 MoveDir : tMoveIdent;
END_VAR

VAR_TEMP
 iTmpColumn : DINT;
 i : DINT;
END_VAR

VAR
 fbCheckPosReached : FBCheckPosReached;
 dummy : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO sv_iUsedColumns DO
   IF (mActiveStepBwdMovements[i].DeviceId = DeviceId) AND
      (mActiveStepBwdMovements[i].MoveId = MoveId) AND
      (mActiveStepBwdMovements[i].MoveDir = MoveDir) THEN
      
      //check posReached flag
      fbCheckPosReached(DeviceId := DeviceId,
                        MoveDir := MoveDir,
                        MoveId := MoveId);
      
      IF CHECK_REF(fbCheckPosReached.pbPosReached^) AND NOT fbCheckPosReached.pbPosReached^ THEN
         ;//endposition not reached -> do not decrease line number
      ELSE
         //endposition reached or no posReached flag available -> decrease row
         iTmpColumn := i;
         REPEAT               
            IF sv_TraceLevel.bODCInterpreter THEN
               dummy := Print('call abInterpreter.aDecreaseRow with iColumn = %d', iTmpColumn);
            END_IF;
            abInterpreter.aDecreaseRow(bStartInActualLine := FALSE,
                                       iColumn := iTmpColumn,
                                       iEndRow := 1);
            iTmpColumn := abInterpreter.aDecreaseRow.iNewActivatedColumn;
            
         UNTIL (abInterpreter.aDecreaseRow.iNewActivatedColumn = 0)
         END_REPEAT;
      END_IF;
      
      //init this element
      mActiveStepBwdMovements[i].DeviceId.CompId := cCompNone;
      mActiveStepBwdMovements[i].DeviceId.IndexId := 1;
      mActiveStepBwdMovements[i].MoveId := cMinMoveIdent;
      mActiveStepBwdMovements[i].MoveDir := cMoveNone;
      
      EXIT;
   END_IF;      
END_FOR;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Manage list and count of currently started movments
in sv_StartedMovements when receiving evStartedStopped events
*)

EVENT_ALGORITHM evaStartedStopped ON EV_Task_3 WITH evStartedStopped


VAR_INPUT
 evStartedStoppedData : tevStartedStoppedData;
END_VAR

VAR_TEMP
 tmpMovement : tsStartedMoveInfoODCExtended;
 i : DINT;
 stepPos : tsODCStepPos;
 idx : DINT;
END_VAR

VAR
 bFound : BOOL;
 fbSetStepState : FBSetStepState;
 bCorrectInstance : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF evStartedStoppedData.State = nStopped OR  evStartedStoppedData.State = nStartNotAllowed THEN
   bFound := FALSE;
   // movement was stopped or never started
   // remove movement from list with started movements
   
   Status := MovementsSema.Wait(WaitTime := cTimeOutSempahore);
   IF Status <> KRTOS_Status_OK THEN
      dummy2 := ASSERT(FALSE, erAssert);
      RETURN;
   END_IF;
   
   FOR i := 1 TO sv_StartedManualMovements.iStartedMovements DO
      
      bCorrectInstance := (evStartedStoppedData.iInstance = 0) OR (evStartedStoppedData.iInstance = sv_StartedManualMovements.MoveData[i].iInstance);
      IF sv_StartedManualMovements.MoveData[i].DeviceId = evStartedStoppedData.DeviceId AND
         sv_StartedManualMovements.MoveData[i].MoveDir = evStartedStoppedData.MoveDir AND
         sv_StartedManualMovements.MoveData[i].MoveId = evStartedStoppedData.MoveId AND bCorrectInstance THEN
         
         stepPos := sv_StartedManualMovements.MoveData[i].StepPos;
         IF (g_SafetyData.bAvailable) THEN
            IF (NOT((stepPos.iColumn = 0) OR (stepPos.iRow = 0)))THEN
               idx := sv_MovementsAvailable[sv_ODCSequenceInt[stepPos.iColumn][stepPos.iRow].iMoveNumber].iODCSafetyMovementsEntry;
               IF (idx > 0) THEN
                  g_SafetyData.MovementToActivate := g_SafetyData.MovementToActivate AND (NOT SHL(1, idx-1));                       
               END_IF;
            END_IF;         
         END_IF;
                 
         IF (NOT((stepPos.iColumn = 0) OR (stepPos.iRow = 0)))THEN                       
            //only correct step sate if actual state is not error
            IF sv_ODCSequenceInt[stepPos.iColumn, stepPos.iRow].StepState <> nStateError THEN
               fbSetStepState(StepPos := sv_StartedManualMovements.MoveData[i].StepPos,
                           StepState := nStateReady);
            END_IF;
                               
         END_IF;
                  
         IF sv_TraceLevel.bODCInterpreter THEN
            dummy := Print('removing started manual movement %d.%d %d/%d', evStartedStoppedData.DeviceId.CompId, evStartedStoppedData.DeviceId.IndexId, evStartedStoppedData.MoveId, evStartedStoppedData.MoveDir);
         END_IF;
         
         //copy last entry in the list to this empty field
         sv_StartedManualMovements.MoveData[i] := sv_StartedManualMovements.MoveData[sv_StartedManualMovements.iStartedMovements];
         
         //zero last entry
         tmpMovement.DeviceId.CompId := cCompNone;
         tmpMovement.DeviceId.IndexId := 1;
         tmpMovement.MoveDir := cMoveNone;
         tmpMovement.MoveId := cMinMoveIdent;
         tmpMovement.StepPos.iColumn := 0;
         tmpMovement.StepPos.iRow := 0;
         tmpMovement.iInstance := 0;
         sv_StartedManualMovements.MoveData[sv_StartedManualMovements.iStartedMovements] := tmpMovement;
         
         sv_StartedManualMovements.iStartedMovements := sv_StartedManualMovements.iStartedMovements - 1;
         //fbDebugTrace2(nODCInterpreter, 'end removing started manual movement');
         bFound := TRUE;
         EXIT;
      END_IF;
   END_FOR;

   Status := MovementsSema.Put();
   IF Status <> KRTOS_Status_OK THEN
      dummy2 := ASSERT(FALSE, erAssert);
   END_IF;
   
   IF sv_bSequenceInterruption THEN
      //started / stopped event during sequence is interrupted
      //-> check if line number should be decreased
      aDecreaseLineNumber(DeviceId := evStartedStoppedData.DeviceId,
                          MoveId := evStartedStoppedData.MoveId,
                          MoveDir := evStartedStoppedData.MoveDir);
   END_IF;
   
   IF NOT bFound THEN
      IF sv_TraceLevel.bODCInterpreter THEN
         dummy := Print('tried to remove stopped movement, but not in list anymore???');
      END_IF;
   END_IF;
END_IF;

 





;#END_EDIT_BLOCK END_ALGORITHM

(*
Start / stop paCyclicConditionCheck depending on
if there are started movements.
*)

POSTUPDATE_ALGORITHM pStartedMovements ON PU_Task_3 WITH sv_StartedManualMovements.iStartedMovements

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_StartedManualMovements.iStartedMovements = 0 THEN
   STOP_PROCESS_ALGORITHM(paCyclicConditionCheck);
   STOP_PROCESS_ALGORITHM(paCheckConditionsManual);
   
   abInterpreter.aStatus();
   IF sv_OperationMode <= nManual AND NOT abInterpreter.aStatus.bActive THEN
      (* the last single manual movement was stopped -> recalculate if needed *)
      aDoPendingRecalc();
      IF aDoPendingRecalc.bStartedRecalc THEN
         fbDebugTrace2(nDeviceState, 'recalc because iStartedMovements = 0');
      END_IF;
   END_IF;
ELSE
   START_PROCESS_ALGORITHM(paCyclicConditionCheck);
   
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
Cyclically check movement conditions of all started movements
(auto mode, combined manual movements, single manual movements)
*)

PROCESS_ALGORITHM paCyclicConditionCheck ON TaskAnalog


VAR_TEMP
 i : DINT;
END_VAR

VAR
 abODCCheckDependenciesCyclic : ABODCCheckDependencies (* must be a separate block since it is accessed from different tasks at the same time *);
 TmpStepPos : tsODCStepPos;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abInterpreter.aStatus();

Status := MovementsSema.Wait(WaitTime := cTimeOutSempahore);
IF Status <> KRTOS_Status_OK THEN
   dummy2 := ASSERT(FALSE, erAssert);
   RETURN;
END_IF;

FOR i := 1 TO sv_StartedManualMovements.iStartedMovements DO
   // check safety for manual movements
   // abODCCheckSafetyConditions must be a separete instance
   // because this PROCESS_ALGORITHM runs in a fast task that can
   // interrupt other tasks
   TmpStepPos := sv_StartedManualMovements.MoveData[i].StepPos;
   IF(abInterpreter.aStatus.bActive AND (TmpStepPos.iColumn = 0 OR TmpStepPos.iRow = 0)) THEN
      fbDebugTrace('interpreter is active but a movement with step pos 0 is running'); //this might be legitime, but is most times not normal
      abInterpreter.aStopInterpreterFatal();   
   END_IF;
   
   abODCCheckDependenciesCyclic.aCheck(StepPos := TmpStepPos, DeviceIdSelf := sv_StartedManualMovements.MoveData[i].DeviceId);
   IF NOT abODCCheckDependenciesCyclic.aCheck.bAllowed THEN
      fbDebugTrace2(nODCInterpreter, CONCAT('cyclic condition check reported movement at ',
                                            DINT_TO_STRING(sv_StartedManualMovements.MoveData[i].StepPos.iColumn),
                                            '/',
                                            DINT_TO_STRING(sv_StartedManualMovements.MoveData[i].StepPos.iRow),
                                            ' as not allowed'));
      abInterpreter.aStopInterpreterError();
   END_IF;
 
END_FOR;

//FIXME: is it a good idea to hold the lock so long???
Status := MovementsSema.Put();
IF Status <> KRTOS_Status_OK THEN
   dummy2 := ASSERT(FALSE, erAssert);
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

(*
Run the autocycle by calling the interpreter.
*)

ALGORITHM aRunAutoCycle


VAR_INPUT
 bStopCycle : BOOL (* stop cycle immediately *);
 bStopAfterCycle : BOOL (* finish the actual cycle and stop *);
END_VAR

VAR_OUTPUT
 bReady : BOOL;
END_VAR

VAR
 bCanStart : BOOL (* got the cycle start signal-> cycle can start if sequence recalc is finished *);
 abWaitCycleStart : ABWaitCycleStart;
 fbStart : FBStart;
 bDelayExceeded : BOOL;
 bEjectorBwdStarted : BOOL;
 DeviceIdEjector : tsDeviceId := (CompId:=cCompEjector,IndexId:=1);
 bInitDone : BOOL;
 pbEjectorBwd : REFTO BOOL;
 pbEjectorBwdActivated : REFTO BOOL;
 pbEjectorReady : REFTO BOOL;
 iMoveNrEjectorBwd : DINT;
 bColumnActive : BOOL;
 bDoRecalc : BOOL;
 bMovesBeforeAutoLoop : BOOL;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP S_CheckStartCond:
AAutoCycleReady (P);
END_STEP

ACTION AAutoCycleReady: #BEGIN_EDIT_BLOCK
bReady := TRUE;
IF (sv_OperationMode <> nFullAutomatic) THEN
   sv_bAutoCycleRunning := FALSE;    
END_IF;
g_SafetyData.MovementToActivate := 0;
abInterpreter.aResetStepMode();

;#END_EDIT_BLOCK END_ACTION (*AAutoCycleReady*)

(* steps *)
STEP S_CheckStartCycle:
AAutoInit (P);
AWaitCycleStart (N);
aRecalc (N);
ADelayCycle (N);
END_STEP

ACTION AAutoInit: #BEGIN_EDIT_BLOCK
bReady := FALSE;
IF (sv_OperationMode <> nFullAutomatic) THEN
   sv_bAutoCycleRunning := FALSE;    
END_IF;
bCanStart := FALSE;
abWaitCycleStart.aCycleStartRequest();

;#END_EDIT_BLOCK END_ACTION (*AAutoInit*)
ACTION AWaitCycleStart: #BEGIN_EDIT_BLOCK
abWaitCycleStart.aWaitCycleStart();
IF abWaitCycleStart.aWaitCycleStart.bCanStart THEN
   (* save flag because it is only TRUE for 1 cycle *)
   bCanStart := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AWaitCycleStart*)
ACTION aRecalc: #BEGIN_EDIT_BLOCK
// allow to recalculate the cycle while waiting for the start signal
// but delay real start of the sequence until recalculation is finished
aDoPendingRecalc();
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because autocycle start wait');
END_IF;

;#END_EDIT_BLOCK END_ACTION (*aRecalc*)
STEP Step42:
END_STEP

STEP Step43:
END_STEP

STEP Step44:
AMovementsBeforeCycleLoop (P);
END_STEP

ACTION AMovementsBeforeCycleLoop: #BEGIN_EDIT_BLOCK
IF (g_iAutoCycleLoopStartLine > 2) THEN
   bMovesBeforeAutoLoop := TRUE;
ELSE
   bMovesBeforeAutoLoop := FALSE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AMovementsBeforeCycleLoop*)
STEP Step20:
END_STEP

STEP S_EjectorAutoBwd:
AInitEjectorBwd (P);
AEjectorAutoBwd (P);
END_STEP

STEP S_CheckEjectorBwd:
ACheckEjectorBwd (P);
END_STEP

STEP S_BeforeCycleLoop:
AStepsBeforeCycle (P);
ARunStepsBeforeCycle (N);
END_STEP

ACTION AStepsBeforeCycle: #BEGIN_EDIT_BLOCK
aClearStepState(FALSE);
abInterpreter.aInitInterpreter(iColumn := 1,
                               iRow := 1,
                               iEndRow := g_iAutoCycleLoopStartLine,
                               bSkipAlreadyPosReached := FALSE,
                               bExcludeActiveColumns := FALSE);

abInterpreter.aIncreaseRow(iColumn := 1,
                           iEndRow := g_iAutoCycleLoopStartLine);

;#END_EDIT_BLOCK END_ACTION (*AStepsBeforeCycle*)
ACTION ARunStepsBeforeCycle: #BEGIN_EDIT_BLOCK
abInterpreter.aInterpret();
abInterpreter.aStatus();

;#END_EDIT_BLOCK END_ACTION (*ARunStepsBeforeCycle*)
STEP S_ODC1:
AStartCycle (P);
AInitInterpreter (P);
END_STEP

STEP S_Run:
ARunInterpreter (N);
END_STEP

ACTION ARunInterpreter: #BEGIN_EDIT_BLOCK
abInterpreter.aInterpret();
abInterpreter.aStatus();

;#END_EDIT_BLOCK END_ACTION (*ARunInterpreter*)
STEP SErrorWait:
AAutoManual (N);
END_STEP

ACTION AAutoManual: #BEGIN_EDIT_BLOCK
fbAutoManual();

;#END_EDIT_BLOCK END_ACTION (*AAutoManual*)
STEP S_FinishCycle:
AIncreaseShotCounter (P);
AResetFlags (P);
END_STEP

ACTION AIncreaseShotCounter: #BEGIN_EDIT_BLOCK
g_SafetyData.MovementToActivate := 0;

fbStart.DeviceId.CompId := cCompOperationMode;
fbStart.DeviceId.IndexId := 1;
fbStart.MoveDir := cMoveNone;
fbStart.MoveId := cMoveIncreaseShotCounter;
fbStart();

;#END_EDIT_BLOCK END_ACTION (*AIncreaseShotCounter*)
ACTION AResetFlags: #BEGIN_EDIT_BLOCK
sv_bFirstCycle := FALSE;
mbCycleTimeMachineRunning := FALSE;

;#END_EDIT_BLOCK END_ACTION (*AResetFlags*)
STEP S_CheckStopCycle:
ACheckRecalcPending (P);
END_STEP

ACTION ACheckRecalcPending: #BEGIN_EDIT_BLOCK
bDoRecalc := (mPendingRecalc <> nODCRecalcNone)

;#END_EDIT_BLOCK END_ACTION (*ACheckRecalcPending*)
STEP Step27:
ACheckColumnActive (P);
END_STEP

ACTION ACheckColumnActive: #BEGIN_EDIT_BLOCK
aIsAnyColumnActive(bActive => bColumnActive);

;#END_EDIT_BLOCK END_ACTION (*ACheckColumnActive*)
STEP S_FinishParallelOpen:
AFinishParallelOpen (N);
ACheckColumns (N);
END_STEP

ACTION AFinishParallelOpen: #BEGIN_EDIT_BLOCK
//call interpreter until all columns
//are finished
abInterpreter.aInterpret();

;#END_EDIT_BLOCK END_ACTION (*AFinishParallelOpen*)
ACTION ACheckColumns: #BEGIN_EDIT_BLOCK
aIsAnyColumnActive(bActive => bColumnActive);

;#END_EDIT_BLOCK END_ACTION (*ACheckColumns*)
STEP Step24:
END_STEP

STEP S_AfterCycleLoop:
AStepsAfterCycle (P);
ARunStepsAfterCycle (N);
END_STEP

ACTION AStepsAfterCycle: #BEGIN_EDIT_BLOCK
abInterpreter.aInitInterpreter(iColumn := 1,
                               iRow := g_iAutoCycleLoopEndLine,
                               iEndRow := sv_iUsedRows,
                               bSkipAlreadyPosReached := FALSE,
                               bExcludeActiveColumns := FALSE);

abInterpreter.aIncreaseRow(iColumn := 1,
                           iEndRow := sv_iUsedRows);

;#END_EDIT_BLOCK END_ACTION (*AStepsAfterCycle*)
ACTION ARunStepsAfterCycle: #BEGIN_EDIT_BLOCK
abInterpreter.aInterpret();
abInterpreter.aStatus();

;#END_EDIT_BLOCK END_ACTION (*ARunStepsAfterCycle*)
STEP S_WaitReady:
END_STEP

STEP S_End:
Action35 (P);
END_STEP

ACTION Action35: #BEGIN_EDIT_BLOCK
bReady := TRUE;
IF (sv_OperationMode <> nFullAutomatic) THEN
   sv_bAutoCycleRunning := FALSE;    
END_IF;
g_SafetyData.MovementToActivate := 0;

;#END_EDIT_BLOCK END_ACTION (*Action35*)

(* transitions *)
GO_ON_TRANSITION T_StartCondOK (* Trans1 *) FROM S_CheckStartCond TO S_CheckStartCycle :=  #BEGIN_EDIT_BLOCK
NOT bStopCycle AND NOT bStopAfterCycle
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION T_StartCycle (* Trans2 *) FROM S_CheckStartCycle TO Step42 :=  #BEGIN_EDIT_BLOCK
bCanStart AND bDelayExceeded AND NOT mbRecalcActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TSequenceInterrupted (* Trans48 *) FROM Step42 TO Step43 :=  #BEGIN_EDIT_BLOCK
sv_bSequenceInterruption
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TContinueSequence (* Trans50 *) FROM Step43 TO Step20 :=  #BEGIN_EDIT_BLOCK
NOT sv_bSequenceInterruption
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans51 (* Trans51 *) FROM Step43 TO Step44 :=  #BEGIN_EDIT_BLOCK
di_StepFwd
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TMovementsBeforeCycle (* Trans52 *) FROM Step44 TO S_BeforeCycleLoop :=  #BEGIN_EDIT_BLOCK
bMovesBeforeAutoLoop
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNoMoveBeforeAutocycle (* Trans53 *) FROM Step44 TO S_ODC1 :=  #BEGIN_EDIT_BLOCK
NOT bMovesBeforeAutoLoop

;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans49 (* Trans49 *) FROM Step42 TO Step20 :=  #BEGIN_EDIT_BLOCK
NOT sv_bSequenceInterruption
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TFirstCycle (* Trans19 *) FROM Step20 TO S_EjectorAutoBwd :=  #BEGIN_EDIT_BLOCK
sv_bFirstCycle
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TEjectorStarted (* Trans12 *) FROM S_EjectorAutoBwd TO S_CheckEjectorBwd :=  #BEGIN_EDIT_BLOCK
bEjectorBwdStarted AND pbEjectorReady^
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TEjectorBwd (* Trans10 *) FROM S_CheckEjectorBwd TO S_BeforeCycleLoop :=  #BEGIN_EDIT_BLOCK
pbEjectorBwd^
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TEjectorNotStarted (* Trans13 *) FROM S_EjectorAutoBwd TO S_BeforeCycleLoop :=  #BEGIN_EDIT_BLOCK
NOT bEjectorBwdStarted
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TBeforeCycleReady (* Trans17 *) FROM S_BeforeCycleLoop TO S_ODC1 :=  #BEGIN_EDIT_BLOCK
abInterpreter.aStatus.bFinished
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNotFirstCycle (* Trans42 *) FROM Step20 TO S_ODC1 :=  #BEGIN_EDIT_BLOCK
NOT sv_bFirstCycle
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans32 (* Trans32 *) FROM S_ODC1 TO S_Run :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION T_ODCFinished (* Trans17 *) FROM S_Run TO S_FinishCycle :=  #BEGIN_EDIT_BLOCK
abInterpreter.aStatus.bFinished
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION T_ODCError (* Trans3 *) FROM S_Run TO SErrorWait :=  #BEGIN_EDIT_BLOCK
abInterpreter.aStatus.bError
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TStop (* Trans4 *) FROM SErrorWait TO S_CheckStartCond :=  #BEGIN_EDIT_BLOCK
bStopCycle
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans52 (* Trans75 *) FROM S_FinishCycle TO S_CheckStopCycle :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
(*must be IEC transition because of shot counter / production counter*)
END_TRANSITION

GO_ON_TRANSITION T_NewCycle (* Trans13 *) FROM S_CheckStopCycle TO S_CheckStartCycle :=  #BEGIN_EDIT_BLOCK
NOT bStopAfterCycle AND
NOT bDoRecalc
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStopOrRecalc (* Trans28 *) FROM S_CheckStopCycle TO Step27 :=  #BEGIN_EDIT_BLOCK
bStopAfterCycle OR bDoRecalc
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans21 (* Trans21 *) FROM Step27 TO S_FinishParallelOpen :=  #BEGIN_EDIT_BLOCK
//"parallel open" movements must also be finished
bColumnActive
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans23 (* Trans23 *) FROM S_FinishParallelOpen TO Step24 :=  #BEGIN_EDIT_BLOCK
NOT bColumnActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans24 (* Trans24 *) FROM Step24 TO S_AfterCycleLoop :=  #BEGIN_EDIT_BLOCK
bStopAfterCycle
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans27 (* Trans27 *) FROM Step24 TO S_CheckStartCycle :=  #BEGIN_EDIT_BLOCK
bDoRecalc
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans22 (* Trans22 *) FROM Step27 TO S_AfterCycleLoop :=  #BEGIN_EDIT_BLOCK
NOT bColumnActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans14 (* Trans14 *) FROM S_AfterCycleLoop TO S_WaitReady :=  #BEGIN_EDIT_BLOCK
abInterpreter.aStatus.bFinished
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TAllMovementsReady (* Trans8 *) FROM S_WaitReady TO S_End :=  #BEGIN_EDIT_BLOCK
//wait untill all movements are ready
//for example airvalve movement can be still active
sv_StartedManualMovements.iStartedMovements = 0
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans15 (* Trans15 *) FROM S_End TO S_CheckStartCycle :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION ADelayCycle: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//delay should not be executed in first cycle
IF sv_bFirstCycle THEN
   bDelayExceeded := TRUE;
ELSE
   IF sv_dCycleDelaySet > t#0s THEN
      sv_dCycleDelayAct := MIN(S_CheckStartCycle.T, sv_dCycleDelaySet);
   ELSE
      sv_dCycleDelayAct := t#0s;
   END_IF;
   bDelayExceeded := S_CheckStartCycle.T >= sv_dCycleDelaySet;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ADelayCycle*)
ACTION AEjectorAutoBwd: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbEjeBwdAtCycleStart AND NOT pbEjectorBwd^ AND NOT bEjectorBwdStarted THEN
   //only start ejector auto bwd movement if the ejector must be bwd at the beginning of the cycle
   //this information is taken from the safety array of the first step
 
   //modify pbActivated^ because otherwise the ejector will not move bwd if it is switched off
   sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.pbActivated := @sv_bTRUE;
   
   //attention:
   //if ejector is not programmed in sequence, there are no safety conditions for ejector bwd movement   
   aStartSingleMovement(DeviceId := DeviceIdEjector,
                        MoveDir := cMoveBwd,
                        MoveId := cMoveBwd,
                        bNeedCheckSafety := sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.bProgrammedInSequence);
   
   bEjectorBwdStarted := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AEjectorAutoBwd*)
ACTION AInitEjectorBwd: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bInitDone THEN
   fbGetMoveNumber(DeviceId := DeviceIdEjector,
                   MoveId := cMoveBwd,
                   MoveDir := cMoveBwd);

   IF fbGetMoveNumber.bFound THEN
      iMoveNrEjectorBwd := fbGetMoveNumber.iMoveNumber;
      pbEjectorBwd := sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pMovementData^.pbPosReached;
      pbEjectorBwdActivated := sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pMovementData^.pbActivated;
      pbEjectorReady := sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pbDeviceReady;
   ELSE
      //ejector bwd movement not found
      pbEjectorBwd := @sv_bTRUE;
      pbEjectorBwdActivated := @sv_bTRUE;
      pbEjectorReady := @sv_bTRUE;
   END_IF;
      
   bInitDone := TRUE;
END_IF;



;#END_EDIT_BLOCK END_ACTION (*AInitEjectorBwd*)
ACTION ACheckEjectorBwd: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//set pbActivated to original reference
sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.pbActivated := pbEjectorBwdActivated;
bEjectorBwdStarted := FALSE;

IF NOT pbEjectorBwd^ THEN
   //ejector is not bwd -> set according alarm
   SET_ALARM(Name := sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.Alarm.AlarmId,
             SubID1 := sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.Alarm.SubId[1],
             SubID2 := sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.Alarm.SubId[2],
             SubID3 := sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.Alarm.SubId[3],
             SubID4 := sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.Alarm.SubId[4]);
   
   //switch to manual mode
   fbAutoManual();
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckEjectorBwd*)
ACTION AInitInterpreter: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

aClearStepState(TRUE);
abInterpreter.aInitInterpreter(iColumn := 1,
                               iRow := g_iAutoCycleLoopStartLine,
                               iEndRow := g_iAutoCycleLoopEndLine,
                               bSkipAlreadyPosReached := FALSE,
                               bExcludeActiveColumns := TRUE);

//find first "valid" line to save cycle time
abInterpreter.aIncreaseRow(iColumn := 1,
                           iEndRow := g_iAutoCycleLoopEndLine);

;#END_EDIT_BLOCK END_ACTION (*AInitInterpreter*)
ACTION AStartCycle: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bFirstCycle THEN
   //check of cycle time at the beginning of first cycle is not necessary
   aCheckCycleTime();
END_IF;

//save last cycle time
sv_dLastCycleTime := sv_dCycleTime;

mbCycleTimeRunning := TRUE;

//reset timers
mbResetCycleTime := TRUE;
mbResetCycleTimeMachine := TRUE;

sv_bAutoCycleRunning := TRUE;
mbCycleTimeMachineRunning := TRUE;

SET_EVENT(evNewCycleStarted);

;#END_EDIT_BLOCK END_ACTION (*AStartCycle*)

(* exits *)

EXIT_TRANSITION StopAllMoves := #BEGIN_EDIT_BLOCK
bStopCycle
;#END_EDIT_BLOCK
PRIORITY 1 WITH 
(* init step *)
INITIAL_STEP S_StopAllMoves:
AStopInterpreter (P);
END_STEP

ACTION AStopInterpreter: #BEGIN_EDIT_BLOCK
abInterpreter.aStopInterpreterNormal();

;#END_EDIT_BLOCK END_ACTION (*AStopInterpreter*)
STEP S_CheckStartCond:
AAutoCycleReady (P);
END_STEP


(* steps *)

(* transitions *)
TRANSITION T_CheckStop (* Trans12 *) FROM S_StopAllMoves TO S_CheckStartCond :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

END_TRANSITION
(* end sfc-code *)


END_ALGORITHM

(*
Run the auto cycle.
When the cycle has finished and mbStopCycle OR mbStopAfterCycle are true
opmode is automatically switched to manual and the PROCESS_ALGORITHM stops itself.
*)

PROCESS_ALGORITHM paRunAutomaticMovements ON TaskSequencer

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//call autoCycle
aRunAutoCycle(bStopCycle := mbStopCycle,
              bStopAfterCycle := mbStopAfterCycle);            

IF aRunAutoCycle.bReady AND (mbStopCycle OR mbStopAfterCycle) THEN
   sv_bAutoCycleRunning := FALSE;
   // switch to manual mode and stop self at end of cycle
   fbAutoManual();
   
   abInterpreter.aResetStepMode();
   STOP_PROCESS_ALGORITHM(paCycleTime);
   STOP_PROCESS_ALGORITHM(paCycleTimeMachine);
   STOP_PROCESS_ALGORITHM();
END_IF;
            


;#END_EDIT_BLOCK END_ALGORITHM

(*
Cause initialisation of ODC sequence after startup(sv_bInitDone)
*)

POSTUPDATE_ALGORITHM pInitDone ON PU_Task_3 WITH sv_bInitDone

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter,'Reloading ODC files because of sv_bInitDone');   

IF sv_bUseProgramSwitches THEN
   //use program switches
   aSetPendingRecalc(RecalcMode := nODCRecalcReloadFiles);
ELSE
   //use existing sequence and only recalc internal arrays
   aSetPendingRecalc(RecalcMode := nODCRecalcInternal);
END_IF;

aDoPendingRecalc();
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because pInitDone');
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paInit ON TaskMid AUTOSTART


VAR
 swoState : KSWO_Status;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//initialize semaphore
Status := MovementsSema.Put();
IF Status <> KRTOS_Status_OK THEN
   dummy2 := ASSERT(FALSE, erAssert);
END_IF;

swoState := KSWO_AddVariable(Task := TaskInject,
                           Name := 'ActCycleTime',
                           Variable := sv_dCycleTime);

swoState := KSWO_AddVariable(Task := TaskAnalog,
                           Name := 'ActCycleTime',
                           Variable := sv_dCycleTime);

STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

(*
React to to operation mode changes and stop the autocycle immediately
when switching to setup/manual mode,
or reset cycle data when switching to Full/Halfauto operation mode.
*)

POSTUPDATE_ALGORITHM pOpmodeChanged ON PU_Task_7 WITH sv_OperationMode

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_OperationMode >= nHalfAutomatic THEN
   mbStopCycle := FALSE;
   mbStopAfterCycle := FALSE;
   (* back up sequence when machine is switched to auto mode
      and the sequence has changed *)
   START_PROCESS_ALGORITHM(paBackupSequence);
   
   (* PA stops itself again when finished *)
   START_PROCESS_ALGORITHM(paRunAutomaticMovements);
   START_PROCESS_ALGORITHM(paCycleTime);
   START_PROCESS_ALGORITHM(paCycleTimeMachine);
ELSIF sv_OperationMode < nHalfAutomatic THEN
   sv_bFirstCycle := TRUE;
   mbStopCycle := TRUE;
   mbCycleTimeRunning := FALSE;
   
   IF sv_StartedManualMovements.iStartedMovements = 0 THEN
      //recalc of sequence only if no movement is active
      //if there is still a movement active, the creation of a new sequence
      //will be triggered by postupdate algo pActiveMovements
      aDoPendingRecalc();
      IF aDoPendingRecalc.bStartedRecalc THEN
         fbDebugTrace2(nDeviceState, 'recalc because opmode change away from auto cycle');
      END_IF;
   END_IF;

END_IF;
   


;#END_EDIT_BLOCK END_ALGORITHM

(*
Handle evAlarmFinishCycleAndStop event which signals to stop after the end
of the current autocycle
*)

EVENT_ALGORITHM evaFinishCycleAndStop ON EV_Task_3 WITH evAlarmFinishCycleAndStop


VAR_INPUT
 evFinishCycleAndStopData : ALARM_EVENT_DATA;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
mbStopAfterCycle := TRUE;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pDataState ON PU_Task_3(1) WITH sv_DataState


VAR
 PrevState : tnDataState;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_DataState = nReadMoldData THEN
   //loading of mold data in progress
   mbIgnoreProgramSwitchChange := TRUE;
   PrevState := nReadMoldData;
   sv_SequenceDimension.iMaxColumns := 0;
   sv_SequenceDimension.iMaxRows := 0;
ELSIF sv_DataState = nReadSequenceData THEN
   //loading of sequence in progress
   mbIgnoreProgramSwitchChange := TRUE;
   PrevState := nReadSequenceData;
   sv_SequenceDimension.iMaxColumns := 0;
   sv_SequenceDimension.iMaxRows := 0;
END_IF;   
   
IF sv_DataState = nReady AND mbIgnoreProgramSwitchChange THEN
   
   //loading procedure ready
   mbIgnoreProgramSwitchChange := FALSE;
   
   //decide if only conditions should be recalculated (after loading sequence)
   //or complete sequence should be created (after program switch changed)
   IF sv_bUseProgramSwitches THEN
      aSetPendingRecalc(RecalcMode := nODCRecalcReloadFiles);
   ELSIF PrevState = nReadMoldData THEN
      aSetPendingRecalc(RecalcMode := nODCRecalcInternal);
   ELSIF PrevState = nReadSequenceData THEN
      aSetPendingRecalc(RecalcMode := nODCRecalcInternal);
   END_IF;
   
   aDoPendingRecalc();
   IF aDoPendingRecalc.bStartedRecalc THEN
      fbDebugTrace2(nDeviceState, 'recalc because data state change');
   END_IF;
   
   PrevState := nReady;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
React to program switch changes, and recalculate the ODC sequence.
*)

POSTUPDATE_ALGORITHM pDescriptionFilesChanged ON PU_Task_3 WITH sv_bODCFilesChanged

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bODCFilesChanged THEN
   RETURN;
END_IF;

sv_bODCFilesChanged := FALSE;

IF NOT sv_bInitDone THEN
   fbDebugTrace('ignoring sv_bODCFilesChanged because sv_bInitDone is FALSE');
   RETURN;
END_IF;

(* rebuild ODC array immediately with reloading files *)
aSetPendingRecalc(RecalcMode := nODCRecalcReloadFiles);

IF sv_OperationMode >= nHalfAutomatic THEN
   fbDebugTrace('skipping ODC recalc after file change because of OperationMode');
   RETURN;
END_IF;

IF sv_StartedMovements.iStartedMovements > 0 THEN
   fbDebugTrace('skipping ODC recalc after file change because there are started movements');
   RETURN;
END_IF;

aDoPendingRecalc();
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because files changed');
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
create internal array and calculate safety conditions after
teachmode becomes inactive
*)

POSTUPDATE_ALGORITHM pNewSequenceFromEditor ON PU_Task_3 WITH sv_iActiveEditors


VAR
 fbLockUnlock : FBLockUnlock := (DeviceId:=(CompId:=cCompOperationMode,IndexId:=1),MoveDir:=cModeAutomatic,MoveId:=cModeAutomatic);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_iActiveEditors <> 0 THEN
   //teach mode active
   //avoid changing operation mode to HA or FA 
   fbLockUnlock.Alarm.AlarmId := erTeachModeActive;
   fbLockUnlock.Mode := nLockAbort;
   fbLockUnlock();
   
   //reset sv_bUseProgramSwitches immediately after activating teach mode
   //so that "controlled by machine sequencer" is displayed instead of program switches
   sv_bUseProgramSwitches := FALSE;
   RETURN;
ELSE
   fbLockUnlock.Alarm.AlarmId := erTeachModeActive;
   fbLockUnlock.Mode := nUnlock;
   fbLockUnlock();
END_IF;

//teach mode inactive => new sequence programmed by editor
// -> create internal array, calculate safety conditions, do plaus checks
aSetPendingRecalc(RecalcMode := nODCRecalcInternal);

aDoPendingRecalc();
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because new sequence from editor');
END_IF;









;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM aRestoreSequenceBackup ON EV_Task_7 WITH sv_iSequenceToRestore

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_iSequenceToRestore = 0 THEN
   RETURN;
END_IF;

IF sv_iSequenceToRestore > cODCSequenceBackupCount THEN
   fbDebugTrace2(nODCInterpreter, 'restoring actual sequence calculated from switches');
   aSetPendingRecalc(RecalcMode := nODCRecalcCylce);
END_IF;


fbDebugTrace2(nODCInterpreter, CONCAT('restoring old sequence ', DINT_TO_STRING(sv_iSequenceToRestore)));
sv_ODCSequence := sv_ODCSequenceBackup[sv_iSequenceToRestore].Sequence;
aSetPendingRecalc(RecalcMode := nODCRecalcSafety);
aDoPendingRecalc(); //FIXME: this may not do more than security recalculation -> otherwise loaded array would be overwritten 
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because sequence backup is restored');
END_IF;
sv_iSequenceToRestore := 0;
fbDebugTrace2(nODCInterpreter, 'restoring old sequence done');


;#END_EDIT_BLOCK END_ALGORITHM

(*
React to program switch changes, and recalculate the ODC sequence.
*)

POSTUPDATE_ALGORITHM pProgramSwitchChanged ON PU_Task_3 WITH sv_bProgramSwitchChanged

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bProgramSwitchChanged THEN
   RETURN;
END_IF;

sv_bProgramSwitchChanged := FALSE;

IF NOT sv_bInitDone THEN
   fbDebugTrace2(nODCInterpreter, 'ignoring program switch change because sv_bInitDone is FALSE');
   RETURN;
END_IF;

IF NOT sv_bUseProgramSwitches THEN
   // ignore changing of program switch if sequence from graphical editor is used
   fbDebugTrace2(nODCInterpreter, 'ignoring program switch change because of sv_bUseProgramSwitches');
   RETURN;
END_IF;

IF mbIgnoreProgramSwitchChange THEN
   fbDebugTrace2(nODCInterpreter, 'ignoring program switch change because of sv_DataState');
   RETURN;
END_IF;

aSetPendingRecalc(RecalcMode := nODCRecalcCylce);

IF sv_OperationMode >= nHalfAutomatic THEN
   fbDebugTrace('skipping ODC recalc after program switch change because of OperationMode');
   RETURN;
END_IF;

IF sv_StartedMovements.iStartedMovements > 0 THEN
   fbDebugTrace('skipping ODC recalc after program switch change because there are started movements');
   RETURN;
END_IF;

(* rebuild ODC array immediately without reloading files *)
aDoPendingRecalc();
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because program switch changed');
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
React to program switch changes, and recalculate the ODC sequence.
*)

POSTUPDATE_ALGORITHM pActivationChanged ON PU_Task_3 WITH sv_bActivationChanged

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bActivationChanged THEN
   RETURN;
END_IF;

sv_bActivationChanged := FALSE;

IF NOT sv_bInitDone THEN
   fbDebugTrace('ignoring sv_bActivationChanged because sv_bInitDone is FALSE');
   RETURN;
END_IF;

IF mbIgnoreProgramSwitchChange THEN
   fbDebugTrace2(nODCInterpreter, 'ignoring activation change because of sv_DataState');
   RETURN;
END_IF;

(* recalculate ODC safety without reloading files/recalculating the sequence *)
aSetPendingRecalc(RecalcMode := nODCRecalcSafety);

IF sv_OperationMode >= nHalfAutomatic THEN
   fbDebugTrace('skipping ODC recalc after activation change because of OperationMode');
   RETURN;
END_IF;

IF sv_StartedMovements.iStartedMovements > 0 THEN
   fbDebugTrace('skipping ODC recalc after activation change because there are started movements');
   RETURN;
END_IF;

aDoPendingRecalc();
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because activation change');
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paVersionInfo ON TaskSlow AUTOSTART


VAR
 b : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

b := FCreateODCVersion();
STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

(*
trigger creation of sequence by program switches
*)

POSTUPDATE_ALGORITHM pChangeToProgramSwitches ON PU_Task_7 WITH sv_bUseProgramSwitches


VAR_TEMP
 iDevice : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbIgnoreProgramSwitchChange THEN
   //loading procedure in progress
   RETURN;
END_IF;

IF sv_bUseProgramSwitches THEN
   //activate all devices after a change from
   //machine sequencer mode to program switch mode
   FOR iDevice := 1 TO sv_ODCDeviceMovements.iCount DO
      IF CHECK_REF(sv_ODCDeviceMovements.Devices[iDevice].pbDeviceActivated^) THEN
         sv_ODCDeviceMovements.Devices[iDevice].pbDeviceActivated^ := TRUE;
      END_IF;      
   END_FOR;
   
   //create new sequence depending on the program switches
   //set mode to nODCRecalcReloadFiles because maybe sequence was
   //never created with program switches before
   aSetPendingRecalc(RecalcMode := nODCRecalcReloadFiles);
   aDoPendingRecalc();
   IF aDoPendingRecalc.bStartedRecalc THEN
      fbDebugTrace2(nDeviceState, 'recalc because change to program switch mode');
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
This algorithm checks the start conditions for the cycle if the 
operator switches to half or fullauto cycle.
Safety relevant devices must be in the position which they should have according
the programmed cycle.
Not safety relevant devices must be in their default position.
Deactivated devices and devices which have no default position are not checked.
*)

ALGORITHM aCheckCycleStartConditions


VAR_TEMP
 iDevice : DINT;
END_VAR

VAR
 Pos : tsODCStepPos;
 DeviceId : tsDeviceId;
 SafetyArray : tyODCDependencyArray;
 iDefaultMove : DINT;
 bAllowed : BOOL;
 abODCCheckDependencies : ABODCCheckDependencies;
 fbCheckPosReached : FBCheckPosReached;
 bEjectorIgnored : BOOL;
 EjectorDependency : LWORD;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

Pos.iColumn := 1;
Pos.iRow := 1;

DeviceId.CompId := sv_ODCSequence[1,1].iCompId;
DeviceId.IndexId := INT_TO_DINT(sv_ODCSequence[1,1].iIndexId);

//check safety array of first step (ODC.BeginSequence)
bEjectorIgnored := FALSE;
IF mbEjeBwdAtCycleStart THEN
   //ejector must not be bwd when operator switches to HA or FA
   //the ejector bwd movement is done in aRunAutoCylce
   //=> start of cycle should be possible if ejector is not bwd)
   //=> dependency must be modified for this case
   //all other safety relevant movements (mold, cores, ...) must be in the calculated startposition
   EjectorDependency := sv_ODCSequenceInt[1,1].SafetyArray[miIndexEjectorInSafetyArray].Dependency;
   sv_ODCSequenceInt[1,1].SafetyArray[miIndexEjectorInSafetyArray].Dependency := cNoDependency;
   bEjectorIgnored := TRUE;
END_IF;    

//check init safety array
//(check all safety relevant devices)
abODCCheckDependencies.aCheck(StepPos := Pos, DeviceIdSelf := DeviceId);
bAllowed := abODCCheckDependencies.aCheck.bAllowed;

//write back the original value
IF bEjectorIgnored THEN
   sv_ODCSequenceInt[1,1].SafetyArray[miIndexEjectorInSafetyArray].Dependency := EjectorDependency;
END_IF;


//check state of not safety relevant devices
//always check even if safety relevant check already failed
SafetyArray := sv_ODCSequenceInt[1,1].SafetyArray;
FOR iDevice := 1 TO sv_ODCDeviceMovements.iCount DO
   DeviceId := sv_ODCDeviceMovements.Devices[iDevice].DeviceId;
   iDefaultMove := sv_ODCDeviceMovements.Devices[iDevice].iDefaultMoveNumber;
   
   IF (SafetyArray[iDevice].Dependency = cNoDependency) AND (DeviceId.CompId <> cCompODC) THEN
      //device not safety relevant
      IF sv_ODCDeviceMovements.Devices[iDevice].pbDeviceActivated^ AND iDefaultMove <> 0 THEN
         //if device is activated and a default movement is available,
         //the default movement of this device must be in endposition
         fbCheckPosReached(DeviceId := DeviceId,
                           MoveDir := sv_MovementsAvailable[iDefaultMove].pMovementData^.MoveDir,
                           MoveId := sv_MovementsAvailable[iDefaultMove].pMovementData^.MoveId);
                           
         IF NOT fbCheckPosReached.bPosReached THEN
            IF sv_TraceLevel.bODCInterpreter THEN
               fbDebugTrace(CONCAT('cycle start not allowed by default position check of ',
                                   DINT_TO_STRING(DeviceId.CompId), '.', DINT_TO_STRING(DeviceId.IndexId),
                                   ' -> setting alarm ',
                                   GET_ALARM_NAME(fbCheckPosReached.Alarm.AlarmId)));
            END_IF;
            //set according alarm
            SET_ALARM(Name := fbCheckPosReached.Alarm.AlarmId,
                      SubID1 := fbCheckPosReached.Alarm.SubId[1],
                      SubID2 := fbCheckPosReached.Alarm.SubId[2],
                      SubID3 := fbCheckPosReached.Alarm.SubId[3],
                      SubID4 := fbCheckPosReached.Alarm.SubId[4]);
            bAllowed := FALSE;
         END_IF;
      END_IF;
   END_IF;
END_FOR;

IF NOT bAllowed THEN
   IF sv_TraceLevel.bODCInterpreter THEN
      fbDebugTrace('checking cycle start conditions found problems -> switching back to manual mode');
   END_IF;
   //switch away from auto mode if any check fails
   fbAutoManual();
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pOperationMode ON PU_Task_7 WITH sv_OperationMode


VAR_TEMP
 sOperationMode : STRING(255);
END_VAR

VAR
 PrevOpMode : tnOperationMode := nManual;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bODCInterpreter THEN
   //trace opmode switch
   IF sv_OperationMode = nSetup THEN
      sOperationMode := 'Setup';
   ELSIF sv_OperationMode = nManual THEN
      sOperationMode := 'Manual';
   ELSIF sv_OperationMode = nHalfAutomatic THEN
      sOperationMode := 'HalfAutomatic';
   ELSIF sv_OperationMode = nFullAutomatic THEN
      sOperationMode := 'FullAutomatic';
   ELSE
      sOperationMode := '???';
   END_IF;
   fbDebugTrace(CONCAT('sv_OperationMode changed to ', sOperationMode));
END_IF;

IF PrevOpMode < nHalfAutomatic AND sv_OperationMode >= nHalfAutomatic THEN
   //check cycle start conditions
   aCheckCycleStartConditions();
END_IF;

PrevOpMode := sv_OperationMode;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paRunManualCombinedMovement ON TaskSequencer


(* IecGraph-Code *)

(* init step *)
INITIAL_STEP SInit:
END_STEP


(* steps *)
STEP S_Run:
Action24 (P);
ARunCombinedMovement (N);
END_STEP

ACTION Action24: #BEGIN_EDIT_BLOCK
sv_bODCCombinedMoveActive := TRUE;

;#END_EDIT_BLOCK END_ACTION (*Action24*)
ACTION ARunCombinedMovement: #BEGIN_EDIT_BLOCK
// run a combined movements
abInterpreter.aInterpret();
abInterpreter.aStatus();

;#END_EDIT_BLOCK END_ACTION (*ARunCombinedMovement*)
STEP S_Finished:
ATrace (P);
END_STEP

STEP S_StopInterpreter:
AStopInterpreter (P);
END_STEP

ACTION AStopInterpreter: #BEGIN_EDIT_BLOCK
abInterpreter.aStopInterpreterNormal();

;#END_EDIT_BLOCK END_ACTION (*AStopInterpreter*)
STEP S_NotActive:
ATraceNotActive (P);
END_STEP

STEP S_Error:
ATraceError (P);
END_STEP

STEP S_Recalc:
ADoPendingRecalc (P);
END_STEP

STEP S_Stop:
AStop (P);
END_STEP

ACTION AStop: #BEGIN_EDIT_BLOCK
sv_bODCCombinedMoveActive := FALSE;
STOP_PROCESS_ALGORITHM();

;#END_EDIT_BLOCK END_ACTION (*AStop*)

(* transitions *)
GO_ON_TRANSITION Trans1 (* Trans1 *) FROM SInit TO S_Run :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TFinished (* Trans2 *) FROM S_Run TO S_Finished :=  #BEGIN_EDIT_BLOCK
abInterpreter.aStatus.bFinished
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TAllMovementsReady (* Trans7 *) FROM S_Finished TO S_StopInterpreter :=  #BEGIN_EDIT_BLOCK
sv_StartedManualMovements.iStartedMovements = 0
;#END_EDIT_BLOCK
(*Interpreter is finished -> wait untill all movements
are ready  (for example airvalve can still be active)*)
END_TRANSITION

GO_ON_TRANSITION Trans11 (* Trans11 *) FROM S_StopInterpreter TO S_Recalc :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNotActive (* Trans5 *) FROM S_Run TO S_NotActive :=  #BEGIN_EDIT_BLOCK
NOT abInterpreter.aStatus.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans8 (* Trans8 *) FROM S_NotActive TO S_Recalc :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TError (* Trans6 *) FROM S_Run TO S_Error :=  #BEGIN_EDIT_BLOCK
abInterpreter.aStatus.bError
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans9 (* Trans9 *) FROM S_Error TO S_Recalc :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans12 (* Trans12 *) FROM S_Recalc TO S_Stop :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans4 (* Trans4 *) FROM S_Stop TO S_Run :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION ATrace: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter,'stopping combined movement PA because interpreter has finished');
IF sv_StartedManualMovements.iStartedMovements <> 0 THEN
   fbDebugTrace2(nODCInterpreter,'There were still some movements active at end of a combined movement');
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ATrace*)
ACTION ATraceError: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter,'stopping combined movement PA because interpreter reported an error');

;#END_EDIT_BLOCK END_ACTION (*ATraceError*)
ACTION ATraceNotActive: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter,'stopping combined movement PA because interpreter is not active anymore');
IF sv_StartedManualMovements.iStartedMovements <> 0 THEN
   fbDebugTrace2(nODCInterpreter,'There were still some movements active at end of a combined movement');
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ATraceNotActive*)
ACTION ADoPendingRecalc: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_StartedManualMovements.iStartedMovements = 0 THEN
   //all movements ready
   aDoPendingRecalc();
   IF aDoPendingRecalc.bStartedRecalc THEN
      fbDebugTrace2(nDeviceState, 'recalc because interpreter finished and iStartedMovements = 0');
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ACTION (*ADoPendingRecalc*)
(* end sfc-code *)


END_ALGORITHM

(*
supervision of check conditions for single movements in
manual and setup mode
For combined movements and in half and fullauto cycle the supervision
is done by the interpreter
*)

PROCESS_ALGORITHM paCheckConditionsManual ON TaskAnalog


VAR_TEMP
 i : DINT;
END_VAR

VAR
 TmpStepPos : tsODCStepPos;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)


FOR i := 1 TO sv_StartedManualMovements.iStartedMovements DO
   
   TmpStepPos := sv_StartedManualMovements.MoveData[i].StepPos;
   IF (TmpStepPos.iColumn <> 0) AND (TmpStepPos.iRow <> 0) THEN
      //if a combined movement (sequence) is active, the supervision of the check conditions
      //is done automatically by the interpreter
      abInterpreter.aCheckConditionsManual(Movement := sv_ODCSequence[TmpStepPos.iColumn][TmpStepPos.iRow], bNoAlarms := FALSE);
      
      IF NOT abInterpreter.aCheckConditionsManual.bCheckConditionsOk THEN
         //check condition not ok
         abInterpreter.aStopInterpreterError();   
      END_IF;
   END_IF;
END_FOR;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paCycleTime ON TaskInject


VAR
 b : BOOL;
 fbTonCycleTime : TON;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Cycle time - from start to start
IF mbCycleTimeRunning THEN
   
   IF mbResetCycleTime THEN
      fbTonCycleTime(IN := FALSE);
      mbResetCycleTime := FALSE;
   END_IF;
   
   fbTonCycleTime(IN := TRUE,
                  PT := t#20d);
  
   b := WRITE_SV_DIRECT(sv_dCycleTime, fbTonCycleTime.ET);
   
   IF sv_dCycleTime > sv_dMaxCycleTime THEN
      SET_ALARM(Name := erCycleTimeExceeded);
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paCycleTimeMachine ON TaskMid


VAR
 b : BOOL;
 fbTonCycleTimeMachine : TON (* Clock the cycletime from start to end of cycle *);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Cycle time machine - from start to end of cycle
IF mbCycleTimeRunning AND mbCycleTimeMachineRunning THEN
   
   IF mbResetCycleTimeMachine THEN
      fbTonCycleTimeMachine(IN := FALSE);
      mbResetCycleTimeMachine := FALSE;
   END_IF;
   
   fbTonCycleTimeMachine(IN := TRUE,
                         PT := t#20d);
    
   b := WRITE_SV_DIRECT(sv_dCycleTimeMachine, fbTonCycleTimeMachine.ET);
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pSequenceInterruption ON PU_Task_13 WITH sv_bSequenceInterruption


VAR
 dummy : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bSequenceInterruption THEN
   IF sv_TraceLevel.bODCInterpreter THEN
      dummy := Print('***** INTERRUPT SEQUENCE *****');
   END_IF;
   mbStopAfterCycle := TRUE;
   abInterpreter.aInterruptSequence();
ELSE      
   sv_bStepBwdActive := FALSE;
   IF sv_OperationMode >= nHalfAutomatic THEN
      IF sv_TraceLevel.bODCInterpreter THEN
         dummy := Print('***** CONTINUE SEQUENCE *****');
      END_IF;
      abInterpreter.aContinueSequence();
      mbStopAfterCycle := FALSE;
   END_IF;   
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aStartInverseMovement


VAR_INPUT
 iMoveNr : DINT;
 iColumn : DINT;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 iFuIndex : DINT;
 iMoveIdInverse : tMoveIdent;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//get inverse movement
iMoveIdInverse := sv_MovementsAvailable[iMoveNr].pMovementData^.iMoveIdInverseMovement;
IF iMoveIdInverse = cMinMoveIdent THEN
   //no inverse movement defined
   //set alarm if moenet does not belong to ODC - function unit
   IF (sv_MovementsAvailable[iMoveNr].DeviceId <> sv_DeviceId) THEN
      SET_ALARM(Name := erNoInverseMovement,
                SubID1 := sv_MovementsAvailable[iMoveNr].DeviceId.CompId,
                SubID2 := sv_MovementsAvailable[iMoveNr].DeviceId.IndexId,
                SubID3 := sv_MovementsAvailable[iMoveNr].pMovementData^.MoveId);
   END_IF;
   
   RETURN; //return here
END_IF;

iFuIndex := sv_MovementsAvailable[iMoveNr].iFuIndex;
FOR i := 1 TO sv_ODCDeviceMovements.Devices[iFuIndex].iNumberOfMovements DO
   IF sv_ODCDeviceMovements.Devices[iFuIndex].Movements[i]^.MoveId = iMoveIdInverse THEN
      //inverse movement found => try to start it
      aStartSingleMovement(DeviceId := sv_ODCDeviceMovements.Devices[iFuIndex].DeviceId,
                           MoveDir := sv_ODCDeviceMovements.Devices[iFuIndex].Movements[i]^.MoveDir,
                           MoveId := sv_ODCDeviceMovements.Devices[iFuIndex].Movements[i]^.MoveId,
                           IntermediateCond := 0,
                           bNeedCheckSafety := (sv_ODCDeviceMovements.Devices[iFuIndex].Movements[i]^.iSafetyIdentifier > 0));
      
      IF aStartSingleMovement.bStarted THEN
         mActiveStepBwdMovements[iColumn].DeviceId := sv_ODCDeviceMovements.Devices[iFuIndex].DeviceId;
         mActiveStepBwdMovements[iColumn].MoveId := sv_ODCDeviceMovements.Devices[iFuIndex].Movements[i]^.MoveId;
         mActiveStepBwdMovements[iColumn].MoveDir := sv_ODCDeviceMovements.Devices[iFuIndex].Movements[i]^.MoveDir;
      END_IF;
                     
      EXIT;
   END_IF;
END_FOR;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pStepFwd ON PU_Task_3 WITH di_StepFwd

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bSequenceInterruption THEN
   //button is only working if sequence is interrupted
   RETURN;
END_IF;

IF di_StepFwd THEN 
   //trigger interpreter to execute the next step(s)
   IF sv_StartedManualMovements.iStartedMovements = 0 THEN
      //ignore step fwd button if any movment is active
      abInterpreter.aEnableNextStep();
   END_IF;  
ELSE
   //stop actually executed step(s)
   abInterpreter.aInterruptSequence();
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pStepBwd ON PU_Task_3 WITH di_StepBwd


VAR_TEMP
 iColumn : DINT;
END_VAR

VAR
 iActiveMoveNr : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bSequenceInterruption THEN
   //button is only working if sequence is interrupted
   RETURN;
END_IF;

IF di_StepBwd THEN
   
   IF sv_StartedManualMovements.iStartedMovements <> 0 THEN
      //ignore step bwd button if any movement is still active
      RETURN;
   END_IF;
   
   sv_bStepBwdActive := TRUE;
   
   //get actual active lines and find the inverse movements
   FOR iColumn := 1 TO sv_iUsedColumns DO
      IF sv_InterpreterParallelInfo[iColumn].bColumnActive THEN
         //it is possible that the sequence was interrupted during waiting
         //for completion of a parallel tree -> in this case the line number must be decreased
         IF (sv_ODCSequence[iColumn, sv_InterpreterParallelInfo[iColumn].iRow].iMoveId = cMoveEndParallel) THEN
            abInterpreter.aDecreaseRow(bStartInActualLine := FALSE,
                                       iColumn := iColumn,
                                       iEndRow := 1);
         ELSIF (sv_ODCSequence[iColumn, sv_InterpreterParallelInfo[iColumn].iRow].iMoveId = cMoveStartParallel) OR 
            (sv_ODCSequence[iColumn, sv_InterpreterParallelInfo[iColumn].iRow].iMoveId = cMoveStartParallelOpen) THEN
            //stepping bwd stopped during waiting for parallel trees
            //-> check actual state of this tree
            abInterpreter.aDecreaseRow(bStartInActualLine := TRUE,
                                       iColumn := iColumn,
                                       iEndRow := 1);
         END_IF;
         
         iActiveMoveNr := sv_ODCSequenceInt[iColumn, sv_InterpreterParallelInfo[iColumn].iRow].iMoveNumber;
         IF iActiveMoveNr > cMoveNone THEN
            aStartInverseMovement(iMoveNr := iActiveMoveNr,
                                 iColumn := iColumn);
         END_IF;
      END_IF;      
   END_FOR;
ELSE
   //stop actually executed step(s)
   abInterpreter.aInterruptSequence();
   
   sv_bStepBwdActive := FALSE;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

EVENT_ALGORITHM evaModifyCycleStartCondition ON EV_Task_3 WITH evModifyCycleStartCondition


VAR_INPUT
 evModifyCycleStartCondData : tevModifyCycleStartCondData;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 dummy : DINT;
 eventData : tevModifyCycleStartCondData;
 iFuIndex : DINT;
 iMoveNr : DINT;
 fbAddDependency : FBAddDependency;
 fbGetMoveNumber : FBGetMoveNumber;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_iInitOK <> 20 THEN
   dummy := Print('!!! evModifyCycleStartCondition event ignored !!!');
   RETURN; //ignore event because machine sequence is not created
END_IF;

//save event data
eventData := evModifyCycleStartCondData;

//get index of this device in the safety array
iFuIndex := 0;
FOR i := 1 TO sv_ODCDeviceMovements.iCount DO
   IF sv_ODCDeviceMovements.Devices[i].DeviceId = eventData.DeviceId THEN
      iFuIndex := i;
      EXIT;
   END_IF;
END_FOR;

IF iFuIndex = 0 THEN
   RETURN; //device not found
END_IF;

IF (eventData.iMode = 1) THEN
   //get movement number
   fbGetMoveNumber(DeviceId := eventData.DeviceId,
                  MoveId := eventData.MoveId,
                  MoveDir := eventData.MoveDir);
   
   IF fbGetMoveNumber.bFound THEN
      iMoveNr := fbGetMoveNumber.iMoveNumber;
   ELSE
      RETURN; //movement not found
   END_IF;
   
   //add this movement as additional start condition of this device
   fbAddDependency(iFuIndex := iFuIndex,
                   iMoveNr := iMoveNr,
                   iCount := eventData.iCount,
                   iMode := 1,
                   Dependency := sv_ODCSequenceInt[1,1].SafetyArray);
   
ELSE
   ; //unsupported mode 
END_IF;




;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 97 @Pou 25 
@@@BEG_Comment@@@
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".


@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
7 
@Var @RT(9)SET_ALARM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(23)START_PROCESS_ALGORITHM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)CHECK_REF @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(22)STOP_PROCESS_ALGORITHM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)FCreateODCVersion @RT(0) @T @T @DERIVED 0 @F @RT(8)FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)SET_EVENT @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(24)FGetCatConfigValueString @RT(0) @T @T @DERIVED 0 @F @RT(8)FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
30 
@Var @RT(13)cMinMoveIdent @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(32)lower limit for MoveId / MoveDir 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)cCompMold @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)101 @RT(14)Component Mold 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)cCompEjector @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)102 @RT(17)Component Ejector 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)cMoveBeginSequence @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)43 @RT(38)dummy movement for begin of a sequence 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)cMoveEndSequence @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)44 @RT(36)dummy movement for end of a sequence 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)cCompInjection @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)104 @RT(19)Component Injection 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveFwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)12 @RT(16)movement forward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveBwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)11 @RT(17)movement backward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)cMoveStartParallel @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)45 @RT(34)dummy movement for "StartParallel" 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)cMoveEndParallel @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)46 @RT(32)dummy movement for "EndParallel" 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)cMoveCooling @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)25 @RT(12)cooling time 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)cMoveShake @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)18 @RT(51)shaking movement (for example ejector vibrate mode) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveOut @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)22 @RT(27)move out (for example core) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)cMoveNone @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(13)cMinMoveIdent @RT(4)None 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(22)cODCDependencyDontCare @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)-1 @RT(76)dependency dont care, function unit not safety relevant, interpretation TRUE 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)cCompCore @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)109 @RT(14)Component Core 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)cMoveFwdInterPos @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)17 @RT(37)move forward to intermediate position 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)cMaxDeviceMovements @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)20 @RT(34)max number of movements per device 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)cMaxODCSteps @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)100 @RT(35)maximum number of rows in odc array 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)cCompNone @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(10)cMinCompId @RT(4)None 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)cMovePlast @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)13 @RT(23)plast movement (rotate) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)cTimeOutSempahore @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(5)t#30s @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)cMaxStartConditions @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)10 @RT(51)max number of start condition steps in the sequence 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)cCompOperationMode @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)111 @RT(24)Component Operation Mode 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(24)cMoveIncreaseShotCounter @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)47 @RT(21)increase shot counter 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(25)cMaxMoveDevicesRegistered @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)50 @RT(49)max number of devices which are serving movements 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)cCycleTimeArraySize @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(48)size of array that contains the last cycle times 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)cAllDevIndex @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)11 @RT(59)to lock all devices of a component ( = cMaxDeviceIndex + 1) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)cMoveStartCondition @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)52 @RT(35)dummy movement for "StartCondition" 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)cMinCompId @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)100 @RT(21)minimum Component ID  
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(5)ABODC @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
110 
@Var @RT(13)abInterpreter @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABInterpreter @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)abKODC_Builder @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)KODC_Builder @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)fbGetMoveNumber @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)FBGetMoveNumber @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbAutoManual @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBAutoManual @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbDebugTrace @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBDebugTrace @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)g_SafetyData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsGlbSafetyData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(13)fbDebugTrace2 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)FBDebugTrace2 @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)MovementsSema @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KRTOS_Semaphore @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(34)protects sv_StartedManualMovements @RT(0) 
@END_Attrib 
1 5 @F @F @F @F 

@Var @RT(14)sv_ODCSequence @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)KODC_Sequence @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_ODCSequenceInt @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)tyODCSequenceInternal @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_ODCMovements @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)KODC_Movements @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_dCycleDelaySet @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_dCycleDelayAct @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(14)sv_bFirstCycle @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_bInitDone @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(29)sv_bCombinedMovementsInManual @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_OperationMode @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(15)tnOperationMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_StartedManualMovements @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(28)tsStartedMoveDataODCExtended @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_MovementsAvailable @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tyMovementRegisterList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_bODCFilesChanged @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_bProgramSwitchChanged @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_bActivationChanged @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_StartedMovements @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tsStartedMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_ODCDeviceMovements @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(23)tsODCDeviceMovementList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(57)list of all devices that registered movements for the ODC @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_iMovementsAvailable @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_bAutoCycleRunning @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_dMaxCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_dCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_dCycleTimeMachine @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(23)act. cylce time machine @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_ODCSequenceGenerateTime @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(13)DATE_AND_TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_ODCSequenceBackup @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tyODCSequenceBackup @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_iODCSequenceAct @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_iSequenceToRestore @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_ODCDescriptionPath @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_DataState @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(11)tnDataState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_iODCSequenceUpdated @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_iUsedRows @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_iUsedColumns @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)sv_iInitOK @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(92)0 nothing initialized, 10 sequence array initialized, 20 sequence array + safety initialized @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)evStopRequest @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(14)tevStopRequest @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(16)evStartedStopped @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(17)tevStartedStopped @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(14)evStartRequest @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tevStartRequest @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(25)evAlarmFinishCycleAndStop @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)ALARM_EVENT @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(15)erODCInitFailed @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(19)erCycleTimeExceeded @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)EV_Task_3 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)EV_Task_7 @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)PU_Task_3 @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)PU_Task_7 @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)TaskAnalog @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(7)TaskMid @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(8)erAssert @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)dummy2 @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(24)mStartedCombinedMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tsStartedMoveInfo @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)mRecalcMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnODCRecalcMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(113)currently active recalc mode, set by aDoPendingRecalc when the ODC decided to start recalculation of the sequence @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)Status @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)KRTOS_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)mbStopCycle @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mbStopAfterCycle @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mbCycleTimeRunning @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(25)mbCycleTimeMachineRunning @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(32)condition for cycle time machine @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mbSequenceChanged @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(74)the ODC sequence array possibly changed->need to backup when first started @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(27)mbIgnoreProgramSwitchChange @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(68)ignore program switch or activation changes during mold data loading @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mPendingRecalc @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnODCRecalcMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(65)recalculations requested by aSetPendingRecalc but not started yet @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mbRecalcActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)TaskSlow @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(17)sv_iActiveEditors @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(29)sv_StartConditionInstanceData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(23)tyStartCondInstanceData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(50)list with start condition params for all instances @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)erCompNotInCorrectPosition @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(22)sv_bUseProgramSwitches @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(84)TRUE: create sequence by using program switches; FALSE: use sequence from ODC editor @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)erTeachModeActive @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(15)evCheckLocklist @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(16)tevCheckLocklist @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(13)sv_TraceLevel @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsTraceLevel @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_dCalculatedCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(52)calculated cycle time (written by machine sequencer) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(27)sv_iEditorPropertiesChanged @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_dAllowedCycleDeviation @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)TaskSequencer @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(30)erMovementDuringActiveSequence @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(30)erSequenceDuringActiveMovement @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(27)erMachineSequenceNotCreated @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(17)sv_dLastCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(8)sv_bTRUE @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)mbEjeBwdAtCycleStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(97)info if ejector must be bwd at the beginning of the cycle (taken from safety array of first step) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(27)miIndexEjectorInSafetyArray @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(25)sv_bODCCombinedMoveActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(87)TRUE: combined movement (for example closing sequence) is active (only in manual mode!) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)mStartConditionPosArray @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(24)tyStartConditionPosArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(90)array with information about the position of each start condition in the internal sequence @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)sv_DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_bOverrideCoreSafety @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_bOverrideEjectorSafety @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_ActiveSequence @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)tsActiveSequence @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LoopParameter @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tyLoopData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(39)array with data of all programmed loops @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)g_iAutoCycleLoopStartLine @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(23)g_iAutoCycleLoopEndLine @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(26)sv_InterpreterParallelInfo @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tyODCParallelInfo @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(61)internal state information of the interpreter, useful for HMI @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(27)g_iODCMoveDevicesRegistered @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(48)number of registered devices with ODC movements  @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(24)sv_bSequenceInterruption @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(29)TRUE: sequence is interrupted @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)di_StepFwd @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)di_StepBwd @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)PU_Task_13 @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(23)mActiveStepBwdMovements @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)tyStepBwdMovements @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(27)ArrayIndex = column number! @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)erNoInverseMovement @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(17)sv_bStepBwdActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(28)TRUE: stepping bwd is active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)erTooManyStartParallel @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(20)sv_SequenceDimension @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tsSequenceDimension @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(47)contains the maximum size of the sequence array @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)TaskInject @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(27)evModifyCycleStartCondition @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(28)tevModifyCycleStartCondition @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(25)sv_bRecalcPendingOrActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(169)The ODC wants to recalc the sequence or a recalc is currently active. Any evStartRequest sent at this time can potentially be ignored if recalculation is already active. @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)mbResetCycleTime @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(23)mbResetCycleTimeMachine @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)evNewCycleStarted @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)tevCycleStart @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

41 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(18)aIsAnyColumnActive @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(7)bActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(15)aCheckCycleTime @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
4 
@Var @RT(14)CycleTimeArray @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tyCycleTime @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(1)1 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(4)dSum @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)dAverageCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(16)paBackupSequence @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(17)aSetPendingRecalc @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(10)RecalcMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnODCRecalcMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(40)How much of the ODC array to recalculate @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(16)aDoPendingRecalc @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(14)bStartedRecalc @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(14)paInitSequence @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(7)TaskMid @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
34 
@Var @RT(11)iCalledInit @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)iCalledCreate @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)iTmpRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(7)iTmpCol @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(5)iMove @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(7)iDevice @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(9)bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)abSequDependencies @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABSequDependencies @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)fbRTC @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)RTC @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)RecalcMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnODCRecalcMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)EmptySequenceEntry @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KODC_Step @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(81)(iCompId:=cCompNone,iMoveDir:=cMoveNone,iMoveId:=cMoveNone,iIndexId:=1,iCount:=0) @RT(0) @RT(0) 
@END_Attrib 
1 15 @F @F @F @F 

@Var @RT(5)sPath @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)bFirstCall @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)sWorkPath @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)k @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(9)iInstance @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)fbLockUnlockAll @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBLockUnlock @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(87)(DeviceId:=(CompId:=cCompAll,IndexId:=cAllDevIndex),MoveDir:=cMoveAll,MoveId:=cMoveAll) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(9)bTryAgain @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)FailedRecalc @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnODCRecalcMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)iCount @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)iOrigEndLine @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)StepBeginLoop @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KODC_Step @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(85)(iCompId:=cCompODC,iMoveDir:=cMoveNone,iMoveId:=cMoveBeginLoop,iIndexId:=1,iCount:=1) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)StepEndLoop @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(9)KODC_Step @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(83)(iCompId:=cCompODC,iMoveDir:=cMoveNone,iMoveId:=cMoveEndLoop,iIndexId:=1,iCount:=1) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)iTmpCol2 @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(6)column @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(8)iTmpRow2 @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(4)line @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(8)bAddLoop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(4)iTmp @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)DeviceIdEjector1 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(33)(CompId:=cCompEjector,IndexId:=1) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)DependencyEjectorBwd @RT(0) @T @F @DT @RT(5)LWORD @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)dependency which represents "ejector bwd" @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)bInit @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)iNoOfStartParallel @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(15)aClearStepState @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
4 
@Var @RT(14)fbSetStepState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)FBSetStepState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)iTmpRow @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(10)iTmpColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(21)bExcludeActiveColumns @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(24)aStartAndCheckConditions @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
9 
@Var @RT(7)StepPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsODCStepPos @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)bNoAlarms @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(52)TRUE: alarms of not fulfilled conditions are not set @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)bCheckConditionsOk @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(17)bStartConditionOk @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(20)bCheckConditionFound @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(22)abODCCheckDependencies @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)ABODCCheckDependencies @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)iStartConditionsNotOk @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(39)number of not fulfilled startconditions @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(21)iCheckConditionsNotOk @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(39)number of not fulfilled checkconditions @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(20)aStartSingleMovement @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
22 
@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)MoveDir @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)MoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)IntermediateCond @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)bNeedCheckSafety @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)StepPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsODCStepPos @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(7)fbStart @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(7)FBStart @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(27)abODCCheckDependenciesStart @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)ABODCCheckDependencies @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(24)evCheckLocklistEventData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tevCheckLocklistData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(17)bStartConditionOk @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)bCheckConditionsOk @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)bCheckConditionFound @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)fbSetStepState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)FBSetStepState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)bIgnoreConditions @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)bSearchMovement @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)bMovementFound @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)bMovementAllowed @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)TmpStepPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsODCStepPos @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)iTmpAlarmCount @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)StepPosLowestAlarms @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsODCStepPos @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)iAlarmCount @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)bStarted @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(22)aStartCombinedMovement @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)MoveDir @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)MoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)StartPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsODCStepPos @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(9)bNotFound @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(15)evaStartRequest @STRUCTURED_TEXT 
@RT(0) @RT(14)evStartRequest @RT(13)EV_Task_3(23) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
6 
@Var @RT(18)evStartRequestData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tevStartRequestData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)StartRequestData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tevStartRequestData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)bCheckSafety @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)iSafety @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bCombined @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(14)evaStopRequest @STRUCTURED_TEXT 
@RT(0) @RT(13)evStopRequest @RT(9)EV_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(17)evStopRequestData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)tevStopRequestData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)fbStop @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(6)FBStop @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(19)aDecreaseLineNumber @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
7 
@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)MoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)MoveDir @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)fbCheckPosReached @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)FBCheckPosReached @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)iTmpColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(17)evaStartedStopped @STRUCTURED_TEXT 
@RT(0) @RT(16)evStartedStopped @RT(9)EV_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
8 
@Var @RT(20)evStartedStoppedData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)tevStartedStoppedData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)tmpMovement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(28)tsStartedMoveInfoODCExtended @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(6)bFound @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)stepPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsODCStepPos @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(3)idx @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(14)fbSetStepState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)FBSetStepState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)bCorrectInstance @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(17)pStartedMovements @STRUCTURED_TEXT 
@RT(0) @RT(43)sv_StartedManualMovements.iStartedMovements @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(22)paCyclicConditionCheck @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(10)TaskAnalog @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(28)abODCCheckDependenciesCyclic @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)ABODCCheckDependencies @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(83)must be a separate block since it is accessed from different tasks at the same time @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)TmpStepPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsODCStepPos @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(13)aRunAutoCycle @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
17 
@Var @RT(10)bStopCycle @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(22)stop cycle immediately @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)bStopAfterCycle @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(32)finish the actual cycle and stop @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)bReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(9)bCanStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(75)got the cycle start signal-> cycle can start if sequence recalc is finished @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abWaitCycleStart @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)ABWaitCycleStart @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)fbStart @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(7)FBStart @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)bDelayExceeded @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)bEjectorBwdStarted @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)DeviceIdEjector @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(33)(CompId:=cCompEjector,IndexId:=1) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)pbEjectorBwd @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)pbEjectorBwdActivated @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)pbEjectorReady @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)iMoveNrEjectorBwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)bColumnActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)bDoRecalc @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)bMovesBeforeAutoLoop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(23)paRunAutomaticMovements @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(13)TaskSequencer @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(9)pInitDone @STRUCTURED_TEXT 
@RT(0) @RT(12)sv_bInitDone @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(6)paInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(7)TaskMid @T @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(8)swoState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSWO_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(14)pOpmodeChanged @STRUCTURED_TEXT 
@RT(0) @RT(16)sv_OperationMode @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(21)evaFinishCycleAndStop @STRUCTURED_TEXT 
@RT(0) @RT(25)evAlarmFinishCycleAndStop @RT(9)EV_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(24)evFinishCycleAndStopData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)ALARM_EVENT_DATA @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(10)pDataState @STRUCTURED_TEXT 
@RT(0) @RT(12)sv_DataState @RT(12)PU_Task_3(1) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(9)PrevState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tnDataState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(24)pDescriptionFilesChanged @STRUCTURED_TEXT 
@RT(0) @RT(19)sv_bODCFilesChanged @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(22)pNewSequenceFromEditor @STRUCTURED_TEXT 
@RT(0) @RT(17)sv_iActiveEditors @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(12)fbLockUnlock @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBLockUnlock @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(98)(DeviceId:=(CompId:=cCompOperationMode,IndexId:=1),MoveDir:=cModeAutomatic,MoveId:=cModeAutomatic) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(22)aRestoreSequenceBackup @STRUCTURED_TEXT 
@RT(0) @RT(21)sv_iSequenceToRestore @RT(9)EV_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(21)pProgramSwitchChanged @STRUCTURED_TEXT 
@RT(0) @RT(24)sv_bProgramSwitchChanged @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(18)pActivationChanged @STRUCTURED_TEXT 
@RT(0) @RT(21)sv_bActivationChanged @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(13)paVersionInfo @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @T @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(24)pChangeToProgramSwitches @STRUCTURED_TEXT 
@RT(0) @RT(22)sv_bUseProgramSwitches @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(7)iDevice @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(26)aCheckCycleStartConditions @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
10 
@Var @RT(3)Pos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsODCStepPos @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)SafetyArray @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tyODCDependencyArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)iDefaultMove @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)iDevice @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(8)bAllowed @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)abODCCheckDependencies @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)ABODCCheckDependencies @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)fbCheckPosReached @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)FBCheckPosReached @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)bEjectorIgnored @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)EjectorDependency @RT(0) @T @F @DT @RT(5)LWORD @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(14)pOperationMode @STRUCTURED_TEXT 
@RT(0) @RT(16)sv_OperationMode @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(10)PrevOpMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnOperationMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(7)nManual @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)sOperationMode @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(27)paRunManualCombinedMovement @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(13)TaskSequencer @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(23)paCheckConditionsManual @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(10)TaskAnalog @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(10)TmpStepPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsODCStepPos @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(11)paCycleTime @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(10)TaskInject @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)fbTonCycleTime @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)TON @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(18)paCycleTimeMachine @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(7)TaskMid @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)fbTonCycleTimeMachine @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)TON @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(46)Clock the cycletime from start to end of cycle @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(21)pSequenceInterruption @STRUCTURED_TEXT 
@RT(0) @RT(24)sv_bSequenceInterruption @RT(10)PU_Task_13 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(21)aStartInverseMovement @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(7)iMoveNr @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)iColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)iFuIndex @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)iMoveIdInverse @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(8)pStepFwd @STRUCTURED_TEXT 
@RT(0) @RT(10)di_StepFwd @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(8)pStepBwd @STRUCTURED_TEXT 
@RT(0) @RT(10)di_StepBwd @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(7)iColumn @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(13)iActiveMoveNr @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(28)evaModifyCycleStartCondition @STRUCTURED_TEXT 
@RT(0) @RT(27)evModifyCycleStartCondition @RT(9)EV_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
8 
@Var @RT(26)evModifyCycleStartCondData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(27)tevModifyCycleStartCondData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)eventData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(27)tevModifyCycleStartCondData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)iFuIndex @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(7)iMoveNr @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)fbAddDependency @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)FBAddDependency @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)fbGetMoveNumber @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)FBGetMoveNumber @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bActive := FALSE;
FOR i := 2 TO sv_iUsedColumns DO
   IF sv_InterpreterParallelInfo[i].bColumnActive THEN
      bActive := TRUE;
      EXIT;
   END_IF;
END_FOR;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(25)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

CycleTimeArray[i] := sv_dCycleTime;
dSum := dSum + CycleTimeArray[i];
i := i + 1;

IF i > cCycleTimeArraySize THEN      
   //check if cycletime of last x - cycles is stable
   dAverageCycleTime := dSum / cCycleTimeArraySize;
        
   //-> check deviation between average cycle time and calculated cycle time
   IF (SUB_TIME(dAverageCycleTime, sv_dCalculatedCycleTime)) > sv_dAllowedCycleDeviation THEN
      sv_iEditorPropertiesChanged := sv_iEditorPropertiesChanged + 1;
   END_IF;
     
   i := 1;
   dSum := t#0s;
END_IF;
  
   
   

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(34)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT mbSequenceChanged THEN
   fbDebugTrace2(nODCInterpreter, 'no sequence backup written as sequence did NOT change');
   STOP_PROCESS_ALGORITHM();
   RETURN;
END_IF;

mbSequenceChanged := FALSE;

IF sv_ODCSequenceBackup[sv_iODCSequenceAct].Sequence = sv_ODCSequence THEN
   fbDebugTrace2(nODCInterpreter, 'ODC sequences equal, doing nothing');
   STOP_PROCESS_ALGORITHM();
   RETURN;
END_IF;
fbDebugTrace2(nODCInterpreter, 'ODC sequences different, making backup');

sv_iODCSequenceAct := sv_iODCSequenceAct + 1;
IF sv_iODCSequenceAct > cODCSequenceBackupCount THEN
   sv_iODCSequenceAct := 1;
END_IF;

//FIXME: maybe do in smaller steps to avoid blocking the system for a long time
fbDebugTrace2(nODCInterpreter, CONCAT('saving new ODC sequence in history at pos ', DINT_TO_STRING(sv_iODCSequenceAct)));

sv_ODCSequenceBackup[sv_iODCSequenceAct].Sequence := sv_ODCSequence;
sv_ODCSequenceBackup[sv_iODCSequenceAct].Date := sv_ODCSequenceGenerateTime;
fbDebugTrace2(nODCInterpreter, 'saving backup done');

STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
Back up the current sequence (sv_ODCSequence)
A backup is only written when sv_ODCSequence is not equal to the last backup
@@@END_Comment@@@ 

@BEG_Body 
@TL(10)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF RecalcMode > mPendingRecalc THEN
   mPendingRecalc := RecalcMode;
   sv_bRecalcPendingOrActive := TRUE;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(5)
Queue a recalculation of the ODC sequence

nODCRecalcReloadFiles reload the ODC files from the CF + nODCRecalcCylce
nODCRecalcCylce       recalculate the cycle(because a program switch changed) + nODCRecalcSafety
nODCRecalcSafety      recalculate safety only(a movement was disabled)
@@@END_Comment@@@ 

@BEG_Body 
@TL(44)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bStartedRecalc := FALSE;

IF mPendingRecalc = nODCRecalcNone THEN
   RETURN;
END_IF;

IF mbRecalcActive THEN
   fbDebugTrace('another ODC recalc is already active, new recalc will be executed later');
   RETURN;
END_IF;

IF mPendingRecalc > mRecalcMode THEN
   mRecalcMode := mPendingRecalc;    
END_IF;
// mRecalcMode will be reset after the recalc finished successfully
// but keeps the value if an error occured
// this way we can be sure the right recalc mode is used when
// the first recalc with nODCRecalcCylce fails and the second recalc with only nODCRecalcSafety succeeds
// the cycle is recalculated, and not only safety

mPendingRecalc := nODCRecalcNone;

IF mRecalcMode = nODCRecalcReloadFiles THEN
   fbDebugTrace2(nODCInterpreter, 'start initializing ODC array WITH reading new files');
ELSIF mRecalcMode = nODCRecalcCylce THEN
   fbDebugTrace2(nODCInterpreter, 'start initializing ODC array WITHOUT reading new files');
ELSIF mRecalcMode = nODCRecalcSafety THEN
   fbDebugTrace2(nODCInterpreter, 'start initializing ODC dependency array');
ELSIF mRecalcMode = nODCRecalcInternal THEN
   fbDebugTrace2(nODCInterpreter, 'start initializing internal ODC array');      
ELSE
   fbDebugTrace2(nODCInterpreter, 'NOT starting initialization of ODC because we got a strange reason');
   RETURN;
END_IF;

bStartedRecalc := TRUE;
mbRecalcActive := TRUE; //set flag immediately, do not wait for PA, which might be delayed a bit because it is low prio
START_PROCESS_ALGORITHM(paInitSequence);

@END_Body 

@@@BEG_Comment@@@ 
@TL(5)
Start a pending recalculation of the ODC sequence

If bStartedRecalc is TRUE then a pending recalculation was started.

To find out when recalculation finishes wait until mbRecalcActive is FALSE again
@@@END_Comment@@@ 

@BEG_SfcBody 
60 37 52 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 15 
@Step @RT(6)SError @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)AError @F @T @RT(1)N @RT(0) @F @F @T @TL(22)
fbDebugTrace('initializing ODC array NOT successful');   

(* set the generic erODCInitFailed ALARM which will block machine operation
   for detailed information other alarms are set which explain 1 or more problems
   of the ODC sequence *)
SET_ALARM(Name := erODCInitFailed);

mbRecalcActive := FALSE;

//reset mRecalcMode
//this way a failed recalc can not be replaced by a succeeding recalc
//of lower priority
mRecalcMode := FailedRecalc;

// indicate an update of the odc list so the hmi can react properly
sv_iODCSequenceUpdated := sv_iODCSequenceUpdated + 1;

//notify other code parts when recalc is finished (in this case unsuccessfully)
sv_bRecalcPendingOrActive := FALSE;

STOP_PROCESS_ALGORITHM();

@F 

@Trans @RT(7)Trans25 @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)Trans25 @F 
@Step @RT(6)SStart @F @T @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(6)AStart @F @T @RT(1)P @RT(0) @F @F @T @TL(14)
fbDebugTrace2(nODCInterpreter, 'starting initialisation of ODC sequence');

RESET_ALARM(Name := erODCInitFailed);

RecalcMode := mRecalcMode;
FailedRecalc := mRecalcMode;  //remember in case of failed recalc so we can repeat
mRecalcMode := nODCRecalcNone;

sv_iInitOK := 0;

(* lock all movements so nothing can happen during init *)
fbLockUnlockAll.Alarm.AlarmId := erMachineSequenceNotCreated;
fbLockUnlockAll(Mode := nLockAbort);

@F 
@Acb @RT(23)AInitAdditionalMoveData @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(26)AResetProgrammedInSequence @F @F @RT(1)P @RT(0) @F @F @F @F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans38 @F @T @F @F @T @F @TL(2)
RecalcMode <> nODCRecalcInternal

@RT(7)Trans38 @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(22)TNewSequenceFromEditor @F @T @F @F @T @F @TL(2)
RecalcMode = nODCRecalcInternal

@RT(7)Trans39 @F 
@Goto @RT(21)SSanityCheckAndNumber @F @F 


@Step @RT(6)Step28 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans13 @F @T @F @F @T @F @TL(2)
NOT (RecalcMode >= nODCRecalcReloadFiles)

@RT(7)Trans13 @F 

@TransSeq @RT(4)tseq @F 5 
@Trans @RT(18)TRecalcReloadFiles @F @T @F @F @T @F @TL(2)
RecalcMode >= nODCRecalcReloadFiles

@RT(7)Trans12 @F 
@Step @RT(13)SInitSequence @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(6)AInit1 @F @T @RT(1)P @RT(0) @F @F @T @TL(11)
iCalledInit := 0;
iCalledCreate := 0;

IF NOT bFirstCall THEN
   sWorkPath := FGetCatConfigValueString('System.workPath', '/harddisk0/');
   bFirstCall := TRUE;
END_IF;

sPath := CONCAT(sWorkPath, sv_ODCDescriptionPath);
abKODC_Builder.Init(Movements := sv_ODCMovements, DescriptionFilePath := sPath, Execute := FALSE);

@F 
@Acb @RT(6)AInit2 @F @T @RT(1)N @RT(0) @F @F @T @TL(3)
abKODC_Builder.Init(Execute := TRUE);
iCalledInit := iCalledInit + 1;

@F 

@Trans @RT(6)Trans2 @F @T @F @F @T @T @TL(2)
abKODC_Builder.Init.Done OR abKODC_Builder.Init.Error

@RT(6)Trans2 @F 
@Step @RT(17)SInitSequenceDone @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)AInit3 @F @T @RT(1)P @RT(0) @F @F @T @TL(14)
IF abKODC_Builder.Init.Error AND abKODC_Builder.Init.Done THEN
   fbDebugTrace2(nODCInterpreter, 'ERROR init returned success and failure at the same time');
END_IF;

IF abKODC_Builder.Init.Done THEN
   fbDebugTrace2(nODCInterpreter, CONCAT('called init ',
                                         DINT_TO_STRING(iCalledInit),
                                         ' times then it returned success'));
ELSIF abKODC_Builder.Init.Error THEN    
   fbDebugTrace2(nODCInterpreter, CONCAT('called init ',
                                         DINT_TO_STRING(iCalledInit),
                                         ' times then it returned error'));
END_IF;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans11 @F @T @F @F @T @F @TL(2)
NOT abKODC_Builder.Init.Error

@RT(7)Trans11 @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(7)Trans26 @F @T @F @F @T @F @TL(2)
abKODC_Builder.Init.Error

@RT(7)Trans26 @F 
@Goto @RT(6)SError @F @F 




@Step @RT(6)Step16 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans20 @F @T @F @F @T @F @TL(2)
NOT (RecalcMode >= nODCRecalcCylce)

@RT(7)Trans20 @F 

@TransSeq @RT(4)tseq @F 11 
@Trans @RT(12)TRecalcCycle @F @T @F @F @T @F @TL(2)
RecalcMode >= nODCRecalcCylce

@RT(7)Trans19 @F 
@Step @RT(15)SCreateSequence @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(14)AClearSequence @F @F @RT(1)P @RT(0) @F @F @T @F 
@Acb @RT(16)ACreateSequence1 @F @T @RT(1)P @RT(0) @F @F @T @TL(6)
fbDebugTrace2(nODCInterpreter, 'initialisation of ODC array');
(* WARNING: Columns and Rows must be <= the real size of the array
   otherwise the builder will write outside of the array
   and memory corruption will occur ! *)
abKODC_Builder.CreateSequence(Sequence := sv_ODCSequence, Columns := cMaxParallelMovements, Rows := cMaxODCSteps, Execute := FALSE);

@F 
@Acb @RT(16)ACreateSequence2 @F @T @RT(1)N @RT(0) @F @F @T @TL(3)
abKODC_Builder.CreateSequence(Execute := TRUE);
iCalledCreate := iCalledCreate + 1;

@F 

@Trans @RT(6)Trans4 @F @T @F @F @T @T @TL(2)
abKODC_Builder.CreateSequence.Error OR abKODC_Builder.CreateSequence.Done

@RT(6)Trans4 @F 
@Step @RT(19)SCreateSequenceDone @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(16)ACreateSequence3 @F @T @RT(1)P @RT(0) @F @F @T @TL(14)
IF abKODC_Builder.CreateSequence.Error AND abKODC_Builder.CreateSequence.Done THEN
   fbDebugTrace2(nODCInterpreter, 'ERROR CreateSequence returned success and failure at the same time');
END_IF;

IF abKODC_Builder.CreateSequence.Done THEN
   fbDebugTrace2(nODCInterpreter, CONCAT('called CreateSequence ',
                                         DINT_TO_STRING(iCalledCreate),
                                         ' times then it returned success'));
ELSIF abKODC_Builder.CreateSequence.Error THEN    
   fbDebugTrace2(nODCInterpreter, CONCAT('called CreateSequence ',
                                         DINT_TO_STRING(iCalledCreate),
                                         ' times then it returned error'));
END_IF;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans27 @F @T @F @F @T @F @TL(2)
NOT abKODC_Builder.CreateSequence.Error

@RT(7)Trans27 @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(7)Trans28 @F @T @F @F @T @F @TL(2)
abKODC_Builder.CreateSequence.Error

@RT(7)Trans28 @F 
@Goto @RT(6)SError @F @F 


@Step @RT(21)SSanityCheckAndNumber @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(23)ACheckSequenceDimension @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(15)AInitEmptySteps @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(7)ASanity @F @T @RT(1)P @RT(0) @F @F @T @TL(10)
bError := FALSE;
abInterpreter.aCheckSequenceSanity();
IF NOT abInterpreter.aCheckSequenceSanity.bOK THEN
   fbDebugTrace('checking sanity of ODC array failed');
   bError := TRUE;
   RETURN;
END_IF;
bAddLoop := NOT abInterpreter.aCheckSequenceSanity.bAutoCycleLoopFound;
iNoOfStartParallel := abInterpreter.aCheckSequenceSanity.iNoOfStartParallel;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans46 @F @T @F @F @T @F @TL(2)
NOT bError

@RT(7)Trans46 @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(7)Trans50 @F @T @F @F @T @F @TL(2)
bError

@RT(7)Trans50 @F 
@Goto @RT(6)SError @F @F 


@Step @RT(6)Step33 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(7)Trans48 @F @T @F @F @T @F @TL(2)
bAddLoop

@RT(7)Trans48 @F 
@Step @RT(14)S_AddCycleLoop @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(20)AInsertAutoCycleLoop @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(10)TLoopAdded @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)Trans50 @F 

@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans49 @F @T @T @F @T @F @TL(2)
NOT bAddLoop

@RT(7)Trans49 @F 


@Step @RT(6)Step32 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(23)ACreateInternalSequence @F @T @RT(1)P @RT(0) @F @F @T @TL(18)
bError := FALSE;
abInterpreter.aClearInternalSequence();

abInterpreter.aCreateInternalSequence();
IF abInterpreter.aCreateInternalSequence.bError THEN
   fbDebugTrace('aCreateInternalSequence failed');
   bError := TRUE;
   RETURN;
END_IF;

sv_iUsedColumns := abInterpreter.aCreateInternalSequence.iUsedColumns;
sv_iUsedRows := abInterpreter.aCreateInternalSequence.iUsedRows;

// save sequence generation time
fbRTC(EN := FALSE);
sv_ODCSequenceGenerateTime := fbRTC.CDT;
mbSequenceChanged := TRUE;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(7)Trans14 @F @T @F @F @T @T @TL(2)
NOT bError

@RT(7)Trans14 @F 
@Step @RT(6)Step26 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(15)AInitSequenceOK @F @T @RT(1)N @RT(0) @F @F @T @TL(2)
sv_iInitOK := 10;

@F 

@Trans @RT(7)Trans36 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans36 @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(7)Trans29 @F @T @F @F @T @T @TL(2)
bError

@RT(7)Trans29 @F 
@Goto @RT(6)SError @F @F 




@Step @RT(19)SBeforeRecalcSafety @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans22 @F @T @F @F @T @F @TL(2)
NOT (RecalcMode >= nODCRecalcSafety)

@RT(7)Trans22 @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(13)TRecalcSafety @F @T @F @F @T @F @TL(2)
RecalcMode >= nODCRecalcSafety

@RT(7)Trans23 @F 
@Step @RT(13)SRecalcSafety @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(20)ACalcSeqDependencies @F @T @RT(1)P @RT(0) @F @F @T @TL(11)
IF iNoOfStartParallel <= cMaxStartParallel THEN
   RESET_ALARM(Name := erTooManyStartParallel);
   abSequDependencies.aCalc();
   IF abSequDependencies.aCalc.bError THEN
      bError := TRUE;
      fbDebugTrace('sequence dependency calculation returned a error');
   END_IF;
ELSE
   SET_ALARM(Name := erTooManyStartParallel);
END_IF;

@F 
@Acb @RT(24)ASetProgrammedInSequence @F @F @RT(1)P @RT(0) @F @F @F @F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans24 @F @T @F @F @T @F @TL(2)
NOT bError

@RT(7)Trans24 @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(7)Trans30 @F @T @F @F @T @F @TL(2)
bError

@RT(7)Trans30 @F 
@Goto @RT(6)SError @F @F 




@Step @RT(22)S_Check_Pending_Recalc @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(22)ACheckForPendingRecalc @F @T @RT(1)P @RT(0) @F @F @T @TL(9)
bTryAgain := FALSE;
IF mPendingRecalc <> nODCRecalcNone THEN
   //recalc during creation of sequence requested
   //=> ignore result and start again
   mRecalcMode := mPendingRecalc;
   mPendingRecalc := nODCRecalcNone;
   bTryAgain := TRUE; 
END_IF;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(9)TNoRecalc @F @T @F @F @T @F @TL(2)
NOT bTryAgain

@RT(7)Trans44 @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(7)TRecalc @F @T @F @F @T @F @TL(2)
bTryAgain

@RT(7)Trans45 @F 
@Goto @RT(6)SStart @F @F 


@Step @RT(7)SFinish @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(24)ACheckEjeBwdAtCycleStart @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(7)AFinish @F @T @RT(1)N @RT(0) @F @F @T @TL(18)
(* array ok -> unlock all movements *)
fbLockUnlockAll.Alarm.AlarmId := erMachineSequenceNotCreated;
fbLockUnlockAll(Mode := nUnlock);

abInterpreter.aSetInitOK();
fbDebugTrace2(nODCInterpreter, 'initializing ODC array successful');   

mbRecalcActive := FALSE;

// indicate an update of the odc list so the hmi can react properly
sv_iInitOK := 20;
sv_iODCSequenceUpdated := sv_iODCSequenceUpdated + 1;

//notify other code parts when recalc is finished (and it is OK to send an evStartRequest)
sv_bRecalcPendingOrActive := FALSE;

STOP_PROCESS_ALGORITHM();

@F 

@Trans @RT(6)Trans8 @F @T @F @F @T @T @TL(2)
TRUE

@RT(6)Trans8 @F 
@Goto @RT(6)SStart @F @F 
@END_SfcData 
@SaActions 8 
@SaText @RT(14)AClearSequence 1 @TL(9)
(* make sure the array is clean
   important for testing when 2 different partially initialized
   arrays are used *)
FOR iTmpCol := 1 TO cMaxParallelMovements DO
   FOR iTmpRow := 1 TO cMaxODCSteps DO
      sv_ODCSequence[iTmpCol][iTmpRow] := EmptySequenceEntry;
   END_FOR;
END_FOR;


@SaText @RT(23)AInitAdditionalMoveData 1 @TL(35)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
IF NOT bInitDone THEN
   
   //get FuIndex of all registered movements
   //fuIndex = index of the device in sv_ODCDeviceMovements
   FOR iMove := 1 TO sv_iMovementsAvailable DO
      FOR iDevice := 1 TO sv_ODCDeviceMovements.iCount DO
         IF sv_MovementsAvailable[iMove].DeviceId = sv_ODCDeviceMovements.Devices[iDevice].DeviceId THEN
            sv_MovementsAvailable[iMove].iFuIndex := iDevice;
            EXIT;
         END_IF;
      END_FOR;  
   END_FOR;
   
   //get number of default movement for every device in sv_ODCDeviceMovements
   FOR iDevice := 1 TO sv_ODCDeviceMovements.iCount DO
      DeviceId := sv_ODCDeviceMovements.Devices[iDevice].DeviceId;
      FOR iMove := 1 TO sv_iMovementsAvailable DO        
         IF sv_MovementsAvailable[iMove].DeviceId = DeviceId AND sv_MovementsAvailable[iMove].pMovementData^.bDefaultPos THEN
            //default movement found
            sv_ODCDeviceMovements.Devices[iDevice].iDefaultMoveNumber := iMove;
            EXIT;
         END_IF;
      END_FOR;   
   END_FOR;
   
   bInitDone := TRUE;
   
END_IF;

   


@SaText @RT(26)AResetProgrammedInSequence 1 @TL(33)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF RecalcMode = nODCRecalcNone OR RecalcMode = nODCRecalcSafety THEN
   ;//no change in sequence
ELSE
   //sequence changed -> reset bProgrammedInSequence for all movements
   FOR iMove := 1 TO sv_iMovementsAvailable DO   
      sv_MovementsAvailable[iMove].pMovementData^.bProgrammedInSequence := FALSE;
      
      IF sv_MovementsAvailable[iMove].pMovementData^.bInstanceable AND
        CHECK_REF(sv_MovementsAvailable[iMove].pMovementData^.InstanceData.pProgrammedInSequenceArray^) THEN
         
         //movement instanceable -> init programmed in sequence for all instances
         FOR k:= 1 TO cMaxIntermediateConditions DO
            sv_MovementsAvailable[iMove].pMovementData^.InstanceData.pProgrammedInSequenceArray^[k] := FALSE;
         END_FOR;
                  
      END_IF;
   END_FOR;
   
   //reset array with start condition positions
   FOR i := 1 TO cMaxStartConditions DO
      mStartConditionPosArray[i].iColumn := 0;
      mStartConditionPosArray[i].iRow := 0;
   END_FOR;
END_IF;





@SaText @RT(24)ASetProgrammedInSequence 1 @TL(32)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//set bProgrammedInSequence for all movements which are
//included in the created sequence
FOR iTmpRow := 1 TO sv_iUsedRows DO
   FOR iTmpCol := 1 TO sv_iUsedColumns DO
      iMove := sv_ODCSequenceInt[iTmpCol,iTmpRow].iMoveNumber;
      IF iMove >= cMoveNone THEN
         sv_MovementsAvailable[iMove].pMovementData^.bProgrammedInSequence := TRUE;
                  
         IF sv_MovementsAvailable[iMove].pMovementData^.bInstanceable AND 
           CHECK_REF(sv_MovementsAvailable[iMove].pMovementData^.InstanceData.pProgrammedInSequenceArray^) THEN
            //movement instanceable -> set programmed in sequence for according instance
            iInstance := sv_ODCSequenceInt[iTmpCol,iTmpRow].iCount;
            sv_MovementsAvailable[iMove].pMovementData^.InstanceData.pProgrammedInSequenceArray^[iInstance] := TRUE;
         END_IF;
         
      END_IF;
      
      //save position if step is a start condition
      IF sv_ODCSequence[iTmpCol,iTmpRow].iMoveId = cMoveStartCondition THEN
         iCount := sv_ODCSequence[iTmpCol, iTmpRow].iCount; 
         mStartConditionPosArray[iCount].iColumn := iTmpCol;
         mStartConditionPosArray[iCount].iRow := iTmpRow;
      END_IF;
      
   END_FOR;
END_FOR;


@SaText @RT(24)ACheckEjeBwdAtCycleStart 1 @TL(40)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//get index of ejector 1 in sv_ODCDeviceMovements
//and also get dependency which represents "Ejector bwd"
IF NOT bInit THEN
   FOR i := 1 TO g_iODCMoveDevicesRegistered DO   
      IF sv_ODCDeviceMovements.Devices[i].DeviceId = DeviceIdEjector1 THEN
         miIndexEjectorInSafetyArray := i;
         
         //find ejector bwd movement
         FOR k := 1 TO sv_ODCDeviceMovements.Devices[miIndexEjectorInSafetyArray].iNumberOfMovements DO
            IF sv_ODCDeviceMovements.Devices[miIndexEjectorInSafetyArray].Movements[k]^.MoveId = cMoveBwd THEN
               
               //movement found in sv_ODCDeviceMovements -> set the according bit               
               DependencyEjectorBwd := cFirstBit;
               
               //first movement: shift right 0, second movement: shift right 1, ... 
               DependencyEjectorBwd := SHR(DependencyEjectorBwd, (k-1));
               EXIT;
            END_IF;
         END_FOR;
         
         EXIT;
      END_IF;
   END_FOR;
   bInit := TRUE;
END_IF;
   
//avoid problems if no ejector is available
mbEjeBwdAtCycleStart := FALSE;
IF miIndexEjectorInSafetyArray > 0 THEN   
   //check dependency array of first step and find out if ejector must be bwd
   IF sv_ODCSequenceInt[1,1].SafetyArray[miIndexEjectorInSafetyArray].Dependency = DependencyEjectorBwd THEN
      mbEjeBwdAtCycleStart := TRUE;
   END_IF;
END_IF;


@SaText @RT(20)AInsertAutoCycleLoop 1 @TL(50)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bODCInterpreter THEN
   dummy := Print('No AutoCycleLoop found ----> add LOOP automatically');
END_IF;

iOrigEndLine := abInterpreter.aCheckSequenceSanity.iEndSequenceRow;
IF sv_TraceLevel.bODCInterpreter THEN
   dummy := Print('original end line: %d', iOrigEndLine);
END_IF;
   
//move line with ODC.EndSequence two lines down
//add ODC.EndLoop before ODC.EndSequence
//move the whole sequence one line down
//add ODC.BeginLoop in second line (first line is ODC.BeginSequence)
//fill sv_LoopData with correct values

FOR iTmpCol2 := 1 TO cMaxParallelMovements DO
   sv_ODCSequence[iTmpCol2,(iOrigEndLine+2)] := sv_ODCSequence[iTmpCol2, iOrigEndLine];
END_FOR;

 
IF sv_TraceLevel.bODCInterpreter THEN
   iTmp := iOrigEndLine +1;
   dummy := Print('Adding end loop in line %d', iTmp);
END_IF;

sv_ODCSequence[1,(iOrigEndLine+1)] := StepEndLoop;
g_iAutoCycleLoopEndLine := (iOrigEndLine+1);

FOR iTmpRow2 := iOrigEndLine TO 2 BY -1 DO
   FOR iTmpCol2 := 1 TO cMaxParallelMovements DO
      sv_ODCSequence[iTmpCol2,iTmpRow2] := sv_ODCSequence[iTmpCol2,(iTmpRow2-1)];
   END_FOR;
END_FOR;

IF sv_TraceLevel.bODCInterpreter THEN   
   dummy := Print('Adding begin loop in line 2');
END_IF;
sv_ODCSequence[1,2] := StepBeginLoop;
g_iAutoCycleLoopStartLine := 2;

sv_LoopParameter[1].sTextKey := 'TxtAutoCycleLoop';
sv_LoopParameter[1].sVariable1 := 'system.sv_bFALSE';
sv_LoopParameter[1].sVariable2 := 'system.sv_bTRUE';
sv_LoopParameter[1].CompareOperator := nCompOperatorEqual;


@SaText @RT(15)AInitEmptySteps 1 @TL(18)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//performance optimization:
//at empty steps the machine sequencer only sets iCompId to cMinCompId
//iMoveId, iMoveDir, ... are not changed and keep the "old" values
//=> this steps must be set to "empty" steps in the IEC code
FOR iTmpCol := 1 TO cMaxParallelMovements DO
   FOR iTmpRow := 1 TO cMaxODCSteps DO
      IF (sv_ODCSequence[iTmpCol][iTmpRow].iCompId = cMinCompId) AND (sv_ODCSequence[iTmpCol][iTmpRow].iMoveId <> cMoveNone) THEN
         //set the whole step to "Empty"
         sv_ODCSequence[iTmpCol][iTmpRow] := EmptySequenceEntry;
      END_IF;
   END_FOR;
END_FOR;


@SaText @RT(23)ACheckSequenceDimension 1 @TL(38)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (sv_SequenceDimension.iMaxColumns > 0) AND (sv_SequenceDimension.iMaxRows > 0) THEN
   
   IF sv_SequenceDimension.iMaxColumns < cMaxParallelMovements THEN
      //loaded sequence is smaller (lower number of columns) than the actual sequence
      //-> init the rest of the columns
      FOR iTmpCol := (sv_SequenceDimension.iMaxColumns + 1) TO cMaxParallelMovements DO
         FOR iTmpRow := 1 TO cMaxODCSteps DO
            sv_ODCSequence[iTmpCol][iTmpRow] := EmptySequenceEntry;
         END_FOR;
      END_FOR;
   END_IF;
   
   IF sv_SequenceDimension.iMaxRows < cMaxODCSteps THEN
      //loaded sequence is smaller (lower number of rows) than the actual sequence
      //-> init the rest of the rows
      FOR iTmpCol := 1 TO sv_SequenceDimension.iMaxColumns DO
         FOR iTmpRow := (sv_SequenceDimension.iMaxRows + 1) TO cMaxODCSteps DO
            sv_ODCSequence[iTmpCol][iTmpRow] := EmptySequenceEntry;
         END_FOR;
      END_FOR;
   END_IF;
ELSE   
   ;//loaded data does not contain the sequence dimension (=> data was created with a KePlast version < 01.38) 
   //Attention:
   //It is not possible to automatically assume that the sequence dimension is 6 columns and 100 rows
   //in this case, because maybe in some customer projects the sequence size was already increased in
   //KePlast versions < 01.38
END_IF;

//set dimension to actual implemented array size
sv_SequenceDimension.iMaxColumns := cMaxParallelMovements;
sv_SequenceDimension.iMaxRows := cMaxODCSteps;


@SaTrans 0 
@SaExits 0 
@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(3)
Does the (re)initialisation of the ODC sequence and saves
the sequence generation time

@@@END_Comment@@@ 

@BEG_Body 
@TL(24)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter, 'begin clearing step state');

FOR iTmpRow := 1 TO sv_iUsedRows DO
   fbSetStepState.StepState := nStateDefault;
   fbSetStepState.StepPos.iRow := iTmpRow;
   
   FOR iTmpColumn := 1 TO sv_iUsedColumns DO
      fbSetStepState.StepPos.iColumn := iTmpColumn;
      
      IF NOT (bExcludeActiveColumns AND sv_InterpreterParallelInfo[iTmpColumn].bColumnActive) THEN
         //reset step state depending on bExcludeActiceColumns 
         fbSetStepState();
      END_IF;
      
   END_FOR;
END_FOR;

fbDebugTrace2(nODCInterpreter, 'finished clearing step state');

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(64)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// check if a start condition exists for the requested movement
bStartConditionOk := TRUE;
iStartConditionsNotOk := 0;
FOR i := 1 TO cMaxStartConditions DO
   IF sv_ODCSequence[StepPos.iColumn][StepPos.iRow] = sv_StartConditionInstanceData[i].DelayedMovement THEN
      // start condition found -> check if start condition is reached
      abInterpreter.aCheckStartConditionReached(iInstance := i);
      IF NOT abInterpreter.aCheckStartConditionReached.bReached THEN
         IF NOT bNoAlarms THEN
            // set alarm
            SET_ALARM(Name := erCompNotInCorrectPosition,
                      SubID1 := sv_StartConditionInstanceData[i].RelatedMovement.iCompId,
                      SubID2 := sv_StartConditionInstanceData[i].RelatedMovement.iIndexId);
         END_IF;         
         bStartConditionOk := FALSE;
         iStartConditionsNotOk := iStartConditionsNotOk + 1;
      END_IF;            
   ELSIF sv_ODCSequence[StepPos.iColumn][StepPos.iRow] = sv_StartConditionInstanceData[i].RelatedMovement THEN
      //also check if the requested movement is the "RelatedMovement" of a startcondition
      //for example: core in with startpos parallel to mold close
      //if mold close movement is requested, the core must be out until the start position for the core is reached
      
      //check if start condition is reached
      abInterpreter.aCheckStartConditionReached(iInstance := i);
      IF NOT abInterpreter.aCheckStartConditionReached.bReached THEN
         //check safety array
         abODCCheckDependencies.aCheck.StepPos.iColumn := mStartConditionPosArray[i].iColumn;
         abODCCheckDependencies.aCheck.StepPos.iRow := mStartConditionPosArray[i].iRow;
            
         abODCCheckDependencies.aCheck(DeviceIdSelf := sv_DeviceId, bNoAlarmsAndStepState := bNoAlarms);
         IF NOT abODCCheckDependencies.aCheck.bAllowed THEN
            fbDebugTrace2(nODCInterpreter, CONCAT('manual movement at pos ',
                                                   DINT_TO_STRING(StepPos.iRow),
                                                   '/',
                                                   DINT_TO_STRING(StepPos.iColumn),
                                                   ' not allowed because of related startcondition'));
            bStartConditionOk := FALSE;
            iStartConditionsNotOk := iStartConditionsNotOk + 1;
         END_IF;
      END_IF;
   END_IF;
END_FOR;


// check if a check condition exists for the requested movement
bCheckConditionsOk := TRUE;
bCheckConditionFound := FALSE;
iCheckConditionsNotOk := 0;
abInterpreter.aFindCheckCondition(Movement := sv_ODCSequence[StepPos.iColumn][StepPos.iRow],
                                    bFound => bCheckConditionFound); 

IF bCheckConditionFound THEN
   abInterpreter.aCheckConditionsManual(Movement := sv_ODCSequence[StepPos.iColumn][StepPos.iRow], bNoAlarms := bNoAlarms);
   bCheckConditionsOk := abInterpreter.aCheckConditionsManual.bCheckConditionsOk;
   iCheckConditionsNotOk := abInterpreter.aCheckConditionsManual.iConditionsNotOk;
END_IF;



@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
Start a single movement (in response to evStartRequest)
@@@END_Comment@@@ 

@BEG_Body 
@TL(149)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bStarted := FALSE;
bMovementFound := FALSE;
bSearchMovement := TRUE;
iAlarmCount := 0;
TmpStepPos.iColumn := 1;
TmpStepPos.iRow := 1;

//core and ejector movements should be possible in "override" mode
//no matter if they are programmed in sequence or not
bIgnoreConditions := (((DeviceId.CompId = cCompCore) AND sv_bOverrideCoreSafety)) OR
                     (((DeviceId.CompId = cCompEjector) AND sv_bOverrideEjectorSafety));

WHILE bSearchMovement DO
   
   //search for the requested movement
   abInterpreter.aFindLabel.SearchStartPos := TmpStepPos;
   abInterpreter.aFindLabel(DeviceId := DeviceId, MoveId :=MoveId, MoveDir := MoveDir, IntermediateCond := IntermediateCond, bAllowNonMatchingId := FALSE);
   IF abInterpreter.aFindLabel.bFound THEN
      bMovementFound := TRUE;
      StepPos := abInterpreter.aFindLabel.StepPos;
   ELSE
      //movement not found in sequence
      bSearchMovement := FALSE;
      StepPos.iColumn := 0;
      StepPos.iRow := 0;
   END_IF;
         
   IF abInterpreter.aFindLabel.bFound OR NOT bNeedCheckSafety OR bIgnoreConditions THEN
      //check conditions for this movement
      abODCCheckDependenciesStart.aCheck(StepPos := StepPos, DeviceIdSelf := DeviceId, bNoAlarmsAndStepState := TRUE);
      
      // check existing start conditions and check conditions for the requested movement
      // attention: check is only necessary if sequence is programmed by editor 
      bStartConditionOk := TRUE;
      bCheckConditionsOk := TRUE;
      bCheckConditionFound := FALSE;
      
      IF NOT bIgnoreConditions THEN   
         IF NOT sv_bUseProgramSwitches AND bNeedCheckSafety AND abInterpreter.aFindLabel.bFound THEN
            aStartAndCheckConditions(StepPos := StepPos,
                                     bNoAlarms := TRUE,
                                     bStartConditionOk => bStartConditionOk,
                                     bCheckConditionsOk => bCheckConditionsOk,
                                     bCheckConditionFound => bCheckConditionFound);
         END_IF;
      END_IF;
   
      iTmpAlarmCount := 0;
      IF NOT abODCCheckDependenciesStart.aCheck.bAllowed THEN
         //safety conditions not ok => save number of not fulfilled conditions
         iTmpAlarmCount := abODCCheckDependenciesStart.aCheck.iNotOkCount;
      END_IF;
      
      IF NOT bStartConditionOk THEN
         //start conditions not ok => increment nummber of not fulfilled conditions
         iTmpAlarmCount := iTmpAlarmCount + aStartAndCheckConditions.iStartConditionsNotOk;
      END_IF;
           
      IF NOT bCheckConditionsOk THEN
         //check conditions not ok => increment nummber of not fulfilled conditions
         iTmpAlarmCount := iTmpAlarmCount + aStartAndCheckConditions.iCheckConditionsNotOk;
      END_IF;
            
      //everything OK -> start movement and exit loop      
      IF abODCCheckDependenciesStart.aCheck.bAllowed AND bStartConditionOk AND bCheckConditionsOk THEN
         //movement with correct condition found => start this movement
         abInterpreter.aAddStartedManualMovement(DeviceId := DeviceId, MoveId := MoveId, MoveDir := MoveDir, 
                                                 StepPos := StepPos, iInstance := IntermediateCond);
         IF abInterpreter.aAddStartedManualMovement.bOK THEN
            fbStart(DeviceId := DeviceId, MoveDir := MoveDir, MoveId := MoveId, IntermediateCond := IntermediateCond);
            bStarted := TRUE;
            
            //set step state to active
            IF (StepPos.iColumn <> 0) AND (StepPos.iRow <> 0) THEN
               fbSetStepState(StepPos := StepPos,
                              StepState := nStateActive);
            END_IF;
         END_IF;
         
         IF bCheckConditionFound THEN
            START_PROCESS_ALGORITHM(paCheckConditionsManual);
         END_IF;
         
         IF NOT abInterpreter.aFindLabel.bFound THEN
            fbDebugTrace2(nODCInterpreter, 'Manual Movement started anyway because it is not safety relevant');   
         END_IF;
         
         bSearchMovement := FALSE;
         bMovementAllowed := TRUE;
         RETURN; // ******  exit algorithm *******
      ELSE
         //check number of not fulfilled conditions
         IF (iAlarmCount = 0) OR (iTmpAlarmCount < iAlarmCount) THEN
            //save this step
            StepPosLowestAlarms := StepPos;
            iAlarmCount := iTmpAlarmCount;
            iTmpAlarmCount := 0;
         END_IF;
         
         //save this position (needed as startposition of next search)
         //attention: iColumn must be increased otherwise always the same step will be found
         TmpStepPos.iColumn := StepPos.iColumn + 1;
         TmpStepPos.iRow := StepPos.iRow;
         bMovementAllowed := FALSE;
      END_IF;
   END_IF;  //end_if aFindLabel.bFound
   
END_WHILE;

IF NOT bMovementFound THEN
   fbDebugTrace2(nODCInterpreter, 'Manual Movement not started because movement is safety relevant but not in ODC');
ELSIF NOT bMovementAllowed THEN   
   //use step which causes the lowest number of alarms   
   //call dependency check again to set the according alarms
   abODCCheckDependenciesStart.aCheck(StepPos := StepPosLowestAlarms, DeviceIdSelf := DeviceId, bNoAlarmsAndStepState := FALSE);
   
   //set alarms related to start and check conditions
   aStartAndCheckConditions(StepPos := StepPosLowestAlarms,
                            bNoAlarms := FALSE,
                            bStartConditionOk => bStartConditionOk,
                            bCheckConditionsOk => bCheckConditionsOk,
                            bCheckConditionFound => bCheckConditionFound);
   
   //set step state to error
   fbSetStepState(StepPos := StepPosLowestAlarms, StepState := nStateError); 
   
   //evCheckLocklist makes sure other alarms(caused by FBLockUnlock for this movement are also set *)
   fbDebugTrace2(nODCInterpreter, CONCAT('Manual Movement ', DINT_TO_STRING(MoveId),
                                          '/', DINT_TO_STRING(MoveDir),
                                          ' not started because safety conditions do not allow it -> sending evCheckLocklist to view all other alarms'));
   evCheckLocklistEventData.DeviceId := DeviceId;
   evCheckLocklistEventData.MoveId   := MoveId;
   evCheckLocklistEventData.MoveDir  := MoveDir;   
   SET_EVENT(evCheckLocklist, evCheckLocklistEventData);
   
   IF NOT bStartConditionOk THEN
      fbDebugTrace2(nODCInterpreter, 'Manual Movement not started because start condition not ok');
   END_IF;
   
   IF NOT bCheckConditionsOk THEN
      fbDebugTrace2(nODCInterpreter, 'Manual Movement not started because check condition not ok');
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(11)
Start a single movement (in response to evStartRequest)

Basically the same movement can occur more than one time in the machine sequence.
If the requested movement is found in the sequence and all conditions are ok, this movement is started.
If one or more conditions (safety conditions, start conditions, check conditions) are not ok, the
algorithm continues searching because possibly the movement is found again and the conditions for this step are ok.

If the movement is not allowed, the movement position with the lowest number of not fulfilled conditions is marked (step state is set)
and tha according alarms are set


@@@END_Comment@@@ 

@BEG_Body 
@TL(56)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bNotFound := FALSE;

(* find start label *)
abInterpreter.aFindLabel.SearchStartPos.iColumn := 1;
abInterpreter.aFindLabel.SearchStartPos.iRow := 1;
abInterpreter.aFindLabel(DeviceId := DeviceId,
                         MoveId := cMoveBeginSequence,
                         MoveDir := MoveDir,
                         IntermediateCond := 0,
                         bAllowNonMatchingId := FALSE);
IF NOT abInterpreter.aFindLabel.bFound THEN
   fbDebugTrace2(nODCInterpreter, 'combined movement -> start label not found -> will try to start single movement');
   bNotFound := TRUE;
   RETURN;
END_IF;

StartPos := abInterpreter.aFindLabel.StepPos;

(* find end of label *)
abInterpreter.aFindLabel(DeviceId := DeviceId,
                         MoveId := cMoveEndSequence,
                         MoveDir := MoveDir,
                         IntermediateCond := 0,
                         bAllowNonMatchingId := FALSE);
IF NOT abInterpreter.aFindLabel.bFound THEN
   fbDebugTrace2(nODCInterpreter, 'combined movement -> end label not found -> will try to start single movement');
   bNotFound := TRUE;
   RETURN;
END_IF;

// save active sequence (for highlighting in machine sequencer)
sv_ActiveSequence.DeviceId := DeviceId;
sv_ActiveSequence.MoveDir := MoveDir;
sv_ActiveSequence.iCount :=  sv_ActiveSequence.iCount + 1;
sv_ActiveSequence.bActive := TRUE;

(* remember for later so we can stop combined movements *)
mStartedCombinedMovement.DeviceId := DeviceId;
mStartedCombinedMovement.MoveId   := MoveId;
mStartedCombinedMovement.MoveDir  := MoveDir;

abInterpreter.aInitInterpreter(iColumn := StartPos.iColumn,
                               iRow := StartPos.iRow,
                               iEndRow := abInterpreter.aFindLabel.StepPos.iRow,
                               bSkipAlreadyPosReached := TRUE,
                               bExcludeActiveColumns := FALSE);

(* paRunManualCombinedMovement stops itself when interpreter is not active anymore *)
START_PROCESS_ALGORITHM(paRunManualCombinedMovement);


@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
Start a combined movement (in response to evStartRequest)
@@@END_Comment@@@ 

@BEG_Body 
@TL(180)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbRecalcActive THEN
   //Ignore start requests if a cycle recalc is active.
   //This flag is set by aDoPendingRecalc() before the low priority paInitSequence actually starts executing code
   //This is necessary to avoid problems where a recalc and a movement start happen at the same cycle
   fbDebugTrace2(nDeviceState, 'evStartRequest ignored because sequence is being recalculated');
   RETURN;
END_IF;

IF sv_iInitOK <> 20 THEN
   //ignore start requests if array is not initialized completely
   //this can happen during startup and during creation of a new sequence
   //or if creation of a sequence failed
   fbDebugTrace2(nDeviceState, 'evStartRequest ignored because sequence not initialized');
   RETURN; 
END_IF;

IF sv_OperationMode >= nHalfAutomatic THEN
   IF sv_bSequenceInterruption THEN
      //sequence is actually interrupted -> find out if it is allowed to start this movement
      fbGetMoveNumber(DeviceId := evStartRequestData.DeviceId,
                     MoveDir := evStartRequestData.MoveDir,
                     MoveId := evStartRequestData.MoveId);
      
      IF fbGetMoveNumber.bFound THEN
         IF sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pMovementData^.bAllowedDuringInterrupt THEN
            //try to start this movement
            aStartSingleMovement(DeviceId := evStartRequestData.DeviceId,
                                 MoveDir := evStartRequestData.MoveDir,
                                 MoveId := evStartRequestData.MoveId,
                                 IntermediateCond := evStartRequestData.IntermediateCond,
                                 bNeedCheckSafety := FALSE);
         END_IF;
      END_IF;        
   ELSE
      //ignore start requests if operation mode is half or full automatic
      fbDebugTrace2(nDeviceState, 'evStartRequest ignored because in half or full auto mode');
   END_IF;
   
   RETURN; // return here
END_IF;

IF sv_iActiveEditors > 0 THEN
   //teach mode active -> ignore start requests
   SET_ALARM(Name := erTeachModeActive);
   RETURN;
END_IF;    

StartRequestData := evStartRequestData;

// work with StartRequest
fbGetMoveNumber(DeviceId := StartRequestData.DeviceId,
                MoveDir := StartRequestData.MoveDir,
                MoveId := StartRequestData.MoveId);

IF fbGetMoveNumber.bFound THEN
   iSafety := sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pMovementData^.iSafetyIdentifier;
   (* FIXME: always set the intermediate condition to 0 when movement does not have intermediate conditions
      needed for searching the movement
   *)
   IF NOT sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pMovementData^.bInstanceable THEN
      StartRequestData.IntermediateCond := 0;
   END_IF;
ELSE
   fbDebugTrace2(nODCInterpreter, 'could not find movement -> assuming movement is safety relevant');
   iSafety := 1;
END_IF;

IF iSafety = 1 THEN
   bCheckSafety := TRUE;
   fbDebugTrace2(nODCInterpreter, 'movement is safety relevant (sequence safety and mold safety (safety editor)');
ELSIF iSafety = 3 THEN 
   bCheckSafety := TRUE;
   fbDebugTrace2(nODCInterpreter, 'movement is safety relevant (sequence safety only - no mold safety (safety editor)');
ELSIF iSafety = 2 THEN
   // only check pos reached of other movements, movement itself is not safety relevant
   bCheckSafety := TRUE;
   fbDebugTrace2(nODCInterpreter, 'movement is partially safety relevant');
ELSIF iSafety = 0 THEN    
   bCheckSafety := FALSE;
   fbDebugTrace2(nODCInterpreter, 'movement is NOT safety relevant');
ELSE
   bCheckSafety := TRUE;
   fbDebugTrace(CONCAT('strange safety relevance value ', DINT_TO_STRING(iSafety)));
END_IF;

abInterpreter.aStatus();
IF abInterpreter.aStatus.bActive THEN
   fbDebugTrace2(nODCInterpreter, 'manual movement not started because there is already a combined movement active');
   
   SET_ALARM(Name := erMovementDuringActiveSequence,
             SubID1 := StartRequestData.DeviceId.CompId,
             SubID2 := StartRequestData.MoveId,
             SubID3 := mStartedCombinedMovement.DeviceId.CompId,
             SubID4 := mStartedCombinedMovement.MoveId,
             Param1 := DINT_TO_STRING(StartRequestData.DeviceId.IndexId));
   RETURN;
END_IF;

(* Rules:
 * When a combined movement is active no other movement may be started
 * When any movement is active no combined movement may be started
 * Autopurge counts as 1 or more movementy so the above rule covers this already
   -> single movements are allowed during autopurge
 * When operation mode is setup, combined movement are never started(only single movemets *)

IF sv_bCombinedMovementsInManual AND (StartRequestData.MoveId = cMoveBeginSequence) THEN
   IF sv_OperationMode = nSetup THEN
      fbDebugTrace2(nODCInterpreter, 'starting a combined movement in setup mode is not allowed');
      RETURN;
   END_IF;
   bCombined := TRUE;
ELSIF sv_bCombinedMovementsInManual AND (sv_OperationMode = nManual) AND
   (* combined movements are not allowed in setup mode *)
   (StartRequestData.DeviceId.CompId = cCompMold AND
   ((StartRequestData.MoveDir = cMoveFwd OR
    StartRequestData.MoveDir = cMoveBwd))
   OR 
   (StartRequestData.DeviceId.CompId = cCompInjection AND  
   (StartRequestData.MoveId = cMoveInject OR
    StartRequestData.MoveId = cMoveCombinedPlast))) THEN
   //this check is for MoveId as plasticize, decompress and intrusion have MoveDir = cMoveBwd
   bCombined := TRUE;
ELSE
   bCombined := FALSE;
   
   //check if  requested device is activated
   FOR i := 1 TO sv_ODCDeviceMovements.iCount DO
      IF sv_ODCDeviceMovements.Devices[i].DeviceId = StartRequestData.DeviceId THEN
         IF NOT sv_ODCDeviceMovements.Devices[i].pbDeviceActivated^ THEN
            fbDebugTrace2(nODCInterpreter, 'start request ignored because device is not activated');
            RETURN;
         END_IF;       
         EXIT;
      END_IF;
   END_FOR;
END_IF;

IF sv_StartedMovements.iStartedMovements <> 0 AND bCombined THEN
   fbDebugTrace2(nODCInterpreter, 'combined manual movement not started because there is already a movement active');
   
   SET_ALARM(Name := erSequenceDuringActiveMovement,
             SubID1 := StartRequestData.DeviceId.CompId,
             SubID2 := StartRequestData.DeviceId.IndexId,
             SubID3 := StartRequestData.MoveId);
   RETURN;
END_IF;

(* back up sequence when a movement is started
   and the sequence has changed *)
START_PROCESS_ALGORITHM(paBackupSequence);

IF bCombined THEN
   fbDebugTrace2(nODCInterpreter, 'evStartRequest -> starting a combined movement');
   aClearStepState(FALSE);
   aStartCombinedMovement(DeviceId := StartRequestData.DeviceId,
                          MoveDir := StartRequestData.MoveDir,
                          MoveId := StartRequestData.MoveId);
END_IF;

IF NOT bCombined OR aStartCombinedMovement.bNotFound THEN
   (* if combined movement markers were not found start single movement *)
   IF (StartRequestData.MoveId = cMoveBeginSequence) THEN
      //do not try to start a single movement if a start request for
      //cMoveBeginSequence was received and this sequence was not found
      fbDebugTrace2(nODCInterpreter, 'requested combined movement not found');      
   ELSE
      fbDebugTrace2(nODCInterpreter, 'evStartRequest -> starting a single movement');
      aStartSingleMovement(DeviceId := StartRequestData.DeviceId,
                           MoveDir := StartRequestData.MoveDir,
                           MoveId := StartRequestData.MoveId,
                           IntermediateCond := StartRequestData.IntermediateCond,
                           bNeedCheckSafety := bCheckSafety);   
   END_IF;   
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(6)
Handle evStartRequest(manual buttons)
start requests will be ignored in the following situations:
- sequence array not initialized completely 
  (startup or creation of new sequence in progress, creation of sequence failed)
- machine running in half or fullauto cycle
- teachmode in machine sequencer is active
@@@END_Comment@@@ 

@BEG_Body 
@TL(49)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bInitDone THEN
   //ignore stop requests before sv_bInitDone
   fbDebugTrace2(nDeviceState, 'evStopRequest ignored because sv_bInitDone is not TRUE');
   RETURN;
END_IF;

IF (sv_OperationMode >= nHalfAutomatic) AND NOT sv_bSequenceInterruption THEN
   //ignore stop requests if operation mode is half or full automatic
   //stop requests for movements which were started during sequence interruption
   //must be handled
   fbDebugTrace2(nDeviceState, 'evStopRequest ignored because in half or full auto mode');
   RETURN;
END_IF;


abInterpreter.aStatus();
IF abInterpreter.aStatus.bActive THEN
   IF mStartedCombinedMovement.DeviceId = evStopRequestData.DeviceId AND
      mStartedCombinedMovement.MoveId = evStopRequestData.MoveId AND
      mStartedCombinedMovement.MoveDir = evStopRequestData.MoveDir THEN
      // we get a stop request for the combined movement
      // so stop it
      fbDebugTrace2(nDeviceState, 'evStopRequest while interpreter is active -> aStopInterpreterNormal()');
      abInterpreter.aStopInterpreterNormal();
      sv_ActiveSequence.bActive := FALSE;
   ELSE
      // we get a stop request for a single movement
      // but a combined movement is active
      // but no single movements are allowed during a combined movement
      // -> ignore the event
      fbDebugTrace2(nDeviceState, 'evStopRequest ignored because combined movement is active and device/movement does not match');
   END_IF;
ELSE
   fbDebugTrace2(nDeviceState, 'evStopRequest while interpreter is inactiveactive -> fbStop()');
   // it is also possible that the interpreter already finished the combined movement
   // we still send a evStop, but that does not cause ony problems
   fbStop(DeviceId := evStopRequestData.DeviceId);
   sv_ActiveSequence.bActive := FALSE;
END_IF;


// no movenumber available, clear all
g_SafetyData.MovementToActivate := 0;         

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
Handle evStopRequest(manual buttons)
Stop single and combined movements
@@@END_Comment@@@ 

@BEG_Body 
@TL(43)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO sv_iUsedColumns DO
   IF (mActiveStepBwdMovements[i].DeviceId = DeviceId) AND
      (mActiveStepBwdMovements[i].MoveId = MoveId) AND
      (mActiveStepBwdMovements[i].MoveDir = MoveDir) THEN
      
      //check posReached flag
      fbCheckPosReached(DeviceId := DeviceId,
                        MoveDir := MoveDir,
                        MoveId := MoveId);
      
      IF CHECK_REF(fbCheckPosReached.pbPosReached^) AND NOT fbCheckPosReached.pbPosReached^ THEN
         ;//endposition not reached -> do not decrease line number
      ELSE
         //endposition reached or no posReached flag available -> decrease row
         iTmpColumn := i;
         REPEAT               
            IF sv_TraceLevel.bODCInterpreter THEN
               dummy := Print('call abInterpreter.aDecreaseRow with iColumn = %d', iTmpColumn);
            END_IF;
            abInterpreter.aDecreaseRow(bStartInActualLine := FALSE,
                                       iColumn := iTmpColumn,
                                       iEndRow := 1);
            iTmpColumn := abInterpreter.aDecreaseRow.iNewActivatedColumn;
            
         UNTIL (abInterpreter.aDecreaseRow.iNewActivatedColumn = 0)
         END_REPEAT;
      END_IF;
      
      //init this element
      mActiveStepBwdMovements[i].DeviceId.CompId := cCompNone;
      mActiveStepBwdMovements[i].DeviceId.IndexId := 1;
      mActiveStepBwdMovements[i].MoveId := cMinMoveIdent;
      mActiveStepBwdMovements[i].MoveDir := cMoveNone;
      
      EXIT;
   END_IF;      
END_FOR;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(91)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF evStartedStoppedData.State = nStopped OR  evStartedStoppedData.State = nStartNotAllowed THEN
   bFound := FALSE;
   // movement was stopped or never started
   // remove movement from list with started movements
   
   Status := MovementsSema.Wait(WaitTime := cTimeOutSempahore);
   IF Status <> KRTOS_Status_OK THEN
      dummy2 := ASSERT(FALSE, erAssert);
      RETURN;
   END_IF;
   
   FOR i := 1 TO sv_StartedManualMovements.iStartedMovements DO
      
      bCorrectInstance := (evStartedStoppedData.iInstance = 0) OR (evStartedStoppedData.iInstance = sv_StartedManualMovements.MoveData[i].iInstance);
      IF sv_StartedManualMovements.MoveData[i].DeviceId = evStartedStoppedData.DeviceId AND
         sv_StartedManualMovements.MoveData[i].MoveDir = evStartedStoppedData.MoveDir AND
         sv_StartedManualMovements.MoveData[i].MoveId = evStartedStoppedData.MoveId AND bCorrectInstance THEN
         
         stepPos := sv_StartedManualMovements.MoveData[i].StepPos;
         IF (g_SafetyData.bAvailable) THEN
            IF (NOT((stepPos.iColumn = 0) OR (stepPos.iRow = 0)))THEN
               idx := sv_MovementsAvailable[sv_ODCSequenceInt[stepPos.iColumn][stepPos.iRow].iMoveNumber].iODCSafetyMovementsEntry;
               IF (idx > 0) THEN
                  g_SafetyData.MovementToActivate := g_SafetyData.MovementToActivate AND (NOT SHL(1, idx-1));                       
               END_IF;
            END_IF;         
         END_IF;
                 
         IF (NOT((stepPos.iColumn = 0) OR (stepPos.iRow = 0)))THEN                       
            //only correct step sate if actual state is not error
            IF sv_ODCSequenceInt[stepPos.iColumn, stepPos.iRow].StepState <> nStateError THEN
               fbSetStepState(StepPos := sv_StartedManualMovements.MoveData[i].StepPos,
                           StepState := nStateReady);
            END_IF;
                               
         END_IF;
                  
         IF sv_TraceLevel.bODCInterpreter THEN
            dummy := Print('removing started manual movement %d.%d %d/%d', evStartedStoppedData.DeviceId.CompId, evStartedStoppedData.DeviceId.IndexId, evStartedStoppedData.MoveId, evStartedStoppedData.MoveDir);
         END_IF;
         
         //copy last entry in the list to this empty field
         sv_StartedManualMovements.MoveData[i] := sv_StartedManualMovements.MoveData[sv_StartedManualMovements.iStartedMovements];
         
         //zero last entry
         tmpMovement.DeviceId.CompId := cCompNone;
         tmpMovement.DeviceId.IndexId := 1;
         tmpMovement.MoveDir := cMoveNone;
         tmpMovement.MoveId := cMinMoveIdent;
         tmpMovement.StepPos.iColumn := 0;
         tmpMovement.StepPos.iRow := 0;
         tmpMovement.iInstance := 0;
         sv_StartedManualMovements.MoveData[sv_StartedManualMovements.iStartedMovements] := tmpMovement;
         
         sv_StartedManualMovements.iStartedMovements := sv_StartedManualMovements.iStartedMovements - 1;
         //fbDebugTrace2(nODCInterpreter, 'end removing started manual movement');
         bFound := TRUE;
         EXIT;
      END_IF;
   END_FOR;

   Status := MovementsSema.Put();
   IF Status <> KRTOS_Status_OK THEN
      dummy2 := ASSERT(FALSE, erAssert);
   END_IF;
   
   IF sv_bSequenceInterruption THEN
      //started / stopped event during sequence is interrupted
      //-> check if line number should be decreased
      aDecreaseLineNumber(DeviceId := evStartedStoppedData.DeviceId,
                          MoveId := evStartedStoppedData.MoveId,
                          MoveDir := evStartedStoppedData.MoveDir);
   END_IF;
   
   IF NOT bFound THEN
      IF sv_TraceLevel.bODCInterpreter THEN
         dummy := Print('tried to remove stopped movement, but not in list anymore???');
      END_IF;
   END_IF;
END_IF;

 




@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
Manage list and count of currently started movments
in sv_StartedMovements when receiving evStartedStopped events
@@@END_Comment@@@ 

@BEG_Body 
@TL(22)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_StartedManualMovements.iStartedMovements = 0 THEN
   STOP_PROCESS_ALGORITHM(paCyclicConditionCheck);
   STOP_PROCESS_ALGORITHM(paCheckConditionsManual);
   
   abInterpreter.aStatus();
   IF sv_OperationMode <= nManual AND NOT abInterpreter.aStatus.bActive THEN
      (* the last single manual movement was stopped -> recalculate if needed *)
      aDoPendingRecalc();
      IF aDoPendingRecalc.bStartedRecalc THEN
         fbDebugTrace2(nDeviceState, 'recalc because iStartedMovements = 0');
      END_IF;
   END_IF;
ELSE
   START_PROCESS_ALGORITHM(paCyclicConditionCheck);
   
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
Start / stop paCyclicConditionCheck depending on
if there are started movements.
@@@END_Comment@@@ 

@BEG_Body 
@TL(43)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abInterpreter.aStatus();

Status := MovementsSema.Wait(WaitTime := cTimeOutSempahore);
IF Status <> KRTOS_Status_OK THEN
   dummy2 := ASSERT(FALSE, erAssert);
   RETURN;
END_IF;

FOR i := 1 TO sv_StartedManualMovements.iStartedMovements DO
   // check safety for manual movements
   // abODCCheckSafetyConditions must be a separete instance
   // because this PROCESS_ALGORITHM runs in a fast task that can
   // interrupt other tasks
   TmpStepPos := sv_StartedManualMovements.MoveData[i].StepPos;
   IF(abInterpreter.aStatus.bActive AND (TmpStepPos.iColumn = 0 OR TmpStepPos.iRow = 0)) THEN
      fbDebugTrace('interpreter is active but a movement with step pos 0 is running'); //this might be legitime, but is most times not normal
      abInterpreter.aStopInterpreterFatal();   
   END_IF;
   
   abODCCheckDependenciesCyclic.aCheck(StepPos := TmpStepPos, DeviceIdSelf := sv_StartedManualMovements.MoveData[i].DeviceId);
   IF NOT abODCCheckDependenciesCyclic.aCheck.bAllowed THEN
      fbDebugTrace2(nODCInterpreter, CONCAT('cyclic condition check reported movement at ',
                                            DINT_TO_STRING(sv_StartedManualMovements.MoveData[i].StepPos.iColumn),
                                            '/',
                                            DINT_TO_STRING(sv_StartedManualMovements.MoveData[i].StepPos.iRow),
                                            ' as not allowed'));
      abInterpreter.aStopInterpreterError();
   END_IF;
 
END_FOR;

//FIXME: is it a good idea to hold the lock so long???
Status := MovementsSema.Put();
IF Status <> KRTOS_Status_OK THEN
   dummy2 := ASSERT(FALSE, erAssert);
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
Cyclically check movement conditions of all started movements
(auto mode, combined manual movements, single manual movements)
@@@END_Comment@@@ 

@BEG_SfcBody 
80 46 55 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 3 
@Step @RT(16)S_CheckStartCond @F @T @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(15)AAutoCycleReady @F @T @RT(1)P @RT(0) @F @F @T @TL(7)
bReady := TRUE;
IF (sv_OperationMode <> nFullAutomatic) THEN
   sv_bAutoCycleRunning := FALSE;    
END_IF;
g_SafetyData.MovementToActivate := 0;
abInterpreter.aResetStepMode();

@F 

@Trans @RT(13)T_StartCondOK @F @T @F @F @T @F @TL(2)
NOT bStopCycle AND NOT bStopAfterCycle

@RT(6)Trans1 @F 
@Loop @RT(4)loop @F 2 
@StepSeq @RT(3)seq @F 9 
@Loop @RT(4)loop @F 2 
@StepSeq @RT(3)seq @F 13 
@Step @RT(17)S_CheckStartCycle @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 4 
@Acb @RT(9)AAutoInit @F @T @RT(1)P @RT(0) @F @F @T @TL(7)
bReady := FALSE;
IF (sv_OperationMode <> nFullAutomatic) THEN
   sv_bAutoCycleRunning := FALSE;    
END_IF;
bCanStart := FALSE;
abWaitCycleStart.aCycleStartRequest();

@F 
@Acb @RT(15)AWaitCycleStart @F @T @RT(1)N @RT(0) @F @F @T @TL(6)
abWaitCycleStart.aWaitCycleStart();
IF abWaitCycleStart.aWaitCycleStart.bCanStart THEN
   (* save flag because it is only TRUE for 1 cycle *)
   bCanStart := TRUE;
END_IF;

@F 
@Acb @RT(7)aRecalc @F @T @RT(1)N @RT(0) @F @F @T @TL(7)
// allow to recalculate the cycle while waiting for the start signal
// but delay real start of the sequence until recalculation is finished
aDoPendingRecalc();
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because autocycle start wait');
END_IF;

@F 
@Acb @RT(11)ADelayCycle @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(12)T_StartCycle @F @T @F @F @T @F @TL(2)
bCanStart AND bDelayExceeded AND NOT mbRecalcActive

@RT(6)Trans2 @F 
@Step @RT(6)Step42 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(20)TSequenceInterrupted @F @T @F @F @T @F @TL(2)
sv_bSequenceInterruption

@RT(7)Trans48 @F 
@Step @RT(6)Step43 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(17)TContinueSequence @F @T @F @F @T @T @TL(2)
NOT sv_bSequenceInterruption

@RT(7)Trans50 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(7)Trans51 @F @T @F @F @T @T @TL(2)
di_StepFwd

@RT(7)Trans51 @F 
@Step @RT(6)Step44 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(25)AMovementsBeforeCycleLoop @F @T @RT(1)P @RT(0) @F @F @T @TL(6)
IF (g_iAutoCycleLoopStartLine > 2) THEN
   bMovesBeforeAutoLoop := TRUE;
ELSE
   bMovesBeforeAutoLoop := FALSE;
END_IF;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(21)TMovementsBeforeCycle @F @T @F @F @T @F @TL(2)
bMovesBeforeAutoLoop

@RT(7)Trans52 @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(22)TNoMoveBeforeAutocycle @F @T @F @F @T @F @TL(3)
NOT bMovesBeforeAutoLoop


@RT(7)Trans53 @F 
@Goto @RT(6)S_ODC1 @F @F 


@Goto @RT(17)S_BeforeCycleLoop @F @F 



@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans49 @F @T @T @F @T @F @TL(2)
NOT sv_bSequenceInterruption

@RT(7)Trans49 @F 


@Step @RT(6)Step20 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 5 
@Trans @RT(11)TFirstCycle @F @T @F @F @T @F @TL(2)
sv_bFirstCycle

@RT(7)Trans19 @F 
@Step @RT(16)S_EjectorAutoBwd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(15)AInitEjectorBwd @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(15)AEjectorAutoBwd @F @F @RT(1)P @RT(0) @F @F @F @F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(15)TEjectorStarted @F @T @F @F @T @F @TL(2)
bEjectorBwdStarted AND pbEjectorReady^

@RT(7)Trans12 @F 
@Step @RT(17)S_CheckEjectorBwd @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(16)ACheckEjectorBwd @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(11)TEjectorBwd @F @T @F @F @T @F @TL(2)
pbEjectorBwd^

@RT(7)Trans10 @F 

@TransSeq @RT(4)tseq @F 1 
@Trans @RT(18)TEjectorNotStarted @F @T @T @F @T @F @TL(2)
NOT bEjectorBwdStarted

@RT(7)Trans13 @F 


@Step @RT(17)S_BeforeCycleLoop @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(17)AStepsBeforeCycle @F @T @RT(1)P @RT(0) @F @F @T @TL(10)
aClearStepState(FALSE);
abInterpreter.aInitInterpreter(iColumn := 1,
                               iRow := 1,
                               iEndRow := g_iAutoCycleLoopStartLine,
                               bSkipAlreadyPosReached := FALSE,
                               bExcludeActiveColumns := FALSE);

abInterpreter.aIncreaseRow(iColumn := 1,
                           iEndRow := g_iAutoCycleLoopStartLine);

@F 
@Acb @RT(20)ARunStepsBeforeCycle @F @T @RT(1)N @RT(0) @F @F @T @TL(3)
abInterpreter.aInterpret();
abInterpreter.aStatus();

@F 

@Trans @RT(17)TBeforeCycleReady @F @T @F @F @T @T @TL(2)
abInterpreter.aStatus.bFinished

@RT(7)Trans17 @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(14)TNotFirstCycle @F @T @F @F @T @F @TL(2)
NOT sv_bFirstCycle

@RT(7)Trans42 @F 
@Goto @RT(6)S_ODC1 @F @F 


@Step @RT(6)S_ODC1 @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(11)AStartCycle @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(16)AInitInterpreter @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(7)Trans32 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans32 @F 
@Step @RT(5)S_Run @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(15)ARunInterpreter @F @T @RT(1)N @RT(0) @F @F @T @TL(3)
abInterpreter.aInterpret();
abInterpreter.aStatus();

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(13)T_ODCFinished @F @T @F @F @T @F @TL(2)
abInterpreter.aStatus.bFinished

@RT(7)Trans17 @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(10)T_ODCError @F @T @F @F @T @F @TL(2)
abInterpreter.aStatus.bError

@RT(6)Trans3 @F 
@Step @RT(10)SErrorWait @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(11)AAutoManual @F @T @RT(1)N @RT(0) @F @F @T @TL(2)
fbAutoManual();

@F 

@Trans @RT(5)TStop @F @T @F @F @T @T @TL(2)
bStopCycle

@RT(6)Trans4 @F 
@Goto @RT(16)S_CheckStartCond @F @F 


@Step @RT(13)S_FinishCycle @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(20)AIncreaseShotCounter @F @T @RT(1)P @RT(0) @F @F @T @TL(8)
g_SafetyData.MovementToActivate := 0;

fbStart.DeviceId.CompId := cCompOperationMode;
fbStart.DeviceId.IndexId := 1;
fbStart.MoveDir := cMoveNone;
fbStart.MoveId := cMoveIncreaseShotCounter;
fbStart();

@F 
@Acb @RT(11)AResetFlags @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
sv_bFirstCycle := FALSE;
mbCycleTimeMachineRunning := FALSE;

@F 

@Trans @RT(7)Trans52 @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)Trans75 @T @TL(1)
must be IEC transition because of shot counter / production counter

@Step @RT(16)S_CheckStopCycle @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(19)ACheckRecalcPending @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
bDoRecalc := (mPendingRecalc <> nODCRecalcNone)

@F 


@Trans @RT(10)T_NewCycle @F @T @T @T @T @F @TL(3)
NOT bStopAfterCycle AND
NOT bDoRecalc

@RT(7)Trans13 @F 

@Trans @RT(13)TStopOrRecalc @F @T @F @F @T @F @TL(2)
bStopAfterCycle OR bDoRecalc

@RT(7)Trans28 @F 
@Step @RT(6)Step27 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(18)ACheckColumnActive @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
aIsAnyColumnActive(bActive => bColumnActive);

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 5 
@Trans @RT(7)Trans21 @F @T @F @F @T @F @TL(3)
//"parallel open" movements must also be finished
bColumnActive

@RT(7)Trans21 @F 
@Step @RT(20)S_FinishParallelOpen @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(19)AFinishParallelOpen @F @T @RT(1)N @RT(0) @F @F @T @TL(4)
//call interpreter until all columns
//are finished
abInterpreter.aInterpret();

@F 
@Acb @RT(13)ACheckColumns @F @T @RT(1)N @RT(0) @F @F @T @TL(2)
aIsAnyColumnActive(bActive => bColumnActive);

@F 

@Trans @RT(7)Trans23 @F @T @F @F @T @T @TL(2)
NOT bColumnActive

@RT(7)Trans23 @F 
@Step @RT(6)Step24 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans24 @F @T @F @F @T @F @TL(2)
bStopAfterCycle

@RT(7)Trans24 @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(7)Trans27 @F @T @F @F @T @F @TL(2)
bDoRecalc

@RT(7)Trans27 @F 
@Goto @RT(17)S_CheckStartCycle @F @F 



@TransSeq @RT(4)tseq @F 1 
@Trans @RT(7)Trans22 @F @T @T @F @T @F @TL(2)
NOT bColumnActive

@RT(7)Trans22 @F 


@Step @RT(16)S_AfterCycleLoop @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(16)AStepsAfterCycle @F @T @RT(1)P @RT(0) @F @F @T @TL(9)
abInterpreter.aInitInterpreter(iColumn := 1,
                               iRow := g_iAutoCycleLoopEndLine,
                               iEndRow := sv_iUsedRows,
                               bSkipAlreadyPosReached := FALSE,
                               bExcludeActiveColumns := FALSE);

abInterpreter.aIncreaseRow(iColumn := 1,
                           iEndRow := sv_iUsedRows);

@F 
@Acb @RT(19)ARunStepsAfterCycle @F @T @RT(1)N @RT(0) @F @F @T @TL(3)
abInterpreter.aInterpret();
abInterpreter.aStatus();

@F 

@Trans @RT(7)Trans14 @F @T @F @F @T @F @TL(2)
abInterpreter.aStatus.bFinished

@RT(7)Trans14 @F 
@Step @RT(11)S_WaitReady @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@Trans @RT(18)TAllMovementsReady @F @T @F @F @T @F @TL(4)
//wait untill all movements are ready
//for example airvalve movement can be still active
sv_StartedManualMovements.iStartedMovements = 0

@RT(6)Trans8 @F 
@Step @RT(5)S_End @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(8)Action35 @F @T @RT(1)P @RT(0) @F @F @T @TL(6)
bReady := TRUE;
IF (sv_OperationMode <> nFullAutomatic) THEN
   sv_bAutoCycleRunning := FALSE;    
END_IF;
g_SafetyData.MovementToActivate := 0;

@F 


@Trans @RT(7)Trans15 @F @T @T @T @T @T @TL(2)
TRUE

@RT(7)Trans15 @F 

@END_SfcData 
@SaActions 6 
@SaText @RT(11)ADelayCycle 1 @TL(17)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//delay should not be executed in first cycle
IF sv_bFirstCycle THEN
   bDelayExceeded := TRUE;
ELSE
   IF sv_dCycleDelaySet > t#0s THEN
      sv_dCycleDelayAct := MIN(S_CheckStartCycle.T, sv_dCycleDelaySet);
   ELSE
      sv_dCycleDelayAct := t#0s;
   END_IF;
   bDelayExceeded := S_CheckStartCycle.T >= sv_dCycleDelaySet;
END_IF;


@SaText @RT(15)AEjectorAutoBwd 1 @TL(22)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbEjeBwdAtCycleStart AND NOT pbEjectorBwd^ AND NOT bEjectorBwdStarted THEN
   //only start ejector auto bwd movement if the ejector must be bwd at the beginning of the cycle
   //this information is taken from the safety array of the first step
 
   //modify pbActivated^ because otherwise the ejector will not move bwd if it is switched off
   sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.pbActivated := @sv_bTRUE;
   
   //attention:
   //if ejector is not programmed in sequence, there are no safety conditions for ejector bwd movement   
   aStartSingleMovement(DeviceId := DeviceIdEjector,
                        MoveDir := cMoveBwd,
                        MoveId := cMoveBwd,
                        bNeedCheckSafety := sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.bProgrammedInSequence);
   
   bEjectorBwdStarted := TRUE;
END_IF;


@SaText @RT(15)AInitEjectorBwd 1 @TL(27)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bInitDone THEN
   fbGetMoveNumber(DeviceId := DeviceIdEjector,
                   MoveId := cMoveBwd,
                   MoveDir := cMoveBwd);

   IF fbGetMoveNumber.bFound THEN
      iMoveNrEjectorBwd := fbGetMoveNumber.iMoveNumber;
      pbEjectorBwd := sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pMovementData^.pbPosReached;
      pbEjectorBwdActivated := sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pMovementData^.pbActivated;
      pbEjectorReady := sv_MovementsAvailable[fbGetMoveNumber.iMoveNumber].pbDeviceReady;
   ELSE
      //ejector bwd movement not found
      pbEjectorBwd := @sv_bTRUE;
      pbEjectorBwdActivated := @sv_bTRUE;
      pbEjectorReady := @sv_bTRUE;
   END_IF;
      
   bInitDone := TRUE;
END_IF;




@SaText @RT(16)ACheckEjectorBwd 1 @TL(21)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//set pbActivated to original reference
sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.pbActivated := pbEjectorBwdActivated;
bEjectorBwdStarted := FALSE;

IF NOT pbEjectorBwd^ THEN
   //ejector is not bwd -> set according alarm
   SET_ALARM(Name := sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.Alarm.AlarmId,
             SubID1 := sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.Alarm.SubId[1],
             SubID2 := sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.Alarm.SubId[2],
             SubID3 := sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.Alarm.SubId[3],
             SubID4 := sv_MovementsAvailable[iMoveNrEjectorBwd].pMovementData^.Alarm.SubId[4]);
   
   //switch to manual mode
   fbAutoManual();
END_IF;


@SaText @RT(16)AInitInterpreter 1 @TL(16)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

aClearStepState(TRUE);
abInterpreter.aInitInterpreter(iColumn := 1,
                               iRow := g_iAutoCycleLoopStartLine,
                               iEndRow := g_iAutoCycleLoopEndLine,
                               bSkipAlreadyPosReached := FALSE,
                               bExcludeActiveColumns := TRUE);

//find first "valid" line to save cycle time
abInterpreter.aIncreaseRow(iColumn := 1,
                           iEndRow := g_iAutoCycleLoopEndLine);


@SaText @RT(11)AStartCycle 1 @TL(24)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bFirstCycle THEN
   //check of cycle time at the beginning of first cycle is not necessary
   aCheckCycleTime();
END_IF;

//save last cycle time
sv_dLastCycleTime := sv_dCycleTime;

mbCycleTimeRunning := TRUE;

//reset timers
mbResetCycleTime := TRUE;
mbResetCycleTimeMachine := TRUE;

sv_bAutoCycleRunning := TRUE;
mbCycleTimeMachineRunning := TRUE;

SET_EVENT(evNewCycleStarted);


@SaTrans 0 
@SaExits 1 
@SaExit @SaText @RT(12)StopAllMoves 1 @TL(2)
bStopCycle

@RT(8)stepname @RT(1)1 @T @F @SaSfc @RT(12)StopAllMoves 5 @RT(5)DUMMY 
@BEG_SfcData 2 
@ExitSeq @RT(4)sseq @F 3 
@Step @RT(14)S_StopAllMoves @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(16)AStopInterpreter @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
abInterpreter.aStopInterpreterNormal();

@F 

@Trans @RT(11)T_CheckStop @F @T @F @F @T @T @TL(2)
TRUE

@RT(7)Trans12 @F 
@Goto @RT(16)S_CheckStartCond @F @F 
@END_SfcData 

@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(1)
Run the autocycle by calling the interpreter.
@@@END_Comment@@@ 

@BEG_Body 
@TL(21)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//call autoCycle
aRunAutoCycle(bStopCycle := mbStopCycle,
              bStopAfterCycle := mbStopAfterCycle);            

IF aRunAutoCycle.bReady AND (mbStopCycle OR mbStopAfterCycle) THEN
   sv_bAutoCycleRunning := FALSE;
   // switch to manual mode and stop self at end of cycle
   fbAutoManual();
   
   abInterpreter.aResetStepMode();
   STOP_PROCESS_ALGORITHM(paCycleTime);
   STOP_PROCESS_ALGORITHM(paCycleTimeMachine);
   STOP_PROCESS_ALGORITHM();
END_IF;
            

@END_Body 

@@@BEG_Comment@@@ 
@TL(3)
Run the auto cycle.
When the cycle has finished and mbStopCycle OR mbStopAfterCycle are true
opmode is automatically switched to manual and the PROCESS_ALGORITHM stops itself.
@@@END_Comment@@@ 

@BEG_Body 
@TL(20)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter,'Reloading ODC files because of sv_bInitDone');   

IF sv_bUseProgramSwitches THEN
   //use program switches
   aSetPendingRecalc(RecalcMode := nODCRecalcReloadFiles);
ELSE
   //use existing sequence and only recalc internal arrays
   aSetPendingRecalc(RecalcMode := nODCRecalcInternal);
END_IF;

aDoPendingRecalc();
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because pInitDone');
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
Cause initialisation of ODC sequence after startup(sv_bInitDone)
@@@END_Comment@@@ 

@BEG_Body 
@TL(21)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//initialize semaphore
Status := MovementsSema.Put();
IF Status <> KRTOS_Status_OK THEN
   dummy2 := ASSERT(FALSE, erAssert);
END_IF;

swoState := KSWO_AddVariable(Task := TaskInject,
                           Name := 'ActCycleTime',
                           Variable := sv_dCycleTime);

swoState := KSWO_AddVariable(Task := TaskAnalog,
                           Name := 'ActCycleTime',
                           Variable := sv_dCycleTime);

STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(34)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_OperationMode >= nHalfAutomatic THEN
   mbStopCycle := FALSE;
   mbStopAfterCycle := FALSE;
   (* back up sequence when machine is switched to auto mode
      and the sequence has changed *)
   START_PROCESS_ALGORITHM(paBackupSequence);
   
   (* PA stops itself again when finished *)
   START_PROCESS_ALGORITHM(paRunAutomaticMovements);
   START_PROCESS_ALGORITHM(paCycleTime);
   START_PROCESS_ALGORITHM(paCycleTimeMachine);
ELSIF sv_OperationMode < nHalfAutomatic THEN
   sv_bFirstCycle := TRUE;
   mbStopCycle := TRUE;
   mbCycleTimeRunning := FALSE;
   
   IF sv_StartedManualMovements.iStartedMovements = 0 THEN
      //recalc of sequence only if no movement is active
      //if there is still a movement active, the creation of a new sequence
      //will be triggered by postupdate algo pActiveMovements
      aDoPendingRecalc();
      IF aDoPendingRecalc.bStartedRecalc THEN
         fbDebugTrace2(nDeviceState, 'recalc because opmode change away from auto cycle');
      END_IF;
   END_IF;

END_IF;
   

@END_Body 

@@@BEG_Comment@@@ 
@TL(3)
React to to operation mode changes and stop the autocycle immediately
when switching to setup/manual mode,
or reset cycle data when switching to Full/Halfauto operation mode.
@@@END_Comment@@@ 

@BEG_Body 
@TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
mbStopAfterCycle := TRUE;

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
Handle evAlarmFinishCycleAndStop event which signals to stop after the end
of the current autocycle
@@@END_Comment@@@ 

@BEG_Body 
@TL(42)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_DataState = nReadMoldData THEN
   //loading of mold data in progress
   mbIgnoreProgramSwitchChange := TRUE;
   PrevState := nReadMoldData;
   sv_SequenceDimension.iMaxColumns := 0;
   sv_SequenceDimension.iMaxRows := 0;
ELSIF sv_DataState = nReadSequenceData THEN
   //loading of sequence in progress
   mbIgnoreProgramSwitchChange := TRUE;
   PrevState := nReadSequenceData;
   sv_SequenceDimension.iMaxColumns := 0;
   sv_SequenceDimension.iMaxRows := 0;
END_IF;   
   
IF sv_DataState = nReady AND mbIgnoreProgramSwitchChange THEN
   
   //loading procedure ready
   mbIgnoreProgramSwitchChange := FALSE;
   
   //decide if only conditions should be recalculated (after loading sequence)
   //or complete sequence should be created (after program switch changed)
   IF sv_bUseProgramSwitches THEN
      aSetPendingRecalc(RecalcMode := nODCRecalcReloadFiles);
   ELSIF PrevState = nReadMoldData THEN
      aSetPendingRecalc(RecalcMode := nODCRecalcInternal);
   ELSIF PrevState = nReadSequenceData THEN
      aSetPendingRecalc(RecalcMode := nODCRecalcInternal);
   END_IF;
   
   aDoPendingRecalc();
   IF aDoPendingRecalc.bStartedRecalc THEN
      fbDebugTrace2(nDeviceState, 'recalc because data state change');
   END_IF;
   
   PrevState := nReady;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(34)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bODCFilesChanged THEN
   RETURN;
END_IF;

sv_bODCFilesChanged := FALSE;

IF NOT sv_bInitDone THEN
   fbDebugTrace('ignoring sv_bODCFilesChanged because sv_bInitDone is FALSE');
   RETURN;
END_IF;

(* rebuild ODC array immediately with reloading files *)
aSetPendingRecalc(RecalcMode := nODCRecalcReloadFiles);

IF sv_OperationMode >= nHalfAutomatic THEN
   fbDebugTrace('skipping ODC recalc after file change because of OperationMode');
   RETURN;
END_IF;

IF sv_StartedMovements.iStartedMovements > 0 THEN
   fbDebugTrace('skipping ODC recalc after file change because there are started movements');
   RETURN;
END_IF;

aDoPendingRecalc();
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because files changed');
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
React to program switch changes, and recalculate the ODC sequence.
@@@END_Comment@@@ 

@BEG_Body 
@TL(38)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_iActiveEditors <> 0 THEN
   //teach mode active
   //avoid changing operation mode to HA or FA 
   fbLockUnlock.Alarm.AlarmId := erTeachModeActive;
   fbLockUnlock.Mode := nLockAbort;
   fbLockUnlock();
   
   //reset sv_bUseProgramSwitches immediately after activating teach mode
   //so that "controlled by machine sequencer" is displayed instead of program switches
   sv_bUseProgramSwitches := FALSE;
   RETURN;
ELSE
   fbLockUnlock.Alarm.AlarmId := erTeachModeActive;
   fbLockUnlock.Mode := nUnlock;
   fbLockUnlock();
END_IF;

//teach mode inactive => new sequence programmed by editor
// -> create internal array, calculate safety conditions, do plaus checks
aSetPendingRecalc(RecalcMode := nODCRecalcInternal);

aDoPendingRecalc();
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because new sequence from editor');
END_IF;








@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
create internal array and calculate safety conditions after
teachmode becomes inactive
@@@END_Comment@@@ 

@BEG_Body 
@TL(25)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_iSequenceToRestore = 0 THEN
   RETURN;
END_IF;

IF sv_iSequenceToRestore > cODCSequenceBackupCount THEN
   fbDebugTrace2(nODCInterpreter, 'restoring actual sequence calculated from switches');
   aSetPendingRecalc(RecalcMode := nODCRecalcCylce);
END_IF;


fbDebugTrace2(nODCInterpreter, CONCAT('restoring old sequence ', DINT_TO_STRING(sv_iSequenceToRestore)));
sv_ODCSequence := sv_ODCSequenceBackup[sv_iSequenceToRestore].Sequence;
aSetPendingRecalc(RecalcMode := nODCRecalcSafety);
aDoPendingRecalc(); //FIXME: this may not do more than security recalculation -> otherwise loaded array would be overwritten 
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because sequence backup is restored');
END_IF;
sv_iSequenceToRestore := 0;
fbDebugTrace2(nODCInterpreter, 'restoring old sequence done');

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(45)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bProgramSwitchChanged THEN
   RETURN;
END_IF;

sv_bProgramSwitchChanged := FALSE;

IF NOT sv_bInitDone THEN
   fbDebugTrace2(nODCInterpreter, 'ignoring program switch change because sv_bInitDone is FALSE');
   RETURN;
END_IF;

IF NOT sv_bUseProgramSwitches THEN
   // ignore changing of program switch if sequence from graphical editor is used
   fbDebugTrace2(nODCInterpreter, 'ignoring program switch change because of sv_bUseProgramSwitches');
   RETURN;
END_IF;

IF mbIgnoreProgramSwitchChange THEN
   fbDebugTrace2(nODCInterpreter, 'ignoring program switch change because of sv_DataState');
   RETURN;
END_IF;

aSetPendingRecalc(RecalcMode := nODCRecalcCylce);

IF sv_OperationMode >= nHalfAutomatic THEN
   fbDebugTrace('skipping ODC recalc after program switch change because of OperationMode');
   RETURN;
END_IF;

IF sv_StartedMovements.iStartedMovements > 0 THEN
   fbDebugTrace('skipping ODC recalc after program switch change because there are started movements');
   RETURN;
END_IF;

(* rebuild ODC array immediately without reloading files *)
aDoPendingRecalc();
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because program switch changed');
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
React to program switch changes, and recalculate the ODC sequence.
@@@END_Comment@@@ 

@BEG_Body 
@TL(39)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bActivationChanged THEN
   RETURN;
END_IF;

sv_bActivationChanged := FALSE;

IF NOT sv_bInitDone THEN
   fbDebugTrace('ignoring sv_bActivationChanged because sv_bInitDone is FALSE');
   RETURN;
END_IF;

IF mbIgnoreProgramSwitchChange THEN
   fbDebugTrace2(nODCInterpreter, 'ignoring activation change because of sv_DataState');
   RETURN;
END_IF;

(* recalculate ODC safety without reloading files/recalculating the sequence *)
aSetPendingRecalc(RecalcMode := nODCRecalcSafety);

IF sv_OperationMode >= nHalfAutomatic THEN
   fbDebugTrace('skipping ODC recalc after activation change because of OperationMode');
   RETURN;
END_IF;

IF sv_StartedMovements.iStartedMovements > 0 THEN
   fbDebugTrace('skipping ODC recalc after activation change because there are started movements');
   RETURN;
END_IF;

aDoPendingRecalc();
IF aDoPendingRecalc.bStartedRecalc THEN
   fbDebugTrace2(nDeviceState, 'recalc because activation change');
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
React to program switch changes, and recalculate the ODC sequence.
@@@END_Comment@@@ 

@BEG_Body 
@TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

b := FCreateODCVersion();
STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(29)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbIgnoreProgramSwitchChange THEN
   //loading procedure in progress
   RETURN;
END_IF;

IF sv_bUseProgramSwitches THEN
   //activate all devices after a change from
   //machine sequencer mode to program switch mode
   FOR iDevice := 1 TO sv_ODCDeviceMovements.iCount DO
      IF CHECK_REF(sv_ODCDeviceMovements.Devices[iDevice].pbDeviceActivated^) THEN
         sv_ODCDeviceMovements.Devices[iDevice].pbDeviceActivated^ := TRUE;
      END_IF;      
   END_FOR;
   
   //create new sequence depending on the program switches
   //set mode to nODCRecalcReloadFiles because maybe sequence was
   //never created with program switches before
   aSetPendingRecalc(RecalcMode := nODCRecalcReloadFiles);
   aDoPendingRecalc();
   IF aDoPendingRecalc.bStartedRecalc THEN
      fbDebugTrace2(nDeviceState, 'recalc because change to program switch mode');
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
trigger creation of sequence by program switches
@@@END_Comment@@@ 

@BEG_Body 
@TL(78)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

Pos.iColumn := 1;
Pos.iRow := 1;

DeviceId.CompId := sv_ODCSequence[1,1].iCompId;
DeviceId.IndexId := INT_TO_DINT(sv_ODCSequence[1,1].iIndexId);

//check safety array of first step (ODC.BeginSequence)
bEjectorIgnored := FALSE;
IF mbEjeBwdAtCycleStart THEN
   //ejector must not be bwd when operator switches to HA or FA
   //the ejector bwd movement is done in aRunAutoCylce
   //=> start of cycle should be possible if ejector is not bwd)
   //=> dependency must be modified for this case
   //all other safety relevant movements (mold, cores, ...) must be in the calculated startposition
   EjectorDependency := sv_ODCSequenceInt[1,1].SafetyArray[miIndexEjectorInSafetyArray].Dependency;
   sv_ODCSequenceInt[1,1].SafetyArray[miIndexEjectorInSafetyArray].Dependency := cNoDependency;
   bEjectorIgnored := TRUE;
END_IF;    

//check init safety array
//(check all safety relevant devices)
abODCCheckDependencies.aCheck(StepPos := Pos, DeviceIdSelf := DeviceId);
bAllowed := abODCCheckDependencies.aCheck.bAllowed;

//write back the original value
IF bEjectorIgnored THEN
   sv_ODCSequenceInt[1,1].SafetyArray[miIndexEjectorInSafetyArray].Dependency := EjectorDependency;
END_IF;


//check state of not safety relevant devices
//always check even if safety relevant check already failed
SafetyArray := sv_ODCSequenceInt[1,1].SafetyArray;
FOR iDevice := 1 TO sv_ODCDeviceMovements.iCount DO
   DeviceId := sv_ODCDeviceMovements.Devices[iDevice].DeviceId;
   iDefaultMove := sv_ODCDeviceMovements.Devices[iDevice].iDefaultMoveNumber;
   
   IF (SafetyArray[iDevice].Dependency = cNoDependency) AND (DeviceId.CompId <> cCompODC) THEN
      //device not safety relevant
      IF sv_ODCDeviceMovements.Devices[iDevice].pbDeviceActivated^ AND iDefaultMove <> 0 THEN
         //if device is activated and a default movement is available,
         //the default movement of this device must be in endposition
         fbCheckPosReached(DeviceId := DeviceId,
                           MoveDir := sv_MovementsAvailable[iDefaultMove].pMovementData^.MoveDir,
                           MoveId := sv_MovementsAvailable[iDefaultMove].pMovementData^.MoveId);
                           
         IF NOT fbCheckPosReached.bPosReached THEN
            IF sv_TraceLevel.bODCInterpreter THEN
               fbDebugTrace(CONCAT('cycle start not allowed by default position check of ',
                                   DINT_TO_STRING(DeviceId.CompId), '.', DINT_TO_STRING(DeviceId.IndexId),
                                   ' -> setting alarm ',
                                   GET_ALARM_NAME(fbCheckPosReached.Alarm.AlarmId)));
            END_IF;
            //set according alarm
            SET_ALARM(Name := fbCheckPosReached.Alarm.AlarmId,
                      SubID1 := fbCheckPosReached.Alarm.SubId[1],
                      SubID2 := fbCheckPosReached.Alarm.SubId[2],
                      SubID3 := fbCheckPosReached.Alarm.SubId[3],
                      SubID4 := fbCheckPosReached.Alarm.SubId[4]);
            bAllowed := FALSE;
         END_IF;
      END_IF;
   END_IF;
END_FOR;

IF NOT bAllowed THEN
   IF sv_TraceLevel.bODCInterpreter THEN
      fbDebugTrace('checking cycle start conditions found problems -> switching back to manual mode');
   END_IF;
   //switch away from auto mode if any check fails
   fbAutoManual();
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(6)
This algorithm checks the start conditions for the cycle if the 
operator switches to half or fullauto cycle.
Safety relevant devices must be in the position which they should have according
the programmed cycle.
Not safety relevant devices must be in their default position.
Deactivated devices and devices which have no default position are not checked.
@@@END_Comment@@@ 

@BEG_Body 
@TL(28)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bODCInterpreter THEN
   //trace opmode switch
   IF sv_OperationMode = nSetup THEN
      sOperationMode := 'Setup';
   ELSIF sv_OperationMode = nManual THEN
      sOperationMode := 'Manual';
   ELSIF sv_OperationMode = nHalfAutomatic THEN
      sOperationMode := 'HalfAutomatic';
   ELSIF sv_OperationMode = nFullAutomatic THEN
      sOperationMode := 'FullAutomatic';
   ELSE
      sOperationMode := '???';
   END_IF;
   fbDebugTrace(CONCAT('sv_OperationMode changed to ', sOperationMode));
END_IF;

IF PrevOpMode < nHalfAutomatic AND sv_OperationMode >= nHalfAutomatic THEN
   //check cycle start conditions
   aCheckCycleStartConditions();
END_IF;

PrevOpMode := sv_OperationMode;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
25 16 17 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 3 
@Step @RT(5)SInit @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@Trans @RT(6)Trans1 @F @T @F @F @T @F @TL(2)
TRUE

@RT(6)Trans1 @F 
@Loop @RT(4)loop @F 2 
@StepSeq @RT(3)seq @F 5 
@Step @RT(5)S_Run @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(8)Action24 @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
sv_bODCCombinedMoveActive := TRUE;

@F 
@Acb @RT(20)ARunCombinedMovement @F @T @RT(1)N @RT(0) @F @F @T @TL(4)
// run a combined movements
abInterpreter.aInterpret();
abInterpreter.aStatus();

@F 

@AltBranch @RT(3)alt @F 3 
@TransSeq @RT(4)tseq @F 5 
@Trans @RT(9)TFinished @F @T @F @F @T @F @TL(2)
abInterpreter.aStatus.bFinished

@RT(6)Trans2 @F 
@Step @RT(10)S_Finished @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)ATrace @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(18)TAllMovementsReady @F @T @F @F @T @F @TL(2)
sv_StartedManualMovements.iStartedMovements = 0

@RT(6)Trans7 @T @TL(2)
Interpreter is finished -> wait untill all movements
are ready  (for example airvalve can still be active)

@Step @RT(17)S_StopInterpreter @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(16)AStopInterpreter @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
abInterpreter.aStopInterpreterNormal();

@F 

@Trans @RT(7)Trans11 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans11 @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(10)TNotActive @F @T @F @F @T @F @TL(2)
NOT abInterpreter.aStatus.bActive

@RT(6)Trans5 @F 
@Step @RT(11)S_NotActive @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(15)ATraceNotActive @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(6)Trans8 @F @T @F @F @T @F @TL(2)
TRUE

@RT(6)Trans8 @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(6)TError @F @T @F @F @T @F @TL(2)
abInterpreter.aStatus.bError

@RT(6)Trans6 @F 
@Step @RT(7)S_Error @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(11)ATraceError @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(6)Trans9 @F @T @F @F @T @F @TL(2)
TRUE

@RT(6)Trans9 @F 


@Step @RT(8)S_Recalc @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(16)ADoPendingRecalc @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(7)Trans12 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans12 @F 
@Step @RT(6)S_Stop @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(5)AStop @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
sv_bODCCombinedMoveActive := FALSE;
STOP_PROCESS_ALGORITHM();

@F 


@Trans @RT(6)Trans4 @F @T @T @T @T @T @TL(2)
TRUE

@RT(6)Trans4 @F 

@END_SfcData 
@SaActions 4 
@SaText @RT(6)ATrace 1 @TL(10)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter,'stopping combined movement PA because interpreter has finished');
IF sv_StartedManualMovements.iStartedMovements <> 0 THEN
   fbDebugTrace2(nODCInterpreter,'There were still some movements active at end of a combined movement');
END_IF;


@SaText @RT(11)ATraceError 1 @TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter,'stopping combined movement PA because interpreter reported an error');


@SaText @RT(15)ATraceNotActive 1 @TL(10)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbDebugTrace2(nODCInterpreter,'stopping combined movement PA because interpreter is not active anymore');
IF sv_StartedManualMovements.iStartedMovements <> 0 THEN
   fbDebugTrace2(nODCInterpreter,'There were still some movements active at end of a combined movement');
END_IF;


@SaText @RT(16)ADoPendingRecalc 1 @TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_StartedManualMovements.iStartedMovements = 0 THEN
   //all movements ready
   aDoPendingRecalc();
   IF aDoPendingRecalc.bStartedRecalc THEN
      fbDebugTrace2(nDeviceState, 'recalc because interpreter finished and iStartedMovements = 0');
   END_IF;
END_IF;



@SaTrans 0 
@SaExits 0 
@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(21)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)


FOR i := 1 TO sv_StartedManualMovements.iStartedMovements DO
   
   TmpStepPos := sv_StartedManualMovements.MoveData[i].StepPos;
   IF (TmpStepPos.iColumn <> 0) AND (TmpStepPos.iRow <> 0) THEN
      //if a combined movement (sequence) is active, the supervision of the check conditions
      //is done automatically by the interpreter
      abInterpreter.aCheckConditionsManual(Movement := sv_ODCSequence[TmpStepPos.iColumn][TmpStepPos.iRow], bNoAlarms := FALSE);
      
      IF NOT abInterpreter.aCheckConditionsManual.bCheckConditionsOk THEN
         //check condition not ok
         abInterpreter.aStopInterpreterError();   
      END_IF;
   END_IF;
END_FOR;

@END_Body 

@@@BEG_Comment@@@ 
@TL(4)
supervision of check conditions for single movements in
manual and setup mode
For combined movements and in half and fullauto cycle the supervision
is done by the interpreter
@@@END_Comment@@@ 

@BEG_Body 
@TL(23)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Cycle time - from start to start
IF mbCycleTimeRunning THEN
   
   IF mbResetCycleTime THEN
      fbTonCycleTime(IN := FALSE);
      mbResetCycleTime := FALSE;
   END_IF;
   
   fbTonCycleTime(IN := TRUE,
                  PT := t#20d);
  
   b := WRITE_SV_DIRECT(sv_dCycleTime, fbTonCycleTime.ET);
   
   IF sv_dCycleTime > sv_dMaxCycleTime THEN
      SET_ALARM(Name := erCycleTimeExceeded);
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(19)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//Cycle time machine - from start to end of cycle
IF mbCycleTimeRunning AND mbCycleTimeMachineRunning THEN
   
   IF mbResetCycleTimeMachine THEN
      fbTonCycleTimeMachine(IN := FALSE);
      mbResetCycleTimeMachine := FALSE;
   END_IF;
   
   fbTonCycleTimeMachine(IN := TRUE,
                         PT := t#20d);
    
   b := WRITE_SV_DIRECT(sv_dCycleTimeMachine, fbTonCycleTimeMachine.ET);
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(22)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bSequenceInterruption THEN
   IF sv_TraceLevel.bODCInterpreter THEN
      dummy := Print('***** INTERRUPT SEQUENCE *****');
   END_IF;
   mbStopAfterCycle := TRUE;
   abInterpreter.aInterruptSequence();
ELSE      
   sv_bStepBwdActive := FALSE;
   IF sv_OperationMode >= nHalfAutomatic THEN
      IF sv_TraceLevel.bODCInterpreter THEN
         dummy := Print('***** CONTINUE SEQUENCE *****');
      END_IF;
      abInterpreter.aContinueSequence();
      mbStopAfterCycle := FALSE;
   END_IF;   
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(40)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//get inverse movement
iMoveIdInverse := sv_MovementsAvailable[iMoveNr].pMovementData^.iMoveIdInverseMovement;
IF iMoveIdInverse = cMinMoveIdent THEN
   //no inverse movement defined
   //set alarm if moenet does not belong to ODC - function unit
   IF (sv_MovementsAvailable[iMoveNr].DeviceId <> sv_DeviceId) THEN
      SET_ALARM(Name := erNoInverseMovement,
                SubID1 := sv_MovementsAvailable[iMoveNr].DeviceId.CompId,
                SubID2 := sv_MovementsAvailable[iMoveNr].DeviceId.IndexId,
                SubID3 := sv_MovementsAvailable[iMoveNr].pMovementData^.MoveId);
   END_IF;
   
   RETURN; //return here
END_IF;

iFuIndex := sv_MovementsAvailable[iMoveNr].iFuIndex;
FOR i := 1 TO sv_ODCDeviceMovements.Devices[iFuIndex].iNumberOfMovements DO
   IF sv_ODCDeviceMovements.Devices[iFuIndex].Movements[i]^.MoveId = iMoveIdInverse THEN
      //inverse movement found => try to start it
      aStartSingleMovement(DeviceId := sv_ODCDeviceMovements.Devices[iFuIndex].DeviceId,
                           MoveDir := sv_ODCDeviceMovements.Devices[iFuIndex].Movements[i]^.MoveDir,
                           MoveId := sv_ODCDeviceMovements.Devices[iFuIndex].Movements[i]^.MoveId,
                           IntermediateCond := 0,
                           bNeedCheckSafety := (sv_ODCDeviceMovements.Devices[iFuIndex].Movements[i]^.iSafetyIdentifier > 0));
      
      IF aStartSingleMovement.bStarted THEN
         mActiveStepBwdMovements[iColumn].DeviceId := sv_ODCDeviceMovements.Devices[iFuIndex].DeviceId;
         mActiveStepBwdMovements[iColumn].MoveId := sv_ODCDeviceMovements.Devices[iFuIndex].Movements[i]^.MoveId;
         mActiveStepBwdMovements[iColumn].MoveDir := sv_ODCDeviceMovements.Devices[iFuIndex].Movements[i]^.MoveDir;
      END_IF;
                     
      EXIT;
   END_IF;
END_FOR;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(21)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bSequenceInterruption THEN
   //button is only working if sequence is interrupted
   RETURN;
END_IF;

IF di_StepFwd THEN 
   //trigger interpreter to execute the next step(s)
   IF sv_StartedManualMovements.iStartedMovements = 0 THEN
      //ignore step fwd button if any movment is active
      abInterpreter.aEnableNextStep();
   END_IF;  
ELSE
   //stop actually executed step(s)
   abInterpreter.aInterruptSequence();
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(51)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT sv_bSequenceInterruption THEN
   //button is only working if sequence is interrupted
   RETURN;
END_IF;

IF di_StepBwd THEN
   
   IF sv_StartedManualMovements.iStartedMovements <> 0 THEN
      //ignore step bwd button if any movement is still active
      RETURN;
   END_IF;
   
   sv_bStepBwdActive := TRUE;
   
   //get actual active lines and find the inverse movements
   FOR iColumn := 1 TO sv_iUsedColumns DO
      IF sv_InterpreterParallelInfo[iColumn].bColumnActive THEN
         //it is possible that the sequence was interrupted during waiting
         //for completion of a parallel tree -> in this case the line number must be decreased
         IF (sv_ODCSequence[iColumn, sv_InterpreterParallelInfo[iColumn].iRow].iMoveId = cMoveEndParallel) THEN
            abInterpreter.aDecreaseRow(bStartInActualLine := FALSE,
                                       iColumn := iColumn,
                                       iEndRow := 1);
         ELSIF (sv_ODCSequence[iColumn, sv_InterpreterParallelInfo[iColumn].iRow].iMoveId = cMoveStartParallel) OR 
            (sv_ODCSequence[iColumn, sv_InterpreterParallelInfo[iColumn].iRow].iMoveId = cMoveStartParallelOpen) THEN
            //stepping bwd stopped during waiting for parallel trees
            //-> check actual state of this tree
            abInterpreter.aDecreaseRow(bStartInActualLine := TRUE,
                                       iColumn := iColumn,
                                       iEndRow := 1);
         END_IF;
         
         iActiveMoveNr := sv_ODCSequenceInt[iColumn, sv_InterpreterParallelInfo[iColumn].iRow].iMoveNumber;
         IF iActiveMoveNr > cMoveNone THEN
            aStartInverseMovement(iMoveNr := iActiveMoveNr,
                                 iColumn := iColumn);
         END_IF;
      END_IF;      
   END_FOR;
ELSE
   //stop actually executed step(s)
   abInterpreter.aInterruptSequence();
   
   sv_bStepBwdActive := FALSE;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(51)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_iInitOK <> 20 THEN
   dummy := Print('!!! evModifyCycleStartCondition event ignored !!!');
   RETURN; //ignore event because machine sequence is not created
END_IF;

//save event data
eventData := evModifyCycleStartCondData;

//get index of this device in the safety array
iFuIndex := 0;
FOR i := 1 TO sv_ODCDeviceMovements.iCount DO
   IF sv_ODCDeviceMovements.Devices[i].DeviceId = eventData.DeviceId THEN
      iFuIndex := i;
      EXIT;
   END_IF;
END_FOR;

IF iFuIndex = 0 THEN
   RETURN; //device not found
END_IF;

IF (eventData.iMode = 1) THEN
   //get movement number
   fbGetMoveNumber(DeviceId := eventData.DeviceId,
                  MoveId := eventData.MoveId,
                  MoveDir := eventData.MoveDir);
   
   IF fbGetMoveNumber.bFound THEN
      iMoveNr := fbGetMoveNumber.iMoveNumber;
   ELSE
      RETURN; //movement not found
   END_IF;
   
   //add this movement as additional start condition of this device
   fbAddDependency(iFuIndex := iFuIndex,
                   iMoveNr := iMoveNr,
                   iCount := eventData.iCount,
                   iMode := 1,
                   Dependency := sv_ODCSequenceInt[1,1].SafetyArray);
   
ELSE
   ; //unsupported mode 
END_IF;



@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
@@@BEG_Password@@@
NGhzZm9kYzQ=
@@@END_Password@@@
