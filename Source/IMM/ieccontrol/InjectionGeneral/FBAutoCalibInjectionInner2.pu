(*
take one edge (falling / raising) and try to indentify the plant
then calculate the quadratic error between real plant and identified plant
also identify the dead time by shifting value to the left and using the
one with the smallest quadratic error

returns ideal controller params in CalculatedParams
print debug output to files when mDebugCalibration is set
*)

IMPORT_OVER_LISTFILE
 KCTRL_CalcController
, KFILE_Open
, KFILE_WriteString
, KFILE_Close
, KMEM_ArrayGet
, cMaxShiftData
, KCTRL_Ret_OK
, KCTRL_Plant_PT1
, KCTRL_Controller_PI
, KCTRL_CalcController_OK
, KFILE_Mode_ReadWriteDelete
, tyHalfArray
, tsCalculatedInjectData
, KCTRL_Ident
, KCTRL_Ident_Data
, KCTRL_Ident_Info
, KCTRL_Ident_Param
, KCTRL_ZFunction
, KCTRL_CalcController_InParam
, KCTRL_CalcController_OutParam
, KCTRL_CalcController_State
, KFILE_Status
, KFILE_Open_Data
, FBAutoCalibLog
, KMEM_CreateData
, KMEM_Status
, tsCalibShiftData

END_IMPORT

FUNCTION_BLOCK FBAutoCalibInjectionInner2 #DUMMY_EDIT_BLOCK

VAR_IN_OUT
 InArray : tyHalfArray (* Input of plant( jumping from 0.1 to 0.9) *);
 OutArray : tyHalfArray (* output of plant to be identified *);
END_VAR

VAR_OUTPUT
 CalculatedParams : tsCalculatedInjectData;
END_VAR

VAR_INPUT
 iPointCount : DINT (* amount of data collected *);
 CycleTime : TIME (* cycle time of collected data *);
 DebugPrefix : STRING(255);
END_VAR

VAR_OUTPUT
 bValid : BOOL;
END_VAR

VAR_INPUT
 rPlantAmp : REAL (* amplification of plant for  *);
 rHighOutputFactor : REAL (* Normalized SetValue: 0.8 *);
 iTimeStartPos : DINT (* Position after falling/raising edge *);
 bDebugCalibration : BOOL;
END_VAR

VAR_OUTPUT
 bError : BOOL;
 iErrorInfo : DINT;
END_VAR

VAR_INPUT
 rPhasemargin : REAL;
 rPhasemarginMin3dB : REAL;
END_VAR

SYSTEM_VAR
 sv_IdentInData : tyHalfArray;
 sv_IdentOutData : tyHalfArray;
END_VAR

VAR_TEMP
 iZCounter : DINT;
 i : DINT;
 j : DINT;
 iIdentCount : DINT;
END_VAR

VAR
 Ident : KCTRL_Ident;
 IdentData : KCTRL_Ident_Data;
 IdentInfo : KCTRL_Ident_Info;
 IdentParam : KCTRL_Ident_Param;
 ZFunction : KCTRL_ZFunction;
 CalcControllerIn : KCTRL_CalcController_InParam;
 CalcControllerOut : KCTRL_CalcController_OutParam;
 CalcControllerState : KCTRL_CalcController_State;
 rQuadraticError : REAL;
 rMinimumQuadraticError : REAL;
 iBestQuadraticErrorPos : DINT;
 filestatus : KFILE_Status;
 file : KFILE_Open_Data;
 writecount : DINT;
 tmpstr : STRING(255);
 rTmpZOut : REAL (* make tmp *);
 printtmp : DINT;
 tIdentifiedDeadTime : TIME;
 rIdentifiedT1 : REAL;
 rIdentifiedK : REAL;
 mWarned : BOOL (* warn only once *);
 iTmpBecausePrintSucks : DINT;
 rTmpValueForDebug : REAL;
 r_temp_A0 : REAL (* For Calculating ZFunc.Init *);
 r_temp_A1 : REAL (* For Calculating ZFunc.Init *);
 r_temp_B0 : REAL (* For Calculating ZFunc.Init *);
 fbLog : FBAutoCalibLog;
 ShiftData : KMEM_CreateData;
 s : KMEM_Status;
 ShiftDataTmp : tsCalibShiftData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//get handle to dynamic array
ShiftData := KMEM_GetHandle(cCalibShiftData);
IF ShiftData.Status <> KMEM_Status_OK THEN
   bError := TRUE;
   iErrorInfo := cCalibInvalidHandle;
   RETURN;
END_IF;

(* identify plant and calculate controller for it *)

bValid := FALSE;
bError := FALSE;
iErrorInfo := 0;

rMinimumQuadraticError := 10.0**38;
(* 
   loop to calculate quadratic error
   shift output of plant to left and recalculate
 *)
FOR iIdentCount:= 1 TO cMaxShiftData DO
   mWarned := FALSE;//only warn for ZFunction Error once per loop

   (* copy to SV array (Ident needs data in a SV) *)
   (* at the same time shift the out array (iIdentCount-1) times to the left *)
   (* todo do not copy InData every day *)
   j := 1;
   FOR i:= iIdentCount TO iPointCount DO
      sv_IdentOutData[j] := OutArray[i];
      sv_IdentInData[j] := InArray[j]; //second j is OK as we do not want to shift this array
      j := j+1;
   END_FOR;


   (*parametrize Ident block: PT1-Plant b(0)/(a(0)+a(1)*z) *)
   IdentParam.dCycleTime := CycleTime;
   IdentParam.uNumDegree := 0;
   IdentParam.uDenumDegree := 1;
   IdentParam.rWeightingFactor := 1.0;
   
   Ident.Par(dCycleTime := CycleTime, Param := IdentParam);
   IF(Ident.Par.parStatus <> KCTRL_Ret_OK) THEN
      printtmp := Print('Ident.Par failed'); 
      bError := TRUE; 
      iErrorInfo := -401; 
   END_IF;
   
   Ident.Init();   
   
   (* do offline anaysis for data *)
   (* in:  sv_IdentInData *)
   (* out: sv_IdentOutData *)
   IdentData.dCycleTime := CycleTime;
   IdentData.rPlantInput := @sv_IdentInData;
   IdentData.rPlantOutput := @sv_IdentOutData;
   IdentData.uIdentLength := DINT_TO_UDINT(iPointCount - iIdentCount);
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   (* do we need to record the zfunction data even if not best? *)
   Ident.Offline(IdentData := IdentData, ZFunction := ShiftDataTmp.ZFunctionData, Info := IdentInfo);
   //write back to dynamic array
   s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   
   (* for debugging print all tested ZFunction Parameters *)
   IF bDebugCalibration THEN
      printtmp := Print('%d --> a0:%f', iIdentCount, Ident.Offline.ZFunction.DenumCoeffs[0]);
   END_IF;
    
   
   (* simulate identified plant *)
   ZFunction.Par.Param := Ident.Offline.ZFunction;
   ZFunction.Par();
   IF(ZFunction.Par.parStatus <> KCTRL_Ret_OK) THEN
      printtmp := Print('zfunction.par failed');
      bError := TRUE; 
      iErrorInfo := -402; 
   END_IF;
   
   rQuadraticError := 0.0;
   // Set Init from Z_Function in such way that the first value agrees with the 
   // mean value of the pressure. The mean value is normalized to 0.8
   // For getting the right Init, we calculate the gain of a dynamic 
   // simulated plant
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   r_temp_A0 := ShiftDataTmp.ZFunctionData.DenumCoeffs[0];
   r_temp_A1 := ShiftDataTmp.ZFunctionData.DenumCoeffs[1];
   r_temp_B0 := ShiftDataTmp.ZFunctionData.NumCoeffs[0];
   
   // Transformation f(z)->f(s)
   IF r_temp_A1 = 0.0 OR r_temp_B0 = 0.0 THEN
      bError := TRUE; 
      iErrorInfo := -403; 
      RETURN;
   END_IF;
   rIdentifiedT1 := (- LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0) / (LN(-(r_temp_A0/r_temp_A1)));
   IF rIdentifiedT1 = 0.0 THEN
      bError := TRUE; 
      iErrorInfo := -408; 
      RETURN;
   END_IF;
   IF (1.0 = EXP(-LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0/rIdentifiedT1)) THEN
      bError := TRUE; 
      iErrorInfo := -404; 
      RETURN;
   END_IF; 
   
   rIdentifiedK :=  r_temp_B0 / (1.0 - EXP(-LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0/rIdentifiedT1))/r_temp_A1;
   
   ZFunction.Init(rX := rHighOutputFactor/rIdentifiedK);  
   ZFunction.Calculate(bEnable := TRUE, rX := rHighOutputFactor/rIdentifiedK);
   (* calculate quadratic error *)
   // befor the falling/raising edge, the plant can't in/decrease, but
   // the approximated plant could do that, if we use the set value for
   // calculating the error (because the gain is not in the near of one 
   // by the wrong deadTime) => use the meanValue of the pressure (0.8 p_max)  
   // Use in every deadTime Step the same number of points, for calculating the error 
   FOR iZCounter := cMaxShiftData +1 -iIdentCount  TO iTimeStartPos - 1  DO
      rQuadraticError := rQuadraticError + EXPT(sv_IdentOutData[iZCounter] - rHighOutputFactor,2);
   END_FOR; 
   //FOR iZCounter:=iTimeStartPos TO iPointCount - cMaxShiftData DO
   FOR iZCounter:=iTimeStartPos TO iPointCount - iIdentCount DO
      (* if ZFunction is feeded instable parameters it can integrate until +-inf an crash then *)
      (* fixed in version 1.04 of ControlLib *)
      (* stop calling if we find out, that values are out of range *)
      (* remove when package fixed? *)
      (* For calculating the failure between approximation and plant it is necessary *)
      (* to start in the same condition. Only the time after the falling edge should be assessed*)
      
      IF(ZFunction.Calculate.rY > -100000.0 AND ZFunction.Calculate.rY < 100000.0) THEN
         ZFunction.Calculate(bEnable := TRUE, rX := InArray[iZCounter]);
      ELSE
         IF(NOT mWarned) THEN
            printtmp := Print('ZFunction Problem at pos %d',iZCounter);
         END_IF;
         mWarned := TRUE;
      END_IF;
      rTmpZOut := ZFunction.Calculate.rY;
      (* save ZFunction output for debugging / to see which one is really the best *)
      (* Take in every step the same number of points *)
      s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
      ShiftDataTmp.DebugZOutArray[iZCounter] := rTmpZOut;
      s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
      rQuadraticError := rQuadraticError + EXPT(sv_IdentOutData[iZCounter] - rTmpZOut,2);//use shifted version here  
   END_FOR;
         
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   ShiftDataTmp.rQuadraticError := rQuadraticError;
   s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount)); 
   (* check if best result so far *)
   IF( rQuadraticError < rMinimumQuadraticError) THEN
      rMinimumQuadraticError := rQuadraticError;
      iBestQuadraticErrorPos := iIdentCount;
      IF rMinimumQuadraticError = 0.0 AND iIdentCount = 1 THEN
          fbLog('It is not possible to have no failure, so the set value is not calculated right!');
          bError := TRUE; 
          iErrorInfo := -405; 
          RETURN;
      END_IF;  
  END_IF;
END_FOR;


(* use parameter set with best quadratic error *)
tIdentifiedDeadTime := MULTIME(CycleTime, iBestQuadraticErrorPos - 1);

(* Get denumerators *)
s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iBestQuadraticErrorPos));
r_temp_A0 := ShiftDataTmp.ZFunctionData.DenumCoeffs[0];
r_temp_A1 := ShiftDataTmp.ZFunctionData.DenumCoeffs[1];
r_temp_B0 := ShiftDataTmp.ZFunctionData.NumCoeffs[0];


rIdentifiedT1 := (- LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0) / (LN(ABS(r_temp_A0)));
IF rIdentifiedT1 = 0.0 THEN
   bError := TRUE; 
   iErrorInfo := -408; 
   RETURN;
END_IF;
   
IF (1.0 = EXP(-LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0/rIdentifiedT1)) OR r_temp_A1 = 0.0 OR r_temp_B0 = 0.0 THEN
   bError := TRUE; 
   iErrorInfo := -406; 
   RETURN;
END_IF; 
   
rIdentifiedK :=  r_temp_B0 / (1.0 - EXP(-(LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0)/rIdentifiedT1))/r_temp_A1;
IF ABS(rIdentifiedK-1.0)>0.1 THEN
   fbLog('There is a problem by the indentification of the holding process.');
   iErrorInfo := -499;
   // Only a warning 
END_IF;   

CalcControllerIn.Plant := KCTRL_Plant_PT1;
CalcControllerIn.Controller := KCTRL_Controller_PI;
CalcControllerIn.rGain := rIdentifiedK; // For the closed-loop control parameters use the approx. gain
CalcControllerIn.dDeadTime := tIdentifiedDeadTime;
CalcControllerIn.dT1 := LINT_TO_TIME(REAL_TO_LINT(rIdentifiedT1 * 1000.0 * 1000.0)); //convert from sec to usec;
IF (rPhasemargin) > 0.0 AND (rPhasemargin < 180.0) THEN
    CalcControllerIn.rPhasemargin := rPhasemargin;
ELSE
    CalcControllerIn.rPhasemargin := 70.0;// default value by berg
END_IF;

IF (rPhasemarginMin3dB) > 0.0 AND (rPhasemarginMin3dB < 180.0) THEN
    CalcControllerIn.rPhasemarginMin3dB := rPhasemarginMin3dB;
ELSE
    CalcControllerIn.rPhasemarginMin3dB := 62.0;// default value by berg
END_IF;

CalcControllerState := KCTRL_CalcController(InParam := CalcControllerIn, OutParam := CalcControllerOut);

IF(CalcControllerState <> KCTRL_CalcController_OK) THEN
   tmpstr := CONCAT(DebugPrefix, 'KCTRL_CalcController failed:',DINT_TO_STRING(CalcControllerOut.ErrorID));
   printtmp := Print(tmpstr);
   bError := TRUE;
   iErrorInfo := -407; 
END_IF;

IF rPlantAmp <> 0.0 THEN
   CalculatedParams.rControllerKR  := CalcControllerOut.rKR * rPlantAmp;
ELSE
   printtmp := Print('plant amplification factor should never be 0');
   CalculatedParams.rControllerKR  := CalcControllerOut.rKR;
END_IF;
CalculatedParams.rControllerW   := CalcControllerOut.rW;
CalculatedParams.tControllerTN  := CalcControllerOut.dTN;
// Use rPlantK = 1.0, because otherwise the internal set value for closed loop control
// does not agree with the real set value, the approximated value should nearly 1.0
CalculatedParams.rPlantK        := 1.0;
CalculatedParams.tPlantDeadTime := CalcControllerIn.dDeadTime;
CalculatedParams.tPlantT1       := CalcControllerIn.dT1;

IF(bDebugCalibration)THEN
   iTmpBecausePrintSucks := (iBestQuadraticErrorPos - 1)* LINT_TO_DINT(TIME_TO_LINT(CycleTime) / 1000);

   printtmp := Print('%sZFunction a0:%f', DebugPrefix, r_temp_A0);
   printtmp := Print('%sIdentified T1:%f',DebugPrefix, rIdentifiedT1);
   printtmp := Print('%sIdentified K:%f',DebugPrefix, rIdentifiedK);
   printtmp := Print('%sSelected ZFunction No %d; DeadTime: %dms',DebugPrefix, iBestQuadraticErrorPos, iTmpBecausePrintSucks);
   printtmp := Print('%scontroller kR:%f, W:%f',DebugPrefix, CalcControllerOut.rKR, CalcControllerOut.rW);
   
   (* output recorded in / output values and identified functions*)
   (* also contains data for calculated Z Functions *)
   file := KFILE_Open(Name:= CONCAT(DebugPrefix,'detail.txt'), Mode := KFILE_Mode_ReadWriteDelete);
   
   tmpstr := 'count;in;out';
   FOR i:= 1 TO cMaxShiftData DO
      tmpstr := CONCAT(tmpstr, ';zfunc', DINT_TO_STRING(i));
   END_FOR;
   tmpstr := CONCAT(tmpstr,';$N');
   
   writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
   //print in / out curve and identified functions
   FOR i:= 1 TO iPointCount -1 DO
      tmpstr := CONCAT(DINT_TO_STRING(i), ';', REAL_TO_STRING(OutArray[i]), ';', REAL_TO_STRING(InArray[i]));
      FOR j:= 1 TO MIN(cMaxShiftData, 15) DO//do not write more than 15 columns or Excel barfs
         IF (i+1 -j <1) THEN
            rTmpValueForDebug := 0.3;//ShiftData[j].DebugZOutArray[1];//do not access array out of bounds
         ELSE
            s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(j));
            rTmpValueForDebug := ShiftDataTmp.DebugZOutArray[i+1 -j]; //add shifting +1 because shift=1 -> no shifting takes place
         END_IF;
         tmpstr := CONCAT(tmpstr, ';', REAL_TO_STRING(rTmpValueForDebug));
      END_FOR;
      tmpstr := CONCAT(tmpstr,';$N');

      writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
   END_FOR;
   filestatus := KFILE_Close(Token := file.Token);
  
   
   (* save quadratic error to csv *)
   file := KFILE_Open(Name:= CONCAT(DebugPrefix,'error.txt'), Mode := KFILE_Mode_ReadWriteDelete);
   tmpstr := 'shiftcount;quadratic error$N';
   writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
   FOR i:=1 TO cMaxShiftData DO
      s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(i));
      tmpstr := CONCAT(DINT_TO_STRING(i), ';', REAL_TO_STRING(ShiftDataTmp.rQuadraticError), '$N');
      writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
   END_FOR;
   filestatus := KFILE_Close(Token := file.Token);
END_IF;

bValid := NOT bError;


;#END_EDIT_BLOCK END_FUNCTION_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 97 @Pou 25 
@@@BEG_Comment@@@
take one edge (falling / raising) and try to indentify the plant
then calculate the quadratic error between real plant and identified plant
also identify the dead time by shifting value to the left and using the
one with the smallest quadratic error

returns ideal controller params in CalculatedParams
print debug output to files when mDebugCalibration is set
@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
5 
@Var @RT(20)KCTRL_CalcController @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)KFILE_Open @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)KFILE_WriteString @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)KFILE_Close @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)KMEM_ArrayGet @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
6 
@Var @RT(13)cMaxShiftData @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)19 @RT(94)how often to shift the signal to the left for identifying the plant( 1 time shifting = x msec) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)KCTRL_Ret_OK @RT(0) @T @T @DERIVED 0 @F @RT(9)KCTRL_Ret @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)KCTRL_Plant_PT1 @RT(0) @T @T @DERIVED 0 @F @RT(15)KCTRL_PlantType @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)KCTRL_Controller_PI @RT(0) @T @T @DERIVED 0 @F @RT(20)KCTRL_ControllerType @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(23)KCTRL_CalcController_OK @RT(0) @T @T @DERIVED 0 @F @RT(26)KCTRL_CalcController_State @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(26)KFILE_Mode_ReadWriteDelete @RT(0) @T @T @DERIVED 0 @F @RT(10)KFILE_Mode @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(102)opens for reading and writing, if file doesn't exist, it will be created, its contents will be deleted 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@FUNCTION_BLOCK @RT(26)FBAutoCalibInjectionInner2 @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
51 
@Var @RT(7)InArray @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tyHalfArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(40)Input of plant( jumping from 0.1 to 0.9) @RT(0) 
@END_Attrib 
1 2 @F @F @F @F 

@Var @RT(8)OutArray @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tyHalfArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(32)output of plant to be identified @RT(0) 
@END_Attrib 
1 2 @F @F @F @F 

@Var @RT(16)CalculatedParams @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tsCalculatedInjectData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(11)iPointCount @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(24)amount of data collected @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)CycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(28)cycle time of collected data @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)DebugPrefix @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)bValid @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(9)rPlantAmp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(27)amplification of plant for  @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)rHighOutputFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(24)Normalized SetValue: 0.8 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)iTimeStartPos @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)Position after falling/raising edge @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)sv_IdentInData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tyHalfArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_IdentOutData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tyHalfArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(9)iZCounter @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)j @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(11)iIdentCount @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(5)Ident @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KCTRL_Ident @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)IdentData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KCTRL_Ident_Data @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)IdentInfo @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KCTRL_Ident_Info @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)IdentParam @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)KCTRL_Ident_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)ZFunction @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KCTRL_ZFunction @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)CalcControllerIn @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(28)KCTRL_CalcController_InParam @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)CalcControllerOut @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(29)KCTRL_CalcController_OutParam @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)CalcControllerState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(26)KCTRL_CalcController_State @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)rQuadraticError @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)rMinimumQuadraticError @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)iBestQuadraticErrorPos @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)filestatus @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)KFILE_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(4)file @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KFILE_Open_Data @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)writecount @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)tmpstr @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)rTmpZOut @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(8)make tmp @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)printtmp @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)tIdentifiedDeadTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)rIdentifiedT1 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rIdentifiedK @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)mWarned @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(14)warn only once @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)bDebugCalibration @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(21)iTmpBecausePrintSucks @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)rTmpValueForDebug @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)r_temp_A0 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)For Calculating ZFunc.Init @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)r_temp_A1 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)For Calculating ZFunc.Init @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)r_temp_B0 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(26)For Calculating ZFunc.Init @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)fbLog @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)FBAutoCalibLog @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(12)rPhasemargin @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)rPhasemarginMin3dB @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)ShiftData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KMEM_CreateData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)s @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KMEM_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)ShiftDataTmp @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)tsCalibShiftData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(288)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//get handle to dynamic array
ShiftData := KMEM_GetHandle(cCalibShiftData);
IF ShiftData.Status <> KMEM_Status_OK THEN
   bError := TRUE;
   iErrorInfo := cCalibInvalidHandle;
   RETURN;
END_IF;

(* identify plant and calculate controller for it *)

bValid := FALSE;
bError := FALSE;
iErrorInfo := 0;

rMinimumQuadraticError := 10.0**38;
(* 
   loop to calculate quadratic error
   shift output of plant to left and recalculate
 *)
FOR iIdentCount:= 1 TO cMaxShiftData DO
   mWarned := FALSE;//only warn for ZFunction Error once per loop

   (* copy to SV array (Ident needs data in a SV) *)
   (* at the same time shift the out array (iIdentCount-1) times to the left *)
   (* todo do not copy InData every day *)
   j := 1;
   FOR i:= iIdentCount TO iPointCount DO
      sv_IdentOutData[j] := OutArray[i];
      sv_IdentInData[j] := InArray[j]; //second j is OK as we do not want to shift this array
      j := j+1;
   END_FOR;


   (*parametrize Ident block: PT1-Plant b(0)/(a(0)+a(1)*z) *)
   IdentParam.dCycleTime := CycleTime;
   IdentParam.uNumDegree := 0;
   IdentParam.uDenumDegree := 1;
   IdentParam.rWeightingFactor := 1.0;
   
   Ident.Par(dCycleTime := CycleTime, Param := IdentParam);
   IF(Ident.Par.parStatus <> KCTRL_Ret_OK) THEN
      printtmp := Print('Ident.Par failed'); 
      bError := TRUE; 
      iErrorInfo := -401; 
   END_IF;
   
   Ident.Init();   
   
   (* do offline anaysis for data *)
   (* in:  sv_IdentInData *)
   (* out: sv_IdentOutData *)
   IdentData.dCycleTime := CycleTime;
   IdentData.rPlantInput := @sv_IdentInData;
   IdentData.rPlantOutput := @sv_IdentOutData;
   IdentData.uIdentLength := DINT_TO_UDINT(iPointCount - iIdentCount);
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   (* do we need to record the zfunction data even if not best? *)
   Ident.Offline(IdentData := IdentData, ZFunction := ShiftDataTmp.ZFunctionData, Info := IdentInfo);
   //write back to dynamic array
   s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   
   (* for debugging print all tested ZFunction Parameters *)
   IF bDebugCalibration THEN
      printtmp := Print('%d --> a0:%f', iIdentCount, Ident.Offline.ZFunction.DenumCoeffs[0]);
   END_IF;
    
   
   (* simulate identified plant *)
   ZFunction.Par.Param := Ident.Offline.ZFunction;
   ZFunction.Par();
   IF(ZFunction.Par.parStatus <> KCTRL_Ret_OK) THEN
      printtmp := Print('zfunction.par failed');
      bError := TRUE; 
      iErrorInfo := -402; 
   END_IF;
   
   rQuadraticError := 0.0;
   // Set Init from Z_Function in such way that the first value agrees with the 
   // mean value of the pressure. The mean value is normalized to 0.8
   // For getting the right Init, we calculate the gain of a dynamic 
   // simulated plant
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   r_temp_A0 := ShiftDataTmp.ZFunctionData.DenumCoeffs[0];
   r_temp_A1 := ShiftDataTmp.ZFunctionData.DenumCoeffs[1];
   r_temp_B0 := ShiftDataTmp.ZFunctionData.NumCoeffs[0];
   
   // Transformation f(z)->f(s)
   IF r_temp_A1 = 0.0 OR r_temp_B0 = 0.0 THEN
      bError := TRUE; 
      iErrorInfo := -403; 
      RETURN;
   END_IF;
   rIdentifiedT1 := (- LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0) / (LN(-(r_temp_A0/r_temp_A1)));
   IF rIdentifiedT1 = 0.0 THEN
      bError := TRUE; 
      iErrorInfo := -408; 
      RETURN;
   END_IF;
   IF (1.0 = EXP(-LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0/rIdentifiedT1)) THEN
      bError := TRUE; 
      iErrorInfo := -404; 
      RETURN;
   END_IF; 
   
   rIdentifiedK :=  r_temp_B0 / (1.0 - EXP(-LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0/rIdentifiedT1))/r_temp_A1;
   
   ZFunction.Init(rX := rHighOutputFactor/rIdentifiedK);  
   ZFunction.Calculate(bEnable := TRUE, rX := rHighOutputFactor/rIdentifiedK);
   (* calculate quadratic error *)
   // befor the falling/raising edge, the plant can't in/decrease, but
   // the approximated plant could do that, if we use the set value for
   // calculating the error (because the gain is not in the near of one 
   // by the wrong deadTime) => use the meanValue of the pressure (0.8 p_max)  
   // Use in every deadTime Step the same number of points, for calculating the error 
   FOR iZCounter := cMaxShiftData +1 -iIdentCount  TO iTimeStartPos - 1  DO
      rQuadraticError := rQuadraticError + EXPT(sv_IdentOutData[iZCounter] - rHighOutputFactor,2);
   END_FOR; 
   //FOR iZCounter:=iTimeStartPos TO iPointCount - cMaxShiftData DO
   FOR iZCounter:=iTimeStartPos TO iPointCount - iIdentCount DO
      (* if ZFunction is feeded instable parameters it can integrate until +-inf an crash then *)
      (* fixed in version 1.04 of ControlLib *)
      (* stop calling if we find out, that values are out of range *)
      (* remove when package fixed? *)
      (* For calculating the failure between approximation and plant it is necessary *)
      (* to start in the same condition. Only the time after the falling edge should be assessed*)
      
      IF(ZFunction.Calculate.rY > -100000.0 AND ZFunction.Calculate.rY < 100000.0) THEN
         ZFunction.Calculate(bEnable := TRUE, rX := InArray[iZCounter]);
      ELSE
         IF(NOT mWarned) THEN
            printtmp := Print('ZFunction Problem at pos %d',iZCounter);
         END_IF;
         mWarned := TRUE;
      END_IF;
      rTmpZOut := ZFunction.Calculate.rY;
      (* save ZFunction output for debugging / to see which one is really the best *)
      (* Take in every step the same number of points *)
      s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
      ShiftDataTmp.DebugZOutArray[iZCounter] := rTmpZOut;
      s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
      rQuadraticError := rQuadraticError + EXPT(sv_IdentOutData[iZCounter] - rTmpZOut,2);//use shifted version here  
   END_FOR;
         
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   ShiftDataTmp.rQuadraticError := rQuadraticError;
   s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount)); 
   (* check if best result so far *)
   IF( rQuadraticError < rMinimumQuadraticError) THEN
      rMinimumQuadraticError := rQuadraticError;
      iBestQuadraticErrorPos := iIdentCount;
      IF rMinimumQuadraticError = 0.0 AND iIdentCount = 1 THEN
          fbLog('It is not possible to have no failure, so the set value is not calculated right!');
          bError := TRUE; 
          iErrorInfo := -405; 
          RETURN;
      END_IF;  
  END_IF;
END_FOR;


(* use parameter set with best quadratic error *)
tIdentifiedDeadTime := MULTIME(CycleTime, iBestQuadraticErrorPos - 1);

(* Get denumerators *)
s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iBestQuadraticErrorPos));
r_temp_A0 := ShiftDataTmp.ZFunctionData.DenumCoeffs[0];
r_temp_A1 := ShiftDataTmp.ZFunctionData.DenumCoeffs[1];
r_temp_B0 := ShiftDataTmp.ZFunctionData.NumCoeffs[0];


rIdentifiedT1 := (- LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0) / (LN(ABS(r_temp_A0)));
IF rIdentifiedT1 = 0.0 THEN
   bError := TRUE; 
   iErrorInfo := -408; 
   RETURN;
END_IF;
   
IF (1.0 = EXP(-LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0/rIdentifiedT1)) OR r_temp_A1 = 0.0 OR r_temp_B0 = 0.0 THEN
   bError := TRUE; 
   iErrorInfo := -406; 
   RETURN;
END_IF; 
   
rIdentifiedK :=  r_temp_B0 / (1.0 - EXP(-(LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0)/rIdentifiedT1))/r_temp_A1;
IF ABS(rIdentifiedK-1.0)>0.1 THEN
   fbLog('There is a problem by the indentification of the holding process.');
   iErrorInfo := -499;
   // Only a warning 
END_IF;   

CalcControllerIn.Plant := KCTRL_Plant_PT1;
CalcControllerIn.Controller := KCTRL_Controller_PI;
CalcControllerIn.rGain := rIdentifiedK; // For the closed-loop control parameters use the approx. gain
CalcControllerIn.dDeadTime := tIdentifiedDeadTime;
CalcControllerIn.dT1 := LINT_TO_TIME(REAL_TO_LINT(rIdentifiedT1 * 1000.0 * 1000.0)); //convert from sec to usec;
IF (rPhasemargin) > 0.0 AND (rPhasemargin < 180.0) THEN
    CalcControllerIn.rPhasemargin := rPhasemargin;
ELSE
    CalcControllerIn.rPhasemargin := 70.0;// default value by berg
END_IF;

IF (rPhasemarginMin3dB) > 0.0 AND (rPhasemarginMin3dB < 180.0) THEN
    CalcControllerIn.rPhasemarginMin3dB := rPhasemarginMin3dB;
ELSE
    CalcControllerIn.rPhasemarginMin3dB := 62.0;// default value by berg
END_IF;

CalcControllerState := KCTRL_CalcController(InParam := CalcControllerIn, OutParam := CalcControllerOut);

IF(CalcControllerState <> KCTRL_CalcController_OK) THEN
   tmpstr := CONCAT(DebugPrefix, 'KCTRL_CalcController failed:',DINT_TO_STRING(CalcControllerOut.ErrorID));
   printtmp := Print(tmpstr);
   bError := TRUE;
   iErrorInfo := -407; 
END_IF;

IF rPlantAmp <> 0.0 THEN
   CalculatedParams.rControllerKR  := CalcControllerOut.rKR * rPlantAmp;
ELSE
   printtmp := Print('plant amplification factor should never be 0');
   CalculatedParams.rControllerKR  := CalcControllerOut.rKR;
END_IF;
CalculatedParams.rControllerW   := CalcControllerOut.rW;
CalculatedParams.tControllerTN  := CalcControllerOut.dTN;
// Use rPlantK = 1.0, because otherwise the internal set value for closed loop control
// does not agree with the real set value, the approximated value should nearly 1.0
CalculatedParams.rPlantK        := 1.0;
CalculatedParams.tPlantDeadTime := CalcControllerIn.dDeadTime;
CalculatedParams.tPlantT1       := CalcControllerIn.dT1;

IF(bDebugCalibration)THEN
   iTmpBecausePrintSucks := (iBestQuadraticErrorPos - 1)* LINT_TO_DINT(TIME_TO_LINT(CycleTime) / 1000);

   printtmp := Print('%sZFunction a0:%f', DebugPrefix, r_temp_A0);
   printtmp := Print('%sIdentified T1:%f',DebugPrefix, rIdentifiedT1);
   printtmp := Print('%sIdentified K:%f',DebugPrefix, rIdentifiedK);
   printtmp := Print('%sSelected ZFunction No %d; DeadTime: %dms',DebugPrefix, iBestQuadraticErrorPos, iTmpBecausePrintSucks);
   printtmp := Print('%scontroller kR:%f, W:%f',DebugPrefix, CalcControllerOut.rKR, CalcControllerOut.rW);
   
   (* output recorded in / output values and identified functions*)
   (* also contains data for calculated Z Functions *)
   file := KFILE_Open(Name:= CONCAT(DebugPrefix,'detail.txt'), Mode := KFILE_Mode_ReadWriteDelete);
   
   tmpstr := 'count;in;out';
   FOR i:= 1 TO cMaxShiftData DO
      tmpstr := CONCAT(tmpstr, ';zfunc', DINT_TO_STRING(i));
   END_FOR;
   tmpstr := CONCAT(tmpstr,';$N');
   
   writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
   //print in / out curve and identified functions
   FOR i:= 1 TO iPointCount -1 DO
      tmpstr := CONCAT(DINT_TO_STRING(i), ';', REAL_TO_STRING(OutArray[i]), ';', REAL_TO_STRING(InArray[i]));
      FOR j:= 1 TO MIN(cMaxShiftData, 15) DO//do not write more than 15 columns or Excel barfs
         IF (i+1 -j <1) THEN
            rTmpValueForDebug := 0.3;//ShiftData[j].DebugZOutArray[1];//do not access array out of bounds
         ELSE
            s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(j));
            rTmpValueForDebug := ShiftDataTmp.DebugZOutArray[i+1 -j]; //add shifting +1 because shift=1 -> no shifting takes place
         END_IF;
         tmpstr := CONCAT(tmpstr, ';', REAL_TO_STRING(rTmpValueForDebug));
      END_FOR;
      tmpstr := CONCAT(tmpstr,';$N');

      writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
   END_FOR;
   filestatus := KFILE_Close(Token := file.Token);
  
   
   (* save quadratic error to csv *)
   file := KFILE_Open(Name:= CONCAT(DebugPrefix,'error.txt'), Mode := KFILE_Mode_ReadWriteDelete);
   tmpstr := 'shiftcount;quadratic error$N';
   writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
   FOR i:=1 TO cMaxShiftData DO
      s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(i));
      tmpstr := CONCAT(DINT_TO_STRING(i), ';', REAL_TO_STRING(ShiftDataTmp.rQuadraticError), '$N');
      writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
   END_FOR;
   filestatus := KFILE_Close(Token := file.Token);
END_IF;

bValid := NOT bError;

@END_Body 

@END_Contents 
