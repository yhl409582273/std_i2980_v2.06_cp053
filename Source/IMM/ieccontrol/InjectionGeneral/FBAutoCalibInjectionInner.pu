(*
take one edge (falling / raising) and try to indentify the plant
then calculate the quadratic error between real plant and identified plant
also identify the dead time by shifting value to the left and using the
one with the smallest quadratic error

returns ideal controller params in CalculatedParams
print debug output to files when mDebugCalibration is set
*)

IMPORT_OVER_LISTFILE
 KCTRL_CalcController
, KFILE_Open
, KFILE_WriteString
, KFILE_Close
, KMEM_GetHandle
, KMEM_ArrayGet
, cCalibOK
, cMaxShiftData
, KCTRL_Ret_OK
, cCalibErrorParFailure
, cCalibErrorWrongGain
, cMaxHalfSize
, cCalibErrorWrongCoefficient
, KCTRL_Plant_IT2
, KCTRL_Controller_P
, KCTRL_CalcController_OK
, KFILE_Mode_ReadWriteDelete
, cCalibShiftData
, tyHalfArray
, tsCalculatedInjectData
, KCTRL_Ident
, KCTRL_Ident_Data
, KCTRL_Ident_Info
, KCTRL_Ident_Param
, KCTRL_ZFunction
, KCTRL_CalcController_InParam
, KCTRL_CalcController_OutParam
, KCTRL_CalcController_State
, KFILE_Status
, KFILE_Open_Data
, KCTRL_ZFunction_Data
, FBAutoCalibLog
, KMEM_CreateData
, KMEM_Status
, tsCalibShiftData

END_IMPORT

FUNCTION_BLOCK FBAutoCalibInjectionInner #DUMMY_EDIT_BLOCK

VAR_IN_OUT
 InArray : tyHalfArray (* Input of plant( jumping from 0.1 to 0.9) *);
 OutArray : tyHalfArray (* output of plant to be identified *);
END_VAR

VAR_OUTPUT
 CalculatedParams : tsCalculatedInjectData;
END_VAR

VAR_INPUT
 iPointCount : DINT;
 CycleTime : TIME;
 DebugPrefix : STRING(255);
 rPlantAmp : REAL (* amplification of plant *);
 iTimeStartPos : DINT (* Position after falling/raising edge *);
 iTimePosHalfJump : DINT (* time position, upper value for the identification process *);
 rMaxNoise : REAL (* Maximal noise in signal *);
 bFalling : BOOL (* TRUE <=> falling edge *);
END_VAR

VAR_OUTPUT
 dErrorInfo : DINT;
 bError : BOOL;
END_VAR

VAR_INPUT
 bDebugCalibration : BOOL;
 rPhasemargin : REAL;
END_VAR

SYSTEM_VAR
 sv_IdentInData : tyHalfArray;
 sv_IdentOutData : tyHalfArray;
END_VAR

VAR_TEMP
 iZCounter : DINT;
 i : DINT;
 lengthArray : DINT;
 j : DINT;
 iIdentCount : DINT;
 iMaxIndex : DINT;
END_VAR

VAR
 iUpperLimit : DINT;
 Ident : KCTRL_Ident;
 IdentData : KCTRL_Ident_Data;
 IdentInfo : KCTRL_Ident_Info;
 IdentParam : KCTRL_Ident_Param;
 ZFunction : KCTRL_ZFunction;
 CalcControllerIn : KCTRL_CalcController_InParam;
 CalcControllerOut : KCTRL_CalcController_OutParam;
 CalcControllerState : KCTRL_CalcController_State;
 rQuadraticError : REAL;
 rMinimumQuadraticError : REAL;
 iBestQuadraticErrorPos : DINT;
 filestatus : KFILE_Status;
 file : KFILE_Open_Data;
 writecount : DINT;
 tmpstr : STRING(255);
 rTmpZOut : REAL (* make tmp *);
 printtmp : DINT;
 tIdentifiedDeadTime : TIME;
 rIdentifiedT1 : REAL;
 rIdentifiedT2 : REAL;
 rTmpC1 : REAL;
 rTmpC2 : REAL;
 rTmpA0 : REAL;
 rTmpA1 : REAL;
 mWarned : BOOL (* warn only once *);
 iTmpBecausePrintSucks : DINT;
 rTmpValueForDebug : REAL;
 ZFuncData : KCTRL_ZFunction_Data;
 fbLog : FBAutoCalibLog;
 rIdentifiedK : REAL;
 ShiftData : KMEM_CreateData;
 s : KMEM_Status;
 ShiftDataTmp : tsCalibShiftData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//get handle to dynamic array
ShiftData := KMEM_GetHandle(cCalibShiftData);
IF ShiftData.Status <> KMEM_Status_OK THEN
   bError := TRUE;
   dErrorInfo := cCalibInvalidHandle;
   RETURN;
END_IF;

(* identify plant and calculate controller for it *)

rMinimumQuadraticError := 10.0**38;
bError := FALSE;
dErrorInfo := cCalibOK;
(* loop to calculate quadratic error between an
   approximation and the shifted recorded data 
 *)
FOR iIdentCount:= 1 TO cMaxShiftData DO
   IF ABS(OutArray[iTimeStartPos+iIdentCount-1]-InArray[iTimeStartPos-1]) > 1.5*rMaxNoise  THEN
      iUpperLimit := iIdentCount;
   END_IF;
END_FOR;
FOR iIdentCount:= 1 TO iUpperLimit DO //cMaxShiftData DO
   mWarned := FALSE;//only warn for ZFunction Error once per loop

   (* copy to SV array (Ident needs data in a SV) *)
   (* at the same time shift the out array (iIdentCount-1) times to the left *)
   j := 1;
   FOR i:= iTimeStartPos-1 TO iTimePosHalfJump DO
      // For a falling edge calculate the approximation with the "inverse"
      // data, take the same out data in every deadTime-step and shift setValue  
      IF bFalling THEN
         sv_IdentOutData[j] := 1.0 - OutArray[i]; 
         sv_IdentInData[j] := 1.0 - InArray[i-iIdentCount+1]; 
      ELSE
         sv_IdentOutData[j] := OutArray[i]; 
         sv_IdentInData[j] := InArray[i-iIdentCount+1];   
      END_IF;
      j := j+1;
   END_FOR;
   lengthArray:=j-1;

   (*parametrize Ident block*)
   // Identification with a PT1-Plant only to get the deadTime,
   // the first part of the jumps look like PT1, but perhaps with
   // negative gain or time 
   IdentParam.dCycleTime := CycleTime;
   IdentParam.uNumDegree := 0;
   IdentParam.uDenumDegree := 1;
   IdentParam.rWeightingFactor := 1.0;
   
   Ident.Par(dCycleTime := CycleTime, Param := IdentParam);
   IF(Ident.Par.parStatus <> KCTRL_Ret_OK) THEN
      printtmp := Print('Ident.Par failed');   
      dErrorInfo := cCalibErrorParFailure;
      bError := TRUE;
      RETURN;
   END_IF;
   
   Ident.Init();
      
   (* do offline anaysis for data *)
   (* in:  sv_IdentInData / ThirdStage *)
   (* out: sv_IdentOutData / ... *)
   IdentData.dCycleTime := CycleTime;
   IdentData.rPlantInput := @sv_IdentInData;
   IdentData.rPlantOutput := @sv_IdentOutData;
   IdentData.uIdentLength := DINT_TO_UDINT(lengthArray);//from 0 or 1??
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   Ident.Offline(IdentData := IdentData, ZFunction := ShiftDataTmp.ZFunctionData, Info := IdentInfo);
   //write back to dynamic array
   s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   
   (* simulate identified plant *)
   ZFunction.Par.Param := Ident.Offline.ZFunction;
   ZFunction.Par();
   IF(ZFunction.Par.parStatus <> KCTRL_Ret_OK) THEN
      printtmp := Print('zfunction.par failed');   
      dErrorInfo := cCalibErrorParFailure;
      bError := TRUE;
      RETURN;
   END_IF;
   
   rQuadraticError := 0.0;
   // Determine the gain of the plant
   ZFunction.Init(rX := 1.0);
   ZFunction.Calculate(bEnable := TRUE, rX := 1.0);
   rIdentifiedK := ZFunction.Calculate.rY; 
   IF rIdentifiedK = 0.0 THEN
      printtmp := Print('Calib failure: identified gain is zero');   
      dErrorInfo := cCalibErrorWrongGain;
      bError := TRUE;
      RETURN;
   END_IF;

   // Start the simulation at the shifted jump with the setValue befor the jump, 
   // the points befor the jumps have also this value  
   ZFunction.Init(rX := sv_IdentInData[1]/rIdentifiedK);
   ZFunction.Calculate(bEnable := TRUE, rX := sv_IdentInData[1]/rIdentifiedK);
   (* calculate quadratic error *)
   FOR iZCounter := 1 TO lengthArray DO
      (* if ZFunction is feeded instable parameters it can integrate until +-inf an crash then *)
      (* fixed in version 1.04 of ControlLib *)
      (* stop calling if we find out, that values are out of range *)
      (* remove when package fixed? *)
      IF sv_IdentInData[iZCounter] = sv_IdentInData[1] THEN
          rTmpZOut := sv_IdentInData[1];
      ELSE
         IF(ZFunction.Calculate.rY > -100000.0 AND ZFunction.Calculate.rY < 100000.0) THEN
           ZFunction.Calculate(bEnable := TRUE, rX := sv_IdentInData[iZCounter]);
           rTmpZOut := ZFunction.Calculate.rY;
         ELSE
            IF(NOT mWarned) THEN
               printtmp := Print('ZFunction Problem at pos %d',iZCounter);
            END_IF;
            mWarned := TRUE;
         END_IF;
      END_IF; 
      
      
      (* save ZFunction output for debugging / to see which one is really the best *)
      //get actual values, modify DebugZOutArray and write back to dynamic array
      s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
      ShiftDataTmp.DebugZOutArray[iZCounter] := rTmpZOut;
      s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount)); 
      
      rQuadraticError := rQuadraticError + EXPT(sv_IdentOutData[iZCounter] (*OutArray[iZCounter]*) - rTmpZOut,2);
   END_FOR;
         
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   ShiftDataTmp.rQuadraticError := rQuadraticError;
   s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount)); 
   (* check if best result so far *)
   IF( rQuadraticError < rMinimumQuadraticError) THEN
      rMinimumQuadraticError := rQuadraticError;
      iBestQuadraticErrorPos := iIdentCount;
   END_IF;
END_FOR;


(* use parameter set with best quadratic error *)
tIdentifiedDeadTime := MULTIME(CycleTime, iBestQuadraticErrorPos - 1);

// Calculate PT2 Approximation for this deadTime with all points
j := 1;
// start check index
IF (iPointCount <= cMaxHalfSize) THEN
   iMaxIndex := iPointCount;
ELSE
   iMaxIndex := cMaxHalfSize;
END_IF;
// end check index
IF iBestQuadraticErrorPos = 0 THEN
   printtmp := Print('Calib failure: detection of quality factor');
   dErrorInfo := cCalibErrorQualityCriterion; 
   bError := TRUE;
   RETURN;
ELSE    
   FOR i:= iBestQuadraticErrorPos TO iMaxIndex DO
      sv_IdentOutData[j] := OutArray[i]; 
      sv_IdentInData[j] := InArray[i-iBestQuadraticErrorPos+1]; 
      j := j+1;
   END_FOR;
   (*parametrize Ident block*)
   IdentParam.dCycleTime := CycleTime;
   IdentParam.uNumDegree := 1;
   IdentParam.uDenumDegree := 2;
   IdentParam.rWeightingFactor := 1.0;
    
   Ident.Par(dCycleTime := CycleTime, Param := IdentParam);
   IF(Ident.Par.parStatus <> KCTRL_Ret_OK) THEN
      printtmp := Print('Ident.Par failed');   
      dErrorInfo := cCalibErrorParFailure;
      bError := TRUE;
      RETURN;
   END_IF;
    
   Ident.Init();
        
    
   (* do offline anaysis for data *)
   (* in:  sv_IdentInData / ThirdStage *)
   (* out: sv_IdentOutData / ... *)
   IdentData.dCycleTime := CycleTime;
   IdentData.rPlantInput := @sv_IdentInData;
   IdentData.rPlantOutput := @sv_IdentOutData;
   IdentData.uIdentLength := DINT_TO_UDINT(j-1);//from 0 or 1??
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iBestQuadraticErrorPos));
   Ident.Offline(IdentData := IdentData, ZFunction := ShiftDataTmp.ZFunctionData, Info := IdentInfo);
   //write back to dynamic array
   s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iBestQuadraticErrorPos));
    
    
   (* Get denumerators *)
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iBestQuadraticErrorPos));
   rTmpA0 := ABS(ShiftDataTmp.ZFunctionData.DenumCoeffs[0]);
   rTmpA1 := ABS(ShiftDataTmp.ZFunctionData.DenumCoeffs[1]);
   
   IF (1.0 + rTmpA0 - rTmpA1) = 0.0 THEN
      printtmp := Print('Calib failure: wrong denumerators');   
      dErrorInfo := cCalibErrorWrongCoefficient;
      bError := TRUE;
      RETURN;
   END_IF;
   (* calculate temporary values for calculating times *)
   rTmpC1 := (rTmpA1 - 2.0 * rTmpA0) *  LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0      / (1.0 + rTmpA0 - rTmpA1);
   rTmpC2 := (rTmpA0                 * (LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0)**2) / (1.0 + rTmpA0 - rTmpA1);
    
   // Calculate approximation of PT2-Times T1 and T2 in such way 
   // that no overshooting is possible (T1,T2 not complex; D<=1)
   (* check for negative value in sqrt *)
   IF(rTmpC1**2 - 4.0 * rTmpC2 > 0.0) THEN
      rIdentifiedT1 := 0.5 * rTmpC1 + 0.5 * SQRT(rTmpC1**2 - 4.0 * rTmpC2);
      rIdentifiedT2 := 0.5 * rTmpC1 - 0.5 * SQRT(rTmpC1**2 - 4.0 * rTmpC2);
   ELSE
      rIdentifiedT1 := 0.5 * rTmpC1;
      rIdentifiedT2 := 0.5 * rTmpC1;
   END_IF;
    
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iBestQuadraticErrorPos));
   ZFuncData := ShiftDataTmp.ZFunctionData;
   ZFunction.Par.Param := ZFuncData;
   ZFunction.Par();
   IF(ZFunction.Par.parStatus <> KCTRL_Ret_OK) THEN
      printtmp := Print('zfunction.par failed');   
      dErrorInfo := cCalibErrorParFailure;
      bError := TRUE;
      RETURN;
   END_IF;
   ZFunction.Init(rX := 1.0);
   ZFunction.Calculate(bEnable := TRUE, rX := 1.0);
   rIdentifiedK := ZFunction.Calculate.rY;
   // The identified gain shoul nearly one
   IF ABS(rIdentifiedK-1.0)>0.1 THEN
      fbLog('There is a problem by the indentification of the holding process.');
      dErrorInfo := -499; 
   END_IF; 
    
   CalcControllerIn.Plant := KCTRL_Plant_IT2;
   CalcControllerIn.Controller := KCTRL_Controller_P;
   CalcControllerIn.rGain := rIdentifiedK;//must be in the near of 1.0
   CalcControllerIn.dDeadTime := tIdentifiedDeadTime;
   CalcControllerIn.dT1 := LINT_TO_TIME(REAL_TO_LINT(rIdentifiedT1 * 1000.0 * 1000.0)); //convert from sec to usec;
   CalcControllerIn.dT2 := LINT_TO_TIME(REAL_TO_LINT(rIdentifiedT2 * 1000.0 * 1000.0)); //convert from sec to usec;
   IF (rPhasemargin) > 0.0 AND (rPhasemargin < 180.0) THEN
      CalcControllerIn.rPhasemargin := rPhasemargin;
   ELSE
      CalcControllerIn.rPhasemargin := 70.0;// default value by berg
   END_IF;
    
   CalcControllerState := KCTRL_CalcController(InParam := CalcControllerIn, OutParam := CalcControllerOut);
    
   IF(CalcControllerState <> KCTRL_CalcController_OK) THEN
      tmpstr := CONCAT(DebugPrefix, 'KCTRL_CalcController failed:',DINT_TO_STRING(CalcControllerOut.ErrorID));
      dErrorInfo := CalcControllerOut.ErrorID;
      bError := FALSE;
      printtmp := Print(tmpstr);
      RETURN;
   END_IF;
    
   IF rPlantAmp <> 0.0 THEN
      CalculatedParams.rControllerKR  := CalcControllerOut.rKR * rPlantAmp;
   ELSE
      printtmp := Print('plant amplification factor should never be 0');
      CalculatedParams.rControllerKR  := CalcControllerOut.rKR;
   END_IF;
   CalculatedParams.rControllerW   := CalcControllerOut.rW;
    // The gain has to be 1.0, if you take the identifiedK the setValue for controling is wrong
   CalculatedParams.rPlantK        := 1.0;
   CalculatedParams.tPlantDeadTime := CalcControllerIn.dDeadTime;
   CalculatedParams.tPlantT1       := CalcControllerIn.dT1;
   CalculatedParams.tPlantT2       := CalcControllerIn.dT2;

   IF(bDebugCalibration)THEN
      iTmpBecausePrintSucks := (iBestQuadraticErrorPos - 1)* LINT_TO_DINT(TIME_TO_LINT(CycleTime) / 1000);

      printtmp := Print('%sZFunction a0:%f a1:%f', DebugPrefix, rTmpA0, rTmpA1);
      printtmp := Print('%sIdentified T1:%f, T2:%f',DebugPrefix, rIdentifiedT1, rIdentifiedT2);
      printtmp := Print('%sSelected ZFunction No %d = %dms',DebugPrefix, iBestQuadraticErrorPos, iTmpBecausePrintSucks);
      printtmp := Print('%scontroller kR:%f, W:%f',DebugPrefix, CalcControllerOut.rKR, CalcControllerOut.rW);
      printtmp := Print('%sIdentified gain:%f',DebugPrefix, rIdentifiedK);
   
      (* output recorded in / output values and identified functions*)
      (* also contains data for calculated Z Functions *)
      file := KFILE_Open(Name:= CONCAT(DebugPrefix,'detail.txt'), Mode := KFILE_Mode_ReadWriteDelete);
   
      tmpstr := 'count;in;out';
      FOR i:= 1 TO iUpperLimit DO //cMaxShiftData DO
         tmpstr := CONCAT(tmpstr, ';zfunc', DINT_TO_STRING(i));
      END_FOR;
      tmpstr := CONCAT(tmpstr,';$N');
   
      writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
      //print in / out curve and identified functions
      FOR i := 1 TO lengthArray DO
         tmpstr := CONCAT(DINT_TO_STRING(i), ';', REAL_TO_STRING(OutArray[iTimeStartPos-1+i-1]), ';', REAL_TO_STRING(InArray[iTimeStartPos-1+i-1]));
         FOR j:= 5 (*1*) TO MIN(iUpperLimit (*cMaxShiftData*),20)(* 15)*) DO//do not write more than 15 columns or Excel barfs
            s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(j));
            rTmpValueForDebug := ShiftDataTmp.DebugZOutArray[i]; //add shifting +1 because shift=1 -> no shifting takes place
            tmpstr := CONCAT(tmpstr, ';', REAL_TO_STRING(rTmpValueForDebug));
         END_FOR;
         tmpstr := CONCAT(tmpstr,';$N');
         writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
      END_FOR;
      filestatus := KFILE_Close(Token := file.Token);
     
      (* save quadratic error to csv *)
      file := KFILE_Open(Name:= CONCAT(DebugPrefix,'error.txt'), Mode := KFILE_Mode_ReadWriteDelete);
      tmpstr := 'shiftcount;quadratic error$N';
      writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
      FOR i:=1 TO iUpperLimit DO //cMaxShiftData DO
         s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(i));
         tmpstr := CONCAT(DINT_TO_STRING(i), ';', REAL_TO_STRING(ShiftDataTmp.rQuadraticError), '$N');
         writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
      END_FOR;
      filestatus := KFILE_Close(Token := file.Token);
   END_IF;
    
END_IF;
    



;#END_EDIT_BLOCK END_FUNCTION_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 114 @Pou 25 
@@@BEG_Comment@@@
take one edge (falling / raising) and try to indentify the plant
then calculate the quadratic error between real plant and identified plant
also identify the dead time by shifting value to the left and using the
one with the smallest quadratic error

returns ideal controller params in CalculatedParams
print debug output to files when mDebugCalibration is set
@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
6 
@Var @RT(20)KCTRL_CalcController @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)KFILE_Open @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(17)KFILE_WriteString @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)KFILE_Close @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)KMEM_GetHandle @RT(0) @T @T @DERIVED 0 @F @RT(40)KEBA_STANDARD_FUNCTION : KMEM_CreateData @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)KMEM_ArrayGet @RT(0) @T @T @DERIVED 0 @F @RT(36)KEBA_STANDARD_FUNCTION : KMEM_Status @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
12 
@Var @RT(8)cCalibOK @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)cMaxShiftData @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)19 @RT(94)how often to shift the signal to the left for identifying the plant( 1 time shifting = x msec) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)KCTRL_Ret_OK @RT(0) @T @T @DERIVED 0 @F @RT(9)KCTRL_Ret @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(21)cCalibErrorParFailure @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)112 @RT(14)Failure at par 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(20)cCalibErrorWrongGain @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)113 @RT(41)Gain is not possible => wrong calibration 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)cMaxHalfSize @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(4)4000 @RT(51)size of array which holds one  falling/raising edge 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(27)cCalibErrorWrongCoefficient @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)114 @RT(39)Wrong coefficients => wrong calibration 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)KCTRL_Plant_IT2 @RT(0) @T @T @DERIVED 0 @F @RT(15)KCTRL_PlantType @F 
@T 
@BEG_Attrib 
0 @RT(1)2 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)KCTRL_Controller_P @RT(0) @T @T @DERIVED 0 @F @RT(20)KCTRL_ControllerType @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(23)KCTRL_CalcController_OK @RT(0) @T @T @DERIVED 0 @F @RT(26)KCTRL_CalcController_State @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(26)KFILE_Mode_ReadWriteDelete @RT(0) @T @T @DERIVED 0 @F @RT(10)KFILE_Mode @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(102)opens for reading and writing, if file doesn't exist, it will be created, its contents will be deleted 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)cCalibShiftData @RT(0) @T @F @DT @RT(10)STRING(31) @RT(0) @T @T @STRING 0 @F @RT(2)31 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(11)'ShiftData' @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@FUNCTION_BLOCK @RT(25)FBAutoCalibInjectionInner @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
57 
@Var @RT(7)InArray @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tyHalfArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(40)Input of plant( jumping from 0.1 to 0.9) @RT(0) 
@END_Attrib 
1 2 @F @F @F @F 

@Var @RT(8)OutArray @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tyHalfArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(32)output of plant to be identified @RT(0) 
@END_Attrib 
1 2 @F @F @F @F 

@Var @RT(16)CalculatedParams @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tsCalculatedInjectData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(11)iPointCount @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)CycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(11)DebugPrefix @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)rPlantAmp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(22)amplification of plant @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)iTimeStartPos @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)Position after falling/raising edge @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)iTimePosHalfJump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(57)time position, upper value for the identification process @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)rMaxNoise @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(23)Maximal noise in signal @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)bFalling @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(21)TRUE <=> falling edge @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)dErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(17)bDebugCalibration @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)sv_IdentInData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tyHalfArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_IdentOutData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tyHalfArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(9)iZCounter @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(11)lengthArray @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)j @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(11)iIdentCount @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(9)iMaxIndex @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(11)iUpperLimit @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)Ident @RT(0) @T @T @DERIVED 0 @F @RT(11)KCTRL_Ident @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)IdentData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KCTRL_Ident_Data @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)IdentInfo @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KCTRL_Ident_Info @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)IdentParam @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)KCTRL_Ident_Param @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)ZFunction @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KCTRL_ZFunction @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)CalcControllerIn @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(28)KCTRL_CalcController_InParam @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)CalcControllerOut @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(29)KCTRL_CalcController_OutParam @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)CalcControllerState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(26)KCTRL_CalcController_State @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)rQuadraticError @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)rMinimumQuadraticError @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)iBestQuadraticErrorPos @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)filestatus @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)KFILE_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(4)file @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)KFILE_Open_Data @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)writecount @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)tmpstr @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)rTmpZOut @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(8)make tmp @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)printtmp @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)tIdentifiedDeadTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)rIdentifiedT1 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)rIdentifiedT2 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)rTmpC1 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)rTmpC2 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)rTmpA0 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)rTmpA1 @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)mWarned @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(14)warn only once @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)iTmpBecausePrintSucks @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)rTmpValueForDebug @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)ZFuncData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)KCTRL_ZFunction_Data @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)fbLog @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)FBAutoCalibLog @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rIdentifiedK @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)rPhasemargin @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)ShiftData @RT(0) @T @T @DERIVED 0 @F @RT(15)KMEM_CreateData @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)s @RT(0) @T @T @DERIVED 0 @F @RT(11)KMEM_Status @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)ShiftDataTmp @RT(0) @T @T @DERIVED 0 @F @RT(16)tsCalibShiftData @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(326)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//get handle to dynamic array
ShiftData := KMEM_GetHandle(cCalibShiftData);
IF ShiftData.Status <> KMEM_Status_OK THEN
   bError := TRUE;
   dErrorInfo := cCalibInvalidHandle;
   RETURN;
END_IF;

(* identify plant and calculate controller for it *)

rMinimumQuadraticError := 10.0**38;
bError := FALSE;
dErrorInfo := cCalibOK;
(* loop to calculate quadratic error between an
   approximation and the shifted recorded data 
 *)
FOR iIdentCount:= 1 TO cMaxShiftData DO
   IF ABS(OutArray[iTimeStartPos+iIdentCount-1]-InArray[iTimeStartPos-1]) > 1.5*rMaxNoise  THEN
      iUpperLimit := iIdentCount;
   END_IF;
END_FOR;
FOR iIdentCount:= 1 TO iUpperLimit DO //cMaxShiftData DO
   mWarned := FALSE;//only warn for ZFunction Error once per loop

   (* copy to SV array (Ident needs data in a SV) *)
   (* at the same time shift the out array (iIdentCount-1) times to the left *)
   j := 1;
   FOR i:= iTimeStartPos-1 TO iTimePosHalfJump DO
      // For a falling edge calculate the approximation with the "inverse"
      // data, take the same out data in every deadTime-step and shift setValue  
      IF bFalling THEN
         sv_IdentOutData[j] := 1.0 - OutArray[i]; 
         sv_IdentInData[j] := 1.0 - InArray[i-iIdentCount+1]; 
      ELSE
         sv_IdentOutData[j] := OutArray[i]; 
         sv_IdentInData[j] := InArray[i-iIdentCount+1];   
      END_IF;
      j := j+1;
   END_FOR;
   lengthArray:=j-1;

   (*parametrize Ident block*)
   // Identification with a PT1-Plant only to get the deadTime,
   // the first part of the jumps look like PT1, but perhaps with
   // negative gain or time 
   IdentParam.dCycleTime := CycleTime;
   IdentParam.uNumDegree := 0;
   IdentParam.uDenumDegree := 1;
   IdentParam.rWeightingFactor := 1.0;
   
   Ident.Par(dCycleTime := CycleTime, Param := IdentParam);
   IF(Ident.Par.parStatus <> KCTRL_Ret_OK) THEN
      printtmp := Print('Ident.Par failed');   
      dErrorInfo := cCalibErrorParFailure;
      bError := TRUE;
      RETURN;
   END_IF;
   
   Ident.Init();
      
   (* do offline anaysis for data *)
   (* in:  sv_IdentInData / ThirdStage *)
   (* out: sv_IdentOutData / ... *)
   IdentData.dCycleTime := CycleTime;
   IdentData.rPlantInput := @sv_IdentInData;
   IdentData.rPlantOutput := @sv_IdentOutData;
   IdentData.uIdentLength := DINT_TO_UDINT(lengthArray);//from 0 or 1??
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   Ident.Offline(IdentData := IdentData, ZFunction := ShiftDataTmp.ZFunctionData, Info := IdentInfo);
   //write back to dynamic array
   s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   
   (* simulate identified plant *)
   ZFunction.Par.Param := Ident.Offline.ZFunction;
   ZFunction.Par();
   IF(ZFunction.Par.parStatus <> KCTRL_Ret_OK) THEN
      printtmp := Print('zfunction.par failed');   
      dErrorInfo := cCalibErrorParFailure;
      bError := TRUE;
      RETURN;
   END_IF;
   
   rQuadraticError := 0.0;
   // Determine the gain of the plant
   ZFunction.Init(rX := 1.0);
   ZFunction.Calculate(bEnable := TRUE, rX := 1.0);
   rIdentifiedK := ZFunction.Calculate.rY; 
   IF rIdentifiedK = 0.0 THEN
      printtmp := Print('Calib failure: identified gain is zero');   
      dErrorInfo := cCalibErrorWrongGain;
      bError := TRUE;
      RETURN;
   END_IF;

   // Start the simulation at the shifted jump with the setValue befor the jump, 
   // the points befor the jumps have also this value  
   ZFunction.Init(rX := sv_IdentInData[1]/rIdentifiedK);
   ZFunction.Calculate(bEnable := TRUE, rX := sv_IdentInData[1]/rIdentifiedK);
   (* calculate quadratic error *)
   FOR iZCounter := 1 TO lengthArray DO
      (* if ZFunction is feeded instable parameters it can integrate until +-inf an crash then *)
      (* fixed in version 1.04 of ControlLib *)
      (* stop calling if we find out, that values are out of range *)
      (* remove when package fixed? *)
      IF sv_IdentInData[iZCounter] = sv_IdentInData[1] THEN
          rTmpZOut := sv_IdentInData[1];
      ELSE
         IF(ZFunction.Calculate.rY > -100000.0 AND ZFunction.Calculate.rY < 100000.0) THEN
           ZFunction.Calculate(bEnable := TRUE, rX := sv_IdentInData[iZCounter]);
           rTmpZOut := ZFunction.Calculate.rY;
         ELSE
            IF(NOT mWarned) THEN
               printtmp := Print('ZFunction Problem at pos %d',iZCounter);
            END_IF;
            mWarned := TRUE;
         END_IF;
      END_IF; 
      
      
      (* save ZFunction output for debugging / to see which one is really the best *)
      //get actual values, modify DebugZOutArray and write back to dynamic array
      s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
      ShiftDataTmp.DebugZOutArray[iZCounter] := rTmpZOut;
      s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount)); 
      
      rQuadraticError := rQuadraticError + EXPT(sv_IdentOutData[iZCounter] (*OutArray[iZCounter]*) - rTmpZOut,2);
   END_FOR;
         
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount));
   ShiftDataTmp.rQuadraticError := rQuadraticError;
   s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iIdentCount)); 
   (* check if best result so far *)
   IF( rQuadraticError < rMinimumQuadraticError) THEN
      rMinimumQuadraticError := rQuadraticError;
      iBestQuadraticErrorPos := iIdentCount;
   END_IF;
END_FOR;


(* use parameter set with best quadratic error *)
tIdentifiedDeadTime := MULTIME(CycleTime, iBestQuadraticErrorPos - 1);

// Calculate PT2 Approximation for this deadTime with all points
j := 1;
// start check index
IF (iPointCount <= cMaxHalfSize) THEN
   iMaxIndex := iPointCount;
ELSE
   iMaxIndex := cMaxHalfSize;
END_IF;
// end check index
IF iBestQuadraticErrorPos = 0 THEN
   printtmp := Print('Calib failure: detection of quality factor');
   dErrorInfo := cCalibErrorQualityCriterion; 
   bError := TRUE;
   RETURN;
ELSE    
   FOR i:= iBestQuadraticErrorPos TO iMaxIndex DO
      sv_IdentOutData[j] := OutArray[i]; 
      sv_IdentInData[j] := InArray[i-iBestQuadraticErrorPos+1]; 
      j := j+1;
   END_FOR;
   (*parametrize Ident block*)
   IdentParam.dCycleTime := CycleTime;
   IdentParam.uNumDegree := 1;
   IdentParam.uDenumDegree := 2;
   IdentParam.rWeightingFactor := 1.0;
    
   Ident.Par(dCycleTime := CycleTime, Param := IdentParam);
   IF(Ident.Par.parStatus <> KCTRL_Ret_OK) THEN
      printtmp := Print('Ident.Par failed');   
      dErrorInfo := cCalibErrorParFailure;
      bError := TRUE;
      RETURN;
   END_IF;
    
   Ident.Init();
        
    
   (* do offline anaysis for data *)
   (* in:  sv_IdentInData / ThirdStage *)
   (* out: sv_IdentOutData / ... *)
   IdentData.dCycleTime := CycleTime;
   IdentData.rPlantInput := @sv_IdentInData;
   IdentData.rPlantOutput := @sv_IdentOutData;
   IdentData.uIdentLength := DINT_TO_UDINT(j-1);//from 0 or 1??
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iBestQuadraticErrorPos));
   Ident.Offline(IdentData := IdentData, ZFunction := ShiftDataTmp.ZFunctionData, Info := IdentInfo);
   //write back to dynamic array
   s := KMEM_ArraySet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iBestQuadraticErrorPos));
    
    
   (* Get denumerators *)
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iBestQuadraticErrorPos));
   rTmpA0 := ABS(ShiftDataTmp.ZFunctionData.DenumCoeffs[0]);
   rTmpA1 := ABS(ShiftDataTmp.ZFunctionData.DenumCoeffs[1]);
   
   IF (1.0 + rTmpA0 - rTmpA1) = 0.0 THEN
      printtmp := Print('Calib failure: wrong denumerators');   
      dErrorInfo := cCalibErrorWrongCoefficient;
      bError := TRUE;
      RETURN;
   END_IF;
   (* calculate temporary values for calculating times *)
   rTmpC1 := (rTmpA1 - 2.0 * rTmpA0) *  LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0      / (1.0 + rTmpA0 - rTmpA1);
   rTmpC2 := (rTmpA0                 * (LINT_TO_REAL(TIME_TO_LINT(CycleTime))/1000.0 / 1000.0)**2) / (1.0 + rTmpA0 - rTmpA1);
    
   // Calculate approximation of PT2-Times T1 and T2 in such way 
   // that no overshooting is possible (T1,T2 not complex; D<=1)
   (* check for negative value in sqrt *)
   IF(rTmpC1**2 - 4.0 * rTmpC2 > 0.0) THEN
      rIdentifiedT1 := 0.5 * rTmpC1 + 0.5 * SQRT(rTmpC1**2 - 4.0 * rTmpC2);
      rIdentifiedT2 := 0.5 * rTmpC1 - 0.5 * SQRT(rTmpC1**2 - 4.0 * rTmpC2);
   ELSE
      rIdentifiedT1 := 0.5 * rTmpC1;
      rIdentifiedT2 := 0.5 * rTmpC1;
   END_IF;
    
   s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(iBestQuadraticErrorPos));
   ZFuncData := ShiftDataTmp.ZFunctionData;
   ZFunction.Par.Param := ZFuncData;
   ZFunction.Par();
   IF(ZFunction.Par.parStatus <> KCTRL_Ret_OK) THEN
      printtmp := Print('zfunction.par failed');   
      dErrorInfo := cCalibErrorParFailure;
      bError := TRUE;
      RETURN;
   END_IF;
   ZFunction.Init(rX := 1.0);
   ZFunction.Calculate(bEnable := TRUE, rX := 1.0);
   rIdentifiedK := ZFunction.Calculate.rY;
   // The identified gain shoul nearly one
   IF ABS(rIdentifiedK-1.0)>0.1 THEN
      fbLog('There is a problem by the indentification of the holding process.');
      dErrorInfo := -499; 
   END_IF; 
    
   CalcControllerIn.Plant := KCTRL_Plant_IT2;
   CalcControllerIn.Controller := KCTRL_Controller_P;
   CalcControllerIn.rGain := rIdentifiedK;//must be in the near of 1.0
   CalcControllerIn.dDeadTime := tIdentifiedDeadTime;
   CalcControllerIn.dT1 := LINT_TO_TIME(REAL_TO_LINT(rIdentifiedT1 * 1000.0 * 1000.0)); //convert from sec to usec;
   CalcControllerIn.dT2 := LINT_TO_TIME(REAL_TO_LINT(rIdentifiedT2 * 1000.0 * 1000.0)); //convert from sec to usec;
   IF (rPhasemargin) > 0.0 AND (rPhasemargin < 180.0) THEN
      CalcControllerIn.rPhasemargin := rPhasemargin;
   ELSE
      CalcControllerIn.rPhasemargin := 70.0;// default value by berg
   END_IF;
    
   CalcControllerState := KCTRL_CalcController(InParam := CalcControllerIn, OutParam := CalcControllerOut);
    
   IF(CalcControllerState <> KCTRL_CalcController_OK) THEN
      tmpstr := CONCAT(DebugPrefix, 'KCTRL_CalcController failed:',DINT_TO_STRING(CalcControllerOut.ErrorID));
      dErrorInfo := CalcControllerOut.ErrorID;
      bError := FALSE;
      printtmp := Print(tmpstr);
      RETURN;
   END_IF;
    
   IF rPlantAmp <> 0.0 THEN
      CalculatedParams.rControllerKR  := CalcControllerOut.rKR * rPlantAmp;
   ELSE
      printtmp := Print('plant amplification factor should never be 0');
      CalculatedParams.rControllerKR  := CalcControllerOut.rKR;
   END_IF;
   CalculatedParams.rControllerW   := CalcControllerOut.rW;
    // The gain has to be 1.0, if you take the identifiedK the setValue for controling is wrong
   CalculatedParams.rPlantK        := 1.0;
   CalculatedParams.tPlantDeadTime := CalcControllerIn.dDeadTime;
   CalculatedParams.tPlantT1       := CalcControllerIn.dT1;
   CalculatedParams.tPlantT2       := CalcControllerIn.dT2;

   IF(bDebugCalibration)THEN
      iTmpBecausePrintSucks := (iBestQuadraticErrorPos - 1)* LINT_TO_DINT(TIME_TO_LINT(CycleTime) / 1000);

      printtmp := Print('%sZFunction a0:%f a1:%f', DebugPrefix, rTmpA0, rTmpA1);
      printtmp := Print('%sIdentified T1:%f, T2:%f',DebugPrefix, rIdentifiedT1, rIdentifiedT2);
      printtmp := Print('%sSelected ZFunction No %d = %dms',DebugPrefix, iBestQuadraticErrorPos, iTmpBecausePrintSucks);
      printtmp := Print('%scontroller kR:%f, W:%f',DebugPrefix, CalcControllerOut.rKR, CalcControllerOut.rW);
      printtmp := Print('%sIdentified gain:%f',DebugPrefix, rIdentifiedK);
   
      (* output recorded in / output values and identified functions*)
      (* also contains data for calculated Z Functions *)
      file := KFILE_Open(Name:= CONCAT(DebugPrefix,'detail.txt'), Mode := KFILE_Mode_ReadWriteDelete);
   
      tmpstr := 'count;in;out';
      FOR i:= 1 TO iUpperLimit DO //cMaxShiftData DO
         tmpstr := CONCAT(tmpstr, ';zfunc', DINT_TO_STRING(i));
      END_FOR;
      tmpstr := CONCAT(tmpstr,';$N');
   
      writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
      //print in / out curve and identified functions
      FOR i := 1 TO lengthArray DO
         tmpstr := CONCAT(DINT_TO_STRING(i), ';', REAL_TO_STRING(OutArray[iTimeStartPos-1+i-1]), ';', REAL_TO_STRING(InArray[iTimeStartPos-1+i-1]));
         FOR j:= 5 (*1*) TO MIN(iUpperLimit (*cMaxShiftData*),20)(* 15)*) DO//do not write more than 15 columns or Excel barfs
            s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(j));
            rTmpValueForDebug := ShiftDataTmp.DebugZOutArray[i]; //add shifting +1 because shift=1 -> no shifting takes place
            tmpstr := CONCAT(tmpstr, ';', REAL_TO_STRING(rTmpValueForDebug));
         END_FOR;
         tmpstr := CONCAT(tmpstr,';$N');
         writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
      END_FOR;
      filestatus := KFILE_Close(Token := file.Token);
     
      (* save quadratic error to csv *)
      file := KFILE_Open(Name:= CONCAT(DebugPrefix,'error.txt'), Mode := KFILE_Mode_ReadWriteDelete);
      tmpstr := 'shiftcount;quadratic error$N';
      writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
      FOR i:=1 TO iUpperLimit DO //cMaxShiftData DO
         s := KMEM_ArrayGet(ShiftData.Handle, ShiftDataTmp, DINT_TO_UDINT(i));
         tmpstr := CONCAT(DINT_TO_STRING(i), ';', REAL_TO_STRING(ShiftDataTmp.rQuadraticError), '$N');
         writecount := KFILE_WriteString(Token := file.Token, Length := 0, Buffer := tmpstr);
      END_FOR;
      filestatus := KFILE_Close(Token := file.Token);
   END_IF;
    
END_IF;
    


@END_Body 

@END_Contents 
