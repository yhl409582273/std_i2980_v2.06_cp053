(*
Mold height simulation:

Mold height adjustment stroke ist 0 .. 500 impulses.

With closed mold it is possible to adjust mold height forward until position 90.
Then mold adjustment will stop.

When the mold height is < 40 it is not possible to close the mold anymore.
It will stop moving at 5% of the mold stroke.

Between Pos 40 and 90 it is possible to adjust the clamp force, and the mold will still close.

*)

IMPORT_OVER_LISTFILE
 GET_TASK_INTERVAL
, GET_SYNC_REFTO
, KSYS_Status_OK
, FBEPForceDI
, FBEPForceAI
, tnICMMode
, tsRequiredPumps
, FBGetSimulationSource
, FBEPUnForceAI
, ABForceDigital
, KSYS_Status
, tOptionId
, FBGetRequiredPumps

END_IMPORT

ALGORITHM_BLOCK ABMldSimu #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_bSimulate : BOOL;
 sv_ForceMoldClosed : BOOL;
 sv_bInitStart : BOOL;
 ai_Position_stat : BOOL;
 ai_ClampPress_stat : BOOL;
 sv_iMoldHeightPosActImpulses : DINT;
 ai_MoldPressure1_stat : BOOL;
 ai_MoldPressure2_stat : BOOL;
 sv_bTwoButtonOperation : BOOL (* TRUE: two startbuttons are linked; SV is set in OperationMode - FU *);
 sv_bInitDone : BOOL;
END_VAR

SYSTEM_OBJECT
 TaskSim : TASK;
 PU_Task_13 : TASK;
 TaskAnalog : TASK;
END_OBJECT

VAR
 fbEPForceDI : FBEPForceDI;
 fbEPForceAIPos : FBEPForceAI;
 fbEPForceAIPresClamp : FBEPForceAI;
 fbEPForceAIPresMold1 : FBEPForceAI;
 fbEPForceAIPresMold2 : FBEPForceAI;
 mpbDIMoldClosed : REFTO BOOL;
 mbDIMoldClosedLinked : BOOL;
 mprMoldPosRaw : REFTO REAL;
 mbAIMoldTransLinked : BOOL;
 mpbDOMoldOpen : REFTO BOOL;
 mpbDOMoldClose : REFTO BOOL;
 mbDOMoldOpenLinked : BOOL;
 mbDOMoldCloseLinked : BOOL;
 mprClampPressRaw : REFTO REAL;
 mbAIClampPressLinked : BOOL;
 mpbDOLock : REFTO BOOL;
 mbDOLockLinked : BOOL;
 mpbDOUnlock : REFTO BOOL;
 mbDOUnlockLinked : BOOL;
 mprMoldPress1Raw : REFTO REAL;
 mbAIMoldPress1Linked : BOOL;
 mprMoldPress2Raw : REFTO REAL;
 mbAIMoldPress2Linked : BOOL;
 mpbButtonMoldClose : REFTO BOOL;
 mpbVentingActive : REFTO BOOL;
 mpbCoiningActive : REFTO BOOL;
 mprAOVelocity : REFTO REAL;
 mpICMMode : REFTO tnICMMode;
 mbICMLinked : BOOL;
 mpPumpsFwd : REFTO tsRequiredPumps;
 mpPumpsBwd : REFTO tsRequiredPumps;
 mprVelocityFwd : REFTO REAL;
 mprVelocityBwd : REFTO REAL;
 fbGetSimulationSource : FBGetSimulationSource;
 mb2Platen : BOOL;
 mpbAutoMoldAdjustActive : REFTO BOOL;
END_VAR

POSTUPDATE_ALGORITHM pStart ON PU_Task_13 WITH sv_bSimulate,sv_bInitStart

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bSimulate THEN
   START_PROCESS_ALGORITHM(paSimulate);
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paSimulate ON TaskAnalog


VAR
 rMldDivision : REAL := 0.03;
 fbEPUnForceAI : FBEPUnForceAI;
 rMoldPosRaw : REAL;
 rMoldClosedTreshold : REAL := 0.0001;
 iMoldHeightCloseTreshold : DINT := 40 (* minimum mold height in impulses, so mold can close *);
 rMoldHeightCloseStopPos : REAL := 0.5 (* pos where mold will stop to close when mold height is too small *);
 rMoldTimeFor10V : REAL := 3.0;
 rClampPressRaw : REAL;
 rCycleTime : REAL;
 dCycleTime : TIME;
 bButtonsUnforced : BOOL;
 abForceDIClosed : ABForceDigital;
 rLimitMoldAdjust2Platen : REAL := 1.0;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP INIT:
aInit (P);
END_STEP


(* steps *)
STEP SIM:
aSimulate (N);
END_STEP

STEP STOP:
aStopSimu (P);
END_STEP


(* transitions *)
TRANSITION SimRequired (* SimRequired *) FROM INIT TO SIM :=  #BEGIN_EDIT_BLOCK
sv_bSimulate
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION StpSimRequired (* StpSimRequired *) FROM SIM TO STOP :=  #BEGIN_EDIT_BLOCK
NOT sv_bSimulate
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Return (* Return *) FROM STOP TO SIM :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION aInit: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

dCycleTime :=  GET_TASK_INTERVAL();
rCycleTime := (LINT_TO_REAL(TIME_TO_LINT(dCycleTime))) / 1000000.0;

fbEPForceAIPos.Range := 10.0; 
fbEPForceAIPresClamp.Range := 10.0; 
fbEPForceAIPresMold1.Range := 10.0; 
fbEPForceAIPresMold2.Range := 10.0; 

IF mbAIMoldTransLinked THEN
   ai_Position_stat := FALSE;
   fbEPForceAIPos(sSysVar := 'Mold1.ai_Position',Value := 10.0);
END_IF;

IF mbAIClampPressLinked THEN
   ai_ClampPress_stat := FALSE;
   fbEPForceAIPresClamp(sSysVar := 'Mold1.ai_ClampPress',Value := 0.0);   
END_IF;

IF mbAIMoldPress1Linked THEN
   ai_MoldPressure1_stat := FALSE;
   fbEPForceAIPresMold1(sSysVar := 'Mold1.ai_MoldPressure1',Value := 0.0);
END_IF; 
IF mbAIMoldPress2Linked THEN
   ai_MoldPressure2_stat := FALSE;
   fbEPForceAIPresMold2(sSysVar := 'Mold1.ai_MoldPressure2',Value := 0.0);
END_IF;

IF mbDIMoldClosedLinked THEN
   abForceDIClosed.aInit('Mold1.di_MoldClosed');
END_IF;


;#END_EDIT_BLOCK END_ACTION (*aInit*)
ACTION aSimulate: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bTwoButtonOperation THEN
   IF mpbButtonMoldClose^ THEN
      bButtonsUnforced := FALSE;
      fbEPForceDI(sSysVar := 'OperationMode1.di_Button1CycleStart',Value := TRUE);
      fbEPForceDI(sSysVar := 'OperationMode1.di_Button2CycleStart',Value := TRUE);
   ELSIF NOT bButtonsUnforced THEN
      fbEPForceDI(sSysVar := 'OperationMode1.di_Button1CycleStart',Value := FALSE);
      fbEPForceDI(sSysVar := 'OperationMode1.di_Button2CycleStart',Value := FALSE);
      bButtonsUnforced := TRUE;
   END_IF;
END_IF;

rMldDivision := 1.0  / rMoldTimeFor10V * rCycleTime;

rMoldPosRaw := mprMoldPosRaw^;
IF mbDOMoldOpenLinked AND mpbDOMoldOpen^ THEN
   //ICM linked
   IF mbICMLinked THEN
      IF mpbVentingActive^ OR mpbCoiningActive^ THEN
         rMoldPosRaw := mprMoldPosRaw^ + MUL(rMldDivision,mprAOVelocity^ / 10.0); 
      ELSE     
         rMoldPosRaw := mprMoldPosRaw^ + MUL(rMldDivision,mprVelocityBwd^); 
      END_IF; 
   ELSE  
      rMoldPosRaw := mprMoldPosRaw^ + MUL(rMldDivision,mprVelocityBwd^); 
   END_IF;     
                        
   IF mbDIMoldClosedLinked THEN
      abForceDIClosed.aSetForceValue(FALSE);
   END_IF;
ELSIF mbDOMoldCloseLinked AND mpbDOMoldClose^ THEN
   //when actual mold height position is to small, mold can not close
   IF rMoldPosRaw < rMoldHeightCloseStopPos AND sv_iMoldHeightPosActImpulses < iMoldHeightCloseTreshold THEN          
      RETURN;
   END_IF;
   
   //ICM linked
   IF mbICMLinked THEN
      IF mpbVentingActive^ OR mpbCoiningActive^ THEN
         rMoldPosRaw := mprMoldPosRaw^ - MUL(rMldDivision,mprAOVelocity^ / 10.0); 
      ELSE     
         rMoldPosRaw := mprMoldPosRaw^ - MUL(rMldDivision,mprVelocityFwd^); 
      END_IF; 
   ELSE  
      rMoldPosRaw := mprMoldPosRaw^ - MUL(rMldDivision,mprVelocityFwd^); 
   END_IF;
   
   //2 platen machine:
   //limit transducer voltage when mold close during auto mold adjust is active
   //so that mold can detect a standstill (a different mold height)
   IF mb2Platen AND mpbAutoMoldAdjustActive^ THEN
      rMoldPosRaw := MAX(rMoldPosRaw, rLimitMoldAdjust2Platen);
   END_IF;
   
   IF rMoldPosRaw <= rMoldClosedTreshold AND mbDIMoldClosedLinked THEN
      abForceDIClosed.aSetForceValue(TRUE);
   END_IF;   
END_IF;
fbEPForceAIPos(sSysVar := 'Mold1.ai_Position',Value := MAX(MIN(rMoldPosRaw, 10.0), 0.0));    


IF mbDOLockLinked AND mpbDOLock^ THEN
   IF mbAIClampPressLinked THEN
      rClampPressRaw := mprClampPressRaw^ + 0.024;
   END_IF;     
END_IF;

IF mbDOUnlockLinked AND mpbDOUnlock^ THEN
   IF mbAIClampPressLinked THEN
      rClampPressRaw := rClampPressRaw - 0.024;
   END_IF;   
END_IF;

IF mbAIClampPressLinked THEN
   fbEPForceAIPresClamp(sSysVar := 'Mold1.ai_ClampPress',Value := MAX(MIN(rClampPressRaw, 10.0), 0.0));
END_IF;


;#END_EDIT_BLOCK END_ACTION (*aSimulate*)
ACTION aStopSimu: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbAIMoldTransLinked THEN
   fbEPUnForceAI(sSysVar := 'Mold1.ai_Position');
END_IF;
IF mbDIMoldClosedLinked THEN
   abForceDIClosed.aUnforce();
END_IF;
STOP_PROCESS_ALGORITHM();

;#END_EDIT_BLOCK END_ACTION (*aStopSimu*)
(* end sfc-code *)


END_ALGORITHM

POSTUPDATE_ALGORITHM pDIMoldClosed ON TaskSim WITH sv_ForceMoldClosed

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bSimulate AND mbDIMoldClosedLinked THEN
   fbEPForceDI(sSysVar := 'Mold1.di_MoldClosed', Value := sv_ForceMoldClosed); 
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paInit ON TaskSim AUTOSTART


VAR
 Status : KSYS_Status;
 pOptions : REFTO tOptionId;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mpbDIMoldClosed:= GET_SYNC_REFTO('Mold1.di_MoldClosed', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbDIMoldClosedLinked := TRUE;
END_IF;

mpbDOMoldOpen:= GET_SYNC_REFTO('Mold1.do_Open', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbDOMoldOpenLinked := TRUE;
END_IF;

mpbDOMoldClose:= GET_SYNC_REFTO('Mold1.do_Close', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbDOMoldCloseLinked := TRUE;
END_IF;

mprMoldPosRaw:= GET_SYNC_REFTO('Mold1.ai_Position', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbAIMoldTransLinked := TRUE;
END_IF;

mprClampPressRaw:= GET_SYNC_REFTO('Mold1.ai_ClampPress', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbAIClampPressLinked := TRUE;
END_IF;
  
mpbDOLock := GET_SYNC_REFTO('Mold1.do_Lock', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbDOLockLinked := TRUE;
END_IF;

mpbDOUnlock := GET_SYNC_REFTO('Mold1.do_Unlock', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbDOUnlockLinked := TRUE;
END_IF;

mprMoldPress1Raw:= GET_SYNC_REFTO('Mold1.ai_MoldPressure1', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbAIMoldPress1Linked := TRUE;
END_IF;
mprMoldPress2Raw:= GET_SYNC_REFTO('Mold1.ai_MoldPressure2', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbAIMoldPress2Linked := TRUE;
END_IF;

mpbButtonMoldClose := GET_SYNC_REFTO('Mold1.di_ButtonFwd', T#0s, Status);
IF Status <> KSYS_Status_OK THEN
   mpbButtonMoldClose := GET_SYNC_REFTO('Mold1.sv_bButtonFwd', T#0s, Status);
END_IF;

mpICMMode := GET_SYNC_REFTO('Mold1.sv_ICMMode', T#0s, Status); 
IF Status = KSYS_Status_OK THEN
   mbICMLinked := TRUE;
END_IF;

IF mbICMLinked THEN
   mpbVentingActive := GET_SYNC_REFTO('Mold1.sv_bVentingActive', T#0s, Status);
   mpbCoiningActive := GET_SYNC_REFTO('Mold1.sv_bCoiningActive', T#0s, Status);
   mprAOVelocity :=  GET_SYNC_REFTO('Mold1.sv_rVelOutputICM', T#0s, Status);     
END_IF;

pOptions := GET_SYNC_REFTO('Mold1.sv_Options', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mb2Platen := (pOptions^ AND cSubOptionMold2Platen) = cSubOptionMold2Platen;
END_IF;

IF mb2Platen THEN
   mpbAutoMoldAdjustActive := GET_SYNC_REFTO('MoldHeightAdjust1.sv_bAutoMoldHeightAdjustActive', T#0s, Status);
END_IF;

STOP_PROCESS_ALGORITHM();



;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aGetSimulationSource

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbGetSimulationSource(pRequiredPumps := mpPumpsFwd,
                      prVelocity => mprVelocityFwd);

fbGetSimulationSource(pRequiredPumps := mpPumpsBwd,
                      prVelocity => mprVelocityBwd);



;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pInitDone ON TaskSim WITH sv_bInitDone


VAR
 fbGetRequiredPumps : FBGetRequiredPumps;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//get required pumps for fwd and bwd movement
fbGetRequiredPumps.DeviceId.CompId := cCompMold;
fbGetRequiredPumps.DeviceId.IndexId := 1;

fbGetRequiredPumps(MoveDir := cMoveFwd,
                   MoveId := cMoveFwd);
mpPumpsFwd := fbGetRequiredPumps.pPumps;

fbGetRequiredPumps(MoveDir := cMoveBwd,
                   MoveId := cMoveBwd);
mpPumpsBwd := fbGetRequiredPumps.pPumps;

aGetSimulationSource();




;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pRequiredPumps ON TaskSim WITH mpPumpsFwd^.RequiredPumps,mpPumpsBwd^.RequiredPumps

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

aGetSimulationSource();


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 114 @Pou 25 
@@@BEG_Comment@@@
Mold height simulation:

Mold height adjustment stroke ist 0 .. 500 impulses.

With closed mold it is possible to adjust mold height forward until position 90.
Then mold adjustment will stop.

When the mold height is < 40 it is not possible to close the mold anymore.
It will stop moving at 5% of the mold stroke.

Between Pos 40 and 90 it is possible to adjust the clamp force, and the mold will still close.

@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
2 
@Var @RT(17)GET_TASK_INTERVAL @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)GET_SYNC_REFTO @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
1 
@Var @RT(14)KSYS_Status_OK @RT(0) @T @T @DERIVED 0 @F @RT(11)KSYS_Status @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(9)ABMldSimu @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
49 
@Var @RT(12)sv_bSimulate @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_ForceMoldClosed @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bInitStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)ai_Position_stat @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)ai_ClampPress_stat @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(28)sv_iMoldHeightPosActImpulses @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(7)TaskSim @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)PU_Task_13 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(11)fbEPForceDI @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)FBEPForceDI @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)fbEPForceAIPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)FBEPForceAI @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)fbEPForceAIPresClamp @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)FBEPForceAI @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)fbEPForceAIPresMold1 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)FBEPForceAI @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)fbEPForceAIPresMold2 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)FBEPForceAI @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)mpbDIMoldClosed @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)mbDIMoldClosedLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mprMoldPosRaw @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mbAIMoldTransLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mpbDOMoldOpen @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mpbDOMoldClose @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mbDOMoldOpenLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mbDOMoldCloseLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mprClampPressRaw @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)mbAIClampPressLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)mpbDOLock @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mbDOLockLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)mpbDOUnlock @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mbDOUnlockLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)TaskAnalog @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(16)mprMoldPress1Raw @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)mbAIMoldPress1Linked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mprMoldPress2Raw @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)mbAIMoldPress2Linked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)ai_MoldPressure1_stat @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)ai_MoldPressure2_stat @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)mpbButtonMoldClose @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)sv_bTwoButtonOperation @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(66)TRUE: two startbuttons are linked; SV is set in OperationMode - FU @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)mpbVentingActive @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)mpbCoiningActive @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)mprAOVelocity @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)mpICMMode @RT(0) @T @T @REFTO 0 @T @DT @RT(9)tnICMMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)mbICMLinked @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)mpPumpsFwd @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(15)tsRequiredPumps @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)mpPumpsBwd @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(15)tsRequiredPumps @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)sv_bInitDone @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(14)mprVelocityFwd @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mprVelocityBwd @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)fbGetSimulationSource @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)FBGetSimulationSource @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)mb2Platen @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(23)mpbAutoMoldAdjustActive @RT(0) @T @T @REFTO 0 @T @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

7 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(6)pStart @STRUCTURED_TEXT 
@RT(0) @RT(26)sv_bSimulate,sv_bInitStart @RT(10)PU_Task_13 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(10)paSimulate @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(10)TaskAnalog @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
13 
@Var @RT(12)rMldDivision @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(4)0.03 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)fbEPUnForceAI @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)FBEPUnForceAI @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)rMoldPosRaw @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)rMoldClosedTreshold @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(6)0.0001 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(24)iMoldHeightCloseTreshold @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(2)40 @RT(50)minimum mold height in impulses, so mold can close @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(23)rMoldHeightCloseStopPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)0.5 @RT(63)pos where mold will stop to close when mold height is too small @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)rMoldTimeFor10V @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)3.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)rClampPressRaw @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)rCycleTime @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)dCycleTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)bButtonsUnforced @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)abForceDIClosed @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)ABForceDigital @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(23)rLimitMoldAdjust2Platen @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(3)1.0 @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(13)pDIMoldClosed @STRUCTURED_TEXT 
@RT(0) @RT(18)sv_ForceMoldClosed @RT(7)TaskSim @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(6)paInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(7)TaskSim @T @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(6)Status @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSYS_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)pOptions @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @F @RT(9)tOptionId @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(20)aGetSimulationSource @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(9)pInitDone @STRUCTURED_TEXT 
@RT(0) @RT(12)sv_bInitDone @RT(7)TaskSim @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(18)fbGetRequiredPumps @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)FBGetRequiredPumps @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(14)pRequiredPumps @STRUCTURED_TEXT 
@RT(0) @RT(51)mpPumpsFwd^.RequiredPumps,mpPumpsBwd^.RequiredPumps @RT(7)TaskSim @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Body 
@TL(9)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bSimulate THEN
   START_PROCESS_ALGORITHM(paSimulate);
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
4 4 4 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 3 
@Step @RT(4)INIT @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(5)aInit @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(11)SimRequired @F @T @F @F @T @T @TL(2)
sv_bSimulate

@RT(11)SimRequired @F 
@Loop @RT(4)loop @F 2 
@StepSeq @RT(4)sseq @F 3 
@Step @RT(3)SIM @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(9)aSimulate @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(14)StpSimRequired @F @T @F @F @T @T @TL(2)
NOT sv_bSimulate

@RT(14)StpSimRequired @F 
@Step @RT(4)STOP @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(9)aStopSimu @F @F @RT(1)P @RT(0) @F @F @F @F 


@Trans @RT(6)Return @F @T @T @T @T @T @TL(2)
TRUE

@RT(6)Return @F 

@END_SfcData 
@SaActions 3 
@SaText @RT(5)aInit 1 @TL(37)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

dCycleTime :=  GET_TASK_INTERVAL();
rCycleTime := (LINT_TO_REAL(TIME_TO_LINT(dCycleTime))) / 1000000.0;

fbEPForceAIPos.Range := 10.0; 
fbEPForceAIPresClamp.Range := 10.0; 
fbEPForceAIPresMold1.Range := 10.0; 
fbEPForceAIPresMold2.Range := 10.0; 

IF mbAIMoldTransLinked THEN
   ai_Position_stat := FALSE;
   fbEPForceAIPos(sSysVar := 'Mold1.ai_Position',Value := 10.0);
END_IF;

IF mbAIClampPressLinked THEN
   ai_ClampPress_stat := FALSE;
   fbEPForceAIPresClamp(sSysVar := 'Mold1.ai_ClampPress',Value := 0.0);   
END_IF;

IF mbAIMoldPress1Linked THEN
   ai_MoldPressure1_stat := FALSE;
   fbEPForceAIPresMold1(sSysVar := 'Mold1.ai_MoldPressure1',Value := 0.0);
END_IF; 
IF mbAIMoldPress2Linked THEN
   ai_MoldPressure2_stat := FALSE;
   fbEPForceAIPresMold2(sSysVar := 'Mold1.ai_MoldPressure2',Value := 0.0);
END_IF;

IF mbDIMoldClosedLinked THEN
   abForceDIClosed.aInit('Mold1.di_MoldClosed');
END_IF;



@SaText @RT(9)aSimulate 1 @TL(83)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bTwoButtonOperation THEN
   IF mpbButtonMoldClose^ THEN
      bButtonsUnforced := FALSE;
      fbEPForceDI(sSysVar := 'OperationMode1.di_Button1CycleStart',Value := TRUE);
      fbEPForceDI(sSysVar := 'OperationMode1.di_Button2CycleStart',Value := TRUE);
   ELSIF NOT bButtonsUnforced THEN
      fbEPForceDI(sSysVar := 'OperationMode1.di_Button1CycleStart',Value := FALSE);
      fbEPForceDI(sSysVar := 'OperationMode1.di_Button2CycleStart',Value := FALSE);
      bButtonsUnforced := TRUE;
   END_IF;
END_IF;

rMldDivision := 1.0  / rMoldTimeFor10V * rCycleTime;

rMoldPosRaw := mprMoldPosRaw^;
IF mbDOMoldOpenLinked AND mpbDOMoldOpen^ THEN
   //ICM linked
   IF mbICMLinked THEN
      IF mpbVentingActive^ OR mpbCoiningActive^ THEN
         rMoldPosRaw := mprMoldPosRaw^ + MUL(rMldDivision,mprAOVelocity^ / 10.0); 
      ELSE     
         rMoldPosRaw := mprMoldPosRaw^ + MUL(rMldDivision,mprVelocityBwd^); 
      END_IF; 
   ELSE  
      rMoldPosRaw := mprMoldPosRaw^ + MUL(rMldDivision,mprVelocityBwd^); 
   END_IF;     
                        
   IF mbDIMoldClosedLinked THEN
      abForceDIClosed.aSetForceValue(FALSE);
   END_IF;
ELSIF mbDOMoldCloseLinked AND mpbDOMoldClose^ THEN
   //when actual mold height position is to small, mold can not close
   IF rMoldPosRaw < rMoldHeightCloseStopPos AND sv_iMoldHeightPosActImpulses < iMoldHeightCloseTreshold THEN          
      RETURN;
   END_IF;
   
   //ICM linked
   IF mbICMLinked THEN
      IF mpbVentingActive^ OR mpbCoiningActive^ THEN
         rMoldPosRaw := mprMoldPosRaw^ - MUL(rMldDivision,mprAOVelocity^ / 10.0); 
      ELSE     
         rMoldPosRaw := mprMoldPosRaw^ - MUL(rMldDivision,mprVelocityFwd^); 
      END_IF; 
   ELSE  
      rMoldPosRaw := mprMoldPosRaw^ - MUL(rMldDivision,mprVelocityFwd^); 
   END_IF;
   
   //2 platen machine:
   //limit transducer voltage when mold close during auto mold adjust is active
   //so that mold can detect a standstill (a different mold height)
   IF mb2Platen AND mpbAutoMoldAdjustActive^ THEN
      rMoldPosRaw := MAX(rMoldPosRaw, rLimitMoldAdjust2Platen);
   END_IF;
   
   IF rMoldPosRaw <= rMoldClosedTreshold AND mbDIMoldClosedLinked THEN
      abForceDIClosed.aSetForceValue(TRUE);
   END_IF;   
END_IF;
fbEPForceAIPos(sSysVar := 'Mold1.ai_Position',Value := MAX(MIN(rMoldPosRaw, 10.0), 0.0));    


IF mbDOLockLinked AND mpbDOLock^ THEN
   IF mbAIClampPressLinked THEN
      rClampPressRaw := mprClampPressRaw^ + 0.024;
   END_IF;     
END_IF;

IF mbDOUnlockLinked AND mpbDOUnlock^ THEN
   IF mbAIClampPressLinked THEN
      rClampPressRaw := rClampPressRaw - 0.024;
   END_IF;   
END_IF;

IF mbAIClampPressLinked THEN
   fbEPForceAIPresClamp(sSysVar := 'Mold1.ai_ClampPress',Value := MAX(MIN(rClampPressRaw, 10.0), 0.0));
END_IF;



@SaText @RT(9)aStopSimu 1 @TL(13)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF mbAIMoldTransLinked THEN
   fbEPUnForceAI(sSysVar := 'Mold1.ai_Position');
END_IF;
IF mbDIMoldClosedLinked THEN
   abForceDIClosed.aUnforce();
END_IF;
STOP_PROCESS_ALGORITHM();


@SaTrans 0 
@SaExits 0 
@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(9)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bSimulate AND mbDIMoldClosedLinked THEN
   fbEPForceDI(sSysVar := 'Mold1.di_MoldClosed', Value := sv_ForceMoldClosed); 
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(77)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

mpbDIMoldClosed:= GET_SYNC_REFTO('Mold1.di_MoldClosed', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbDIMoldClosedLinked := TRUE;
END_IF;

mpbDOMoldOpen:= GET_SYNC_REFTO('Mold1.do_Open', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbDOMoldOpenLinked := TRUE;
END_IF;

mpbDOMoldClose:= GET_SYNC_REFTO('Mold1.do_Close', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbDOMoldCloseLinked := TRUE;
END_IF;

mprMoldPosRaw:= GET_SYNC_REFTO('Mold1.ai_Position', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbAIMoldTransLinked := TRUE;
END_IF;

mprClampPressRaw:= GET_SYNC_REFTO('Mold1.ai_ClampPress', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbAIClampPressLinked := TRUE;
END_IF;
  
mpbDOLock := GET_SYNC_REFTO('Mold1.do_Lock', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbDOLockLinked := TRUE;
END_IF;

mpbDOUnlock := GET_SYNC_REFTO('Mold1.do_Unlock', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbDOUnlockLinked := TRUE;
END_IF;

mprMoldPress1Raw:= GET_SYNC_REFTO('Mold1.ai_MoldPressure1', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbAIMoldPress1Linked := TRUE;
END_IF;
mprMoldPress2Raw:= GET_SYNC_REFTO('Mold1.ai_MoldPressure2', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mbAIMoldPress2Linked := TRUE;
END_IF;

mpbButtonMoldClose := GET_SYNC_REFTO('Mold1.di_ButtonFwd', T#0s, Status);
IF Status <> KSYS_Status_OK THEN
   mpbButtonMoldClose := GET_SYNC_REFTO('Mold1.sv_bButtonFwd', T#0s, Status);
END_IF;

mpICMMode := GET_SYNC_REFTO('Mold1.sv_ICMMode', T#0s, Status); 
IF Status = KSYS_Status_OK THEN
   mbICMLinked := TRUE;
END_IF;

IF mbICMLinked THEN
   mpbVentingActive := GET_SYNC_REFTO('Mold1.sv_bVentingActive', T#0s, Status);
   mpbCoiningActive := GET_SYNC_REFTO('Mold1.sv_bCoiningActive', T#0s, Status);
   mprAOVelocity :=  GET_SYNC_REFTO('Mold1.sv_rVelOutputICM', T#0s, Status);     
END_IF;

pOptions := GET_SYNC_REFTO('Mold1.sv_Options', T#0s, Status);
IF Status = KSYS_Status_OK THEN
   mb2Platen := (pOptions^ AND cSubOptionMold2Platen) = cSubOptionMold2Platen;
END_IF;

IF mb2Platen THEN
   mpbAutoMoldAdjustActive := GET_SYNC_REFTO('MoldHeightAdjust1.sv_bAutoMoldHeightAdjustActive', T#0s, Status);
END_IF;

STOP_PROCESS_ALGORITHM();


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(12)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

fbGetSimulationSource(pRequiredPumps := mpPumpsFwd,
                      prVelocity => mprVelocityFwd);

fbGetSimulationSource(pRequiredPumps := mpPumpsBwd,
                      prVelocity => mprVelocityBwd);


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(21)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//get required pumps for fwd and bwd movement
fbGetRequiredPumps.DeviceId.CompId := cCompMold;
fbGetRequiredPumps.DeviceId.IndexId := 1;

fbGetRequiredPumps(MoveDir := cMoveFwd,
                   MoveId := cMoveFwd);
mpPumpsFwd := fbGetRequiredPumps.pPumps;

fbGetRequiredPumps(MoveDir := cMoveBwd,
                   MoveId := cMoveBwd);
mpPumpsBwd := fbGetRequiredPumps.pPumps;

aGetSimulationSource();



@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

aGetSimulationSource();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
