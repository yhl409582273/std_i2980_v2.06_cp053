(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

Nozzle backward movement.
*)

IMPORT_OVER_LISTFILE
 WRITE_SVREAL_DIRECT
, WRITE_SV_DIRECT
, GET_MY_FU_NAME
, KSWO_AddVariable
, cLockGroupMotor
, cLockGroupSafetyGateNozzle
, cMoveBwd
, nActive
, nInactive
, nSetup
, nPositionDependent
, nLimitSwitchDependent
, nMoveTimeDependent
, tnCalibState_Error
, nManual
, nHalfAutomatic
, tsMoveData
, tsVelPre
, KAPPL_VisProfile
, tnOperationMode
, tsDeviceId
, KCTRL_Lintab_Point
, tsMinOutput
, tsSetTimes
, tsActTimes
, tnMovementMode
, KAPPL_LintabData
, tsCalibMovement
, tsMoveCtrl
, ABProfileMovement
, ABConstMovement
, ABConstCalib
, ABLintabApply
, ABStepOutput
, ABMovementRegister
, FBSetMovementState
, KSWO_Status

END_IMPORT

ALGORITHM_BLOCK ABMoveBwd #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_MoveBwdNozzle : tsMoveData;
 sv_bTransducerAvailable : BOOL;
 sv_rNozzlePosition : REAL;
 sv_rPressure : REAL;
 sv_rVelocity : REAL;
 sv_iActiveStage : DINT;
 sv_ConstBwd : tsVelPre;
 sv_ConstBwdSetup : tsVelPre;
 sv_NozzleBwdProfVis : KAPPL_VisProfile;
 sv_OperationMode : tnOperationMode;
 ai_Position : REAL;
 sv_DeviceId : tsDeviceId;
 sv_dStandStillDetectTime : TIME (* time for standstill detection *);
 sv_rMaxVoltageDiff : REAL (* max. voltage difference to detect stand still *);
 sv_TmpLintabPoint : KCTRL_Lintab_Point;
 sv_bDoTransducerCalib : BOOL;
 sv_bOutputActive : BOOL (* Output is active *);
 sv_bPreOutputReady : BOOL (* PreOutput is ready *);
 sv_rNozzleStroke : REAL;
 sv_bTransducerError : BOOL;
 sv_MinOutputBwd : tsMinOutput (* minimum output of nozzle profile *);
 sv_dMoveBwdTimeSet : TIME (* time of nozzle bwd movement in manual mode *);
 sv_NozzleBwdTimesSet : tsSetTimes;
 sv_NozzleBwdTimesAct : tsActTimes;
 di_LimitSwitchBwd : BOOL (* nozzle bwd limit switch *);
 sv_MovementMode : tnMovementMode (* Nozzle Movement with Limitswitch or with position measurement *);
 sv_bInitStart : BOOL;
 sv_rVelocityAbs : REAL;
 sv_rPressureAbs : REAL;
 sv_LintabOutBwdP : KAPPL_LintabData;
 sv_LintabOutBwdV : KAPPL_LintabData;
 sv_rMaxSpeedBwd : REAL;
 sv_bNozzleBwd : BOOL;
 sv_CalibState : tsCalibMovement;
 sv_dCalculatedDurationBwd : TIME (* Calculated duration for nozzle bwd *);
 sv_bFwdTimeReached : BOOL (* nozzle fwd time reached (for time dependent nozzle control) (must be FastRetain: cyclical change in AutoCycle) *);
 sv_bBwdTimeReached : BOOL (* nozzle bwd time reached (for time dependent nozzle control) (must be FastRetain: cyclical change in AutoCycle) *);
 sv_bMoveIdent : BOOL;
 sv_rIdentPosition : REAL;
 sv_rIdentStopRamp : REAL;
 sv_dSetDelayTimeOffBwd : TIME;
 sv_rSmoothFactor : REAL;
 sv_bODCCombinedMoveActive : BOOL;
END_VAR

SYSTEM_OBJECT
 TaskSlow : TASK;
 TaskAnalog : TASK;
 PU_Task_7 : TASK;
 erNozzleNotBwd : ALARM;
END_OBJECT

VAR_EXTERNAL
 g_MoveCtrl : tsMoveCtrl;
END_VAR

VAR
 abNozzleBwdProfile : ABProfileMovement;
 abNozzleBwdConst : ABConstMovement;
 abNozzleBwdConstSetup : ABConstMovement;
 abNozzleBwdCalib : ABConstCalib;
 mbLimitSwBwdLinked : BOOL;
 abLintabApplyVel : ABLintabApply;
 abLintabApplyPres : ABLintabApply;
 abNozzleBwdStep : ABStepOutput;
END_VAR

ALGORITHM aRegister


VAR
 abMovementRegister : ABMovementRegister;
 sDeviceName : STRING(40) := 'Nozzle';
 sIconPath : STRING(255);
 sCompletePath : STRING(255);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// movement registration
sv_MoveBwdNozzle.LockGroups[1] := cLockGroupMotor;
sv_MoveBwdNozzle.LockGroups[2] := cLockGroupSafetyGateNozzle;

sv_MoveBwdNozzle.pdStartDelaySet := @sv_NozzleBwdTimesSet.dSetDelayTime;
sv_MoveBwdNozzle.pdStartDelayAct := @sv_NozzleBwdTimesAct.dActDelayTime;
sv_MoveBwdNozzle.pdActiveTimeAct := @sv_NozzleBwdTimesAct.dActMoveTime;
sv_MoveBwdNozzle.pdTimeLimit     := @sv_NozzleBwdTimesSet.dMaxMoveTime;
sv_MoveBwdNozzle.pdCalculatedDuration := @sv_dCalculatedDurationBwd;
sv_MoveBwdNozzle.Alarm.AlarmId := erNozzleNotBwd;
sv_MoveBwdNozzle.Alarm.SubId[1] := sv_DeviceId.CompId;
sv_MoveBwdNozzle.Alarm.SubId[2] := sv_DeviceId.IndexId;

sv_MoveBwdNozzle.pbPosReached := @sv_bNozzleBwd;
sIconPath := "\hmi\images\movNozzleBwd.gif";
sCompletePath := CONCAT(sDeviceName,(DINT_TO_STRING(sv_DeviceId.IndexId)),sIconPath);
sv_MoveBwdNozzle.sIconPath := sCompletePath;

abMovementRegister.aRegister(@sv_MoveBwdNozzle);


mbLimitSwBwdLinked := IS_LINKED(di_LimitSwitchBwd);


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aInit

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdProfile.aInit(pProfile := @sv_NozzleBwdProfVis,
                         MoveDir := sv_MoveBwdNozzle.MoveDir,
                         pdCalcedDuration := @sv_dCalculatedDurationBwd,
                         prCalcDurationStartPosition := @sv_NozzleBwdProfVis.Profile.Points[1].rStartPos);

abNozzleBwdConstSetup.aInit(pConst := @sv_ConstBwdSetup,
                            MoveId := sv_MoveBwdNozzle.MoveDir);

abNozzleBwdCalib.aInit(pConst := @sv_ConstBwdSetup,
                       MoveId := sv_MoveBwdNozzle.MoveDir);

abNozzleBwdConst.aInit(pConst := @sv_ConstBwd,
                       MoveId := sv_MoveBwdNozzle.MoveId);

abLintabApplyPres.aInit(pLintab := @sv_LintabOutBwdP);

abLintabApplyVel.aInit(pLintab := @sv_LintabOutBwdV);

abNozzleBwdStep.aInit(pConst := @sv_ConstBwdSetup,
                      MoveId := cMoveBwd,
                      prMaxSpeed := @sv_rMaxSpeedBwd);



;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pMinOutputChanged ON PU_Task_7 WITH sv_MinOutputBwd,sv_bInitStart

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//copy minoutput to bwd const movement
sv_ConstBwd.Velocity.rMinOutput := sv_MinOutputBwd.rVelocity;
sv_ConstBwd.Pressure.rMinOutput := sv_MinOutputBwd.rPressure;

//copy minoutput to bwd movment in setup mode
sv_ConstBwdSetup.Velocity.rMinOutput := sv_MinOutputBwd.rVelocity;
sv_ConstBwdSetup.Pressure.rMinOutput := sv_MinOutputBwd.rPressure;

//copy minoutput to bwd profile
sv_NozzleBwdProfVis.rMinOutputVel := sv_MinOutputBwd.rVelocity;
sv_NozzleBwdProfVis.rMinOutputPress := sv_MinOutputBwd.rPressure;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aRun


VAR_INPUT
 bStop : BOOL (* Stop movement, e.g. button has been released *);
END_VAR

VAR_OUTPUT
 bReady : BOOL (* Backward finished *);
END_VAR

VAR_TEMP
 bNozzlePosInvalid : BOOL;
 b : BOOL;
END_VAR

VAR
 fbSetMovementState : FBSetMovementState;
 dummy : DINT;
 bError : BOOL;
 iErrorInfo : DINT;
 rActPos : REAL (* set calculated "actual position" if  movement should not stop *);
 bDirection : BOOL (* direction of profile, True ascending *);
 rHalfPos : REAL (* Half position of last profile step *);
 iNoOfPoints : UDINT;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP START:
AStart (P);
END_STEP

ACTION AStart: #BEGIN_EDIT_BLOCK
bReady := FALSE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := g_MoveCtrl.pData^.MoveDir,
                   State    := nActive);

//reset fwd time reached
sv_bFwdTimeReached := FALSE;

;#END_EDIT_BLOCK END_ACTION (*AStart*)

(* steps *)
STEP S_CheckOpMode:
END_STEP

STEP S_CheckIfCalib:
END_STEP

STEP S_SetupMove:
AResetConstSetupBlock (P);
aRunConstSetup (N);
END_STEP

STEP S_CalibActivated:
AResetCalibBlock (P);
ATransducerCalib (N);
ACheckCalibError (N);
END_STEP

STEP S_MoveIdent:
AResetIdentBlock (P);
AStepOutput (N);
END_STEP

STEP S_CheckMoveMode:
END_STEP

STEP S_CheckTransducer:
END_STEP

STEP S_ProfileMove:
AResetProfileBlock (P);
aSetActProfile (N);
aRunProfile (N);
END_STEP

STEP S_ConstMove:
AResetConstBlock (P);
aRunConst (N);
END_STEP

STEP S_ConstTime:
AReset (P);
aRunConstTime (N);
ASetBwdTimeReached (N);
END_STEP

STEP S_Ready:
AReady (P);
END_STEP

ACTION AReady: #BEGIN_EDIT_BLOCK
bReady := TRUE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := g_MoveCtrl.pData^.MoveDir,
                   State    := nInactive);

;#END_EDIT_BLOCK END_ACTION (*AReady*)

(* transitions *)
GO_ON_TRANSITION TStart (* TStart *) FROM START TO S_CheckOpMode :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TSetupMode (* TSetupMode *) FROM S_CheckOpMode TO S_CheckIfCalib :=  #BEGIN_EDIT_BLOCK
sv_OperationMode = nSetup
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNotCalib (* TNotCalib *) FROM S_CheckIfCalib TO S_SetupMove :=  #BEGIN_EDIT_BLOCK
(NOT sv_bDoTransducerCalib OR
NOT sv_bTransducerAvailable) AND
NOT sv_bMoveIdent
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TSetupReady (* TSetupReady *) FROM S_SetupMove TO S_Ready :=  #BEGIN_EDIT_BLOCK
NOT abNozzleBwdConstSetup.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TCalib (* TCalib *) FROM S_CheckIfCalib TO S_CalibActivated :=  #BEGIN_EDIT_BLOCK
sv_bDoTransducerCalib AND
sv_bTransducerAvailable
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TCalibReady (* TCalibReady *) FROM S_CalibActivated TO S_Ready :=  #BEGIN_EDIT_BLOCK
NOT abNozzleBwdCalib.aRun.bActive OR bError
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TMoveIdentActivated (* TMoveIdentActivated *) FROM S_CheckIfCalib TO S_MoveIdent :=  #BEGIN_EDIT_BLOCK
sv_bMoveIdent
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveIdentReady (* TMoveIdentReady *) FROM S_MoveIdent TO S_Ready :=  #BEGIN_EDIT_BLOCK
NOT abNozzleBwdStep.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNotSetup (* TNotSetup *) FROM S_CheckOpMode TO S_CheckMoveMode :=  #BEGIN_EDIT_BLOCK
sv_OperationMode <> nSetup
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TPositionMode (* TPositionMode *) FROM S_CheckMoveMode TO S_CheckTransducer :=  #BEGIN_EDIT_BLOCK
sv_MovementMode = nPositionDependent
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TTransducer (* TTransducer *) FROM S_CheckTransducer TO S_ProfileMove :=  #BEGIN_EDIT_BLOCK
sv_bTransducerAvailable
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TProfileReady (* TProfileReady *) FROM S_ProfileMove TO S_Ready :=  #BEGIN_EDIT_BLOCK
NOT abNozzleBwdProfile.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TNoTransducer (* TNoTransducer *) FROM S_CheckTransducer TO S_Ready :=  #BEGIN_EDIT_BLOCK
NOT sv_bTransducerAvailable
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TLimitSwitch (* TLimitSwitch *) FROM S_CheckMoveMode TO S_ConstMove :=  #BEGIN_EDIT_BLOCK
sv_MovementMode = nLimitSwitchDependent AND
mbLimitSwBwdLinked
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TConstReady (* TConstReady *) FROM S_ConstMove TO S_Ready :=  #BEGIN_EDIT_BLOCK
NOT abNozzleBwdConst.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TOtherModes (* TOtherModes *) FROM S_CheckMoveMode TO S_ConstTime :=  #BEGIN_EDIT_BLOCK
sv_MovementMode = nMoveTimeDependent OR
(sv_MovementMode = nLimitSwitchDependent AND NOT mbLimitSwBwdLinked)
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TConstTimeReady (* TConstTimeReady *) FROM S_ConstTime TO S_Ready :=  #BEGIN_EDIT_BLOCK
NOT abNozzleBwdConst.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TReady (* TReady *) FROM S_Ready TO START :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION AResetCalibBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bError := FALSE;
abNozzleBwdCalib.aRun(bStart := FALSE,
                      LintabPoint := sv_TmpLintabPoint);
IF abNozzleBwdCalib.aRun.bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   bError := TRUE;
   dummy := Print("Calib Error: Reset calib block failed"); 
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AResetCalibBlock*)
ACTION AResetConstSetupBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdConstSetup.aRun(bStart := FALSE);

;#END_EDIT_BLOCK END_ACTION (*AResetConstSetupBlock*)
ACTION AResetProfileBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdProfile.aRun(bStart := FALSE);

iNoOfPoints := sv_NozzleBwdProfVis.Profile.iNoOfPoints + 1;
bDirection := sv_NozzleBwdProfVis.Profile.Points[1].rStartPos < sv_NozzleBwdProfVis.Profile.Points[iNoOfPoints].rStartPos;



;#END_EDIT_BLOCK END_ACTION (*AResetProfileBlock*)
ACTION AResetConstBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdConst.aRun(bStart := FALSE);

;#END_EDIT_BLOCK END_ACTION (*AResetConstBlock*)
ACTION ACheckCalibError: #BEGIN_EDIT_BLOCK
IF bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   dummy := Print("Calib Error: %i", iErrorInfo);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckCalibError*)
ACTION aSetActProfile: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

rActPos := sv_rNozzlePosition;
// In manual mode do backward until button is not pressed, but use profile-movement
// set input of actual position in profile movement maximal to the value,
// where maximum of last step will be reached
IF sv_OperationMode = nManual AND (NOT sv_bODCCombinedMoveActive) THEN
    rHalfPos := (sv_NozzleBwdProfVis.Profile.Points[(iNoOfPoints -1)].rStartPos +                   
                 sv_NozzleBwdProfVis.Profile.Points[iNoOfPoints].rStartPos) / 2.0 ;
    IF (bDirection AND rActPos > rHalfPos) OR (NOT bDirection AND rActPos < rHalfPos) THEN
       rActPos := rHalfPos;
    END_IF;
END_IF;


;#END_EDIT_BLOCK END_ACTION (*aSetActProfile*)
ACTION AReset: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdConst.aRun(bStart := FALSE);

IF (sv_OperationMode >= nHalfAutomatic) THEN
   //set move time
   abNozzleBwdConst.aSetMoveTime(dSetMoveTime := sv_dMoveBwdTimeSet);
END_IF;



;#END_EDIT_BLOCK END_ACTION (*AReset*)
ACTION ASetBwdTimeReached: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

sv_bBwdTimeReached := (sv_NozzleBwdTimesAct.dActMoveTime >= sv_dMoveBwdTimeSet)

;#END_EDIT_BLOCK END_ACTION (*ASetBwdTimeReached*)
ACTION AResetIdentBlock: #BEGIN_EDIT_BLOCK
abNozzleBwdStep.aRun(bStart := FALSE);


;#END_EDIT_BLOCK END_ACTION (*AResetIdentBlock*)
ACTION ATransducerCalib: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdCalib.aRun(bStop := bStop OR sv_bTransducerError,
                      bStart := TRUE,
                      rActVoltage := ai_Position,
                      rMaxVoltageDiff := sv_rMaxVoltageDiff,
                      dStandStillDetectTime := sv_dStandStillDetectTime,
                      LintabPoint := sv_TmpLintabPoint,
                      rSetValue := sv_rNozzleStroke,
                      dDelayTimeOn := sv_NozzleBwdTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_NozzleBwdTimesSet.dSetDelayTimeValve,
                      bActive => sv_bOutputActive,
                      rOutputPre => sv_rPressureAbs,
                      rOutputVel => sv_rVelocityAbs,
                      bPreOutputReached => sv_bPreOutputReady,
                      iErrorInfo => iErrorInfo);
sv_bDoTransducerCalib := NOT (abNozzleBwdCalib.aRun.bPointDetected);
bError := abNozzleBwdCalib.aRun.bError OR bError;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*ATransducerCalib*)
ACTION AStepOutput: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdStep.aRun(bUsePosDetect := sv_rIdentPosition <> 0.0,
                     rPositionDown := (sv_rNozzlePosition + sv_rIdentPosition) * 0.5,
                     rLowOutput := sv_rMaxSpeedBwd * 0.1,
                     bStart := TRUE,
                     bStop := bStop,
                     bDirection := TRUE,
                     rActPos := sv_rNozzlePosition,
                     rTargetPos := sv_rIdentPosition,
                     dDelayTimeOn := sv_NozzleBwdTimesSet.dSetDelayTimePump,
                     dDelayTimeOff := sv_dSetDelayTimeOffBwd,
                     rPositionUp := sv_rNozzlePosition,
                     rHighOutput := sv_ConstBwdSetup.Velocity.Output.rOutputValue,
                     dMaxMoveTime := sv_NozzleBwdTimesSet.dMaxMoveTime,
                     rStopRamp := sv_rIdentStopRamp,
                     bActive => sv_bOutputActive,
                     rOutputPre => sv_rPressureAbs,
                     rOutputVel => sv_rVelocityAbs,
                     bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*AStepOutput*)
ACTION aRunProfile: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (bDirection) THEN
   bNozzlePosInvalid := (sv_rNozzlePosition >= sv_rNozzleStroke);
ELSE
   bNozzlePosInvalid := (sv_rNozzlePosition <= 0.0);
END_IF;

abNozzleBwdProfile.aRun(bStop := bStop OR sv_bTransducerError OR bNozzlePosInvalid,
                        bStart := TRUE,
                        rActPosition := rActPos,
                        dMaxMoveTime := sv_NozzleBwdTimesSet.dMaxMoveTime,
                        dDelayTimeOn := sv_NozzleBwdTimesSet.dSetDelayTimePump,
                        dDelayTimeOff := sv_NozzleBwdTimesSet.dSetDelayTimeValve,
                        DeadTime := sv_dSetDelayTimeOffBwd,
                        rSmoothFactor := sv_rSmoothFactor,
                        bActive => sv_bOutputActive,
                        iActiveStage => sv_iActiveStage,
                        bPreOutputReached => sv_bPreOutputReady);

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abNozzleBwdProfile.aRun.rPressureOutput);                       
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abNozzleBwdProfile.aRun.rVelocityOutput);
b := WRITE_SV_DIRECT(sv_NozzleBwdTimesAct.dActMoveTime, abNozzleBwdProfile.aRun.dActMoveTime);                     
                        
abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);



;#END_EDIT_BLOCK END_ACTION (*aRunProfile*)
ACTION aRunConstTime: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdConst.aRun(bStart := TRUE,
                      bStop := bStop,
                      bUsePosDetect := FALSE,
                      dMaxTime := sv_NozzleBwdTimesSet.dMaxMoveTime,
                      dDelayTimeOn := sv_NozzleBwdTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_NozzleBwdTimesSet.dSetDelayTimeValve,
                      bActive => sv_bOutputActive,
                      bPreOutputReached => sv_bPreOutputReady);

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abNozzleBwdConst.aRun.rOutputPre);                       
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abNozzleBwdConst.aRun.rOutputVel);
b := WRITE_SV_DIRECT(sv_NozzleBwdTimesAct.dActMoveTime, abNozzleBwdConst.aRun.dActTime);                     


abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);

;#END_EDIT_BLOCK END_ACTION (*aRunConstTime*)
ACTION aRunConstSetup: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdConstSetup.aRun(bStart := TRUE,
                           bStop := bStop,
                           dDelayTimeOn := sv_NozzleBwdTimesSet.dSetDelayTimePump,
                           dDelayTimeOff := sv_NozzleBwdTimesSet.dSetDelayTimeValve,
                           rOutputPre => sv_rPressureAbs,
                           rOutputVel => sv_rVelocityAbs,
                           bActive => sv_bOutputActive,
                           bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*aRunConstSetup*)
ACTION aRunConst: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdConst.aRun(bStop := bStop OR di_LimitSwitchBwd,
                      bStart := TRUE,
                      bUsePosDetect := FALSE,
                      dMaxTime := sv_NozzleBwdTimesSet.dMaxMoveTime,
                      dDelayTimeOn := sv_NozzleBwdTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_NozzleBwdTimesSet.dSetDelayTimeValve,
                      bActive => sv_bOutputActive,
                      bPreOutputReached => sv_bPreOutputReady);

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abNozzleBwdConst.aRun.rOutputPre);                       
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abNozzleBwdConst.aRun.rOutputVel);
b := WRITE_SV_DIRECT(sv_NozzleBwdTimesAct.dActMoveTime, abNozzleBwdConst.aRun.dActTime);                     


abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);

;#END_EDIT_BLOCK END_ACTION (*aRunConst*)
(* end sfc-code *)


END_ALGORITHM

PROCESS_ALGORITHM paInitDebugMeasurement ON TaskSlow AUTOSTART


VAR
 fuName : STRING(255);
 variableName : STRING(255);
 swoState : KSWO_Status;
END_VAR
#BEGIN_EDIT_BLOCK
fuName := GET_MY_FU_NAME();
variableName := CONCAT(fuName,'.Bwd.rSetPressure bar');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rPressureAbs);
variableName := CONCAT(fuName,'.Bwd.rSetVelocity mm/s');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rVelocityAbs);
variableName := CONCAT(fuName,'.Bwd.bActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bOutputActive);
STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCpyAccelerations ON PU_Task_7 WITH sv_NozzleBwdProfVis.Profile.Points[2].rVelRamp


VAR_TEMP
 i : UDINT;
END_VAR
#BEGIN_EDIT_BLOCK
FOR i:= 3 TO 20 DO
    sv_NozzleBwdProfVis.Profile.Points[i].rVelRamp := sv_NozzleBwdProfVis.Profile.Points[2].rVelRamp;
END_FOR;



;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 152 @Pou 25 
@@@BEG_Comment@@@
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

Nozzle backward movement.
@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
4 
@Var @RT(19)WRITE_SVREAL_DIRECT @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)WRITE_SV_DIRECT @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)GET_MY_FU_NAME @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)KSWO_AddVariable @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
12 
@Var @RT(15)cLockGroupMotor @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)69 @RT(56)Members: Mold, Ejector, Cores, Injection, Plast, Purge,  
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(26)cLockGroupSafetyGateNozzle @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)62 @RT(59)Members: Nozzle Forward, Injection, Plast, Intrusion, Purge 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveBwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)11 @RT(17)movement backward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)nActive @RT(0) @T @T @DERIVED 0 @F @RT(16)tnActiveInactive @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)nInactive @RT(0) @T @T @DERIVED 0 @F @RT(16)tnActiveInactive @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)nSetup @RT(0) @T @T @DERIVED 0 @F @RT(15)tnOperationMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(36)Setup mode only for service engineer 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)nPositionDependent @RT(0) @T @T @DERIVED 0 @F @RT(14)tnMovementMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(21)nLimitSwitchDependent @RT(0) @T @T @DERIVED 0 @F @RT(14)tnMovementMode @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)nMoveTimeDependent @RT(0) @T @T @DERIVED 0 @F @RT(14)tnMovementMode @F 
@T 
@BEG_Attrib 
0 @RT(1)2 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)tnCalibState_Error @RT(0) @T @T @DERIVED 0 @F @RT(12)tnCalibState @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(32)error occured during calibration 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)nManual @RT(0) @T @T @DERIVED 0 @F @RT(15)tnOperationMode @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(31)manual mode, play with switches 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)nHalfAutomatic @RT(0) @T @T @DERIVED 0 @F @RT(15)tnOperationMode @F 
@T 
@BEG_Attrib 
0 @RT(1)2 @RT(34)confirmation every cycle necessary 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(9)ABMoveBwd @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
56 
@Var @RT(16)sv_MoveBwdNozzle @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bTransducerAvailable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_rNozzlePosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_rPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_rVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_iActiveStage @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(11)sv_ConstBwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_ConstBwdSetup @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_NozzleBwdProfVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_OperationMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnOperationMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(11)ai_Position @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(11)sv_DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_dStandStillDetectTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(29)time for standstill detection @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_rMaxVoltageDiff @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(45)max. voltage difference to detect stand still @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_TmpLintabPoint @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)KCTRL_Lintab_Point @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_bDoTransducerCalib @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_bOutputActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(16)Output is active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_bPreOutputReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)PreOutput is ready @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_rNozzleStroke @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_bTransducerError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_MinOutputBwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tsMinOutput @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(32)minimum output of nozzle profile @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_dMoveBwdTimeSet @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(42)time of nozzle bwd movement in manual mode @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_NozzleBwdTimesSet @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsSetTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_NozzleBwdTimesAct @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsActTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)di_LimitSwitchBwd @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(23)nozzle bwd limit switch @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_MovementMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)tnMovementMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(61)Nozzle Movement with Limitswitch or with position measurement @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bInitStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rVelocityAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rPressureAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LintabOutBwdP @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LintabOutBwdV @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rMaxSpeedBwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bNozzleBwd @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_CalibState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsCalibMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_dCalculatedDurationBwd @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(34)Calculated duration for nozzle bwd @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_bFwdTimeReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(110)nozzle fwd time reached (for time dependent nozzle control) (must be FastRetain: cyclical change in AutoCycle) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_bBwdTimeReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(110)nozzle bwd time reached (for time dependent nozzle control) (must be FastRetain: cyclical change in AutoCycle) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bMoveIdent @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rIdentPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rIdentStopRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_dSetDelayTimeOffBwd @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_rSmoothFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_bODCCombinedMoveActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(8)TaskSlow @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)TaskAnalog @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)PU_Task_7 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(14)erNozzleNotBwd @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)g_MoveCtrl @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveCtrl @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(18)abNozzleBwdProfile @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)ABProfileMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abNozzleBwdConst @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)ABConstMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)abNozzleBwdConstSetup @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)ABConstMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abNozzleBwdCalib @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)ABConstCalib @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mbLimitSwBwdLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abLintabApplyVel @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)abLintabApplyPres @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)abNozzleBwdStep @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)ABStepOutput @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

6 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(9)aRegister @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
4 
@Var @RT(18)abMovementRegister @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABMovementRegister @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)sDeviceName @RT(0) @T @F @DT @RT(10)STRING(40) @RT(0) @T @T @STRING 0 @F @RT(2)40 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(8)'Nozzle' @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)sIconPath @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)sCompletePath @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(5)aInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(17)pMinOutputChanged @STRUCTURED_TEXT 
@RT(0) @RT(29)sv_MinOutputBwd,sv_bInitStart @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aRun @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
12 
@Var @RT(5)bStop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(44)Stop movement, e.g. button has been released @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)bReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(17)Backward finished @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(17)bNozzlePosInvalid @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(18)fbSetMovementState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)FBSetMovementState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)rActPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(61)set calculated "actual position" if  movement should not stop @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)bDirection @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(36)direction of profile, True ascending @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)rHalfPos @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(34)Half position of last profile step @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)iNoOfPoints @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(22)paInitDebugMeasurement @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @T @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(6)fuName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)variableName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)swoState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSWO_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(17)pCpyAccelerations @STRUCTURED_TEXT 
@RT(0) @RT(46)sv_NozzleBwdProfVis.Profile.Points[2].rVelRamp @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)i @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(28)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// movement registration
sv_MoveBwdNozzle.LockGroups[1] := cLockGroupMotor;
sv_MoveBwdNozzle.LockGroups[2] := cLockGroupSafetyGateNozzle;

sv_MoveBwdNozzle.pdStartDelaySet := @sv_NozzleBwdTimesSet.dSetDelayTime;
sv_MoveBwdNozzle.pdStartDelayAct := @sv_NozzleBwdTimesAct.dActDelayTime;
sv_MoveBwdNozzle.pdActiveTimeAct := @sv_NozzleBwdTimesAct.dActMoveTime;
sv_MoveBwdNozzle.pdTimeLimit     := @sv_NozzleBwdTimesSet.dMaxMoveTime;
sv_MoveBwdNozzle.pdCalculatedDuration := @sv_dCalculatedDurationBwd;
sv_MoveBwdNozzle.Alarm.AlarmId := erNozzleNotBwd;
sv_MoveBwdNozzle.Alarm.SubId[1] := sv_DeviceId.CompId;
sv_MoveBwdNozzle.Alarm.SubId[2] := sv_DeviceId.IndexId;

sv_MoveBwdNozzle.pbPosReached := @sv_bNozzleBwd;
sIconPath := "\hmi\images\movNozzleBwd.gif";
sCompletePath := CONCAT(sDeviceName,(DINT_TO_STRING(sv_DeviceId.IndexId)),sIconPath);
sv_MoveBwdNozzle.sIconPath := sCompletePath;

abMovementRegister.aRegister(@sv_MoveBwdNozzle);


mbLimitSwBwdLinked := IS_LINKED(di_LimitSwitchBwd);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(28)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdProfile.aInit(pProfile := @sv_NozzleBwdProfVis,
                         MoveDir := sv_MoveBwdNozzle.MoveDir,
                         pdCalcedDuration := @sv_dCalculatedDurationBwd,
                         prCalcDurationStartPosition := @sv_NozzleBwdProfVis.Profile.Points[1].rStartPos);

abNozzleBwdConstSetup.aInit(pConst := @sv_ConstBwdSetup,
                            MoveId := sv_MoveBwdNozzle.MoveDir);

abNozzleBwdCalib.aInit(pConst := @sv_ConstBwdSetup,
                       MoveId := sv_MoveBwdNozzle.MoveDir);

abNozzleBwdConst.aInit(pConst := @sv_ConstBwd,
                       MoveId := sv_MoveBwdNozzle.MoveId);

abLintabApplyPres.aInit(pLintab := @sv_LintabOutBwdP);

abLintabApplyVel.aInit(pLintab := @sv_LintabOutBwdV);

abNozzleBwdStep.aInit(pConst := @sv_ConstBwdSetup,
                      MoveId := cMoveBwd,
                      prMaxSpeed := @sv_rMaxSpeedBwd);


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(17)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//copy minoutput to bwd const movement
sv_ConstBwd.Velocity.rMinOutput := sv_MinOutputBwd.rVelocity;
sv_ConstBwd.Pressure.rMinOutput := sv_MinOutputBwd.rPressure;

//copy minoutput to bwd movment in setup mode
sv_ConstBwdSetup.Velocity.rMinOutput := sv_MinOutputBwd.rVelocity;
sv_ConstBwdSetup.Pressure.rMinOutput := sv_MinOutputBwd.rPressure;

//copy minoutput to bwd profile
sv_NozzleBwdProfVis.rMinOutputVel := sv_MinOutputBwd.rVelocity;
sv_NozzleBwdProfVis.rMinOutputPress := sv_MinOutputBwd.rPressure;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
18 13 19 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 1 
@Loop @RT(4)loop @F 2 
@StepSeq @RT(4)sseq @F 5 
@Step @RT(5)START @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)AStart @F @T @RT(1)P @RT(0) @F @F @T @TL(8)
bReady := FALSE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := g_MoveCtrl.pData^.MoveDir,
                   State    := nActive);

//reset fwd time reached
sv_bFwdTimeReached := FALSE;

@F 

@Trans @RT(6)TStart @F @T @F @F @T @F @TL(2)
TRUE

@RT(6)TStart @F 
@Step @RT(13)S_CheckOpMode @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(10)TSetupMode @F @T @F @F @T @F @TL(2)
sv_OperationMode = nSetup

@RT(10)TSetupMode @F 
@Step @RT(14)S_CheckIfCalib @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 3 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(9)TNotCalib @F @T @F @F @T @F @TL(4)
(NOT sv_bDoTransducerCalib OR
NOT sv_bTransducerAvailable) AND
NOT sv_bMoveIdent

@RT(9)TNotCalib @F 
@Step @RT(11)S_SetupMove @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(21)AResetConstSetupBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(14)aRunConstSetup @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(11)TSetupReady @F @T @F @F @T @T @TL(2)
NOT abNozzleBwdConstSetup.aRun.bActive

@RT(11)TSetupReady @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(6)TCalib @F @T @F @F @T @F @TL(3)
sv_bDoTransducerCalib AND
sv_bTransducerAvailable

@RT(6)TCalib @F 
@Step @RT(16)S_CalibActivated @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(16)AResetCalibBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(16)ATransducerCalib @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(16)ACheckCalibError @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(11)TCalibReady @F @T @F @F @T @T @TL(2)
NOT abNozzleBwdCalib.aRun.bActive OR bError

@RT(11)TCalibReady @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(19)TMoveIdentActivated @F @T @F @F @T @F @TL(2)
sv_bMoveIdent

@RT(19)TMoveIdentActivated @F 
@Step @RT(11)S_MoveIdent @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(16)AResetIdentBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(11)AStepOutput @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(15)TMoveIdentReady @F @T @F @F @T @T @TL(2)
NOT abNozzleBwdStep.aRun.bActive

@RT(15)TMoveIdentReady @F 



@TransSeq @RT(4)tseq @F 3 
@Trans @RT(9)TNotSetup @F @T @F @F @T @F @TL(2)
sv_OperationMode <> nSetup

@RT(9)TNotSetup @F 
@Step @RT(15)S_CheckMoveMode @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 3 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(13)TPositionMode @F @T @F @F @T @F @TL(2)
sv_MovementMode = nPositionDependent

@RT(13)TPositionMode @F 
@Step @RT(17)S_CheckTransducer @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(11)TTransducer @F @T @F @F @T @F @TL(2)
sv_bTransducerAvailable

@RT(11)TTransducer @F 
@Step @RT(13)S_ProfileMove @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(18)AResetProfileBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(14)aSetActProfile @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(11)aRunProfile @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(13)TProfileReady @F @T @F @F @T @F @TL(2)
NOT abNozzleBwdProfile.aRun.bActive

@RT(13)TProfileReady @F 

@TransSeq @RT(4)tseq @F 1 
@Trans @RT(13)TNoTransducer @F @T @F @F @T @T @TL(2)
NOT sv_bTransducerAvailable

@RT(13)TNoTransducer @F 



@TransSeq @RT(4)tseq @F 3 
@Trans @RT(12)TLimitSwitch @F @T @F @F @T @F @TL(3)
sv_MovementMode = nLimitSwitchDependent AND
mbLimitSwBwdLinked

@RT(12)TLimitSwitch @F 
@Step @RT(11)S_ConstMove @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(16)AResetConstBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(9)aRunConst @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(11)TConstReady @F @T @F @F @T @F @TL(2)
NOT abNozzleBwdConst.aRun.bActive

@RT(11)TConstReady @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(11)TOtherModes @F @T @F @F @T @F @TL(3)
sv_MovementMode = nMoveTimeDependent OR
(sv_MovementMode = nLimitSwitchDependent AND NOT mbLimitSwBwdLinked)

@RT(11)TOtherModes @F 
@Step @RT(11)S_ConstTime @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(6)AReset @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(13)aRunConstTime @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(18)ASetBwdTimeReached @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(15)TConstTimeReady @F @T @F @F @T @F @TL(2)
NOT abNozzleBwdConst.aRun.bActive

@RT(15)TConstTimeReady @F 




@Step @RT(7)S_Ready @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)AReady @F @T @RT(1)P @RT(0) @F @F @T @TL(5)
bReady := TRUE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := g_MoveCtrl.pData^.MoveDir,
                   State    := nInactive);

@F 


@Trans @RT(6)TReady @F @T @F @T @T @T @TL(2)
TRUE

@RT(6)TReady @F 

@END_SfcData 
@SaActions 15 
@SaText @RT(16)AResetCalibBlock 1 @TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bError := FALSE;
abNozzleBwdCalib.aRun(bStart := FALSE,
                      LintabPoint := sv_TmpLintabPoint);
IF abNozzleBwdCalib.aRun.bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   bError := TRUE;
   dummy := Print("Calib Error: Reset calib block failed"); 
END_IF;


@SaText @RT(21)AResetConstSetupBlock 1 @TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdConstSetup.aRun(bStart := FALSE);


@SaText @RT(18)AResetProfileBlock 1 @TL(12)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdProfile.aRun(bStart := FALSE);

iNoOfPoints := sv_NozzleBwdProfVis.Profile.iNoOfPoints + 1;
bDirection := sv_NozzleBwdProfVis.Profile.Points[1].rStartPos < sv_NozzleBwdProfVis.Profile.Points[iNoOfPoints].rStartPos;




@SaText @RT(16)AResetConstBlock 1 @TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdConst.aRun(bStart := FALSE);


@SaText @RT(16)ACheckCalibError 1 @TL(5)
IF bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   dummy := Print("Calib Error: %i", iErrorInfo);
END_IF;


@SaText @RT(14)aSetActProfile 1 @TL(18)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

rActPos := sv_rNozzlePosition;
// In manual mode do backward until button is not pressed, but use profile-movement
// set input of actual position in profile movement maximal to the value,
// where maximum of last step will be reached
IF sv_OperationMode = nManual AND (NOT sv_bODCCombinedMoveActive) THEN
    rHalfPos := (sv_NozzleBwdProfVis.Profile.Points[(iNoOfPoints -1)].rStartPos +                   
                 sv_NozzleBwdProfVis.Profile.Points[iNoOfPoints].rStartPos) / 2.0 ;
    IF (bDirection AND rActPos > rHalfPos) OR (NOT bDirection AND rActPos < rHalfPos) THEN
       rActPos := rHalfPos;
    END_IF;
END_IF;



@SaText @RT(6)AReset 1 @TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdConst.aRun(bStart := FALSE);

IF (sv_OperationMode >= nHalfAutomatic) THEN
   //set move time
   abNozzleBwdConst.aSetMoveTime(dSetMoveTime := sv_dMoveBwdTimeSet);
END_IF;




@SaText @RT(18)ASetBwdTimeReached 1 @TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

sv_bBwdTimeReached := (sv_NozzleBwdTimesAct.dActMoveTime >= sv_dMoveBwdTimeSet)


@SaText @RT(16)AResetIdentBlock 1 @TL(3)
abNozzleBwdStep.aRun(bStart := FALSE);



@SaText @RT(16)ATransducerCalib 1 @TL(28)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdCalib.aRun(bStop := bStop OR sv_bTransducerError,
                      bStart := TRUE,
                      rActVoltage := ai_Position,
                      rMaxVoltageDiff := sv_rMaxVoltageDiff,
                      dStandStillDetectTime := sv_dStandStillDetectTime,
                      LintabPoint := sv_TmpLintabPoint,
                      rSetValue := sv_rNozzleStroke,
                      dDelayTimeOn := sv_NozzleBwdTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_NozzleBwdTimesSet.dSetDelayTimeValve,
                      bActive => sv_bOutputActive,
                      rOutputPre => sv_rPressureAbs,
                      rOutputVel => sv_rVelocityAbs,
                      bPreOutputReached => sv_bPreOutputReady,
                      iErrorInfo => iErrorInfo);
sv_bDoTransducerCalib := NOT (abNozzleBwdCalib.aRun.bPointDetected);
bError := abNozzleBwdCalib.aRun.bError OR bError;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


@SaText @RT(11)AStepOutput 1 @TL(30)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdStep.aRun(bUsePosDetect := sv_rIdentPosition <> 0.0,
                     rPositionDown := (sv_rNozzlePosition + sv_rIdentPosition) * 0.5,
                     rLowOutput := sv_rMaxSpeedBwd * 0.1,
                     bStart := TRUE,
                     bStop := bStop,
                     bDirection := TRUE,
                     rActPos := sv_rNozzlePosition,
                     rTargetPos := sv_rIdentPosition,
                     dDelayTimeOn := sv_NozzleBwdTimesSet.dSetDelayTimePump,
                     dDelayTimeOff := sv_dSetDelayTimeOffBwd,
                     rPositionUp := sv_rNozzlePosition,
                     rHighOutput := sv_ConstBwdSetup.Velocity.Output.rOutputValue,
                     dMaxMoveTime := sv_NozzleBwdTimesSet.dMaxMoveTime,
                     rStopRamp := sv_rIdentStopRamp,
                     bActive => sv_bOutputActive,
                     rOutputPre => sv_rPressureAbs,
                     rOutputVel => sv_rVelocityAbs,
                     bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


@SaText @RT(11)aRunProfile 1 @TL(35)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (bDirection) THEN
   bNozzlePosInvalid := (sv_rNozzlePosition >= sv_rNozzleStroke);
ELSE
   bNozzlePosInvalid := (sv_rNozzlePosition <= 0.0);
END_IF;

abNozzleBwdProfile.aRun(bStop := bStop OR sv_bTransducerError OR bNozzlePosInvalid,
                        bStart := TRUE,
                        rActPosition := rActPos,
                        dMaxMoveTime := sv_NozzleBwdTimesSet.dMaxMoveTime,
                        dDelayTimeOn := sv_NozzleBwdTimesSet.dSetDelayTimePump,
                        dDelayTimeOff := sv_NozzleBwdTimesSet.dSetDelayTimeValve,
                        DeadTime := sv_dSetDelayTimeOffBwd,
                        rSmoothFactor := sv_rSmoothFactor,
                        bActive => sv_bOutputActive,
                        iActiveStage => sv_iActiveStage,
                        bPreOutputReached => sv_bPreOutputReady);

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abNozzleBwdProfile.aRun.rPressureOutput);                       
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abNozzleBwdProfile.aRun.rVelocityOutput);
b := WRITE_SV_DIRECT(sv_NozzleBwdTimesAct.dActMoveTime, abNozzleBwdProfile.aRun.dActMoveTime);                     
                        
abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);




@SaText @RT(13)aRunConstTime 1 @TL(25)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdConst.aRun(bStart := TRUE,
                      bStop := bStop,
                      bUsePosDetect := FALSE,
                      dMaxTime := sv_NozzleBwdTimesSet.dMaxMoveTime,
                      dDelayTimeOn := sv_NozzleBwdTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_NozzleBwdTimesSet.dSetDelayTimeValve,
                      bActive => sv_bOutputActive,
                      bPreOutputReached => sv_bPreOutputReady);

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abNozzleBwdConst.aRun.rOutputPre);                       
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abNozzleBwdConst.aRun.rOutputVel);
b := WRITE_SV_DIRECT(sv_NozzleBwdTimesAct.dActMoveTime, abNozzleBwdConst.aRun.dActTime);                     


abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);


@SaText @RT(14)aRunConstSetup 1 @TL(20)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdConstSetup.aRun(bStart := TRUE,
                           bStop := bStop,
                           dDelayTimeOn := sv_NozzleBwdTimesSet.dSetDelayTimePump,
                           dDelayTimeOff := sv_NozzleBwdTimesSet.dSetDelayTimeValve,
                           rOutputPre => sv_rPressureAbs,
                           rOutputVel => sv_rVelocityAbs,
                           bActive => sv_bOutputActive,
                           bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


@SaText @RT(9)aRunConst 1 @TL(25)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleBwdConst.aRun(bStop := bStop OR di_LimitSwitchBwd,
                      bStart := TRUE,
                      bUsePosDetect := FALSE,
                      dMaxTime := sv_NozzleBwdTimesSet.dMaxMoveTime,
                      dDelayTimeOn := sv_NozzleBwdTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_NozzleBwdTimesSet.dSetDelayTimeValve,
                      bActive => sv_bOutputActive,
                      bPreOutputReached => sv_bPreOutputReady);

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abNozzleBwdConst.aRun.rOutputPre);                       
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abNozzleBwdConst.aRun.rOutputVel);
b := WRITE_SV_DIRECT(sv_NozzleBwdTimesAct.dActMoveTime, abNozzleBwdConst.aRun.dActTime);                     


abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);


@SaTrans 0 
@SaExits 0 
@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(15)
fuName := GET_MY_FU_NAME();
variableName := CONCAT(fuName,'.Bwd.rSetPressure bar');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rPressureAbs);
variableName := CONCAT(fuName,'.Bwd.rSetVelocity mm/s');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rVelocityAbs);
variableName := CONCAT(fuName,'.Bwd.bActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bOutputActive);
STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(5)
FOR i:= 3 TO 20 DO
    sv_NozzleBwdProfVis.Profile.Points[i].rVelRamp := sv_NozzleBwdProfVis.Profile.Points[2].rVelRamp;
END_FOR;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
