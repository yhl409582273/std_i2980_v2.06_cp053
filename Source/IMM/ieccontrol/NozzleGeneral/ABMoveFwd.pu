(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".
*)

IMPORT_OVER_LISTFILE
 GET_MY_FU_NAME
, SET_ALARM
, WRITE_SVREAL_DIRECT
, WRITE_SV_DIRECT
, KSWO_AddVariable
, cLockGroupSafetyGateNozzle
, cLockGroupMotor
, cMoveFwd
, nActive
, nInactive
, nSetup
, nPositionDependent
, nLimitSwitchDependent
, nMoveTimeDependent
, cMoveFwdContactF
, tnCalibState_Error
, nManual
, tsCalibMovement
, tsVelPre
, KAPPL_VisProfile
, tnOperationMode
, tsMoveData
, tsDeviceId
, KCTRL_Lintab_Point
, tsMinOutput
, tsSetTimes
, tsActTimes
, tnMovementMode
, KAPPL_LintabData
, tsInjectHoldElementData
, tsMoveCtrl
, ABProfileMovement
, ABConstMovement
, ABConstCalib
, ABLintabApply
, ABStepOutput
, ABMovementRegister
, FBSetMovementState
, TON
, FBStandStill
, R_TRIG
, KSWO_Status

END_IMPORT

ALGORITHM_BLOCK ABMoveFwd #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_CalibState : tsCalibMovement;
 sv_bTransducerAvailable : BOOL;
 sv_rNozzlePosition : REAL;
 sv_rPressure : REAL;
 sv_rVelocity : REAL;
 sv_iActiveStage : DINT;
 sv_ConstFwdSetup : tsVelPre (* constant output parameters of nozzle fwd movement in setup mode *);
 sv_ConstFwdStage1 : tsVelPre;
 sv_ConstFwdStage2 : tsVelPre;
 sv_NozzleFwdProfVis : KAPPL_VisProfile;
 sv_NozzleBwdProfVis : KAPPL_VisProfile (* profile of nozzle bwd movement *);
 sv_OperationMode : tnOperationMode;
 sv_MoveFwdNozzle : tsMoveData;
 ai_Position : REAL (* analog input value from transducer *);
 di_LimitSwitchFwd2 : BOOL;
 di_LimitSwitchFwd : BOOL;
 sv_DeviceId : tsDeviceId;
 sv_dStandStillDetectTime : TIME (* time for standstill detection *);
 sv_rMaxVoltageDiff : REAL (* max. voltage difference to detect stand still *);
 sv_TmpLintabPoint : KCTRL_Lintab_Point;
 sv_bDoTransducerCalib : BOOL;
 sv_bOutputActive : BOOL (* Output is active *);
 sv_bPreOutputReady : BOOL (* PreOutput is ready *);
 sv_bTransducerError : BOOL;
 sv_MinOutputFwd : tsMinOutput;
 sv_dNozzleFwdStage2Set : TIME (* time for output of nozzle fwd movement after limitswitch is touched *);
 sv_NozzleFwdTimesSet : tsSetTimes;
 sv_NozzleFwdTimesAct : tsActTimes;
 sv_dNozzleFwdStage2Act : TIME (* time for output of nozzle fwd movement after limitswitch is touched *);
 sv_MovementMode : tnMovementMode (* Nozzle Movement with Limitswitch or with position measurement *);
 sv_rNozzleStroke : REAL;
 sv_bInitStart : BOOL;
 sv_bContactPointDetected : BOOL (* flag: nozzle zero position detected *);
 sv_LintabOutFwdP : KAPPL_LintabData;
 sv_LintabOutFwdV : KAPPL_LintabData;
 sv_rVelocityAbs : REAL;
 sv_rPressureAbs : REAL;
 sv_rMaxSpeedFwd : REAL;
 sv_bInitDone : BOOL;
 sv_bNozzleFwd : BOOL;
 sv_bNozzleAdjHMI : BOOL;
 sv_dSetStandstillDetectionTime : TIME;
 sv_dMaxNozzleAdjustTime : TIME;
 sv_dActNozzleAdjustTime : TIME;
 sv_rNozzlePositionOffset : REAL;
 sv_rPosOffsetTolerance : REAL (* Tolerance in mm for new position offset of contact point *);
 sv_dCalculatedDurationFwd : TIME (* Calculated duration for nozzle fwd *);
 sv_MoveFwdContactF : tsMoveData;
 sv_ConstFwdContactF : tsVelPre (* constant output parameters of nozzle fwd contact pressure build-up movement  *);
 sv_dNozzleFwdContactFSet : TIME (* set time for output of nozzle fwd pressure build up movement *);
 sv_dNozzleFwdContactFAct : TIME (* act. set time for output of nozzle fwd pressure build up movement *);
 sv_bFwdTimeReached : BOOL (* nozzle fwd time reached (for time dependent nozzle control) (must be FastRetain: cyclical change in AutoCycle) *);
 sv_bBwdTimeReached : BOOL (* nozzle bwd time reached (for time dependent nozzle control) (must be FastRetain: cyclical change in AutoCycle) *);
 sv_dCalcDurationFwdContactF : TIME (* Calculated duration for nozzle fwd *);
 sv_NozzleFwdContactFData : tsInjectHoldElementData;
 sv_rNozzleStrokePlaus : REAL (* Nozzle stroke - Nozzle Position offset  *);
 sv_bPressBuildUpActive : BOOL (* TRUE: pressure build up is active *);
 sv_dActPressureBuildUpTime : TIME (* actual time for nozzle fwd pressure build up *);
 sv_bMoveIdent : BOOL;
 sv_rIdentPosition : REAL;
 sv_rIdentStopRamp : REAL;
 sv_dSetDelayTimeOffFwd : TIME;
 sv_rSmoothFactor : REAL;
 sv_dActFwdTime : TIME (* actual nozzle fwd time (includes contact force build up) *);
 sv_bTRUE : BOOL;
 sv_bFALSE : BOOL;
END_VAR

SYSTEM_OBJECT
 TaskSlow : TASK;
 TaskAnalog : TASK;
 PU_Task_7 : TASK;
 erNozzleAdjustFinished : ALARM;
 erNozzleAdjustAborted : ALARM;
 erMaxNozzleAdjTimeExc : ALARM;
 erContactPointOutOfTolerance : ALARM;
 erContactPointNotDetected : ALARM;
 erNozzleNotFwd : ALARM;
END_OBJECT

VAR_EXTERNAL
 g_MoveCtrl : tsMoveCtrl;
END_VAR

VAR
 abNozzleFwdProfile : ABProfileMovement;
 abNozzleFwdConstSetup : ABConstMovement;
 abNozzleFwdConstStage1 : ABConstMovement;
 abNozzleFwdConstStage2 : ABConstMovement;
 mbLimitSwFwdLinked : BOOL;
 mbLimitSwFwd2Linked : BOOL;
 abNozzleFwdCalib : ABConstCalib;
 abLintabApplyVel : ABLintabApply;
 abLintabApplyPres : ABLintabApply;
 abNozzleFwdConstAdjust : ABConstMovement;
 abNozzleFwdPressBuildUp : ABConstMovement;
 abNozzleFwdStep : ABStepOutput;
END_VAR

ALGORITHM aRegister


VAR
 abMovementRegister : ABMovementRegister;
 abMovementRegisterContactF : ABMovementRegister;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// movement registration
sv_MoveFwdNozzle.pdStartDelaySet := @sv_NozzleFwdTimesSet.dSetDelayTime;
sv_MoveFwdNozzle.pdStartDelayAct := @sv_NozzleFwdTimesAct.dActDelayTime;
sv_MoveFwdNozzle.pdActiveTimeAct := @sv_NozzleFwdTimesAct.dActMoveTime;
sv_MoveFwdNozzle.pdTimeLimit     := @sv_NozzleFwdTimesSet.dMaxMoveTime;
sv_MoveFwdNozzle.pdCalculatedDuration := @sv_dCalculatedDurationFwd;
sv_MoveFwdNozzle.LockGroups[1] := cLockGroupSafetyGateNozzle;
sv_MoveFwdNozzle.LockGroups[2] := cLockGroupMotor;
sv_MoveFwdNozzle.Alarm.AlarmId := erNozzleNotFwd;
sv_MoveFwdNozzle.Alarm.SubId[1] := sv_DeviceId.CompId;
sv_MoveFwdNozzle.Alarm.SubId[2] := sv_DeviceId.IndexId;
sv_MoveFwdNozzle.pbPosReached := @sv_bNozzleFwd;
sv_MoveFwdNozzle.sIconPath := CONCAT(GET_MY_FU_NAME(), '\hmi\images\movNozzleFwd.gif');

abMovementRegister.aRegister(@sv_MoveFwdNozzle);

// MoveFwdContactF movement registration
sv_MoveFwdContactF.pdStartDelaySet := @sv_NozzleFwdTimesSet.dSetDelayTime;
sv_MoveFwdContactF.pdStartDelayAct := @sv_NozzleFwdTimesAct.dActDelayTime;
sv_MoveFwdContactF.pdActiveTimeAct := @sv_dActFwdTime;
sv_MoveFwdContactF.pdTimeLimit     := @sv_NozzleFwdTimesSet.dMaxMoveTime;
sv_MoveFwdContactF.pdCalculatedDuration := @sv_dCalcDurationFwdContactF;
sv_MoveFwdContactF.LockGroups[1] := cLockGroupSafetyGateNozzle;
sv_MoveFwdContactF.LockGroups[2] := cLockGroupMotor;
sv_MoveFwdContactF.Alarm := sv_MoveFwdNozzle.Alarm;
sv_MoveFwdContactF.pbPosReached := @sv_bNozzleFwd;
sv_MoveFwdContactF.sIconPath := sv_MoveFwdNozzle.sIconPath;

abMovementRegisterContactF.aRegister(@sv_MoveFwdContactF);


mbLimitSwFwdLinked := IS_LINKED(di_LimitSwitchFwd);
mbLimitSwFwd2Linked := IS_LINKED(di_LimitSwitchFwd2);


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aInit

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdProfile.aInit(pProfile := @sv_NozzleFwdProfVis,
                         MoveDir := sv_MoveFwdNozzle.MoveDir,
                         pdCalcedDuration := @sv_dCalculatedDurationFwd,
                         prCalcDurationStartPosition := @sv_NozzleBwdProfVis.Profile.Points[sv_NozzleBwdProfVis.Profile.iNoOfPoints+1].rStartPos);

abNozzleFwdConstSetup.aInit(pConst := @sv_ConstFwdSetup,
                            MoveId := sv_MoveFwdNozzle.MoveId);

abNozzleFwdCalib.aInit(pConst := @sv_ConstFwdSetup,
                       MoveId := sv_MoveFwdNozzle.MoveId);

abNozzleFwdConstStage1.aInit(pConst := @sv_ConstFwdStage1,
                             MoveId := sv_MoveFwdNozzle.MoveId);

abNozzleFwdConstStage2.aInit(pConst := @sv_ConstFwdStage2,
                             MoveId := sv_MoveFwdNozzle.MoveId);

abLintabApplyPres.aInit(pLintab := @sv_LintabOutFwdP);

abLintabApplyVel.aInit(pLintab := @sv_LintabOutFwdV);

abNozzleFwdConstAdjust.aInit(pConst := @sv_ConstFwdSetup,
                             MoveId := sv_MoveFwdNozzle.MoveId);

abNozzleFwdPressBuildUp.aInit(pConst := @sv_ConstFwdContactF,
                              MoveId := sv_MoveFwdContactF.MoveId);

abNozzleFwdStep.aInit(pConst := @sv_ConstFwdSetup,
                      MoveId := cMoveFwd,
                      prMaxSpeed := @sv_rMaxSpeedFwd);



;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pMinOutputChanged ON PU_Task_7 WITH sv_MinOutputFwd,sv_bInitStart

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//copy minoutput to fwd const stage1 movement
sv_ConstFwdStage1.Velocity.rMinOutput := sv_MinOutputFwd.rVelocity;
sv_ConstFwdStage1.Pressure.rMinOutput := sv_MinOutputFwd.rPressure;

//copy minoutput to fwd const stage2 movement
sv_ConstFwdStage2.Velocity.rMinOutput := sv_MinOutputFwd.rVelocity;
sv_ConstFwdStage2.Pressure.rMinOutput := sv_MinOutputFwd.rPressure;

//copy minoutput to fwd movement in setup mode
sv_ConstFwdSetup.Velocity.rMinOutput := sv_MinOutputFwd.rVelocity;
sv_ConstFwdSetup.Pressure.rMinOutput := sv_MinOutputFwd.rPressure;

//copy minoutput to const fwd movement for pressure build up
sv_ConstFwdContactF.Velocity.rMinOutput := sv_MinOutputFwd.rVelocity;
sv_ConstFwdContactF.Pressure.rMinOutput := sv_MinOutputFwd.rPressure;

//copy minoutput to fwd profile
sv_NozzleFwdProfVis.rMinOutputVel := sv_MinOutputFwd.rVelocity;
sv_NozzleFwdProfVis.rMinOutputPress := sv_MinOutputFwd.rPressure;


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aRun


VAR_INPUT
 bStop : BOOL;
END_VAR

VAR_OUTPUT
 bReady : BOOL;
END_VAR

VAR_TEMP
 i : UDINT;
 dDelayTimeOn : TIME;
 dDelayTimeOff : TIME;
 dActMoveTime : TIME;
 b : BOOL;
END_VAR

VAR
 fbSetMovementState : FBSetMovementState;
 bVelC1Reached : BOOL;
 tmpPressureAbs : REAL;
 tmpVelocityAbs : REAL;
 bPreOutputOld : BOOL;
 bStage1Runned : BOOL;
 dummy : DINT;
 bError : BOOL;
 iErrorInfo : DINT;
 fbTSupervisionTime : TON;
 dActiveTime : TIME;
 bStandStill : BOOL;
 fbStandStill : FBStandStill;
 bAutoAdjustAllowed : BOOL;
 bContactPressBuildUp : BOOL (* true if touch pressure should be built up *);
 fbRTrigStandstill : R_TRIG;
 bContactPointDetected : BOOL;
 bContactPointDetError : BOOL;
END_VAR

(* IecGraph-Code *)

(* init step *)
INITIAL_STEP START:
AStart (P);
END_STEP

ACTION AStart: #BEGIN_EDIT_BLOCK
bReady := FALSE;
bContactPressBuildUp := FALSE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := g_MoveCtrl.pData^.MoveDir,
                   State    := nActive);

//reset bwd time reached
sv_bBwdTimeReached := FALSE;

;#END_EDIT_BLOCK END_ACTION (*AStart*)

(* steps *)
STEP S_CheckOpMode:
END_STEP

STEP S_CheckIfCalib:
END_STEP

STEP S_ConstSetup:
AResetConstBlock (P);
aRunConstSetup (N);
END_STEP

STEP S_CalibActivated:
AResetCalibBlock (P);
ATransducerCalib (N);
ACheckCalibError (N);
END_STEP

STEP S_ConstAdjust:
AResetAdjustBlock (P);
AResetStandStill (P);
ADetectStandStill (N);
aRunConstAdjustSetup (N);
ACheckSupervisionTime (N);
END_STEP

ACTION ACheckSupervisionTime: #BEGIN_EDIT_BLOCK
fbTSupervisionTime(IN := TRUE);
sv_dActNozzleAdjustTime := fbTSupervisionTime.ET;
IF fbTSupervisionTime.Q THEN
   bAutoAdjustAllowed := FALSE; 
   SET_ALARM(erMaxNozzleAdjTimeExc);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckSupervisionTime*)
STEP S_SetPosOffset:
ASetNozzleOffset (P);
END_STEP

STEP S_NozzleAdjustAborted:
Action38 (P);
END_STEP

ACTION Action38: #BEGIN_EDIT_BLOCK
sv_bNozzleAdjHMI := FALSE;
SET_ALARM(erNozzleAdjustAborted);

;#END_EDIT_BLOCK END_ACTION (*Action38*)
STEP S_MoveIdent:
AResetIdentBlock (P);
AStepOutput (N);
END_STEP

STEP S_CheckMoveMode:
END_STEP

STEP S_CheckContactPoint:
END_STEP

STEP S_ContactPointNotDetected:
ASetAlarm (P);
END_STEP

ACTION ASetAlarm: #BEGIN_EDIT_BLOCK
SET_ALARM(erContactPointNotDetected);

;#END_EDIT_BLOCK END_ACTION (*ASetAlarm*)
STEP Step45:
END_STEP

STEP Step47:
ASetContactPressBuildUp (P);
END_STEP

ACTION ASetContactPressBuildUp: #BEGIN_EDIT_BLOCK
bContactPressBuildUp := TRUE;

;#END_EDIT_BLOCK END_ACTION (*ASetContactPressBuildUp*)
STEP S_ProfileMove:
AResetProfileBlock (P);
AResetDetection (P);
aRunProfile (N);
ACheckContactPoint (N);
ACheckPointReached (P0);
END_STEP

STEP S_Check:
END_STEP

STEP S_NewPosOffset:
AActivateContactForce (P);
END_STEP

ACTION AActivateContactForce: #BEGIN_EDIT_BLOCK
bContactPressBuildUp := TRUE;

;#END_EDIT_BLOCK END_ACTION (*AActivateContactForce*)
STEP S_CheckLimitSwitch:
Action21 (N);
END_STEP

ACTION Action21: #BEGIN_EDIT_BLOCK
dActiveTime := T#0s;
sv_NozzleFwdTimesAct.dActMoveTime := T#0s;

;#END_EDIT_BLOCK END_ACTION (*Action21*)
STEP CheckLimits:
END_STEP

STEP S_ConstStage1:
AResetConstStage1 (P);
ACheckVelCReached (N);
AS2PreOutputMax (N);
aRunConstStage1 (N);
END_STEP

STEP S_ConstStage2Di2:
AResetConstStage2DI2 (P);
AStopConstStage1 (N);
aRunConstStage1To2 (N);
END_STEP

STEP S_ActivateContactFAfterLimSW2:
AActivateConFAfterLimSW2 (P);
END_STEP

ACTION AActivateConFAfterLimSW2: #BEGIN_EDIT_BLOCK
IF di_LimitSwitchFwd2 THEN
   bContactPressBuildUp := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AActivateConFAfterLimSW2*)
STEP S_ConstStage2:
AResetConstStage2 (P);
AStopConstStage1 (N);
aRunConstStage2 (N);
END_STEP

STEP S_ActivateContactFAfterLimSW1:
AActivateConFAfterLimSW1 (P);
END_STEP

ACTION AActivateConFAfterLimSW1: #BEGIN_EDIT_BLOCK
IF (sv_dNozzleFwdStage2Act >= sv_dNozzleFwdStage2Set) THEN
   bContactPressBuildUp := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AActivateConFAfterLimSW1*)
STEP S_PreOut:
AS2PreOutput0 (N);
END_STEP

STEP S_ConstTime:
AReset (P);
aRunConstTime (N);
ASetFwdTimeReached (N);
END_STEP

STEP S_ActivateConFAfterTimeElapsed:
AActivateConFAfterTimeElapsed (P);
END_STEP

ACTION AActivateConFAfterTimeElapsed: #BEGIN_EDIT_BLOCK
bContactPressBuildUp := sv_bFwdTimeReached;

;#END_EDIT_BLOCK END_ACTION (*AActivateConFAfterTimeElapsed*)
STEP S_CheckIfPressureBuildUp:
END_STEP

STEP S_NozzlePressureBuildup:
AResetConstBuildUpPress (P);
aRunConstBuildUpPress (N);
END_STEP

STEP S_AdaptDuration:
ADurationReference (P);
END_STEP

STEP S_Ready:
AReady (P);
END_STEP

ACTION AReady: #BEGIN_EDIT_BLOCK
bReady := TRUE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := g_MoveCtrl.pData^.MoveDir,
                   State    := nInactive);

;#END_EDIT_BLOCK END_ACTION (*AReady*)

(* transitions *)
GO_ON_TRANSITION TStart (* TStart *) FROM START TO S_CheckOpMode :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TSetupMode (* TSetupMode *) FROM S_CheckOpMode TO S_CheckIfCalib :=  #BEGIN_EDIT_BLOCK
sv_OperationMode = nSetup
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNotCalib (* TNotCalib *) FROM S_CheckIfCalib TO S_ConstSetup :=  #BEGIN_EDIT_BLOCK
(NOT sv_bDoTransducerCalib OR
NOT sv_bTransducerAvailable) AND
NOT sv_bNozzleAdjHMI AND
NOT sv_bMoveIdent
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TSetupReady (* TSetupReady *) FROM S_ConstSetup TO S_Ready :=  #BEGIN_EDIT_BLOCK
NOT abNozzleFwdConstSetup.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TCalib (* TCalib *) FROM S_CheckIfCalib TO S_CalibActivated :=  #BEGIN_EDIT_BLOCK
sv_bDoTransducerCalib AND
sv_bTransducerAvailable
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TCalibReady (* TCalibReady *) FROM S_CalibActivated TO S_Ready :=  #BEGIN_EDIT_BLOCK
NOT abNozzleFwdCalib.aRun.bActive OR bError
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNozzleAdj (* TNozzleAdj *) FROM S_CheckIfCalib TO S_ConstAdjust :=  #BEGIN_EDIT_BLOCK
NOT sv_bDoTransducerCalib AND
sv_bTransducerAvailable AND
sv_bNozzleAdjHMI
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNozzleAdjReady (* TNozzleAdjReady *) FROM S_ConstAdjust TO S_SetPosOffset :=  #BEGIN_EDIT_BLOCK
NOT abNozzleFwdConstAdjust.aRun.bActive AND
bStandStill
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans49 (* Trans49 *) FROM S_SetPosOffset TO S_Ready :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TNozzleAdjNotReady (* TNozzleAdjNotReady *) FROM S_ConstAdjust TO S_NozzleAdjustAborted :=  #BEGIN_EDIT_BLOCK
NOT abNozzleFwdConstAdjust.aRun.bActive AND
NOT bStandStill
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans36 (* Trans36 *) FROM S_NozzleAdjustAborted TO S_Ready :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TMoveIdentActivated (* TMoveIdentActivated *) FROM S_CheckIfCalib TO S_MoveIdent :=  #BEGIN_EDIT_BLOCK
sv_bMoveIdent
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TMoveIdentReady (* TMoveIdentReady *) FROM S_MoveIdent TO S_Ready :=  #BEGIN_EDIT_BLOCK
NOT abNozzleFwdStep.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNotSetup (* TNotSetup *) FROM S_CheckOpMode TO S_CheckMoveMode :=  #BEGIN_EDIT_BLOCK
sv_OperationMode <> nSetup
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TPositionMode (* TPositionMode *) FROM S_CheckMoveMode TO S_CheckContactPoint :=  #BEGIN_EDIT_BLOCK
sv_MovementMode = nPositionDependent
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TContactPoint (* TContactPoint *) FROM S_CheckContactPoint TO Step45 :=  #BEGIN_EDIT_BLOCK
sv_bContactPointDetected
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNoContactPoint (* TNoContactPoint *) FROM S_CheckContactPoint TO S_ContactPointNotDetected :=  #BEGIN_EDIT_BLOCK
NOT sv_bContactPointDetected
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans56 (* Trans56 *) FROM S_ContactPointNotDetected TO S_Ready :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNozzleNotFwd (* TNozzleNotFwd *) FROM Step45 TO S_ProfileMove :=  #BEGIN_EDIT_BLOCK
NOT sv_bNozzleFwd
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNozzleIsFwd (* TNozzleIsFwd *) FROM Step45 TO Step47 :=  #BEGIN_EDIT_BLOCK
sv_bNozzleFwd
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans71 (* Trans71 *) FROM Step47 TO S_CheckIfPressureBuildUp :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TProfileMoveReady (* TProfileMoveReady *) FROM S_ProfileMove TO S_Check :=  #BEGIN_EDIT_BLOCK
NOT abNozzleFwdProfile.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TContactPointOk (* TContactPointOk *) FROM S_Check TO S_NewPosOffset :=  #BEGIN_EDIT_BLOCK
bContactPointDetected
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TContactPointNotOk (* TContactPointNotOk *) FROM S_Check TO S_Ready :=  #BEGIN_EDIT_BLOCK
NOT bContactPointDetected
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans45 (* Trans45 *) FROM S_NewPosOffset TO S_CheckIfPressureBuildUp :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TLimitSwitch (* TLimitSwitch *) FROM S_CheckMoveMode TO S_CheckLimitSwitch :=  #BEGIN_EDIT_BLOCK
sv_MovementMode = nLimitSwitchDependent
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TLimitSwitchAvailable (* TLimitSwitchAvailable *) FROM S_CheckLimitSwitch TO S_ConstStage1 :=  #BEGIN_EDIT_BLOCK
mbLimitSwFwdLinked AND 
NOT di_LimitSwitchFwd
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TStartSecondStage (* TStartSecondStage *) FROM S_CheckLimitSwitch TO CheckLimits :=  #BEGIN_EDIT_BLOCK
mbLimitSwFwdLinked AND 
di_LimitSwitchFwd 

;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TGoToTimeDep (* TGoToTimeDep *) FROM CheckLimits TO S_ConstStage2 :=  #BEGIN_EDIT_BLOCK
NOT mbLimitSwFwd2Linked

;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TGoToSecLimitSwDep (* TGoToSecLimitSwDep *) FROM CheckLimits TO S_ConstStage2Di2 :=  #BEGIN_EDIT_BLOCK
mbLimitSwFwd2Linked AND 
NOT di_LimitSwitchFwd2
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TNozzleInFront (* TNozzleInFront *) FROM CheckLimits TO S_ActivateContactFAfterLimSW2 :=  #BEGIN_EDIT_BLOCK
mbLimitSwFwd2Linked 
AND di_LimitSwitchFwd2
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TLimitSwitchReached (* TLimitSwitchReached *) FROM S_ConstStage1 TO S_ConstStage2 :=  #BEGIN_EDIT_BLOCK
di_LimitSwitchFwd AND 
bVelC1Reached AND  
NOT mbLimitSwFwd2Linked
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TGoToNextLimitSwitch (* TGoToNextLimitSwitch *) FROM S_ConstStage1 TO S_ConstStage2Di2 :=  #BEGIN_EDIT_BLOCK
mbLimitSwFwd2Linked AND
di_LimitSwitchFwd AND 
bVelC1Reached 
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans44 (* Trans44 *) FROM S_ConstStage2Di2 TO S_ActivateContactFAfterLimSW2 :=  #BEGIN_EDIT_BLOCK
((NOT abNozzleFwdConstStage2.aRun.bActive)
AND(NOT abNozzleFwdConstStage1.aRun.bActive))
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans67 (* Trans67 *) FROM S_ActivateContactFAfterLimSW2 TO S_PreOut :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION Trans35 (* Trans35 *) FROM S_ConstStage1 TO S_PreOut :=  #BEGIN_EDIT_BLOCK
NOT abNozzleFwdConstStage1.aRun.bActive 
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TConstStage2Ready (* TConstStage2Ready *) FROM S_ConstStage2 TO S_ActivateContactFAfterLimSW1 :=  #BEGIN_EDIT_BLOCK
    (NOT abNozzleFwdConstStage2.aRun.bActive)
AND (NOT abNozzleFwdConstStage1.aRun.bActive)
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans68 (* Trans68 *) FROM S_ActivateContactFAfterLimSW1 TO S_PreOut :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans21 (* Trans21 *) FROM S_PreOut TO S_CheckIfPressureBuildUp :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TTimeMode (* TTimeMode *) FROM S_CheckMoveMode TO S_ConstTime :=  #BEGIN_EDIT_BLOCK
sv_MovementMode = nMoveTimeDependent
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TTimeMoveReady (* TTimeMoveReady *) FROM S_ConstTime TO S_ActivateConFAfterTimeElapsed :=  #BEGIN_EDIT_BLOCK
NOT abNozzleFwdConstStage2.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans64 (* Trans64 *) FROM S_ActivateConFAfterTimeElapsed TO S_CheckIfPressureBuildUp :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TMoveFwdContactF (* TMoveFwdContactF *) FROM S_CheckIfPressureBuildUp TO S_NozzlePressureBuildup :=  #BEGIN_EDIT_BLOCK
g_MoveCtrl.pData^.MoveId = cMoveFwdContactF
AND bContactPressBuildUp
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TPressBuiltUpReady (* TPressBuiltUpReady *) FROM S_NozzlePressureBuildup TO S_Ready :=  #BEGIN_EDIT_BLOCK
NOT abNozzleFwdPressBuildUp.aRun.bActive
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION TMoveFwd (* TMoveFwd *) FROM S_CheckIfPressureBuildUp TO S_AdaptDuration :=  #BEGIN_EDIT_BLOCK
g_MoveCtrl.pData^.MoveId = cMoveFwd
OR NOT bContactPressBuildUp
;#END_EDIT_BLOCK
END_TRANSITION

GO_ON_TRANSITION Trans72 (* Trans72 *) FROM S_AdaptDuration TO S_Ready :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

TRANSITION TReady (* TReady *) FROM S_Ready TO START :=  #BEGIN_EDIT_BLOCK
TRUE
;#END_EDIT_BLOCK
END_TRANSITION

(* end IecGraph-Code *)
(* sfc-code *)

(* stand alone actions *)
ACTION AResetConstBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
abNozzleFwdConstSetup.aRun(bStart := FALSE);

;#END_EDIT_BLOCK END_ACTION (*AResetConstBlock*)
ACTION AResetProfileBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
abNozzleFwdProfile.aRun(bStart := FALSE);


;#END_EDIT_BLOCK END_ACTION (*AResetProfileBlock*)
ACTION AResetConstStage1: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
abNozzleFwdConstStage1.aRun(bStart := FALSE);
bStage1Runned := TRUE;

;#END_EDIT_BLOCK END_ACTION (*AResetConstStage1*)
ACTION AResetConstStage2: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
dActiveTime := sv_NozzleFwdTimesAct.dActMoveTime;
abNozzleFwdConstStage2.aRun(bStart := FALSE);

//set move time
abNozzleFwdConstStage2.aSetMoveTime(dSetMoveTime := sv_dNozzleFwdStage2Set);

;#END_EDIT_BLOCK END_ACTION (*AResetConstStage2*)
ACTION AResetCalibBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
bError := FALSE;
abNozzleFwdCalib.aRun(bStart := FALSE,
                      LintabPoint := sv_TmpLintabPoint);
IF abNozzleFwdCalib.aRun.bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   bError := TRUE;
   dummy := Print("Calib Error: Reset calib block failed"); 
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AResetCalibBlock*)
ACTION ACheckVelCReached: #BEGIN_EDIT_BLOCK
bVelC1Reached := (ABS(sv_rVelocityAbs - sv_ConstFwdStage1.Velocity.Output.rOutputValue) < 0.1);

;#END_EDIT_BLOCK END_ACTION (*ACheckVelCReached*)
ACTION AS2PreOutput0: #BEGIN_EDIT_BLOCK
bStage1Runned := FALSE;

sv_ConstFwdStage2.Pressure.PreOutput.rOutputValue := 0.0;
sv_ConstFwdStage2.Velocity.PreOutput.rOutputValue := 0.0;

;#END_EDIT_BLOCK END_ACTION (*AS2PreOutput0*)
ACTION AS2PreOutputMax: #BEGIN_EDIT_BLOCK

IF bVelC1Reached THEN
  sv_ConstFwdStage2.Pressure.PreOutput.rOutputValue := sv_ConstFwdStage1.Pressure.Output.rOutputValue;
  sv_ConstFwdStage2.Velocity.PreOutput.rOutputValue := sv_ConstFwdStage1.Velocity.Output.rOutputValue;
END_IF;


;#END_EDIT_BLOCK END_ACTION (*AS2PreOutputMax*)
ACTION AStopConstStage1: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdConstStage1.aRun(bStop:=TRUE); 

;#END_EDIT_BLOCK END_ACTION (*AStopConstStage1*)
ACTION ACheckCalibError: #BEGIN_EDIT_BLOCK
IF bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   dummy := Print("Calib Error: %i", iErrorInfo);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckCalibError*)
ACTION AResetAdjustBlock: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//init supervision time
fbTSupervisionTime(IN := FALSE,
                   PT := sv_dMaxNozzleAdjustTime);

abNozzleFwdConstAdjust.aRun(bStart := FALSE);
bAutoAdjustAllowed := TRUE;

sv_rNozzlePositionOffset := 0.0;

;#END_EDIT_BLOCK END_ACTION (*AResetAdjustBlock*)
ACTION AResetStandStill: #BEGIN_EDIT_BLOCK
bStandStill := FALSE;

IF NOT mbLimitSwFwdLinked THEN
   fbStandStill(bDoCalib := FALSE);
END_IF;

;#END_EDIT_BLOCK END_ACTION (*AResetStandStill*)
ACTION ADetectStandStill: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bStandStill THEN
   IF mbLimitSwFwdLinked THEN
      bStandStill := di_LimitSwitchFwd;
   ELSE
      fbStandStill(rActVoltage := ai_Position,
                   bDoCalib := TRUE,
                   dCalibTime := sv_dSetStandstillDetectionTime,
                   rMaxVoltageDiff := sv_rMaxVoltageDiff,
                   bStandStill => bStandStill);
   END_IF;
END_IF;






;#END_EDIT_BLOCK END_ACTION (*ADetectStandStill*)
ACTION ASetNozzleOffset: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//calculate offset
//attention: offset is normally negative
sv_rNozzlePositionOffset := sv_rNozzlePositionOffset - sv_rNozzlePosition;

sv_rNozzleStrokePlaus := sv_rNozzleStroke + sv_rNozzlePositionOffset;

// automatically correct bwd profile if necessary
FOR i:=1 TO sv_NozzleBwdProfVis.Profile.iNoOfPoints + 1 DO
   sv_NozzleBwdProfVis.Profile.Points[i].rStartPos := 
         MIN(sv_NozzleBwdProfVis.Profile.Points[i].rStartPos, sv_rNozzleStrokePlaus);
END_FOR;

sv_bContactPointDetected := TRUE;
sv_bNozzleAdjHMI := FALSE;
SET_ALARM(erNozzleAdjustFinished);

;#END_EDIT_BLOCK END_ACTION (*ASetNozzleOffset*)
ACTION AResetConstBuildUpPress: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
*** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
***                       For further information see Comment tab!                        ***
*********************************************************************************************)

abNozzleFwdPressBuildUp.aRun(bStart := FALSE);

//set move time
abNozzleFwdPressBuildUp.aSetMoveTime(dSetMoveTime := sv_dNozzleFwdContactFSet);

sv_NozzleFwdContactFData.pdHoldDuration := @sv_dNozzleFwdContactFSet;

;#END_EDIT_BLOCK END_ACTION (*AResetConstBuildUpPress*)
ACTION AResetDetection: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bStandStill := FALSE;
fbStandStill(bDoCalib := FALSE);
fbRTrigStandstill(CLK := FALSE);
bContactPointDetected := FALSE;
bContactPointDetError := FALSE;

;#END_EDIT_BLOCK END_ACTION (*AResetDetection*)
ACTION ACheckPointReached: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)             

IF abNozzleFwdProfile.aRun.bTimeOut OR abNozzleFwdProfile.aRun.bError THEN
   //timeout or error during profile movement
   bContactPointDetected := FALSE;
ELSIF (((sv_rNozzlePosition > sv_rPosOffsetTolerance) AND bStandStill) 
   OR (sv_rNozzlePosition <= -sv_rPosOffsetTolerance)) THEN
   //standstill out of tolerance or movement finished out of tolerance
   bContactPointDetected := FALSE;
   SET_ALARM(erContactPointOutOfTolerance);  
ELSE
   //movement finished inside the tolerance
   bContactPointDetected := TRUE;
END_IF;

;#END_EDIT_BLOCK END_ACTION (*ACheckPointReached*)
ACTION ACheckContactPoint: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)             

fbStandStill(rActVoltage := ai_Position,
             bDoCalib := TRUE,
             dCalibTime := t#500ms,
             rMaxVoltageDiff := sv_rMaxVoltageDiff,
             bStandStill => bStandStill);

;#END_EDIT_BLOCK END_ACTION (*ACheckContactPoint*)
ACTION ADurationReference: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
*** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
***                       For further information see Comment tab!                        ***
*********************************************************************************************)

sv_NozzleFwdContactFData.pdHoldDuration := EMPTY;

;#END_EDIT_BLOCK END_ACTION (*ADurationReference*)
ACTION AReset: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdConstStage2.aRun(bStart := FALSE);

//set move time
abNozzleFwdConstStage2.aSetMoveTime(dSetMoveTime := sv_dNozzleFwdStage2Set); 

;#END_EDIT_BLOCK END_ACTION (*AReset*)
ACTION ASetFwdTimeReached: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

sv_bFwdTimeReached := (sv_dNozzleFwdStage2Act >= sv_dNozzleFwdStage2Set)

;#END_EDIT_BLOCK END_ACTION (*ASetFwdTimeReached*)
ACTION AResetConstStage2DI2: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

dActiveTime := sv_NozzleFwdTimesAct.dActMoveTime;
abNozzleFwdConstStage2.aRun(bStart := FALSE);

;#END_EDIT_BLOCK END_ACTION (*AResetConstStage2DI2*)
ACTION AResetIdentBlock: #BEGIN_EDIT_BLOCK
abNozzleFwdStep.aRun(bStart := FALSE);


;#END_EDIT_BLOCK END_ACTION (*AResetIdentBlock*)
ACTION ATransducerCalib: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdCalib.aRun(bStop := bStop OR sv_bTransducerError,
                      bStart := TRUE,
                      rActVoltage := ai_Position,
                      rMaxVoltageDiff := sv_rMaxVoltageDiff,
                      dStandStillDetectTime := sv_dStandStillDetectTime,
                      LintabPoint := sv_TmpLintabPoint,
                      rSetValue := 0.0,
                      dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                      bActive => sv_bOutputActive,
                      rOutputPre => sv_rPressureAbs,
                      rOutputVel => sv_rVelocityAbs,
                      bPreOutputReached => sv_bPreOutputReady,
                      iErrorInfo => iErrorInfo);
sv_bDoTransducerCalib := NOT (abNozzleFwdCalib.aRun.bPointDetected);
bError := abNozzleFwdCalib.aRun.bError OR bError;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*ATransducerCalib*)
ACTION AStepOutput: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdStep.aRun(bUsePosDetect := sv_rIdentPosition <> 0.0,
                     rPositionDown := (sv_rNozzlePosition + sv_rIdentPosition) * 0.5,
                     rLowOutput := sv_rMaxSpeedFwd * 0.1,
                     bStart := TRUE,
                     bStop := bStop,
                     bDirection := FALSE,
                     rActPos := sv_rNozzlePosition,
                     rTargetPos := sv_rIdentPosition,
                     dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                     dDelayTimeOff := sv_dSetDelayTimeOffFwd,
                     rPositionUp := sv_rNozzlePosition,
                     rHighOutput := sv_ConstFwdSetup.Velocity.Output.rOutputValue,
                     dMaxMoveTime := sv_NozzleFwdTimesSet.dMaxMoveTime,
                     rStopRamp := sv_rIdentStopRamp,
                     bActive => sv_bOutputActive,
                     rOutputPre => sv_rPressureAbs,
                     rOutputVel => sv_rVelocityAbs,
                     bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*AStepOutput*)
ACTION aRunProfile: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdProfile.aRun(bStop := bStop OR sv_bTransducerError OR bStandStill,
                        bStart := TRUE,
                        rActPosition := sv_rNozzlePosition,
                        dMaxMoveTime := sv_NozzleFwdTimesSet.dMaxMoveTime,
                        dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                        dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                        DeadTime := sv_dSetDelayTimeOffFwd,
                        rSmoothFactor := sv_rSmoothFactor,
                        bActive => sv_bOutputActive,
                        iActiveStage => sv_iActiveStage,
                        bPreOutputReached => sv_bPreOutputReady);

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abNozzleFwdProfile.aRun.rPressureOutput);
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abNozzleFwdProfile.aRun.rVelocityOutput);
b := WRITE_SV_DIRECT(sv_NozzleFwdTimesAct.dActMoveTime, abNozzleFwdProfile.aRun.dActMoveTime);


abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);

;#END_EDIT_BLOCK END_ACTION (*aRunProfile*)
ACTION aRunConstTime: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdConstStage2.aRun(bStart := TRUE,
                            bStop := bStop,
                            bUsePosDetect := FALSE,
                            dMaxTime := sv_NozzleFwdTimesSet.dMaxMoveTime,
                            dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                            dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                            bActive => sv_bOutputActive,
                            bPreOutputReached => sv_bPreOutputReady);

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abNozzleFwdConstStage2.aRun.rOutputPre);
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abNozzleFwdConstStage2.aRun.rOutputVel);
b := WRITE_SV_DIRECT(sv_NozzleFwdTimesAct.dActMoveTime, abNozzleFwdConstStage2.aRun.dActTime);
b := WRITE_SV_DIRECT(sv_dNozzleFwdStage2Act, sv_NozzleFwdTimesAct.dActMoveTime);


abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);

;#END_EDIT_BLOCK END_ACTION (*aRunConstTime*)
ACTION aRunConstStage2: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (bStage1Runned) THEN
   dDelayTimeOn := T#0s;
   dDelayTimeOff := T#0s;
ELSE
   dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump;
   dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve;   
END_IF;

abNozzleFwdConstStage2.aRun(dMaxTime := sv_NozzleFwdTimesSet.dMaxMoveTime - dActiveTime,
                            bStart := TRUE,
                            bStop := bStop,
                            bUsePosDetect := FALSE,
                            dDelayTimeOn := dDelayTimeOn,
                            dDelayTimeOff := dDelayTimeOff,
                            rOutputPre => tmpPressureAbs,
                            rOutputVel => tmpVelocityAbs,
                            bActive => sv_bOutputActive,
                            bPreOutputReached => sv_bPreOutputReady);
dActMoveTime := abNozzleFwdConstStage2.aRun.dActTime + dActiveTime;
b := WRITE_SV_DIRECT(sv_NozzleFwdTimesAct.dActMoveTime, dActMoveTime);
b := WRITE_SV_DIRECT(sv_dNozzleFwdStage2Act, abNozzleFwdConstStage2.aRun.dActTime);

// sv_bPreOutput must be true for 2nd cycle, then outputvalue is valid
IF (sv_bPreOutputReady AND bPreOutputOld) THEN
   b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, tmpPressureAbs);
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, tmpVelocityAbs);
END_IF;

bPreOutputOld := sv_bPreOutputReady;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);



;#END_EDIT_BLOCK END_ACTION (*aRunConstStage2*)
ACTION aRunConstStage1To2: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (bStage1Runned) THEN
   dDelayTimeOn := T#0s;
   dDelayTimeOff := T#0s;
ELSE
   dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump;
   dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve;   
END_IF;

abNozzleFwdConstStage2.aRun(bStop := bStop OR di_LimitSwitchFwd2,
                            dMaxTime := (sv_NozzleFwdTimesSet.dMaxMoveTime - dActiveTime),
                            bStart := TRUE,
                            bUsePosDetect := FALSE,
                            dDelayTimeOn := dDelayTimeOn,
                            dDelayTimeOff := dDelayTimeOff,
                            rOutputPre => tmpPressureAbs,
                            rOutputVel => tmpVelocityAbs,
                            bActive => sv_bOutputActive,
                            bPreOutputReached => sv_bPreOutputReady);
dActMoveTime := abNozzleFwdConstStage2.aRun.dActTime + dActiveTime;
b := WRITE_SV_DIRECT(sv_NozzleFwdTimesAct.dActMoveTime, dActMoveTime);

// sv_bPreOutput must be true for 2nd cycle, then outputvalue is valid
IF (sv_bPreOutputReady AND bPreOutputOld) THEN
   b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, tmpPressureAbs);
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, tmpVelocityAbs);
END_IF;

bPreOutputOld := sv_bPreOutputReady;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);



;#END_EDIT_BLOCK END_ACTION (*aRunConstStage1To2*)
ACTION aRunConstStage1: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdConstStage1.aRun(bStop := bStop OR (di_LimitSwitchFwd AND NOT bVelC1Reached),
                            bStart := TRUE,
                            bUsePosDetect := FALSE,
                            dMaxTime := sv_NozzleFwdTimesSet.dMaxMoveTime,
                            dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                            dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                            rOutputPre => tmpPressureAbs,
                            rOutputVel => tmpVelocityAbs,
                            bActive => sv_bOutputActive,
                            bPreOutputReached => sv_bPreOutputReady);

b := WRITE_SV_DIRECT(sv_NozzleFwdTimesAct.dActMoveTime, abNozzleFwdConstStage1.aRun.dActTime);

// sv_bPreOutput must be true for 2nd cycle, then outputvalue is valid
IF (sv_bPreOutputReady AND bPreOutputOld) THEN
   b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, tmpPressureAbs);
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, tmpVelocityAbs);
END_IF;

bPreOutputOld := sv_bPreOutputReady;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);

;#END_EDIT_BLOCK END_ACTION (*aRunConstStage1*)
ACTION aRunConstSetup: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdConstSetup.aRun(bStart := TRUE,
                           bStop := bStop,
                           bUsePosDetect := FALSE,
                           dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                           dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                           rOutputPre => sv_rPressureAbs,
                           rOutputVel => sv_rVelocityAbs,
                           bActive => sv_bOutputActive,
                           dActTime => sv_NozzleFwdTimesAct.dActMoveTime,
                           bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*aRunConstSetup*)
ACTION aRunConstBuildUpPress: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdPressBuildUp.aRun(bStart := TRUE,
                             bStop := bStop,
                             bUsePosDetect := FALSE,
                             dMaxTime := sv_NozzleFwdTimesSet.dMaxMoveTime,
                             dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                             dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                             bActive => sv_bOutputActive,
                             bPreOutputReached => sv_bPreOutputReady);

sv_bPressBuildUpActive := sv_bOutputActive;
b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abNozzleFwdPressBuildUp.aRun.rOutputPre);                       
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abNozzleFwdPressBuildUp.aRun.rOutputVel);
b := WRITE_SV_DIRECT(sv_dActPressureBuildUpTime, abNozzleFwdPressBuildUp.aRun.dActTime);  
b := WRITE_SV_DIRECT(sv_dNozzleFwdContactFAct, sv_dActPressureBuildUpTime);                     


abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);

;#END_EDIT_BLOCK END_ACTION (*aRunConstBuildUpPress*)
ACTION aRunConstAdjustSetup: #BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdConstAdjust.aRun(bStop := bStop OR bStandStill OR sv_bTransducerError OR NOT bAutoAdjustAllowed,
                            bStart := TRUE,
                            bUsePosDetect := FALSE,
                            dMaxTime := sv_NozzleFwdTimesSet.dMaxMoveTime,
                            dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                            dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                            rOutputPre => sv_rPressureAbs,
                            rOutputVel => sv_rVelocityAbs,
                            bActive => sv_bOutputActive,
                            dActTime => sv_NozzleFwdTimesAct.dActMoveTime,
                            bPreOutputReached => sv_bPreOutputReady);


abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);


abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);

;#END_EDIT_BLOCK END_ACTION (*aRunConstAdjustSetup*)
(* end sfc-code *)


END_ALGORITHM

POSTUPDATE_ALGORITHM pStrokeChanged ON PU_Task_7 WITH sv_rNozzleStroke

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//copy stroke to start position of first profile point
sv_NozzleFwdProfVis.Profile.Points[1].rStartPos := sv_rNozzleStroke;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paInitDebugMeasurement ON TaskSlow AUTOSTART


VAR
 fuName : STRING(255);
 variableName : STRING(255);
 swoState : KSWO_Status;
END_VAR
#BEGIN_EDIT_BLOCK
fuName := GET_MY_FU_NAME();
variableName := CONCAT(fuName,'.Fwd.rSetPressure bar');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rPressureAbs);
variableName := CONCAT(fuName,'.Fwd.rSetVelocity mm/s');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rVelocityAbs);
variableName := CONCAT(fuName,'.Fwd.bActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bOutputActive);
STOP_PROCESS_ALGORITHM();


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pMovementMode ON PU_Task_7 WITH sv_MovementMode,sv_bInitDone

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_MovementMode = nMoveTimeDependent THEN   
   sv_NozzleFwdContactFData.pdInjectDuration := @sv_dNozzleFwdStage2Set;    
ELSE  
   sv_NozzleFwdContactFData.pdInjectDuration := @sv_dCalculatedDurationFwd;
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pNozzleStroke ON PU_Task_7 WITH sv_bInitStart,sv_rNozzleStroke

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//update sv_rNozzleStrokePlaus (used for plaus on HMI) 
sv_rNozzleStrokePlaus := sv_rNozzleStroke + sv_rNozzlePositionOffset;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCpyAccelerations ON PU_Task_7 WITH sv_NozzleFwdProfVis.Profile.Points[2].rVelRamp


VAR_TEMP
 i : UDINT;
END_VAR
#BEGIN_EDIT_BLOCK
FOR i:= 3 TO 20 DO
    sv_NozzleFwdProfVis.Profile.Points[i].rVelRamp := sv_NozzleFwdProfVis.Profile.Points[2].rVelRamp;
END_FOR;



;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pActivateDeactivate ON PU_Task_7 WITH sv_dNozzleFwdContactFSet,sv_OperationMode,sv_bNozzleFwd,sv_bFwdTimeReached,sv_MovementMode

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//deactive movement NozzleFwdContactF in HA and FA mode
//if nozzle is already forward and contact force build up time is 0.0 sec
IF (sv_OperationMode = nSetup) OR (sv_OperationMode = nManual) OR (sv_dNozzleFwdContactFSet > t#0.0s) THEN
   sv_MoveFwdContactF.pbActivated := @sv_bTRUE;
ELSE
   //HA or FA active and set set for contact forec build up = 0 sec.
   IF ((sv_MovementMode = nMoveTimeDependent) AND sv_bFwdTimeReached) OR
      ((sv_MovementMode <> nMoveTimeDependent) AND sv_bNozzleFwd) THEN
      // nozzle is already forward -> deactivate
      sv_MoveFwdContactF.pbActivated := @sv_bFALSE;
   ELSE
      // nozzle not forward -> activate
      sv_MoveFwdContactF.pbActivated := @sv_bTRUE;
   END_IF;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 152 @Pou 25 
@@@BEG_Comment@@@
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".
@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
5 
@Var @RT(14)GET_MY_FU_NAME @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)SET_ALARM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(19)WRITE_SVREAL_DIRECT @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)WRITE_SV_DIRECT @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)KSWO_AddVariable @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
12 
@Var @RT(26)cLockGroupSafetyGateNozzle @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)62 @RT(59)Members: Nozzle Forward, Injection, Plast, Intrusion, Purge 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(15)cLockGroupMotor @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)69 @RT(56)Members: Mold, Ejector, Cores, Injection, Plast, Purge,  
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveFwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)12 @RT(16)movement forward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)nActive @RT(0) @T @T @DERIVED 0 @F @RT(16)tnActiveInactive @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)nInactive @RT(0) @T @T @DERIVED 0 @F @RT(16)tnActiveInactive @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)nSetup @RT(0) @T @T @DERIVED 0 @F @RT(15)tnOperationMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(36)Setup mode only for service engineer 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)nPositionDependent @RT(0) @T @T @DERIVED 0 @F @RT(14)tnMovementMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(21)nLimitSwitchDependent @RT(0) @T @T @DERIVED 0 @F @RT(14)tnMovementMode @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)nMoveTimeDependent @RT(0) @T @T @DERIVED 0 @F @RT(14)tnMovementMode @F 
@T 
@BEG_Attrib 
0 @RT(1)2 @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)cMoveFwdContactF @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)66 @RT(45)nozzle forward with building up contact force 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(18)tnCalibState_Error @RT(0) @T @T @DERIVED 0 @F @RT(12)tnCalibState @F 
@T 
@BEG_Attrib 
0 @RT(1)3 @RT(32)error occured during calibration 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)nManual @RT(0) @T @T @DERIVED 0 @F @RT(15)tnOperationMode @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(31)manual mode, play with switches 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(9)ABMoveFwd @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
88 
@Var @RT(13)sv_CalibState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsCalibMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_bTransducerAvailable @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_rNozzlePosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_rPressure @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_rVelocity @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_iActiveStage @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_ConstFwdSetup @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(63)constant output parameters of nozzle fwd movement in setup mode @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_ConstFwdStage1 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_ConstFwdStage2 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_NozzleFwdProfVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_NozzleBwdProfVis @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_VisProfile @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(30)profile of nozzle bwd movement @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_OperationMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnOperationMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_MoveFwdNozzle @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(11)ai_Position @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(34)analog input value from transducer @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)di_LimitSwitchFwd2 @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)di_LimitSwitchFwd @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(11)sv_DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_dStandStillDetectTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(29)time for standstill detection @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_rMaxVoltageDiff @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(45)max. voltage difference to detect stand still @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_TmpLintabPoint @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)KCTRL_Lintab_Point @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_bDoTransducerCalib @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_bOutputActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(16)Output is active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_bPreOutputReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(18)PreOutput is ready @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_bTransducerError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_MinOutputFwd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)tsMinOutput @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_dNozzleFwdStage2Set @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(67)time for output of nozzle fwd movement after limitswitch is touched @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_NozzleFwdTimesSet @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsSetTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_NozzleFwdTimesAct @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsActTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_dNozzleFwdStage2Act @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(67)time for output of nozzle fwd movement after limitswitch is touched @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_MovementMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)tnMovementMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(61)Nozzle Movement with Limitswitch or with position measurement @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_rNozzleStroke @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bInitStart @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_bContactPointDetected @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(35)flag: nozzle zero position detected @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LintabOutFwdP @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_LintabOutFwdV @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)KAPPL_LintabData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rVelocityAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rPressureAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(15)sv_rMaxSpeedFwd @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(12)sv_bInitDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bNozzleFwd @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_bNozzleAdjHMI @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(30)sv_dSetStandstillDetectionTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_dMaxNozzleAdjustTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_dActNozzleAdjustTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_rNozzlePositionOffset @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_rPosOffsetTolerance @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(56)Tolerance in mm for new position offset of contact point @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_dCalculatedDurationFwd @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(34)Calculated duration for nozzle fwd @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_MoveFwdContactF @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_ConstFwdContactF @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tsVelPre @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(76)constant output parameters of nozzle fwd contact pressure build-up movement  @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_dNozzleFwdContactFSet @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(60)set time for output of nozzle fwd pressure build up movement @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_dNozzleFwdContactFAct @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(65)act. set time for output of nozzle fwd pressure build up movement @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_bFwdTimeReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(110)nozzle fwd time reached (for time dependent nozzle control) (must be FastRetain: cyclical change in AutoCycle) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_bBwdTimeReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(110)nozzle bwd time reached (for time dependent nozzle control) (must be FastRetain: cyclical change in AutoCycle) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(27)sv_dCalcDurationFwdContactF @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(34)Calculated duration for nozzle fwd @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_NozzleFwdContactFData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(23)tsInjectHoldElementData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_rNozzleStrokePlaus @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(39)Nozzle stroke - Nozzle Position offset  @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_bPressBuildUpActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)TRUE: pressure build up is active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_dActPressureBuildUpTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(44)actual time for nozzle fwd pressure build up @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(13)sv_bMoveIdent @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rIdentPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_rIdentStopRamp @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_dSetDelayTimeOffFwd @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_rSmoothFactor @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(14)sv_dActFwdTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(56)actual nozzle fwd time (includes contact force build up) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(8)sv_bTRUE @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(9)sv_bFALSE @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(8)TaskSlow @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)TaskAnalog @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)PU_Task_7 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(22)erNozzleAdjustFinished @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(21)erNozzleAdjustAborted @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(21)erMaxNozzleAdjTimeExc @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(28)erContactPointOutOfTolerance @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(25)erContactPointNotDetected @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(14)erNozzleNotFwd @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)g_MoveCtrl @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveCtrl @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@Var @RT(18)abNozzleFwdProfile @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)ABProfileMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)abNozzleFwdConstSetup @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)ABConstMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)abNozzleFwdConstStage1 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)ABConstMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)abNozzleFwdConstStage2 @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)ABConstMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)mbLimitSwFwdLinked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)mbLimitSwFwd2Linked @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abNozzleFwdCalib @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)ABConstCalib @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(16)abLintabApplyVel @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)abLintabApplyPres @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(13)ABLintabApply @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)abNozzleFwdConstAdjust @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)ABConstMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(23)abNozzleFwdPressBuildUp @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)ABConstMovement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)abNozzleFwdStep @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)ABStepOutput @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

10 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(9)aRegister @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(18)abMovementRegister @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABMovementRegister @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(26)abMovementRegisterContactF @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)ABMovementRegister @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(5)aInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(17)pMinOutputChanged @STRUCTURED_TEXT 
@RT(0) @RT(29)sv_MinOutputFwd,sv_bInitStart @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(4)aRun @SEQUENTIAL_FLOW_CHART 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
25 
@Var @RT(5)bStop @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)bReady @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(12)dDelayTimeOn @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(13)dDelayTimeOff @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(12)dActMoveTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(18)fbSetMovementState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)FBSetMovementState @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)bVelC1Reached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)tmpPressureAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)tmpVelocityAbs @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)bPreOutputOld @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)bStage1Runned @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)bError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)iErrorInfo @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)fbTSupervisionTime @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(3)TON @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)dActiveTime @RT(0) @T @F @DT @RT(4)TIME @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)bStandStill @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)fbStandStill @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBStandStill @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)bAutoAdjustAllowed @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)bContactPressBuildUp @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)true if touch pressure should be built up @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)fbRTrigStandstill @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(6)R_TRIG @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)bContactPointDetected @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)bContactPointDetError @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(14)pStrokeChanged @STRUCTURED_TEXT 
@RT(0) @RT(16)sv_rNozzleStroke @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(22)paInitDebugMeasurement @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(8)TaskSlow @T @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
3 
@Var @RT(6)fuName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)variableName @RT(0) @T @F @DT @RT(11)STRING(255) @RT(0) @T @T @STRING 0 @F @RT(3)255 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)swoState @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSWO_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(13)pMovementMode @STRUCTURED_TEXT 
@RT(0) @RT(28)sv_MovementMode,sv_bInitDone @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(13)pNozzleStroke @STRUCTURED_TEXT 
@RT(0) @RT(30)sv_bInitStart,sv_rNozzleStroke @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(17)pCpyAccelerations @STRUCTURED_TEXT 
@RT(0) @RT(46)sv_NozzleFwdProfVis.Profile.Points[2].rVelRamp @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)i @RT(0) @T @F @DT @RT(5)UDINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(19)pActivateDeactivate @STRUCTURED_TEXT 
@RT(0) @RT(90)sv_dNozzleFwdContactFSet,sv_OperationMode,sv_bNozzleFwd,sv_bFwdTimeReached,sv_MovementMode @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Body 
@TL(39)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// movement registration
sv_MoveFwdNozzle.pdStartDelaySet := @sv_NozzleFwdTimesSet.dSetDelayTime;
sv_MoveFwdNozzle.pdStartDelayAct := @sv_NozzleFwdTimesAct.dActDelayTime;
sv_MoveFwdNozzle.pdActiveTimeAct := @sv_NozzleFwdTimesAct.dActMoveTime;
sv_MoveFwdNozzle.pdTimeLimit     := @sv_NozzleFwdTimesSet.dMaxMoveTime;
sv_MoveFwdNozzle.pdCalculatedDuration := @sv_dCalculatedDurationFwd;
sv_MoveFwdNozzle.LockGroups[1] := cLockGroupSafetyGateNozzle;
sv_MoveFwdNozzle.LockGroups[2] := cLockGroupMotor;
sv_MoveFwdNozzle.Alarm.AlarmId := erNozzleNotFwd;
sv_MoveFwdNozzle.Alarm.SubId[1] := sv_DeviceId.CompId;
sv_MoveFwdNozzle.Alarm.SubId[2] := sv_DeviceId.IndexId;
sv_MoveFwdNozzle.pbPosReached := @sv_bNozzleFwd;
sv_MoveFwdNozzle.sIconPath := CONCAT(GET_MY_FU_NAME(), '\hmi\images\movNozzleFwd.gif');

abMovementRegister.aRegister(@sv_MoveFwdNozzle);

// MoveFwdContactF movement registration
sv_MoveFwdContactF.pdStartDelaySet := @sv_NozzleFwdTimesSet.dSetDelayTime;
sv_MoveFwdContactF.pdStartDelayAct := @sv_NozzleFwdTimesAct.dActDelayTime;
sv_MoveFwdContactF.pdActiveTimeAct := @sv_dActFwdTime;
sv_MoveFwdContactF.pdTimeLimit     := @sv_NozzleFwdTimesSet.dMaxMoveTime;
sv_MoveFwdContactF.pdCalculatedDuration := @sv_dCalcDurationFwdContactF;
sv_MoveFwdContactF.LockGroups[1] := cLockGroupSafetyGateNozzle;
sv_MoveFwdContactF.LockGroups[2] := cLockGroupMotor;
sv_MoveFwdContactF.Alarm := sv_MoveFwdNozzle.Alarm;
sv_MoveFwdContactF.pbPosReached := @sv_bNozzleFwd;
sv_MoveFwdContactF.sIconPath := sv_MoveFwdNozzle.sIconPath;

abMovementRegisterContactF.aRegister(@sv_MoveFwdContactF);


mbLimitSwFwdLinked := IS_LINKED(di_LimitSwitchFwd);
mbLimitSwFwd2Linked := IS_LINKED(di_LimitSwitchFwd2);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(37)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdProfile.aInit(pProfile := @sv_NozzleFwdProfVis,
                         MoveDir := sv_MoveFwdNozzle.MoveDir,
                         pdCalcedDuration := @sv_dCalculatedDurationFwd,
                         prCalcDurationStartPosition := @sv_NozzleBwdProfVis.Profile.Points[sv_NozzleBwdProfVis.Profile.iNoOfPoints+1].rStartPos);

abNozzleFwdConstSetup.aInit(pConst := @sv_ConstFwdSetup,
                            MoveId := sv_MoveFwdNozzle.MoveId);

abNozzleFwdCalib.aInit(pConst := @sv_ConstFwdSetup,
                       MoveId := sv_MoveFwdNozzle.MoveId);

abNozzleFwdConstStage1.aInit(pConst := @sv_ConstFwdStage1,
                             MoveId := sv_MoveFwdNozzle.MoveId);

abNozzleFwdConstStage2.aInit(pConst := @sv_ConstFwdStage2,
                             MoveId := sv_MoveFwdNozzle.MoveId);

abLintabApplyPres.aInit(pLintab := @sv_LintabOutFwdP);

abLintabApplyVel.aInit(pLintab := @sv_LintabOutFwdV);

abNozzleFwdConstAdjust.aInit(pConst := @sv_ConstFwdSetup,
                             MoveId := sv_MoveFwdNozzle.MoveId);

abNozzleFwdPressBuildUp.aInit(pConst := @sv_ConstFwdContactF,
                              MoveId := sv_MoveFwdContactF.MoveId);

abNozzleFwdStep.aInit(pConst := @sv_ConstFwdSetup,
                      MoveId := cMoveFwd,
                      prMaxSpeed := @sv_rMaxSpeedFwd);


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(25)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//copy minoutput to fwd const stage1 movement
sv_ConstFwdStage1.Velocity.rMinOutput := sv_MinOutputFwd.rVelocity;
sv_ConstFwdStage1.Pressure.rMinOutput := sv_MinOutputFwd.rPressure;

//copy minoutput to fwd const stage2 movement
sv_ConstFwdStage2.Velocity.rMinOutput := sv_MinOutputFwd.rVelocity;
sv_ConstFwdStage2.Pressure.rMinOutput := sv_MinOutputFwd.rPressure;

//copy minoutput to fwd movement in setup mode
sv_ConstFwdSetup.Velocity.rMinOutput := sv_MinOutputFwd.rVelocity;
sv_ConstFwdSetup.Pressure.rMinOutput := sv_MinOutputFwd.rPressure;

//copy minoutput to const fwd movement for pressure build up
sv_ConstFwdContactF.Velocity.rMinOutput := sv_MinOutputFwd.rVelocity;
sv_ConstFwdContactF.Pressure.rMinOutput := sv_MinOutputFwd.rPressure;

//copy minoutput to fwd profile
sv_NozzleFwdProfVis.rMinOutputVel := sv_MinOutputFwd.rVelocity;
sv_NozzleFwdProfVis.rMinOutputPress := sv_MinOutputFwd.rPressure;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_SfcBody 
46 40 48 

@BEG_SfcData 2 
@StepSeq @RT(4)sseq @F 1 
@Loop @RT(4)loop @F 2 
@StepSeq @RT(4)sseq @F 5 
@Step @RT(5)START @F @T @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)AStart @F @T @RT(1)P @RT(0) @F @F @T @TL(9)
bReady := FALSE;
bContactPressBuildUp := FALSE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := g_MoveCtrl.pData^.MoveDir,
                   State    := nActive);

//reset bwd time reached
sv_bBwdTimeReached := FALSE;

@F 

@Trans @RT(6)TStart @F @T @F @F @T @F @TL(2)
TRUE

@RT(6)TStart @F 
@Step @RT(13)S_CheckOpMode @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(10)TSetupMode @F @T @F @F @T @F @TL(2)
sv_OperationMode = nSetup

@RT(10)TSetupMode @F 
@Step @RT(14)S_CheckIfCalib @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 4 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(9)TNotCalib @F @T @F @F @T @F @TL(5)
(NOT sv_bDoTransducerCalib OR
NOT sv_bTransducerAvailable) AND
NOT sv_bNozzleAdjHMI AND
NOT sv_bMoveIdent

@RT(9)TNotCalib @F 
@Step @RT(12)S_ConstSetup @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(16)AResetConstBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(14)aRunConstSetup @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(11)TSetupReady @F @T @F @F @T @T @TL(2)
NOT abNozzleFwdConstSetup.aRun.bActive

@RT(11)TSetupReady @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(6)TCalib @F @T @F @F @T @F @TL(3)
sv_bDoTransducerCalib AND
sv_bTransducerAvailable

@RT(6)TCalib @F 
@Step @RT(16)S_CalibActivated @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(16)AResetCalibBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(16)ATransducerCalib @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(16)ACheckCalibError @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(11)TCalibReady @F @T @F @F @T @T @TL(2)
NOT abNozzleFwdCalib.aRun.bActive OR bError

@RT(11)TCalibReady @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(10)TNozzleAdj @F @T @F @F @T @F @TL(4)
NOT sv_bDoTransducerCalib AND
sv_bTransducerAvailable AND
sv_bNozzleAdjHMI

@RT(10)TNozzleAdj @F 
@Step @RT(13)S_ConstAdjust @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 5 
@Acb @RT(17)AResetAdjustBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(16)AResetStandStill @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(17)ADetectStandStill @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(20)aRunConstAdjustSetup @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(21)ACheckSupervisionTime @F @T @RT(1)N @RT(0) @F @F @T @TL(7)
fbTSupervisionTime(IN := TRUE);
sv_dActNozzleAdjustTime := fbTSupervisionTime.ET;
IF fbTSupervisionTime.Q THEN
   bAutoAdjustAllowed := FALSE; 
   SET_ALARM(erMaxNozzleAdjTimeExc);
END_IF;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(15)TNozzleAdjReady @F @T @F @F @T @F @TL(3)
NOT abNozzleFwdConstAdjust.aRun.bActive AND
bStandStill

@RT(15)TNozzleAdjReady @F 
@Step @RT(14)S_SetPosOffset @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(16)ASetNozzleOffset @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(7)Trans49 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans49 @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(18)TNozzleAdjNotReady @F @T @F @F @T @T @TL(3)
NOT abNozzleFwdConstAdjust.aRun.bActive AND
NOT bStandStill

@RT(18)TNozzleAdjNotReady @F 
@Step @RT(21)S_NozzleAdjustAborted @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(8)Action38 @F @T @RT(1)P @RT(0) @F @F @T @TL(3)
sv_bNozzleAdjHMI := FALSE;
SET_ALARM(erNozzleAdjustAborted);

@F 

@Trans @RT(7)Trans36 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans36 @F 



@TransSeq @RT(4)tseq @F 3 
@Trans @RT(19)TMoveIdentActivated @F @T @F @F @T @F @TL(2)
sv_bMoveIdent

@RT(19)TMoveIdentActivated @F 
@Step @RT(11)S_MoveIdent @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(16)AResetIdentBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(11)AStepOutput @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(15)TMoveIdentReady @F @T @F @F @T @T @TL(2)
NOT abNozzleFwdStep.aRun.bActive

@RT(15)TMoveIdentReady @F 



@TransSeq @RT(4)tseq @F 5 
@Trans @RT(9)TNotSetup @F @T @F @F @T @F @TL(2)
sv_OperationMode <> nSetup

@RT(9)TNotSetup @F 
@Step @RT(15)S_CheckMoveMode @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 3 
@TransSeq @RT(4)tseq @F 11 
@Trans @RT(13)TPositionMode @F @T @F @F @T @F @TL(2)
sv_MovementMode = nPositionDependent

@RT(13)TPositionMode @F 
@Step @RT(19)S_CheckContactPoint @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(13)TContactPoint @F @T @F @F @T @F @TL(2)
sv_bContactPointDetected

@RT(13)TContactPoint @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(15)TNoContactPoint @F @T @F @F @T @F @TL(2)
NOT sv_bContactPointDetected

@RT(15)TNoContactPoint @F 
@Step @RT(25)S_ContactPointNotDetected @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(9)ASetAlarm @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
SET_ALARM(erContactPointNotDetected);

@F 

@Trans @RT(7)Trans56 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans56 @F 
@Goto @RT(7)S_Ready @F @F 


@Step @RT(6)Step45 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(13)TNozzleNotFwd @F @T @F @F @T @F @TL(2)
NOT sv_bNozzleFwd

@RT(13)TNozzleNotFwd @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(12)TNozzleIsFwd @F @T @F @F @T @F @TL(2)
sv_bNozzleFwd

@RT(12)TNozzleIsFwd @F 
@Step @RT(6)Step47 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(23)ASetContactPressBuildUp @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
bContactPressBuildUp := TRUE;

@F 

@Trans @RT(7)Trans71 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans71 @F 
@Goto @RT(24)S_CheckIfPressureBuildUp @F @F 


@Step @RT(13)S_ProfileMove @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 5 
@Acb @RT(18)AResetProfileBlock @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(15)AResetDetection @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(11)aRunProfile @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(18)ACheckContactPoint @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(18)ACheckPointReached @F @F @RT(2)P0 @RT(0) @F @F @F @F 

@Trans @RT(17)TProfileMoveReady @F @T @F @F @T @F @TL(2)
NOT abNozzleFwdProfile.aRun.bActive

@RT(17)TProfileMoveReady @F 
@Step @RT(7)S_Check @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(15)TContactPointOk @F @T @F @F @T @F @TL(2)
bContactPointDetected

@RT(15)TContactPointOk @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(18)TContactPointNotOk @F @T @F @F @T @F @TL(2)
NOT bContactPointDetected

@RT(18)TContactPointNotOk @F 
@Goto @RT(7)S_Ready @F @F 


@Step @RT(14)S_NewPosOffset @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(21)AActivateContactForce @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
bContactPressBuildUp := TRUE;

@F 

@Trans @RT(7)Trans45 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans45 @F 

@TransSeq @RT(4)tseq @F 11 
@Trans @RT(12)TLimitSwitch @F @T @F @F @T @F @TL(2)
sv_MovementMode = nLimitSwitchDependent

@RT(12)TLimitSwitch @F 
@Step @RT(18)S_CheckLimitSwitch @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(8)Action21 @F @T @RT(1)N @RT(0) @F @F @T @TL(3)
dActiveTime := T#0s;
sv_NozzleFwdTimesAct.dActMoveTime := T#0s;

@F 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(21)TLimitSwitchAvailable @F @T @F @F @T @F @TL(3)
mbLimitSwFwdLinked AND 
NOT di_LimitSwitchFwd

@RT(21)TLimitSwitchAvailable @F 

@TransSeq @RT(4)tseq @F 4 
@Trans @RT(17)TStartSecondStage @F @T @F @F @T @F @TL(4)
mbLimitSwFwdLinked AND 
di_LimitSwitchFwd 


@RT(17)TStartSecondStage @F 
@Step @RT(11)CheckLimits @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 3 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(12)TGoToTimeDep @F @T @F @F @T @F @TL(3)
NOT mbLimitSwFwd2Linked


@RT(12)TGoToTimeDep @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(18)TGoToSecLimitSwDep @F @T @F @F @T @F @TL(3)
mbLimitSwFwd2Linked AND 
NOT di_LimitSwitchFwd2

@RT(18)TGoToSecLimitSwDep @F 
@Goto @RT(16)S_ConstStage2Di2 @F @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(14)TNozzleInFront @F @T @F @F @T @F @TL(3)
mbLimitSwFwd2Linked 
AND di_LimitSwitchFwd2

@RT(14)TNozzleInFront @F 
@Goto @RT(29)S_ActivateContactFAfterLimSW2 @F @F 


@Goto @RT(13)S_ConstStage2 @F @F 


@Step @RT(13)S_ConstStage1 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 4 
@Acb @RT(17)AResetConstStage1 @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(17)ACheckVelCReached @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(15)AS2PreOutputMax @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(15)aRunConstStage1 @F @F @RT(1)N @RT(0) @F @F @F @F 

@AltBranch @RT(3)alt @F 3 
@TransSeq @RT(4)tseq @F 1 
@Trans @RT(19)TLimitSwitchReached @F @T @F @F @T @F @TL(4)
di_LimitSwitchFwd AND 
bVelC1Reached AND  
NOT mbLimitSwFwd2Linked

@RT(19)TLimitSwitchReached @F 

@TransSeq @RT(4)tseq @F 6 
@Trans @RT(20)TGoToNextLimitSwitch @F @T @F @F @T @F @TL(4)
mbLimitSwFwd2Linked AND
di_LimitSwitchFwd AND 
bVelC1Reached 

@RT(20)TGoToNextLimitSwitch @F 
@Step @RT(16)S_ConstStage2Di2 @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(20)AResetConstStage2DI2 @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(16)AStopConstStage1 @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(18)aRunConstStage1To2 @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(7)Trans44 @F @T @F @F @T @F @TL(3)
((NOT abNozzleFwdConstStage2.aRun.bActive)
AND(NOT abNozzleFwdConstStage1.aRun.bActive))

@RT(7)Trans44 @F 
@Step @RT(29)S_ActivateContactFAfterLimSW2 @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(24)AActivateConFAfterLimSW2 @F @T @RT(1)P @RT(0) @F @F @T @TL(4)
IF di_LimitSwitchFwd2 THEN
   bContactPressBuildUp := TRUE;
END_IF;

@F 

@Trans @RT(7)Trans67 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans67 @F 
@Goto @RT(8)S_PreOut @F @F 

@TransSeq @RT(4)tseq @F 2 
@Trans @RT(7)Trans35 @F @T @F @F @T @T @TL(2)
NOT abNozzleFwdConstStage1.aRun.bActive 

@RT(7)Trans35 @F 
@Goto @RT(8)S_PreOut @F @F 


@Step @RT(13)S_ConstStage2 @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(17)AResetConstStage2 @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(16)AStopConstStage1 @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(15)aRunConstStage2 @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(17)TConstStage2Ready @F @T @F @F @T @F @TL(3)
    (NOT abNozzleFwdConstStage2.aRun.bActive)
AND (NOT abNozzleFwdConstStage1.aRun.bActive)

@RT(17)TConstStage2Ready @F 
@Step @RT(29)S_ActivateContactFAfterLimSW1 @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(24)AActivateConFAfterLimSW1 @F @T @RT(1)P @RT(0) @F @F @T @TL(4)
IF (sv_dNozzleFwdStage2Act >= sv_dNozzleFwdStage2Set) THEN
   bContactPressBuildUp := TRUE;
END_IF;

@F 

@Trans @RT(7)Trans68 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans68 @F 
@Step @RT(8)S_PreOut @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(13)AS2PreOutput0 @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(7)Trans21 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans21 @F 

@TransSeq @RT(4)tseq @F 5 
@Trans @RT(9)TTimeMode @F @T @F @F @T @F @TL(2)
sv_MovementMode = nMoveTimeDependent

@RT(9)TTimeMode @F 
@Step @RT(11)S_ConstTime @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 3 
@Acb @RT(6)AReset @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(13)aRunConstTime @F @F @RT(1)N @RT(0) @F @F @F @F 
@Acb @RT(18)ASetFwdTimeReached @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(14)TTimeMoveReady @F @T @F @F @T @F @TL(2)
NOT abNozzleFwdConstStage2.aRun.bActive

@RT(14)TTimeMoveReady @F 
@Step @RT(30)S_ActivateConFAfterTimeElapsed @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(29)AActivateConFAfterTimeElapsed @F @T @RT(1)P @RT(0) @F @F @T @TL(2)
bContactPressBuildUp := sv_bFwdTimeReached;

@F 

@Trans @RT(7)Trans64 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans64 @F 


@Step @RT(24)S_CheckIfPressureBuildUp @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 0 

@AltBranch @RT(3)alt @F 2 
@TransSeq @RT(4)tseq @F 3 
@Trans @RT(16)TMoveFwdContactF @F @T @F @F @T @F @TL(3)
g_MoveCtrl.pData^.MoveId = cMoveFwdContactF
AND bContactPressBuildUp

@RT(16)TMoveFwdContactF @F 
@Step @RT(23)S_NozzlePressureBuildup @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 2 
@Acb @RT(23)AResetConstBuildUpPress @F @F @RT(1)P @RT(0) @F @F @F @F 
@Acb @RT(21)aRunConstBuildUpPress @F @F @RT(1)N @RT(0) @F @F @F @F 

@Trans @RT(18)TPressBuiltUpReady @F @T @F @F @T @F @TL(2)
NOT abNozzleFwdPressBuildUp.aRun.bActive

@RT(18)TPressBuiltUpReady @F 

@TransSeq @RT(4)tseq @F 3 
@Trans @RT(8)TMoveFwd @F @T @F @F @T @F @TL(3)
g_MoveCtrl.pData^.MoveId = cMoveFwd
OR NOT bContactPressBuildUp

@RT(8)TMoveFwd @F 
@Step @RT(15)S_AdaptDuration @F @F @F @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(18)ADurationReference @F @F @RT(1)P @RT(0) @F @F @F @F 

@Trans @RT(7)Trans72 @F @T @F @F @T @F @TL(2)
TRUE

@RT(7)Trans72 @F 




@Step @RT(7)S_Ready @F @F @T @F @RT(0) @F 
@AcbCont @RT(7)unnamed @F 1 
@Acb @RT(6)AReady @F @T @RT(1)P @RT(0) @F @F @T @TL(5)
bReady := TRUE;
fbSetMovementState(MoveId   := g_MoveCtrl.pData^.MoveId,
                   MoveDir  := g_MoveCtrl.pData^.MoveDir,
                   State    := nInactive);

@F 


@Trans @RT(6)TReady @F @T @T @T @T @T @TL(2)
TRUE

@RT(6)TReady @F 

@END_SfcData 
@SaActions 33 
@SaText @RT(16)AResetConstBlock 1 @TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
abNozzleFwdConstSetup.aRun(bStart := FALSE);


@SaText @RT(18)AResetProfileBlock 1 @TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
abNozzleFwdProfile.aRun(bStart := FALSE);



@SaText @RT(17)AResetConstStage1 1 @TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
abNozzleFwdConstStage1.aRun(bStart := FALSE);
bStage1Runned := TRUE;


@SaText @RT(17)AResetConstStage2 1 @TL(10)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
dActiveTime := sv_NozzleFwdTimesAct.dActMoveTime;
abNozzleFwdConstStage2.aRun(bStart := FALSE);

//set move time
abNozzleFwdConstStage2.aSetMoveTime(dSetMoveTime := sv_dNozzleFwdStage2Set);


@SaText @RT(16)AResetCalibBlock 1 @TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)
 
bError := FALSE;
abNozzleFwdCalib.aRun(bStart := FALSE,
                      LintabPoint := sv_TmpLintabPoint);
IF abNozzleFwdCalib.aRun.bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   bError := TRUE;
   dummy := Print("Calib Error: Reset calib block failed"); 
END_IF;


@SaText @RT(17)ACheckVelCReached 1 @TL(2)
bVelC1Reached := (ABS(sv_rVelocityAbs - sv_ConstFwdStage1.Velocity.Output.rOutputValue) < 0.1);


@SaText @RT(13)AS2PreOutput0 1 @TL(5)
bStage1Runned := FALSE;

sv_ConstFwdStage2.Pressure.PreOutput.rOutputValue := 0.0;
sv_ConstFwdStage2.Velocity.PreOutput.rOutputValue := 0.0;


@SaText @RT(15)AS2PreOutputMax 1 @TL(7)

IF bVelC1Reached THEN
  sv_ConstFwdStage2.Pressure.PreOutput.rOutputValue := sv_ConstFwdStage1.Pressure.Output.rOutputValue;
  sv_ConstFwdStage2.Velocity.PreOutput.rOutputValue := sv_ConstFwdStage1.Velocity.Output.rOutputValue;
END_IF;



@SaText @RT(16)AStopConstStage1 1 @TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdConstStage1.aRun(bStop:=TRUE); 


@SaText @RT(16)ACheckCalibError 1 @TL(5)
IF bError THEN
   sv_CalibState.Status := tnCalibState_Error;
   dummy := Print("Calib Error: %i", iErrorInfo);
END_IF;


@SaText @RT(17)AResetAdjustBlock 1 @TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//init supervision time
fbTSupervisionTime(IN := FALSE,
                   PT := sv_dMaxNozzleAdjustTime);

abNozzleFwdConstAdjust.aRun(bStart := FALSE);
bAutoAdjustAllowed := TRUE;

sv_rNozzlePositionOffset := 0.0;


@SaText @RT(16)AResetStandStill 1 @TL(6)
bStandStill := FALSE;

IF NOT mbLimitSwFwdLinked THEN
   fbStandStill(bDoCalib := FALSE);
END_IF;


@SaText @RT(17)ADetectStandStill 1 @TL(22)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF NOT bStandStill THEN
   IF mbLimitSwFwdLinked THEN
      bStandStill := di_LimitSwitchFwd;
   ELSE
      fbStandStill(rActVoltage := ai_Position,
                   bDoCalib := TRUE,
                   dCalibTime := sv_dSetStandstillDetectionTime,
                   rMaxVoltageDiff := sv_rMaxVoltageDiff,
                   bStandStill => bStandStill);
   END_IF;
END_IF;







@SaText @RT(16)ASetNozzleOffset 1 @TL(21)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//calculate offset
//attention: offset is normally negative
sv_rNozzlePositionOffset := sv_rNozzlePositionOffset - sv_rNozzlePosition;

sv_rNozzleStrokePlaus := sv_rNozzleStroke + sv_rNozzlePositionOffset;

// automatically correct bwd profile if necessary
FOR i:=1 TO sv_NozzleBwdProfVis.Profile.iNoOfPoints + 1 DO
   sv_NozzleBwdProfVis.Profile.Points[i].rStartPos := 
         MIN(sv_NozzleBwdProfVis.Profile.Points[i].rStartPos, sv_rNozzleStrokePlaus);
END_FOR;

sv_bContactPointDetected := TRUE;
sv_bNozzleAdjHMI := FALSE;
SET_ALARM(erNozzleAdjustFinished);


@SaText @RT(23)AResetConstBuildUpPress 1 @TL(12)
(**************************************** WARNING ********************************************
*** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
***                       For further information see Comment tab!                        ***
*********************************************************************************************)

abNozzleFwdPressBuildUp.aRun(bStart := FALSE);

//set move time
abNozzleFwdPressBuildUp.aSetMoveTime(dSetMoveTime := sv_dNozzleFwdContactFSet);

sv_NozzleFwdContactFData.pdHoldDuration := @sv_dNozzleFwdContactFSet;


@SaText @RT(15)AResetDetection 1 @TL(11)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

bStandStill := FALSE;
fbStandStill(bDoCalib := FALSE);
fbRTrigStandstill(CLK := FALSE);
bContactPointDetected := FALSE;
bContactPointDetError := FALSE;


@SaText @RT(18)ACheckPointReached 1 @TL(18)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)             

IF abNozzleFwdProfile.aRun.bTimeOut OR abNozzleFwdProfile.aRun.bError THEN
   //timeout or error during profile movement
   bContactPointDetected := FALSE;
ELSIF (((sv_rNozzlePosition > sv_rPosOffsetTolerance) AND bStandStill) 
   OR (sv_rNozzlePosition <= -sv_rPosOffsetTolerance)) THEN
   //standstill out of tolerance or movement finished out of tolerance
   bContactPointDetected := FALSE;
   SET_ALARM(erContactPointOutOfTolerance);  
ELSE
   //movement finished inside the tolerance
   bContactPointDetected := TRUE;
END_IF;


@SaText @RT(18)ACheckContactPoint 1 @TL(11)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)             

fbStandStill(rActVoltage := ai_Position,
             bDoCalib := TRUE,
             dCalibTime := t#500ms,
             rMaxVoltageDiff := sv_rMaxVoltageDiff,
             bStandStill => bStandStill);


@SaText @RT(18)ADurationReference 1 @TL(7)
(**************************************** WARNING ********************************************
*** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
***                       For further information see Comment tab!                        ***
*********************************************************************************************)

sv_NozzleFwdContactFData.pdHoldDuration := EMPTY;


@SaText @RT(6)AReset 1 @TL(10)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdConstStage2.aRun(bStart := FALSE);

//set move time
abNozzleFwdConstStage2.aSetMoveTime(dSetMoveTime := sv_dNozzleFwdStage2Set); 


@SaText @RT(18)ASetFwdTimeReached 1 @TL(7)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

sv_bFwdTimeReached := (sv_dNozzleFwdStage2Act >= sv_dNozzleFwdStage2Set)


@SaText @RT(20)AResetConstStage2DI2 1 @TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

dActiveTime := sv_NozzleFwdTimesAct.dActMoveTime;
abNozzleFwdConstStage2.aRun(bStart := FALSE);


@SaText @RT(16)AResetIdentBlock 1 @TL(3)
abNozzleFwdStep.aRun(bStart := FALSE);



@SaText @RT(16)ATransducerCalib 1 @TL(28)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdCalib.aRun(bStop := bStop OR sv_bTransducerError,
                      bStart := TRUE,
                      rActVoltage := ai_Position,
                      rMaxVoltageDiff := sv_rMaxVoltageDiff,
                      dStandStillDetectTime := sv_dStandStillDetectTime,
                      LintabPoint := sv_TmpLintabPoint,
                      rSetValue := 0.0,
                      dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                      dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                      bActive => sv_bOutputActive,
                      rOutputPre => sv_rPressureAbs,
                      rOutputVel => sv_rVelocityAbs,
                      bPreOutputReached => sv_bPreOutputReady,
                      iErrorInfo => iErrorInfo);
sv_bDoTransducerCalib := NOT (abNozzleFwdCalib.aRun.bPointDetected);
bError := abNozzleFwdCalib.aRun.bError OR bError;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


@SaText @RT(11)AStepOutput 1 @TL(30)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdStep.aRun(bUsePosDetect := sv_rIdentPosition <> 0.0,
                     rPositionDown := (sv_rNozzlePosition + sv_rIdentPosition) * 0.5,
                     rLowOutput := sv_rMaxSpeedFwd * 0.1,
                     bStart := TRUE,
                     bStop := bStop,
                     bDirection := FALSE,
                     rActPos := sv_rNozzlePosition,
                     rTargetPos := sv_rIdentPosition,
                     dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                     dDelayTimeOff := sv_dSetDelayTimeOffFwd,
                     rPositionUp := sv_rNozzlePosition,
                     rHighOutput := sv_ConstFwdSetup.Velocity.Output.rOutputValue,
                     dMaxMoveTime := sv_NozzleFwdTimesSet.dMaxMoveTime,
                     rStopRamp := sv_rIdentStopRamp,
                     bActive => sv_bOutputActive,
                     rOutputPre => sv_rPressureAbs,
                     rOutputVel => sv_rVelocityAbs,
                     bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


@SaText @RT(11)aRunProfile 1 @TL(28)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdProfile.aRun(bStop := bStop OR sv_bTransducerError OR bStandStill,
                        bStart := TRUE,
                        rActPosition := sv_rNozzlePosition,
                        dMaxMoveTime := sv_NozzleFwdTimesSet.dMaxMoveTime,
                        dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                        dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                        DeadTime := sv_dSetDelayTimeOffFwd,
                        rSmoothFactor := sv_rSmoothFactor,
                        bActive => sv_bOutputActive,
                        iActiveStage => sv_iActiveStage,
                        bPreOutputReached => sv_bPreOutputReady);

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abNozzleFwdProfile.aRun.rPressureOutput);
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abNozzleFwdProfile.aRun.rVelocityOutput);
b := WRITE_SV_DIRECT(sv_NozzleFwdTimesAct.dActMoveTime, abNozzleFwdProfile.aRun.dActMoveTime);


abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);


@SaText @RT(13)aRunConstTime 1 @TL(26)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdConstStage2.aRun(bStart := TRUE,
                            bStop := bStop,
                            bUsePosDetect := FALSE,
                            dMaxTime := sv_NozzleFwdTimesSet.dMaxMoveTime,
                            dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                            dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                            bActive => sv_bOutputActive,
                            bPreOutputReached => sv_bPreOutputReady);

b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abNozzleFwdConstStage2.aRun.rOutputPre);
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abNozzleFwdConstStage2.aRun.rOutputVel);
b := WRITE_SV_DIRECT(sv_NozzleFwdTimesAct.dActMoveTime, abNozzleFwdConstStage2.aRun.dActTime);
b := WRITE_SV_DIRECT(sv_dNozzleFwdStage2Act, sv_NozzleFwdTimesAct.dActMoveTime);


abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);


@SaText @RT(15)aRunConstStage2 1 @TL(43)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (bStage1Runned) THEN
   dDelayTimeOn := T#0s;
   dDelayTimeOff := T#0s;
ELSE
   dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump;
   dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve;   
END_IF;

abNozzleFwdConstStage2.aRun(dMaxTime := sv_NozzleFwdTimesSet.dMaxMoveTime - dActiveTime,
                            bStart := TRUE,
                            bStop := bStop,
                            bUsePosDetect := FALSE,
                            dDelayTimeOn := dDelayTimeOn,
                            dDelayTimeOff := dDelayTimeOff,
                            rOutputPre => tmpPressureAbs,
                            rOutputVel => tmpVelocityAbs,
                            bActive => sv_bOutputActive,
                            bPreOutputReached => sv_bPreOutputReady);
dActMoveTime := abNozzleFwdConstStage2.aRun.dActTime + dActiveTime;
b := WRITE_SV_DIRECT(sv_NozzleFwdTimesAct.dActMoveTime, dActMoveTime);
b := WRITE_SV_DIRECT(sv_dNozzleFwdStage2Act, abNozzleFwdConstStage2.aRun.dActTime);

// sv_bPreOutput must be true for 2nd cycle, then outputvalue is valid
IF (sv_bPreOutputReady AND bPreOutputOld) THEN
   b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, tmpPressureAbs);
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, tmpVelocityAbs);
END_IF;

bPreOutputOld := sv_bPreOutputReady;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);




@SaText @RT(18)aRunConstStage1To2 1 @TL(42)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (bStage1Runned) THEN
   dDelayTimeOn := T#0s;
   dDelayTimeOff := T#0s;
ELSE
   dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump;
   dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve;   
END_IF;

abNozzleFwdConstStage2.aRun(bStop := bStop OR di_LimitSwitchFwd2,
                            dMaxTime := (sv_NozzleFwdTimesSet.dMaxMoveTime - dActiveTime),
                            bStart := TRUE,
                            bUsePosDetect := FALSE,
                            dDelayTimeOn := dDelayTimeOn,
                            dDelayTimeOff := dDelayTimeOff,
                            rOutputPre => tmpPressureAbs,
                            rOutputVel => tmpVelocityAbs,
                            bActive => sv_bOutputActive,
                            bPreOutputReached => sv_bPreOutputReady);
dActMoveTime := abNozzleFwdConstStage2.aRun.dActTime + dActiveTime;
b := WRITE_SV_DIRECT(sv_NozzleFwdTimesAct.dActMoveTime, dActMoveTime);

// sv_bPreOutput must be true for 2nd cycle, then outputvalue is valid
IF (sv_bPreOutputReady AND bPreOutputOld) THEN
   b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, tmpPressureAbs);
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, tmpVelocityAbs);
END_IF;

bPreOutputOld := sv_bPreOutputReady;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);




@SaText @RT(15)aRunConstStage1 1 @TL(32)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdConstStage1.aRun(bStop := bStop OR (di_LimitSwitchFwd AND NOT bVelC1Reached),
                            bStart := TRUE,
                            bUsePosDetect := FALSE,
                            dMaxTime := sv_NozzleFwdTimesSet.dMaxMoveTime,
                            dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                            dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                            rOutputPre => tmpPressureAbs,
                            rOutputVel => tmpVelocityAbs,
                            bActive => sv_bOutputActive,
                            bPreOutputReached => sv_bPreOutputReady);

b := WRITE_SV_DIRECT(sv_NozzleFwdTimesAct.dActMoveTime, abNozzleFwdConstStage1.aRun.dActTime);

// sv_bPreOutput must be true for 2nd cycle, then outputvalue is valid
IF (sv_bPreOutputReady AND bPreOutputOld) THEN
   b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, tmpPressureAbs);
   b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, tmpVelocityAbs);
END_IF;

bPreOutputOld := sv_bPreOutputReady;

abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);


@SaText @RT(14)aRunConstSetup 1 @TL(22)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdConstSetup.aRun(bStart := TRUE,
                           bStop := bStop,
                           bUsePosDetect := FALSE,
                           dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                           dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                           rOutputPre => sv_rPressureAbs,
                           rOutputVel => sv_rVelocityAbs,
                           bActive => sv_bOutputActive,
                           dActTime => sv_NozzleFwdTimesAct.dActMoveTime,
                           bPreOutputReached => sv_bPreOutputReady);

abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


@SaText @RT(21)aRunConstBuildUpPress 1 @TL(27)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdPressBuildUp.aRun(bStart := TRUE,
                             bStop := bStop,
                             bUsePosDetect := FALSE,
                             dMaxTime := sv_NozzleFwdTimesSet.dMaxMoveTime,
                             dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                             dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                             bActive => sv_bOutputActive,
                             bPreOutputReached => sv_bPreOutputReady);

sv_bPressBuildUpActive := sv_bOutputActive;
b := WRITE_SVREAL_DIRECT(sv_rPressureAbs, abNozzleFwdPressBuildUp.aRun.rOutputPre);                       
b := WRITE_SVREAL_DIRECT(sv_rVelocityAbs, abNozzleFwdPressBuildUp.aRun.rOutputVel);
b := WRITE_SV_DIRECT(sv_dActPressureBuildUpTime, abNozzleFwdPressBuildUp.aRun.dActTime);  
b := WRITE_SV_DIRECT(sv_dNozzleFwdContactFAct, sv_dActPressureBuildUpTime);                     


abLintabApplyPres.aCalc(rX := sv_rPressureAbs);
b := WRITE_SVREAL_DIRECT(sv_rPressure, abLintabApplyPres.aCalc.rY);

abLintabApplyVel.aCalc(rX := sv_rVelocityAbs);
b := WRITE_SVREAL_DIRECT(sv_rVelocity, abLintabApplyVel.aCalc.rY);


@SaText @RT(20)aRunConstAdjustSetup 1 @TL(25)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abNozzleFwdConstAdjust.aRun(bStop := bStop OR bStandStill OR sv_bTransducerError OR NOT bAutoAdjustAllowed,
                            bStart := TRUE,
                            bUsePosDetect := FALSE,
                            dMaxTime := sv_NozzleFwdTimesSet.dMaxMoveTime,
                            dDelayTimeOn := sv_NozzleFwdTimesSet.dSetDelayTimePump,
                            dDelayTimeOff := sv_NozzleFwdTimesSet.dSetDelayTimeValve,
                            rOutputPre => sv_rPressureAbs,
                            rOutputVel => sv_rVelocityAbs,
                            bActive => sv_bOutputActive,
                            dActTime => sv_NozzleFwdTimesAct.dActMoveTime,
                            bPreOutputReached => sv_bPreOutputReady);


abLintabApplyPres.aCalc(rX := sv_rPressureAbs,
                        rY => sv_rPressure);


abLintabApplyVel.aCalc(rX := sv_rVelocityAbs,
                       rY => sv_rVelocity);


@SaTrans 0 
@SaExits 0 
@END_SfcBody 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//copy stroke to start position of first profile point
sv_NozzleFwdProfVis.Profile.Points[1].rStartPos := sv_rNozzleStroke;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(15)
fuName := GET_MY_FU_NAME();
variableName := CONCAT(fuName,'.Fwd.rSetPressure bar');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rPressureAbs);
variableName := CONCAT(fuName,'.Fwd.rSetVelocity mm/s');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_rVelocityAbs);
variableName := CONCAT(fuName,'.Fwd.bActive');
swoState := KSWO_AddVariable( Task := TaskAnalog,
                              Name := variableName,
                              Variable := sv_bOutputActive);
STOP_PROCESS_ALGORITHM();

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(12)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_MovementMode = nMoveTimeDependent THEN   
   sv_NozzleFwdContactFData.pdInjectDuration := @sv_dNozzleFwdStage2Set;    
ELSE  
   sv_NozzleFwdContactFData.pdInjectDuration := @sv_dCalculatedDurationFwd;
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//update sv_rNozzleStrokePlaus (used for plaus on HMI) 
sv_rNozzleStrokePlaus := sv_rNozzleStroke + sv_rNozzlePositionOffset;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(5)
FOR i:= 3 TO 20 DO
    sv_NozzleFwdProfVis.Profile.Points[i].rVelRamp := sv_NozzleFwdProfVis.Profile.Points[2].rVelRamp;
END_FOR;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(21)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//deactive movement NozzleFwdContactF in HA and FA mode
//if nozzle is already forward and contact force build up time is 0.0 sec
IF (sv_OperationMode = nSetup) OR (sv_OperationMode = nManual) OR (sv_dNozzleFwdContactFSet > t#0.0s) THEN
   sv_MoveFwdContactF.pbActivated := @sv_bTRUE;
ELSE
   //HA or FA active and set set for contact forec build up = 0 sec.
   IF ((sv_MovementMode = nMoveTimeDependent) AND sv_bFwdTimeReached) OR
      ((sv_MovementMode <> nMoveTimeDependent) AND sv_bNozzleFwd) THEN
      // nozzle is already forward -> deactivate
      sv_MoveFwdContactF.pbActivated := @sv_bFALSE;
   ELSE
      // nozzle not forward -> activate
      sv_MoveFwdContactF.pbActivated := @sv_bTRUE;
   END_IF;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
