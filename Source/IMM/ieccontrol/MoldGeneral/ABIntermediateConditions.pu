(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

This AB is responsible for 
- maintainance of mTmpFwdInterruptList, mTmpBwdInterruptList, sv_FwdInterruptList and sv_BwdInterruptList
  (after new sequence was created, the temporary lists are copied to the sv´s)
- getting the according target value (sv_rFwdInterruptPosition, sv_rBwdInterruptPosition)
  if start event is received
- forward the target values to the endposition monitor blocks
- monitor mold open intermediate position for robot (only if euromap function unit is available)
- maintainance of pos reached flags for all instances of close and open interpos movements

@FunctionID: S_FU_01_Mold1
*)

IMPORT_OVER_LISTFILE
 GET_SYNC_REFTO
, START_PROCESS_ALGORITHM
, cMoveFwd
, cMoveBwd
, cMaxIntermediateConditions
, nInterCondUpdate
, nInterCondRemove
, cCompNone
, cMinMoveIdent
, cMoveFwdInterPos
, cMoveBwdInterPos
, cCompODC
, cCompEuromap
, tsDeviceId
, tsInterCondList
, tyNumberOfDevices
, tyInstanceListArray
, tyInterCondBoolArray
, tsMoveData
, tevInterCondChanged
, tevStart
, tsSetTimes
, tsActTimes
, tsMovementHistory
, tsMoveCtrl
, tMoveIdent
, tnInterCondChangedMode
, tsInterCondListElement
, tevStartData
, tevInterCondChangedData
, KSYS_Status

END_IMPORT

ALGORITHM_BLOCK ABIntermediateConditions #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_DeviceId : tsDeviceId;
 sv_rBwdInterruptPosition : REAL (* Interrupt Position for Mold Bwd Movement (stop movement at this position so that a core can move) *);
 sv_rFwdInterruptPosition : REAL (* Interrupt Position for Mold Fwd Movement (stop movement at this position so that a core can move) *);
 sv_FwdInterruptList : tsInterCondList (* list with interrupt positions for mold close *);
 sv_BwdInterruptList : tsInterCondList (* list with interrupt positions for mold open *);
 sv_bDeviceRegisterDone : BOOL;
 sv_NumberOfDevices : tyNumberOfDevices;
 sv_rIntermedMoldOpenPosRobot : REAL (* intermediate mold open position for robot *);
 sv_bMoldOpenPosRobotReached : BOOL (* TRUE: actual mold position >= intermediate mold open position for robot *);
 sv_rMoldPosition : REAL;
 sv_InstanceDataCloseInterPos : tyInstanceListArray (* array with target positions of mold close interpos movements *);
 sv_InstanceDataOpenInterPos : tyInstanceListArray (* array with target positions of mold open interpos movements *);
 sv_iEditorPropertiesChanged : DINT (* must be increased if properties, that are relevant for ODC editor, changed *);
 sv_bUseProgramSwitches : BOOL (* TRUE: create sequence by using program switches; FALSE: use sequence from ODC editor *);
 sv_rFwdInterruptAccel : REAL;
 sv_rFwdInterruptDeaccel : REAL;
 sv_rBwdInterruptAccel : REAL;
 sv_rBwdInterruptDeaccel : REAL;
 sv_CloseInterPosProgInSequ : tyInterCondBoolArray (* information, which instances of mold close interpos movement are programmed in sequence  *);
 sv_PosReachedArrayCloseInterPos : tyInterCondBoolArray (* array with pos reached information for all instances of mold close inter pos movement *);
 sv_MoveCloseInterPos : tsMoveData (* move forward to intermediate position *);
 sv_OpenInterPosProgInSequ : tyInterCondBoolArray (* information, which instances of mold open interpos movement are programmed in sequence  *);
 sv_PosReachedArrayOpenInterPos : tyInterCondBoolArray (* array with pos reached information for all instances of mold open inter pos movement *);
 sv_MoveOpenInterPos : tsMoveData (* move bwd to intermediate position *);
 sv_MoldCloseTimesSet : tsSetTimes;
 sv_MoldCloseTimesAct : tsActTimes;
 sv_MoldOpenTimesSet : tsSetTimes;
 sv_MoldOpenTimesAct : tsActTimes;
 sv_rInterPosMonTolerance : REAL (* tolerance for intermediate position monitoring *);
 sv_bSequenceInterruption : BOOL (* TRUE: sequence is interrupted *);
 sv_bStepBwdActive : BOOL (* TRUE: stepping bwd is active *);
 sv_MovementHistory : tsMovementHistory;
 sv_bStepPosReached : BOOL (* TRUE: target position of step bwd movement reached (only needed for stepping bwd) *);
END_VAR

SYSTEM_OBJECT
 EV_Task_3 : TASK;
 evInterCondChanged : tevInterCondChanged;
 evStart : tevStart;
 PU_Task_13 : TASK;
 TaskAnalog : TASK;
 PU_Task_3 : TASK;
 PU_Task_7 : TASK;
END_OBJECT

VAR_EXTERNAL
 g_MoveCtrl : tsMoveCtrl;
END_VAR

VAR
 mTmpFwdInterruptList : tsInterCondList (* temporary list with interrupt positions for mold close *);
 mTmpBwdInterruptList : tsInterCondList (* temporary list with interrupt positions for mold open *);
 mevStart : tevStart (* local evStart (init is done if ODC is registered) *);
 mpiODCSequenceUpdated : REFTO DINT (* refto ODC1.sv_iODCSequenceUpdated *);
 miCloseInterPosCount : DINT (* number of programmed close interpos instances *);
 miOpenInterPosCount : DINT (* number of programmed open interpos instances *);
END_VAR

(*
copy data from interrupt lists to instance data list
this is necessary for correct displaying of the programmed cycle in
the ODC editor
*)

ALGORITHM aCopyToInstanceData


VAR_INPUT
 MoveDir : tMoveIdent;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 pSourceList : REFTO tsInterCondList;
 pTargetList : REFTO tyInstanceListArray;
 pProgInSequenceArray : REFTO tyInterCondBoolArray;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF MoveDir = cMoveFwd THEN
   pSourceList := @sv_FwdInterruptList;
   pTargetList := @sv_InstanceDataCloseInterPos;
   pProgInSequenceArray := @sv_CloseInterPosProgInSequ;
ELSIF MoveDir = cMoveBwd THEN
   pSourceList := @sv_BwdInterruptList;
   pTargetList := @sv_InstanceDataOpenInterPos;
   pProgInSequenceArray := @sv_OpenInterPosProgInSequ;
ELSE
   ;
END_IF;


FOR i:= 1 TO cMaxIntermediateConditions DO
   pTargetList^[i].rTargetValue := pSourceList^.List[i].rTargetValue;
   IF pProgInSequenceArray^[i] THEN
      //interpos movement programmed -> copy values
      pTargetList^[i].rDeceleration := pSourceList^.List[i].rDeceleration;
      pTargetList^[i].rAcceleration := pSourceList^.List[i].rAcceleration;
   ELSE
      //interpos movement not programmed -> copy 100.0 as init value
      pTargetList^[i].rDeceleration := 100.0;
      pTargetList^[i].rAcceleration := 100.0;
   END_IF;
END_FOR;

sv_iEditorPropertiesChanged := sv_iEditorPropertiesChanged + 1



;#END_EDIT_BLOCK END_ALGORITHM

(*
- add, modify, or remove entry from mTmpFwdInterruptList or mTmpBwdInterruptList (depending on the move direction)
- sort the list

Attention:
The temporary lists are copied to sv_FwdInterruptList and sv_BwdInterruptList after a new sequence is created 
(done in the postupdate algorithm pNewSequence).
This avoids that changes in core move position take effect before the new cycle is created.

*)

ALGORITHM aUpdateList


VAR_INPUT
 MoveDir : tMoveIdent;
 DeviceId : tsDeviceId;
 Mode : tnInterCondChangedMode;
 rTargetValue : REAL (* new target value *);
 rAcceleration : REAL;
 rDeceleration : REAL;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 bFound : BOOL;
 InterCondList : tsInterCondList;
 bChanged : BOOL;
 TempElement : tsInterCondListElement;
 iFound : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF MoveDir = cMoveFwd THEN
   InterCondList := mTmpFwdInterruptList;
ELSIF MoveDir = cMoveBwd THEN
   InterCondList := mTmpBwdInterruptList;
ELSE
   //other move directions are not handled
   RETURN;
END_IF;

//search for the according device id
bFound := FALSE;
iFound := 0;
FOR i := 1 TO InterCondList.iUsedElements DO
   IF InterCondList.List[i].DeviceIdSender = DeviceId THEN
      iFound := i;
      bFound := TRUE;
      EXIT;
   END_IF;   
END_FOR;

IF bFound AND Mode = nInterCondUpdate THEN
   //update target value
   InterCondList.List[iFound].rTargetValue := rTargetValue;
   InterCondList.List[iFound].rDeceleration := rDeceleration;
   InterCondList.List[iFound].rAcceleration := rAcceleration;
ELSIF NOT bFound AND Mode = nInterCondUpdate THEN
   //create new entry
   InterCondList.iUsedElements := InterCondList.iUsedElements + 1;
   InterCondList.List[InterCondList.iUsedElements].DeviceIdSender := DeviceId;
   InterCondList.List[InterCondList.iUsedElements].rTargetValue := rTargetValue;
   InterCondList.List[InterCondList.iUsedElements].rDeceleration := rDeceleration;
   InterCondList.List[InterCondList.iUsedElements].rAcceleration := rAcceleration;
ELSIF bFound AND Mode = nInterCondRemove THEN
   //remove entry   
   InterCondList.List[iFound].DeviceIdSender.CompId := cCompNone;
   InterCondList.List[iFound].DeviceIdSender.IndexId := cMinMoveIdent;
   InterCondList.List[iFound].rTargetValue := 0.0;
   InterCondList.List[iFound].rAcceleration := 0.0;
   InterCondList.List[iFound].rDeceleration := 0.0;
   
   //rearrange list (move all used elements behind the found element)
   FOR i := iFound TO InterCondList.iUsedElements DO
      InterCondList.List[i] := InterCondList.List[i+1];
   END_FOR;
   
   InterCondList.iUsedElements := InterCondList.iUsedElements -1;
END_IF;
   

//sort list depending on the move direction
bChanged := TRUE;
WHILE bChanged DO
   bChanged := FALSE;
   FOR i := 1 TO (InterCondList.iUsedElements -1) DO
      IF (MoveDir = cMoveFwd AND (InterCondList.List[i+1].rTargetValue > InterCondList.List[i].rTargetValue)) OR
         (MoveDir = cMoveBwd AND (InterCondList.List[i+1].rTargetValue < InterCondList.List[i].rTargetValue))THEN
         //change necessary
         TempElement := InterCondList.List[i];
         InterCondList.List[i] := InterCondList.List[i+1];
         InterCondList.List[i+1] := TempElement;
         bChanged := TRUE;
      END_IF;
   END_FOR;
END_WHILE;

//copy "working list" back
IF MoveDir = cMoveFwd THEN
   mTmpFwdInterruptList := InterCondList;
ELSIF MoveDir = cMoveBwd THEN
   mTmpBwdInterruptList := InterCondList;
END_IF;
 




;#END_EDIT_BLOCK END_ALGORITHM

(*
get target value from interrupt list
*)

ALGORITHM aGetTargetValue


VAR_INPUT
 MoveDir : tMoveIdent;
 MoveId : tMoveIdent;
 iIndex : DINT;
END_VAR

VAR
 i : DINT;
 prTarget : REFTO REAL;
 rLastMoveAccel : REAL;
 LastMoveId : tMoveIdent;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//avoid out of range errors
i := MAX(1,iIndex);

IF MoveDir = cMoveFwd THEN
   prTarget := @sv_rFwdInterruptPosition;
ELSE
   prTarget := @sv_rBwdInterruptPosition;
END_IF;

IF (((MoveId = cMoveFwd OR MoveId = cMoveFwdInterPos) AND 
     (LastMoveId = cMoveBwd OR LastMoveId = cMoveBwdInterPos)) OR 
    ((MoveId = cMoveBwd OR MoveId = cMoveBwdInterPos) AND 
     (LastMoveId = cMoveFwd OR LastMoveId = cMoveFwdInterPos)))THEN //change of movement-direction -> reset acceleration
   rLastMoveAccel := 0.0;
END_IF;

IF MoveId = cMoveFwd OR MoveId = cMoveBwd THEN
   //movement to endposition -> set interrupt pos to 0.0
   prTarget^ := 0.0;
   IF MoveId = cMoveFwd THEN   
      sv_rFwdInterruptAccel := rLastMoveAccel;
      sv_rFwdInterruptDeaccel := 0.0;
   ELSE
      sv_rBwdInterruptAccel := rLastMoveAccel;
      sv_rBwdInterruptDeaccel := 0.0;       
   END_IF;
ELSIF MoveId = cMoveFwdInterPos THEN
   IF sv_bUseProgramSwitches THEN
      //use target values from core masks
      prTarget^ := sv_FwdInterruptList.List[i].rTargetValue;
      // use deceleration when stopping at interstop pos, use acceleration for starting after interstop 
      // iIndex is set to next movement already -> use acceleration of last movement!
      IF i > 1 THEN
         sv_rFwdInterruptAccel := sv_FwdInterruptList.List[i-1].rAcceleration;
      ELSE
         sv_rFwdInterruptAccel := 0.0;    
      END_IF;
      rLastMoveAccel := sv_FwdInterruptList.List[i].rAcceleration;
      sv_rFwdInterruptDeaccel := sv_FwdInterruptList.List[i].rDeceleration;
      
      // use delay time from mold close movement
      sv_MoveCloseInterPos.pdStartDelaySet := @sv_MoldCloseTimesSet.dSetDelayTime;
      sv_MoveCloseInterPos.pdStartDelayAct := @sv_MoldCloseTimesAct.dActDelayTime;
   ELSE
      // use instance values from odc editor
      prTarget^ := sv_InstanceDataCloseInterPos[i].rTargetValue;
      // use deceleration when stopping at interstop pos, use acceleration for starting after interstop 
      // iIndex is set to next movement already -> use acceleration of last movement!       
      // List is not sorted!!
      sv_rFwdInterruptAccel   := rLastMoveAccel;
      rLastMoveAccel          := sv_InstanceDataCloseInterPos[i].rAcceleration;    
      sv_rFwdInterruptDeaccel := sv_InstanceDataCloseInterPos[i].rDeceleration;
      
      //use delay time from machine sequencer
      sv_MoveCloseInterPos.pdStartDelaySet := @sv_InstanceDataCloseInterPos[i].dDelay;
      sv_MoveCloseInterPos.pdStartDelayAct := EMPTY;
   END_IF;
   
   //adapt reference to duration variable
   sv_MoveCloseInterPos.pdCalculatedDuration := @sv_InstanceDataCloseInterPos[i].dCalculatedDuration;
   
ELSIF MoveId = cMoveBwdInterPos THEN
   IF sv_bUseProgramSwitches THEN
      //use target values from core masks
      prTarget^ := sv_BwdInterruptList.List[i].rTargetValue;
      // use deceleration when stopping at interstop pos, use acceleration for starting after interstop 
      // iIndex is set to next movement already -> use acceleration of last movement!       
      IF i > 1 THEN
         sv_rBwdInterruptAccel    := sv_BwdInterruptList.List[i-1].rAcceleration;
      ELSE
         sv_rBwdInterruptAccel    := 0.0;    
      END_IF;
      rLastMoveAccel := sv_BwdInterruptList.List[i].rAcceleration;     
      sv_rBwdInterruptDeaccel := sv_BwdInterruptList.List[i].rDeceleration;
      
      // use delay time from mold open movement
      sv_MoveOpenInterPos.pdStartDelaySet := @sv_MoldOpenTimesSet.dSetDelayTime;
      sv_MoveOpenInterPos.pdStartDelayAct := @sv_MoldOpenTimesAct.dActDelayTime;
   ELSE
      // use instance values from odc editor
      prTarget^ := sv_InstanceDataOpenInterPos[i].rTargetValue;
      // use deceleration when stopping at interstop pos, use acceleration for starting after interstop 
      // iIndex is set to next movement already -> use acceleration of last movement!       
      // List is not sorted!!
      sv_rBwdInterruptAccel   := rLastMoveAccel;
      rLastMoveAccel          := sv_InstanceDataOpenInterPos[i].rAcceleration;    
      sv_rBwdInterruptDeaccel := sv_InstanceDataOpenInterPos[i].rDeceleration;
      
      //use delay time from machine sequencer
      sv_MoveOpenInterPos.pdStartDelaySet := @sv_InstanceDataOpenInterPos[i].dDelay;
      sv_MoveOpenInterPos.pdStartDelayAct := EMPTY;
   END_IF;
   
   //adapt reference to duration variable
   sv_MoveOpenInterPos.pdCalculatedDuration := @sv_InstanceDataOpenInterPos[i].dCalculatedDuration;
   
END_IF;

LastMoveId := MoveId;


;#END_EDIT_BLOCK END_ALGORITHM

(*
get target value if start event is received

attention:
taskslot is asigned to make sure that execution is done before evaStart in ABControl.pu
*)

EVENT_ALGORITHM evaStart ON EV_Task_3(50) WITH mevStart


VAR_INPUT
 evStartData : tevStartData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF evStartData.DeviceId <> sv_DeviceId THEN
   RETURN;
END_IF;

IF sv_bSequenceInterruption AND sv_bStepBwdActive THEN
   //start event during step bwd received
   //find out what mold movement was executed last and get target position and ramps of this movement
   IF sv_MovementHistory.iActCount > 1 THEN
      aGetTargetValue(MoveDir := sv_MovementHistory.Data[(sv_MovementHistory.iActCount-1)].MoveDir,
                   MoveId := sv_MovementHistory.Data[(sv_MovementHistory.iActCount-1)].MoveId,
                   iIndex := sv_MovementHistory.Data[(sv_MovementHistory.iActCount-1)].iCount);
      IF sv_MovementHistory.Data[(sv_MovementHistory.iActCount-1)].MoveDir <> evStartData.MoveDir THEN
         IF evStartData.MoveDir = cMoveFwd THEN
            //copy values of bwd movement to fwd movement
            sv_rFwdInterruptPosition := sv_rBwdInterruptPosition;
            sv_rFwdInterruptAccel := sv_rBwdInterruptAccel;
            sv_rFwdInterruptDeaccel := sv_rBwdInterruptDeaccel;
         ELSE
            //copy values of fwd movement to bwd movement
            sv_rBwdInterruptPosition := sv_rFwdInterruptPosition;
            sv_rBwdInterruptAccel := sv_rFwdInterruptAccel;
            sv_rBwdInterruptDeaccel := sv_rFwdInterruptDeaccel;         
         END_IF;
      END_IF;
   ELSE
      //reset SV´s
      sv_rBwdInterruptPosition := 0.0;
      sv_rFwdInterruptPosition := 0.0;
   END_IF;
   
ELSE   
   aGetTargetValue(MoveDir := evStartData.MoveDir,
                MoveId := evStartData.MoveId,
                iIndex := evStartData.IntermediateCond);   
END_IF;




;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aUpdateRamps


VAR_INPUT
 DeviceIdSender : tsDeviceId;
 MoveDir : tMoveIdent;
 rDeceleration : REAL;
 rAcceleration : REAL;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 pList : REFTO tsInterCondList;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//the ramps must be updated immediatly and not only if a new sequence is created

IF MoveDir = cMoveFwd THEN
   pList := @sv_FwdInterruptList;
ELSIF MoveDir = cMoveBwd THEN
   pList := @sv_BwdInterruptList;
ELSE
   //other move directions are not handled
   RETURN;
END_IF;

FOR i := 1 TO pList^.iUsedElements DO
   IF pList^.List[i].DeviceIdSender = DeviceIdSender THEN
      //update ramps
      pList^.List[i].rDeceleration := rDeceleration;
      pList^.List[i].rAcceleration := rAcceleration;
      EXIT;
   END_IF;   
END_FOR;


;#END_EDIT_BLOCK END_ALGORITHM

(*
receive evInterCondChanged events and update list
*)

EVENT_ALGORITHM evaInterCondChanged ON EV_Task_3 WITH evInterCondChanged


VAR_INPUT
 evInterCondChangedData : tevInterCondChangedData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_DeviceId <> evInterCondChangedData.DeviceIdReceiver THEN
   RETURN; 
END_IF;

//update list
aUpdateList(MoveDir := evInterCondChangedData.MoveDir,
            DeviceId := evInterCondChangedData.DeviceIdSender,
            Mode := evInterCondChangedData.InterCondChangedMode,
            rTargetValue := evInterCondChangedData.rTargetValue,
            rDeceleration := evInterCondChangedData.rDeceleration,
            rAcceleration := evInterCondChangedData.rAcceleration);


//update ramps
IF evInterCondChangedData.InterCondChangedMode = nInterCondUpdate THEN
   aUpdateRamps(DeviceIdSender := evInterCondChangedData.DeviceIdSender, 
                MoveDir := evInterCondChangedData.MoveDir,
                rDeceleration := evInterCondChangedData.rDeceleration,
                rAcceleration := evInterCondChangedData.rAcceleration);
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
assign system.evStart to local event if ODC is registered
*)

POSTUPDATE_ALGORITHM pDeviceRegisterDone ON PU_Task_13 WITH sv_bDeviceRegisterDone


VAR
 Status : KSYS_Status;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//find out if ODC is registered
IF sv_NumberOfDevices[cCompODC] > 0 THEN
   //ODC available -> react on start events necessary
   mevStart := evStart;
    
   mpiODCSequenceUpdated := GET_SYNC_REFTO('ODC1.sv_iODCSequenceUpdated', T#0s, Status); 
END_IF;

IF sv_NumberOfDevices[cCompEuromap] > 0 THEN
   //euromap available
   //-> start algorithm for monitoring mold open intermediate position
   START_PROCESS_ALGORITHM(paMonitorOpenInterPosRobot);
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paMonitorOpenInterPosRobot ON TaskAnalog

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//monitor mold open intermediate mold open position for robot
sv_bMoldOpenPosRobotReached := sv_rMoldPosition >= sv_rIntermedMoldOpenPosRobot;


;#END_EDIT_BLOCK END_ALGORITHM

(*
- copy data from temporary lists to interrupt lists after new sequence is created
- start or stop process algorithms for maintainance of pos reached flags for interpos movements
*)

POSTUPDATE_ALGORITHM pNewSequence ON PU_Task_3 WITH mpiODCSequenceUpdated^


VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//new sequence created
//copy data from temporary lists to interrupt lists
sv_FwdInterruptList := mTmpFwdInterruptList;
sv_BwdInterruptList := mTmpBwdInterruptList;

IF sv_bUseProgramSwitches THEN
   //copy data of interrupt list to instance data
   //(for correct displaying in the editor)
   aCopyToInstanceData(MoveDir := cMoveFwd);
   aCopyToInstanceData(MoveDir := cMoveBwd);
END_IF;

IF sv_MoveCloseInterPos.bProgrammedInSequence THEN
   //mold close movement to interpos programmed
   //-> find out how many instances are programmed
   FOR i := 1 TO cMaxIntermediateConditions DO
      IF sv_CloseInterPosProgInSequ[i] THEN
         miCloseInterPosCount := i;
      END_IF;
   END_FOR;
   START_PROCESS_ALGORITHM(paPosReachedCloseInterPos);
ELSE
   STOP_PROCESS_ALGORITHM(paPosReachedCloseInterPos);
END_IF;

IF sv_MoveOpenInterPos.bProgrammedInSequence THEN
   //mold open movement to interpos programmed
   //-> find out how many instances are programmed
   FOR i := 1 TO cMaxIntermediateConditions DO
      IF sv_OpenInterPosProgInSequ[i] THEN
         miOpenInterPosCount := i;
      END_IF;
   END_FOR;
   START_PROCESS_ALGORITHM(paPosReachedOpenInterPos);
ELSE
   STOP_PROCESS_ALGORITHM(paPosReachedOpenInterPos);
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
set pos reached information for all programmed close interpos movements
*)

PROCESS_ALGORITHM paPosReachedCloseInterPos ON TaskAnalog(3000)


VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO miCloseInterPosCount DO
   IF sv_CloseInterPosProgInSequ[i] THEN
      //instance programmed
      sv_PosReachedArrayCloseInterPos[i] := (sv_rMoldPosition <= (sv_InstanceDataCloseInterPos[i].rTargetValue + sv_rInterPosMonTolerance));
   ELSE
      //instance not programmed
      sv_PosReachedArrayCloseInterPos[i] := FALSE;
   END_IF;
END_FOR;


;#END_EDIT_BLOCK END_ALGORITHM

(*
set pos reached information for all programmed close interpos movements
*)

PROCESS_ALGORITHM paPosReachedOpenInterPos ON TaskAnalog(3000)


VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO miOpenInterPosCount DO
   IF sv_OpenInterPosProgInSequ[i] THEN
      //instance programmed
      sv_PosReachedArrayOpenInterPos[i] := (sv_rMoldPosition >= (sv_InstanceDataOpenInterPos[i].rTargetValue - sv_rInterPosMonTolerance));
   ELSE
      //instance not programmed
      sv_PosReachedArrayOpenInterPos[i] := FALSE;
   END_IF;
END_FOR;


;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pCloseDelay ON PU_Task_7 WITH sv_MoldCloseTimesSet.dSetDelayTime,sv_bUseProgramSwitches


VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bUseProgramSwitches THEN
   FOR i:= 1 TO cMaxIntermediateConditions DO
      sv_InstanceDataCloseInterPos[i].dDelay := sv_MoldCloseTimesSet.dSetDelayTime;
   END_FOR;
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pOpenDelay ON PU_Task_7 WITH sv_MoldOpenTimesSet.dSetDelayTime,sv_bUseProgramSwitches


VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bUseProgramSwitches THEN
   FOR i:= 1 TO cMaxIntermediateConditions DO
      sv_InstanceDataOpenInterPos[i].dDelay := sv_MoldOpenTimesSet.dSetDelayTime;
   END_FOR;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paPosReachedStepBwdPos ON TaskAnalog

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//monitor pos reached flag for target position of step mode
IF g_MoveCtrl.pData^.MoveDir = cMoveBwd THEN
   sv_bStepPosReached := (sv_rMoldPosition >= sv_rBwdInterruptPosition);
ELSIF g_MoveCtrl.pData^.MoveDir = cMoveFwd THEN
   sv_bStepPosReached := (sv_rMoldPosition <= sv_rFwdInterruptPosition);
END_IF;




;#END_EDIT_BLOCK END_ALGORITHM

POSTUPDATE_ALGORITHM pSequenceInterruption ON PU_Task_7 WITH sv_bSequenceInterruption

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bSequenceInterruption THEN
   START_PROCESS_ALGORITHM(paPosReachedStepBwdPos);
ELSE
   STOP_PROCESS_ALGORITHM(paPosReachedStepBwdPos); 
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 114 @Pou 25 
@@@BEG_Comment@@@
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

This AB is responsible for 
- maintainance of mTmpFwdInterruptList, mTmpBwdInterruptList, sv_FwdInterruptList and sv_BwdInterruptList
  (after new sequence was created, the temporary lists are copied to the sv´s)
- getting the according target value (sv_rFwdInterruptPosition, sv_rBwdInterruptPosition)
  if start event is received
- forward the target values to the endposition monitor blocks
- monitor mold open intermediate position for robot (only if euromap function unit is available)
- maintainance of pos reached flags for all instances of close and open interpos movements

@FunctionID: S_FU_01_Mold1
@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
2 
@Var @RT(14)GET_SYNC_REFTO @RT(0) @T @T @DERIVED 0 @F @RT(22)KEBA_STANDARD_FUNCTION @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(23)START_PROCESS_ALGORITHM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
11 
@Var @RT(8)cMoveFwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)12 @RT(16)movement forward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cMoveBwd @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)11 @RT(17)movement backward 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(26)cMaxIntermediateConditions @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)10 @RT(38)max. number of intermediate conditions 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)nInterCondUpdate @RT(0) @T @T @DERIVED 0 @F @RT(22)tnInterCondChangedMode @F 
@T 
@BEG_Attrib 
0 @RT(1)0 @RT(28)update/add condition to list 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)nInterCondRemove @RT(0) @T @T @DERIVED 0 @F @RT(22)tnInterCondChangedMode @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(26)remove condition from list 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)cCompNone @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(10)cMinCompId @RT(4)None 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)cMinMoveIdent @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(1)1 @RT(32)lower limit for MoveId / MoveDir 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)cMoveFwdInterPos @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)17 @RT(37)move forward to intermediate position 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)cMoveBwdInterPos @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(2)16 @RT(38)move backward to intermediate position 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)cCompODC @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)136 @RT(13)Component ODC 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)cCompEuromap @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)129 @RT(17)Component Euromap 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(24)ABIntermediateConditions @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
47 
@Var @RT(11)sv_DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_rBwdInterruptPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(97)Interrupt Position for Mold Bwd Movement (stop movement at this position so that a core can move) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_rFwdInterruptPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(97)Interrupt Position for Mold Fwd Movement (stop movement at this position so that a core can move) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_FwdInterruptList @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsInterCondList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(44)list with interrupt positions for mold close @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_BwdInterruptList @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsInterCondList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(43)list with interrupt positions for mold open @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_bDeviceRegisterDone @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_NumberOfDevices @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tyNumberOfDevices @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(28)sv_rIntermedMoldOpenPosRobot @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(41)intermediate mold open position for robot @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(27)sv_bMoldOpenPosRobotReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(71)TRUE: actual mold position >= intermediate mold open position for robot @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(16)sv_rMoldPosition @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(28)sv_InstanceDataCloseInterPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tyInstanceListArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(60)array with target positions of mold close interpos movements @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(27)sv_InstanceDataOpenInterPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tyInstanceListArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(59)array with target positions of mold open interpos movements @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(27)sv_iEditorPropertiesChanged @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(74)must be increased if properties, that are relevant for ODC editor, changed @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(22)sv_bUseProgramSwitches @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(84)TRUE: create sequence by using program switches; FALSE: use sequence from ODC editor @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_rFwdInterruptAccel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_rFwdInterruptDeaccel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(21)sv_rBwdInterruptAccel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(23)sv_rBwdInterruptDeaccel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(26)sv_CloseInterPosProgInSequ @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tyInterCondBoolArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(88)information, which instances of mold close interpos movement are programmed in sequence  @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(31)sv_PosReachedArrayCloseInterPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tyInterCondBoolArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(85)array with pos reached information for all instances of mold close inter pos movement @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_MoveCloseInterPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(37)move forward to intermediate position @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(25)sv_OpenInterPosProgInSequ @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tyInterCondBoolArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(87)information, which instances of mold open interpos movement are programmed in sequence  @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(30)sv_PosReachedArrayOpenInterPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tyInterCondBoolArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(84)array with pos reached information for all instances of mold open inter pos movement @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_MoveOpenInterPos @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)move bwd to intermediate position @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(9)EV_Task_3 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(18)evInterCondChanged @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(19)tevInterCondChanged @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(7)evStart @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tevStart @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)PU_Task_13 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(10)TaskAnalog @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)PU_Task_3 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(20)mTmpFwdInterruptList @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsInterCondList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(54)temporary list with interrupt positions for mold close @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)mTmpBwdInterruptList @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsInterCondList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(53)temporary list with interrupt positions for mold open @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)mevStart @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(8)tevStart @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(49)local evStart (init is done if ODC is registered) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)mpiODCSequenceUpdated @RT(0) @T @T @REFTO 0 @T @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(33)refto ODC1.sv_iODCSequenceUpdated @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)miCloseInterPosCount @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(45)number of programmed close interpos instances @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(19)miOpenInterPosCount @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(44)number of programmed open interpos instances @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)sv_MoldCloseTimesSet @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsSetTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(20)sv_MoldCloseTimesAct @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsActTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_MoldOpenTimesSet @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsSetTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)sv_MoldOpenTimesAct @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsActTimes @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(9)PU_Task_7 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(24)sv_rInterPosMonTolerance @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(46)tolerance for intermediate position monitoring @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(24)sv_bSequenceInterruption @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(29)TRUE: sequence is interrupted @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(17)sv_bStepBwdActive @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(28)TRUE: stepping bwd is active @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_MovementHistory @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tsMovementHistory @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_bStepPosReached @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(81)TRUE: target position of step bwd movement reached (only needed for stepping bwd) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(10)g_MoveCtrl @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsMoveCtrl @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 6 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

15 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(19)aCopyToInstanceData @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
5 
@Var @RT(7)MoveDir @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(11)pSourceList @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(15)tsInterCondList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)pTargetList @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(19)tyInstanceListArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)pProgInSequenceArray @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(20)tyInterCondBoolArray @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(11)aUpdateList @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
12 
@Var @RT(7)MoveDir @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(8)DeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(4)Mode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tnInterCondChangedMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)rTargetValue @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(16)new target value @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)rAcceleration @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)rDeceleration @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(6)bFound @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)InterCondList @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tsInterCondList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)bChanged @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)TempElement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tsInterCondListElement @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)iFound @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(15)aGetTargetValue @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
7 
@Var @RT(7)MoveDir @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)MoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)iIndex @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(8)prTarget @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)rLastMoveAccel @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)LastMoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(8)evaStart @STRUCTURED_TEXT 
@RT(0) @RT(8)mevStart @RT(13)EV_Task_3(50) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(11)evStartData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tevStartData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(12)aUpdateRamps @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
6 
@Var @RT(14)DeviceIdSender @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)MoveDir @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)rDeceleration @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)rAcceleration @RT(0) @T @F @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(5)pList @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(15)tsInterCondList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(19)evaInterCondChanged @STRUCTURED_TEXT 
@RT(0) @RT(18)evInterCondChanged @RT(9)EV_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(22)evInterCondChangedData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(23)tevInterCondChangedData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(19)pDeviceRegisterDone @STRUCTURED_TEXT 
@RT(0) @RT(22)sv_bDeviceRegisterDone @RT(10)PU_Task_13 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(6)Status @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)KSYS_Status @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(26)paMonitorOpenInterPosRobot @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(10)TaskAnalog @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(12)pNewSequence @STRUCTURED_TEXT 
@RT(0) @RT(22)mpiODCSequenceUpdated^ @RT(9)PU_Task_3 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(25)paPosReachedCloseInterPos @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(16)TaskAnalog(3000) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(24)paPosReachedOpenInterPos @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(16)TaskAnalog(3000) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(11)pCloseDelay @STRUCTURED_TEXT 
@RT(0) @RT(57)sv_MoldCloseTimesSet.dSetDelayTime,sv_bUseProgramSwitches @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(10)pOpenDelay @STRUCTURED_TEXT 
@RT(0) @RT(56)sv_MoldOpenTimesSet.dSetDelayTime,sv_bUseProgramSwitches @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(22)paPosReachedStepBwdPos @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(10)TaskAnalog @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@POSTUPDATE_ALGORITHM @RT(21)pSequenceInterruption @STRUCTURED_TEXT 
@RT(0) @RT(24)sv_bSequenceInterruption @RT(9)PU_Task_7 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Body 
@TL(34)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF MoveDir = cMoveFwd THEN
   pSourceList := @sv_FwdInterruptList;
   pTargetList := @sv_InstanceDataCloseInterPos;
   pProgInSequenceArray := @sv_CloseInterPosProgInSequ;
ELSIF MoveDir = cMoveBwd THEN
   pSourceList := @sv_BwdInterruptList;
   pTargetList := @sv_InstanceDataOpenInterPos;
   pProgInSequenceArray := @sv_OpenInterPosProgInSequ;
ELSE
   ;
END_IF;


FOR i:= 1 TO cMaxIntermediateConditions DO
   pTargetList^[i].rTargetValue := pSourceList^.List[i].rTargetValue;
   IF pProgInSequenceArray^[i] THEN
      //interpos movement programmed -> copy values
      pTargetList^[i].rDeceleration := pSourceList^.List[i].rDeceleration;
      pTargetList^[i].rAcceleration := pSourceList^.List[i].rAcceleration;
   ELSE
      //interpos movement not programmed -> copy 100.0 as init value
      pTargetList^[i].rDeceleration := 100.0;
      pTargetList^[i].rAcceleration := 100.0;
   END_IF;
END_FOR;

sv_iEditorPropertiesChanged := sv_iEditorPropertiesChanged + 1


@END_Body 

@@@BEG_Comment@@@ 
@TL(3)
copy data from interrupt lists to instance data list
this is necessary for correct displaying of the programmed cycle in
the ODC editor
@@@END_Comment@@@ 

@BEG_Body 
@TL(80)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF MoveDir = cMoveFwd THEN
   InterCondList := mTmpFwdInterruptList;
ELSIF MoveDir = cMoveBwd THEN
   InterCondList := mTmpBwdInterruptList;
ELSE
   //other move directions are not handled
   RETURN;
END_IF;

//search for the according device id
bFound := FALSE;
iFound := 0;
FOR i := 1 TO InterCondList.iUsedElements DO
   IF InterCondList.List[i].DeviceIdSender = DeviceId THEN
      iFound := i;
      bFound := TRUE;
      EXIT;
   END_IF;   
END_FOR;

IF bFound AND Mode = nInterCondUpdate THEN
   //update target value
   InterCondList.List[iFound].rTargetValue := rTargetValue;
   InterCondList.List[iFound].rDeceleration := rDeceleration;
   InterCondList.List[iFound].rAcceleration := rAcceleration;
ELSIF NOT bFound AND Mode = nInterCondUpdate THEN
   //create new entry
   InterCondList.iUsedElements := InterCondList.iUsedElements + 1;
   InterCondList.List[InterCondList.iUsedElements].DeviceIdSender := DeviceId;
   InterCondList.List[InterCondList.iUsedElements].rTargetValue := rTargetValue;
   InterCondList.List[InterCondList.iUsedElements].rDeceleration := rDeceleration;
   InterCondList.List[InterCondList.iUsedElements].rAcceleration := rAcceleration;
ELSIF bFound AND Mode = nInterCondRemove THEN
   //remove entry   
   InterCondList.List[iFound].DeviceIdSender.CompId := cCompNone;
   InterCondList.List[iFound].DeviceIdSender.IndexId := cMinMoveIdent;
   InterCondList.List[iFound].rTargetValue := 0.0;
   InterCondList.List[iFound].rAcceleration := 0.0;
   InterCondList.List[iFound].rDeceleration := 0.0;
   
   //rearrange list (move all used elements behind the found element)
   FOR i := iFound TO InterCondList.iUsedElements DO
      InterCondList.List[i] := InterCondList.List[i+1];
   END_FOR;
   
   InterCondList.iUsedElements := InterCondList.iUsedElements -1;
END_IF;
   

//sort list depending on the move direction
bChanged := TRUE;
WHILE bChanged DO
   bChanged := FALSE;
   FOR i := 1 TO (InterCondList.iUsedElements -1) DO
      IF (MoveDir = cMoveFwd AND (InterCondList.List[i+1].rTargetValue > InterCondList.List[i].rTargetValue)) OR
         (MoveDir = cMoveBwd AND (InterCondList.List[i+1].rTargetValue < InterCondList.List[i].rTargetValue))THEN
         //change necessary
         TempElement := InterCondList.List[i];
         InterCondList.List[i] := InterCondList.List[i+1];
         InterCondList.List[i+1] := TempElement;
         bChanged := TRUE;
      END_IF;
   END_FOR;
END_WHILE;

//copy "working list" back
IF MoveDir = cMoveFwd THEN
   mTmpFwdInterruptList := InterCondList;
ELSIF MoveDir = cMoveBwd THEN
   mTmpBwdInterruptList := InterCondList;
END_IF;
 



@END_Body 

@@@BEG_Comment@@@ 
@TL(8)
- add, modify, or remove entry from mTmpFwdInterruptList or mTmpBwdInterruptList (depending on the move direction)
- sort the list

Attention:
The temporary lists are copied to sv_FwdInterruptList and sv_BwdInterruptList after a new sequence is created 
(done in the postupdate algorithm pNewSequence).
This avoids that changes in core move position take effect before the new cycle is created.

@@@END_Comment@@@ 

@BEG_Body 
@TL(105)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//avoid out of range errors
i := MAX(1,iIndex);

IF MoveDir = cMoveFwd THEN
   prTarget := @sv_rFwdInterruptPosition;
ELSE
   prTarget := @sv_rBwdInterruptPosition;
END_IF;

IF (((MoveId = cMoveFwd OR MoveId = cMoveFwdInterPos) AND 
     (LastMoveId = cMoveBwd OR LastMoveId = cMoveBwdInterPos)) OR 
    ((MoveId = cMoveBwd OR MoveId = cMoveBwdInterPos) AND 
     (LastMoveId = cMoveFwd OR LastMoveId = cMoveFwdInterPos)))THEN //change of movement-direction -> reset acceleration
   rLastMoveAccel := 0.0;
END_IF;

IF MoveId = cMoveFwd OR MoveId = cMoveBwd THEN
   //movement to endposition -> set interrupt pos to 0.0
   prTarget^ := 0.0;
   IF MoveId = cMoveFwd THEN   
      sv_rFwdInterruptAccel := rLastMoveAccel;
      sv_rFwdInterruptDeaccel := 0.0;
   ELSE
      sv_rBwdInterruptAccel := rLastMoveAccel;
      sv_rBwdInterruptDeaccel := 0.0;       
   END_IF;
ELSIF MoveId = cMoveFwdInterPos THEN
   IF sv_bUseProgramSwitches THEN
      //use target values from core masks
      prTarget^ := sv_FwdInterruptList.List[i].rTargetValue;
      // use deceleration when stopping at interstop pos, use acceleration for starting after interstop 
      // iIndex is set to next movement already -> use acceleration of last movement!
      IF i > 1 THEN
         sv_rFwdInterruptAccel := sv_FwdInterruptList.List[i-1].rAcceleration;
      ELSE
         sv_rFwdInterruptAccel := 0.0;    
      END_IF;
      rLastMoveAccel := sv_FwdInterruptList.List[i].rAcceleration;
      sv_rFwdInterruptDeaccel := sv_FwdInterruptList.List[i].rDeceleration;
      
      // use delay time from mold close movement
      sv_MoveCloseInterPos.pdStartDelaySet := @sv_MoldCloseTimesSet.dSetDelayTime;
      sv_MoveCloseInterPos.pdStartDelayAct := @sv_MoldCloseTimesAct.dActDelayTime;
   ELSE
      // use instance values from odc editor
      prTarget^ := sv_InstanceDataCloseInterPos[i].rTargetValue;
      // use deceleration when stopping at interstop pos, use acceleration for starting after interstop 
      // iIndex is set to next movement already -> use acceleration of last movement!       
      // List is not sorted!!
      sv_rFwdInterruptAccel   := rLastMoveAccel;
      rLastMoveAccel          := sv_InstanceDataCloseInterPos[i].rAcceleration;    
      sv_rFwdInterruptDeaccel := sv_InstanceDataCloseInterPos[i].rDeceleration;
      
      //use delay time from machine sequencer
      sv_MoveCloseInterPos.pdStartDelaySet := @sv_InstanceDataCloseInterPos[i].dDelay;
      sv_MoveCloseInterPos.pdStartDelayAct := EMPTY;
   END_IF;
   
   //adapt reference to duration variable
   sv_MoveCloseInterPos.pdCalculatedDuration := @sv_InstanceDataCloseInterPos[i].dCalculatedDuration;
   
ELSIF MoveId = cMoveBwdInterPos THEN
   IF sv_bUseProgramSwitches THEN
      //use target values from core masks
      prTarget^ := sv_BwdInterruptList.List[i].rTargetValue;
      // use deceleration when stopping at interstop pos, use acceleration for starting after interstop 
      // iIndex is set to next movement already -> use acceleration of last movement!       
      IF i > 1 THEN
         sv_rBwdInterruptAccel    := sv_BwdInterruptList.List[i-1].rAcceleration;
      ELSE
         sv_rBwdInterruptAccel    := 0.0;    
      END_IF;
      rLastMoveAccel := sv_BwdInterruptList.List[i].rAcceleration;     
      sv_rBwdInterruptDeaccel := sv_BwdInterruptList.List[i].rDeceleration;
      
      // use delay time from mold open movement
      sv_MoveOpenInterPos.pdStartDelaySet := @sv_MoldOpenTimesSet.dSetDelayTime;
      sv_MoveOpenInterPos.pdStartDelayAct := @sv_MoldOpenTimesAct.dActDelayTime;
   ELSE
      // use instance values from odc editor
      prTarget^ := sv_InstanceDataOpenInterPos[i].rTargetValue;
      // use deceleration when stopping at interstop pos, use acceleration for starting after interstop 
      // iIndex is set to next movement already -> use acceleration of last movement!       
      // List is not sorted!!
      sv_rBwdInterruptAccel   := rLastMoveAccel;
      rLastMoveAccel          := sv_InstanceDataOpenInterPos[i].rAcceleration;    
      sv_rBwdInterruptDeaccel := sv_InstanceDataOpenInterPos[i].rDeceleration;
      
      //use delay time from machine sequencer
      sv_MoveOpenInterPos.pdStartDelaySet := @sv_InstanceDataOpenInterPos[i].dDelay;
      sv_MoveOpenInterPos.pdStartDelayAct := EMPTY;
   END_IF;
   
   //adapt reference to duration variable
   sv_MoveOpenInterPos.pdCalculatedDuration := @sv_InstanceDataOpenInterPos[i].dCalculatedDuration;
   
END_IF;

LastMoveId := MoveId;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
get target value from interrupt list
@@@END_Comment@@@ 

@BEG_Body 
@TL(43)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF evStartData.DeviceId <> sv_DeviceId THEN
   RETURN;
END_IF;

IF sv_bSequenceInterruption AND sv_bStepBwdActive THEN
   //start event during step bwd received
   //find out what mold movement was executed last and get target position and ramps of this movement
   IF sv_MovementHistory.iActCount > 1 THEN
      aGetTargetValue(MoveDir := sv_MovementHistory.Data[(sv_MovementHistory.iActCount-1)].MoveDir,
                   MoveId := sv_MovementHistory.Data[(sv_MovementHistory.iActCount-1)].MoveId,
                   iIndex := sv_MovementHistory.Data[(sv_MovementHistory.iActCount-1)].iCount);
      IF sv_MovementHistory.Data[(sv_MovementHistory.iActCount-1)].MoveDir <> evStartData.MoveDir THEN
         IF evStartData.MoveDir = cMoveFwd THEN
            //copy values of bwd movement to fwd movement
            sv_rFwdInterruptPosition := sv_rBwdInterruptPosition;
            sv_rFwdInterruptAccel := sv_rBwdInterruptAccel;
            sv_rFwdInterruptDeaccel := sv_rBwdInterruptDeaccel;
         ELSE
            //copy values of fwd movement to bwd movement
            sv_rBwdInterruptPosition := sv_rFwdInterruptPosition;
            sv_rBwdInterruptAccel := sv_rFwdInterruptAccel;
            sv_rBwdInterruptDeaccel := sv_rFwdInterruptDeaccel;         
         END_IF;
      END_IF;
   ELSE
      //reset SV´s
      sv_rBwdInterruptPosition := 0.0;
      sv_rFwdInterruptPosition := 0.0;
   END_IF;
   
ELSE   
   aGetTargetValue(MoveDir := evStartData.MoveDir,
                MoveId := evStartData.MoveId,
                iIndex := evStartData.IntermediateCond);   
END_IF;



@END_Body 

@@@BEG_Comment@@@ 
@TL(4)
get target value if start event is received

attention:
taskslot is asigned to make sure that execution is done before evaStart in ABControl.pu
@@@END_Comment@@@ 

@BEG_Body 
@TL(25)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//the ramps must be updated immediatly and not only if a new sequence is created

IF MoveDir = cMoveFwd THEN
   pList := @sv_FwdInterruptList;
ELSIF MoveDir = cMoveBwd THEN
   pList := @sv_BwdInterruptList;
ELSE
   //other move directions are not handled
   RETURN;
END_IF;

FOR i := 1 TO pList^.iUsedElements DO
   IF pList^.List[i].DeviceIdSender = DeviceIdSender THEN
      //update ramps
      pList^.List[i].rDeceleration := rDeceleration;
      pList^.List[i].rAcceleration := rAcceleration;
      EXIT;
   END_IF;   
END_FOR;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(26)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_DeviceId <> evInterCondChangedData.DeviceIdReceiver THEN
   RETURN; 
END_IF;

//update list
aUpdateList(MoveDir := evInterCondChangedData.MoveDir,
            DeviceId := evInterCondChangedData.DeviceIdSender,
            Mode := evInterCondChangedData.InterCondChangedMode,
            rTargetValue := evInterCondChangedData.rTargetValue,
            rDeceleration := evInterCondChangedData.rDeceleration,
            rAcceleration := evInterCondChangedData.rAcceleration);


//update ramps
IF evInterCondChangedData.InterCondChangedMode = nInterCondUpdate THEN
   aUpdateRamps(DeviceIdSender := evInterCondChangedData.DeviceIdSender, 
                MoveDir := evInterCondChangedData.MoveDir,
                rDeceleration := evInterCondChangedData.rDeceleration,
                rAcceleration := evInterCondChangedData.rAcceleration);
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
receive evInterCondChanged events and update list
@@@END_Comment@@@ 

@BEG_Body 
@TL(19)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//find out if ODC is registered
IF sv_NumberOfDevices[cCompODC] > 0 THEN
   //ODC available -> react on start events necessary
   mevStart := evStart;
    
   mpiODCSequenceUpdated := GET_SYNC_REFTO('ODC1.sv_iODCSequenceUpdated', T#0s, Status); 
END_IF;

IF sv_NumberOfDevices[cCompEuromap] > 0 THEN
   //euromap available
   //-> start algorithm for monitoring mold open intermediate position
   START_PROCESS_ALGORITHM(paMonitorOpenInterPosRobot);
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
assign system.evStart to local event if ODC is registered
@@@END_Comment@@@ 

@BEG_Body 
@TL(8)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//monitor mold open intermediate mold open position for robot
sv_bMoldOpenPosRobotReached := sv_rMoldPosition >= sv_rIntermedMoldOpenPosRobot;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(43)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//new sequence created
//copy data from temporary lists to interrupt lists
sv_FwdInterruptList := mTmpFwdInterruptList;
sv_BwdInterruptList := mTmpBwdInterruptList;

IF sv_bUseProgramSwitches THEN
   //copy data of interrupt list to instance data
   //(for correct displaying in the editor)
   aCopyToInstanceData(MoveDir := cMoveFwd);
   aCopyToInstanceData(MoveDir := cMoveBwd);
END_IF;

IF sv_MoveCloseInterPos.bProgrammedInSequence THEN
   //mold close movement to interpos programmed
   //-> find out how many instances are programmed
   FOR i := 1 TO cMaxIntermediateConditions DO
      IF sv_CloseInterPosProgInSequ[i] THEN
         miCloseInterPosCount := i;
      END_IF;
   END_FOR;
   START_PROCESS_ALGORITHM(paPosReachedCloseInterPos);
ELSE
   STOP_PROCESS_ALGORITHM(paPosReachedCloseInterPos);
END_IF;

IF sv_MoveOpenInterPos.bProgrammedInSequence THEN
   //mold open movement to interpos programmed
   //-> find out how many instances are programmed
   FOR i := 1 TO cMaxIntermediateConditions DO
      IF sv_OpenInterPosProgInSequ[i] THEN
         miOpenInterPosCount := i;
      END_IF;
   END_FOR;
   START_PROCESS_ALGORITHM(paPosReachedOpenInterPos);
ELSE
   STOP_PROCESS_ALGORITHM(paPosReachedOpenInterPos);
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(2)
- copy data from temporary lists to interrupt lists after new sequence is created
- start or stop process algorithms for maintainance of pos reached flags for interpos movements
@@@END_Comment@@@ 

@BEG_Body 
@TL(15)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO miCloseInterPosCount DO
   IF sv_CloseInterPosProgInSequ[i] THEN
      //instance programmed
      sv_PosReachedArrayCloseInterPos[i] := (sv_rMoldPosition <= (sv_InstanceDataCloseInterPos[i].rTargetValue + sv_rInterPosMonTolerance));
   ELSE
      //instance not programmed
      sv_PosReachedArrayCloseInterPos[i] := FALSE;
   END_IF;
END_FOR;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
set pos reached information for all programmed close interpos movements
@@@END_Comment@@@ 

@BEG_Body 
@TL(15)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

FOR i := 1 TO miOpenInterPosCount DO
   IF sv_OpenInterPosProgInSequ[i] THEN
      //instance programmed
      sv_PosReachedArrayOpenInterPos[i] := (sv_rMoldPosition >= (sv_InstanceDataOpenInterPos[i].rTargetValue - sv_rInterPosMonTolerance));
   ELSE
      //instance not programmed
      sv_PosReachedArrayOpenInterPos[i] := FALSE;
   END_IF;
END_FOR;

@END_Body 

@@@BEG_Comment@@@ 
@TL(1)
set pos reached information for all programmed close interpos movements
@@@END_Comment@@@ 

@BEG_Body 
@TL(12)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bUseProgramSwitches THEN
   FOR i:= 1 TO cMaxIntermediateConditions DO
      sv_InstanceDataCloseInterPos[i].dDelay := sv_MoldCloseTimesSet.dSetDelayTime;
   END_FOR;
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(11)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bUseProgramSwitches THEN
   FOR i:= 1 TO cMaxIntermediateConditions DO
      sv_InstanceDataOpenInterPos[i].dDelay := sv_MoldOpenTimesSet.dSetDelayTime;
   END_FOR;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(14)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//monitor pos reached flag for target position of step mode
IF g_MoveCtrl.pData^.MoveDir = cMoveBwd THEN
   sv_bStepPosReached := (sv_rMoldPosition >= sv_rBwdInterruptPosition);
ELSIF g_MoveCtrl.pData^.MoveDir = cMoveFwd THEN
   sv_bStepPosReached := (sv_rMoldPosition <= sv_rFwdInterruptPosition);
END_IF;



@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(11)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_bSequenceInterruption THEN
   START_PROCESS_ALGORITHM(paPosReachedStepBwdPos);
ELSE
   STOP_PROCESS_ALGORITHM(paPosReachedStepBwdPos); 
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
