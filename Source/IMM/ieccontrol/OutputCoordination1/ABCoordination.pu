(*
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

This AB coordinates the access to the available pumps
The SourceDevice (eg. Ejector1) requests the access to the pump(s) by the AlgorithmBlock ABOutputRequest (aRequest).
If the requested pump is idle (no other SourceDevice is making outputs) the sourceDevice gets the signal that it is allowed
to make outputs (see ABOutputRequest.aCheck). If the pump is occupied, the SourceDevice has to wait until the pump
is free again (see ABOutputRequest.aRelease).


*)

IMPORT_OVER_LISTFILE
 SET_EVENT
, SET_ALARM
, cCompNone
, cCompPump
, ABCoordList
, tevAnaDevCmd
, tevAnaDevResponse
, tevOutputRequest
, tevOutputResponse
, FBDebugTrace
, tsTraceLevel
, tyPumpData
, tyNumberOfDevices
, tevReleaseSinglePump
, tevInterruptActivePump
, tyCoordElementData
, tsElementDataCoord
, tyStopForInterrupt
, tevRequestSinglePump
, tnPumpState
, tsRequiredPumps
, tsDeviceId
, tsElementCoord
, tevAnaDevCmdData
, tMoveIdent
, tnAnaOutputMode
, tpMoveData
, tevOutputRequestData
, tyRequiredPumps
, tevOutputResponseData
, tevAnaDevResponseData
, tevRequestSinglePumpData
, tevReleaseSinglePumpData
, tevInterruptActivePumpData

END_IMPORT

ALGORITHM_BLOCK ABCoordination #DUMMY_EDIT_BLOCK

SYSTEM_VAR
 sv_TraceLevel : tsTraceLevel;
 sv_PumpData : tyPumpData;
 sv_NumberOfDevices : tyNumberOfDevices;
END_VAR

SYSTEM_OBJECT
 evAnaDevCmd : tevAnaDevCmd;
 evAnaDevResponse : tevAnaDevResponse;
 EV_Task_1 : TASK;
 evOutputRequest : tevOutputRequest;
 evOutputResponse : tevOutputResponse;
 TaskMid : TASK;
 erNoPumpDefinition : ALARM;
 evReleaseSinglePump : tevReleaseSinglePump;
 evInterruptActivePump : tevInterruptActivePump;
 erPumpInterruptNotAllowed : ALARM;
 erInterruptLastPump : ALARM;
 evRequestSinglePump : tevRequestSinglePump;
END_OBJECT

VAR
 abCoordList : ABCoordList;
 fbDebugTrace : FBDebugTrace;
 dummy : DINT;
 mReturnPumpToMove : tyCoordElementData;
 mInterruptPumpForMove : tyCoordElementData;
 mEmptyCoordElementData : tsElementDataCoord;
 mStopForInterrupt : tyStopForInterrupt;
 mPumpStateFree : tnPumpState := nPumpStateFree;
 mPumpStateBusy : tnPumpState := nPumpStateBusy;
END_VAR

ALGORITHM aIsMaster


VAR_INPUT
 iPump : DINT;
 pRequiredPumps : REFTO tsRequiredPumps;
END_VAR

VAR_OUTPUT
 bMaster : BOOL;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//the first required pump of a movement is master
//all other pumps are slaves
IF CHECK_REF(pRequiredPumps^) THEN
   FOR i := 1 TO cMaxNrOfPumps DO
      //search for the first required pump
      //if first required pump = given pump: pump is master
      IF pRequiredPumps^.RequiredPumps[i] THEN
         IF (i = iPump) THEN
            bMaster := TRUE;
         ELSE
            bMaster := FALSE;
         END_IF;
         
         EXIT; //exit loop
      END_IF;
   END_FOR;
ELSE
   bMaster := FALSE;
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

PROCESS_ALGORITHM paInit ON TaskMid(1) AUTOSTART

#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abCoordList.aInit();

STOP_PROCESS_ALGORITHM();













;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aReleaseSinglePump


VAR_INPUT
 iPump : DINT;
 DeviceIdSender : tsDeviceId;
END_VAR

VAR_TEMP
 i : DINT;
END_VAR

VAR
 DeviceIdSource : tsDeviceId;
 DeviceIdTarget : tsDeviceId;
 CoordElement : tsElementCoord;
 iCoordPos : DINT;
 evAnaDevCmdData : tevAnaDevCmdData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bAnalog THEN
   dummy := Print('ABCoordination.aReleaseSinglePump: Pump %d ', iPump);
END_IF;

DeviceIdTarget.CompId := cCompPump;
DeviceIdTarget.IndexId := iPump; 
abCoordList.aSearch.SearchData.DeviceIdAnaDev := DeviceIdTarget;
abCoordList.aSearch();

IF abCoordList.aSearch.bFound THEN
   iCoordPos := abCoordList.aSearch.iPos; 
   CoordElement := abCoordList.aSearch.Element;
   DeviceIdSource := abCoordList.aSearch.Element.ElementData.DeviceIdSource;
   
   //a movement releases a pump -> check if this movement should get back a pump
   //if yes: delete this return information
   FOR i := 1 TO sv_NumberOfDevices[cCompPump] DO
      IF DeviceIdSender = mReturnPumpToMove[i].DeviceIdSource THEN
         mReturnPumpToMove[i] := mEmptyCoordElementData;
      END_IF;
   END_FOR;
   
   REPEAT
      // search for the SourceDevice in the CoordList
      IF DeviceIdSource = DeviceIdSender THEN
         
         IF CoordElement.ElementData.AnaDevState = nAnaDevStarted THEN
                                  
            // set state to "nAnaDevStopping"
            CoordElement := abCoordList.aSearch.Element;
            CoordElement.ElementData.AnaDevState := nAnaDevStopping;
            abCoordList.aModifyAt(iPos := abCoordList.aSearch.iPos, Element:= CoordElement);
            
            // sending stop command to pump
            evAnaDevCmdData.DeviceId    := DeviceIdTarget;
            evAnaDevCmdData.Cmd         := nAnaDevStop;
            SET_EVENT(evAnaDevCmd, evAnaDevCmdData);
               
         ELSIF CoordElement.ElementData.AnaDevState = nAnaDevStopped THEN
            // state is nAnaDevStopped -> the SourceDevice was waiting for the pump 
            // and has released the pump now -> remove from Coordlist 
            // If the state is nAnaDevStopping the entry will be cleared when the pump
            // sends the response to OutputCoordination with the state nAnaDevStopped
            abCoordList.aRemoveAt(iCoordPos);  
         END_IF;
                                 
         EXIT; // the pump that should be released was found -> exit loop
      END_IF;
      
      // searching for the next CoordEntry in the list
      abCoordList.aSearchNext.SearchData.DeviceIdAnaDev := DeviceIdTarget;
      abCoordList.aSearchNext();
      iCoordPos := abCoordList.aSearchNext.iPos;
      CoordElement := abCoordList.aSearchNext.Element;
      DeviceIdSource := abCoordList.aSearchNext.Element.ElementData.DeviceIdSource;
   UNTIL NOT abCoordList.aSearchNext.bFound
   END_REPEAT;                    
ELSE
   //error: pump was never requested but should be released now
   dummy := Print('ABCoordination.aReleaseSinglePump: Pump %d should be released although it is not used', iPump);             
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
@i    Requesting an output:
    
@i    1. evaOutputRequest receives the request event sent by the SourceDevice. 
@i    2. check if the TargetDevice is occupied at the moment by searching in abCoordList.
@i    3. if the Target is occupied a new entry is added to the coordList with the state nAnaDevStopped,
@i       -> the Source has to wait for the target until it is idle again.
@i    4. if the target is free, a new entry is added to the coordList with the state nAnaDevStarted, and the 
@i       event evAnaDevCmd is sent to the Target OutputDevice.
     

@i    Releasing an outputDevice:
    
@i    1. evaOutputRequest receives the release event sent by the SourceDevice. 
@i    2. Searching for the target in the coordlist.
@i       If the target has the state nAnaDevStarted (output is active), 
@i       the state will be set to nAnaDevStopping, and the target is signalled that it shoud stop the output (by sending evAnaDevCmd).
@i       If the target has the state nAnaDevStopped (idle) the targetDevice is removed from the coordList.    

*)

ALGORITHM aRequestSinglePump


VAR_INPUT
 iPump : DINT;
 DeviceIdSource : tsDeviceId;
 MoveId : tMoveIdent;
 AnaOutputMode : tnAnaOutputMode;
 prPressureSource : REFTO REAL;
 prVelocitySource : REFTO REAL;
 piCtrlParamSet : REFTO INT;
 bMaster : BOOL;
END_VAR

VAR_TEMP
 b : BOOL;
 TmpDeviceId : tsDeviceId;
 TmpMoveId : tMoveIdent;
END_VAR

VAR
 evAnaDevCmdData : tevAnaDevCmdData;
 DeviceIdTarget : tsDeviceId;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (iPump = 0) OR (iPump > cMaxNrOfPumps) THEN
   dummy := Print('aRequestSinglePump with invalid pump number called');
   RETURN;
END_IF;
                       
DeviceIdTarget.CompId := cCompPump;
DeviceIdTarget.IndexId := iPump; 
abCoordList.aSearch.SearchData.DeviceIdAnaDev := DeviceIdTarget;
abCoordList.aSearch();

// add Entry to CoordList
abCoordList.aAdd.Element.SearchData.DeviceIdAnaDev    := DeviceIdTarget;
abCoordList.aAdd.Element.ElementData.DeviceIdSource   := DeviceIdSource;
abCoordList.aAdd.Element.ElementData.MoveId           := MoveId;
abCoordList.aAdd.Element.ElementData.AnaOutputMode    := AnaOutputMode;
abCoordList.aAdd.Element.ElementData.prPressureSource := prPressureSource;
abCoordList.aAdd.Element.ElementData.prVelocitySource := prVelocitySource;
abCoordList.aAdd.Element.ElementData.piCtrlParamSet   := piCtrlParamSet;         
abCoordList.aAdd.Element.ElementData.bMaster          := bMaster;

IF abCoordList.aSearch.bFound THEN
   // target (pump) found in Coordlist -> target is already requested
   // set state to "Stopped" -> Source is waiting for the target
   abCoordList.aAdd.Element.ElementData.AnaDevState   := nAnaDevStopped;
ELSE
   // Target was not found in Coordlist (Target is ready to be started)
   // -> set State to "Started"
   abCoordList.aAdd.Element.ElementData.AnaDevState   := nAnaDevStarted;
END_IF;

abCoordList.aAdd();
IF NOT abCoordList.aSearch.bFound THEN
   // send Start to pump
   evAnaDevCmdData.DeviceId         := DeviceIdTarget;
   evAnaDevCmdData.Cmd              := nAnaDevStart;
   evAnaDevCmdData.Mode             := AnaOutputMode;
   evAnaDevCmdData.prAnaOutP        := prPressureSource;
   evAnaDevCmdData.prAnaOutV        := prVelocitySource;
   evAnaDevCmdData.MoveId           := MoveId;
   evAnaDevCmdData.piCtrlParamSet   := piCtrlParamSet;
   evAnaDevCmdData.bMaster          := bMaster;
   SET_EVENT(evAnaDevCmd, evAnaDevCmdData);
    
   //write sv_PumpData
   b := WRITE_SV_DIRECT(sv_PumpData[iPump].PumpState, mPumpStateBusy);
   TmpDeviceId := DeviceIdSource;
   b := WRITE_SV_DIRECT(sv_PumpData[iPump].ActiveDevice, TmpDeviceId);
   TmpMoveId := MoveId;
   b := WRITE_SV_DIRECT(sv_PumpData[iPump].ActiveMoveId, TmpMoveId);
 
END_IF;
 

     
   
      

    


;#END_EDIT_BLOCK END_ALGORITHM

ALGORITHM aInterruptActivePump


VAR_INPUT
 iPump : DINT;
 DeviceIdSender : tsDeviceId;
 pMoveData : tpMoveData;
 AnaOutputMode : tnAnaOutputMode;
 prVelocity : REFTO REAL (* optional parameter; by default sv_rVelocity is used *);
 prPressure : REFTO REAL (* optional parameter; by default sv_rPressure is used *);
END_VAR

VAR_TEMP
 iEntry : DINT;
END_VAR

VAR
 DeviceIdTarget : tsDeviceId;
 CoordElement : tsElementCoord;
 evAnaDevCmdData : tevAnaDevCmdData;
 iUsedPumps : INT;
 iListEntries : DINT;
 TmpCoordElement : tsElementCoord;
 DeviceIdSource : tsDeviceId;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bAnalog THEN
   dummy := Print('ABCoordination.aInterruptActivePump: Pump %d should be interrupted', iPump);
END_IF;

IF (mReturnPumpToMove[iPump].DeviceIdSource.CompId <> cCompNone) THEN
   //pump is already interrupted -> set alarm
   SET_ALARM(Name := erPumpInterruptNotAllowed,
               SubID1 := iPump,
               SubID2 := DeviceIdSender.CompId,
               SubID3 := DeviceIdSender.IndexId,
               SubID4 := pMoveData^.MoveId);
   RETURN;
END_IF;

DeviceIdTarget.CompId := cCompPump;
DeviceIdTarget.IndexId := iPump; 
abCoordList.aSearch.SearchData.DeviceIdAnaDev := DeviceIdTarget;
abCoordList.aSearch();

IF abCoordList.aSearch.bFound THEN 
      
   CoordElement := abCoordList.aSearch.Element;
   IF CoordElement.ElementData.AnaDevState = nAnaDevStarted THEN         
      
      //it is not allowed to interrupt all pumps of a movement
      //check if at least one pump remains for this device after the "interrupted" pump is given away      
      DeviceIdSource := CoordElement.ElementData.DeviceIdSource;
      iListEntries := abCoordList.aGetElementCount();
      iUsedPumps := 0;
      FOR iEntry := 1 TO iListEntries DO
         abCoordList.aElementAt(iPos := iEntry, Element => TmpCoordElement);
         IF (TmpCoordElement.ElementData.DeviceIdSource = DeviceIdSource) AND (TmpCoordElement.ElementData.AnaDevState = nAnaDevStarted) THEN
            iUsedPumps := iUsedPumps + 1;
         END_IF;
      END_FOR;
      
      IF NOT (iUsedPumps > 1) THEN
         //the last pump should be given away -> alarm
         SET_ALARM(Name := erInterruptLastPump,
                   SubID1 := iPump,
                   SubID2 := DeviceIdSender.CompId,
                   SubID3 := DeviceIdSender.IndexId,
                   SubID4 := DeviceIdSource.CompId);
         RETURN;
      END_IF;
      
      //remember which movements actually used the pump (for giving it back later)
      mReturnPumpToMove[iPump] := CoordElement.ElementData;
      mStopForInterrupt[iPump] := TRUE;
      
      //save information about which movement should use the pump
      mInterruptPumpForMove[iPump].DeviceIdSource := DeviceIdSender;
      mInterruptPumpForMove[iPump].MoveId := pMoveData^.MoveId;
      mInterruptPumpForMove[iPump].AnaOutputMode := AnaOutputMode;
      mInterruptPumpForMove[iPump].AnaDevState := nAnaDevStopped;
      mInterruptPumpForMove[iPump].prPressureSource := prPressure;
      mInterruptPumpForMove[iPump].prVelocitySource := prVelocity;
      mInterruptPumpForMove[iPump].piCtrlParamSet := pMoveData^.AnaOutData.piCtrlParamSet;
      
      aIsMaster(iPump := iPump, 
                pRequiredPumps := pMoveData^.AnaOutData.pRequiredPumps);
      
      mInterruptPumpForMove[iPump].bMaster := aIsMaster.bMaster;
      
      //set state to "nAnaDevStopping"
      CoordElement.ElementData.AnaDevState := nAnaDevStopping;
      abCoordList.aModifyAt(iPos := abCoordList.aSearch.iPos, Element:= CoordElement);
      
      // send stop command to pump
      evAnaDevCmdData.DeviceId    := DeviceIdTarget;
      evAnaDevCmdData.Cmd         := nAnaDevStop;
      SET_EVENT(evAnaDevCmd, evAnaDevCmdData);
   END_IF;
                                                     
ELSE
   //error: pump should be stopped but it is not active
   dummy := Print('ABCoordination.aInterruptActivePump: Pump %d should be interrupted but it is not active', iPump);             
END_IF;


;#END_EDIT_BLOCK END_ALGORITHM

(*
@i    Requesting an output:
    
@i    1. evaOutputRequest receives the request event sent by the SourceDevice. 
@i    2. check if the TargetDevice is occupied at the moment by searching in abCoordList.
@i    3. if the Target is occupied a new entry is added to the coordList with the state nAnaDevStopped,
@i       -> the Source has to wait for the target until it is idle again.
@i    4. if the target is free, a new entry is added to the coordList with the state nAnaDevStarted, and the 
@i       event evAnaDevCmd is sent to the Target OutputDevice.
     

@i    Releasing an outputDevice:
    
@i    1. evaOutputRequest receives the release event sent by the SourceDevice. 
@i    2. Searching for the target in the coordlist.
@i       If the target has the state nAnaDevStarted (output is active), 
@i       the state will be set to nAnaDevStopping, and the target is signalled that it shoud stop the output (by sending evAnaDevCmd).
@i       If the target has the state nAnaDevStopped (idle) the targetDevice is removed from the coordList.    

*)

EVENT_ALGORITHM evaOutputRequest ON EV_Task_1 WITH evOutputRequest


VAR_INPUT
 evOutputRequestData : tevOutputRequestData;
END_VAR

VAR_TEMP
 iPump : DINT;
END_VAR

VAR
 RequiredPumps : tyRequiredPumps;
 NoPumps : tyRequiredPumps;
 evOutputResponseData : tevOutputResponseData;
 bMaster : BOOL;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF CHECK_REF(evOutputRequestData.pMoveData^.AnaOutData.pRequiredPumps^) THEN
   //movement has info about pump assignment
   RequiredPumps := evOutputRequestData.pMoveData^.AnaOutData.pRequiredPumps^.RequiredPumps;   
ELSE
   //output request without a definition of required pumps -> alarm  
   SET_ALARM(Name := erNoPumpDefinition,
             SubID1 := evOutputRequestData.DeviceIdSender.CompId,
             SubID2 := evOutputRequestData.DeviceIdSender.IndexId,
             SubID3 := evOutputRequestData.pMoveData^.MoveId);
   RETURN;
END_IF;

IF RequiredPumps = NoPumps THEN
   //no pump is required 
   IF NOT evOutputRequestData.bRelease THEN
      //-> send response and return
      evOutputResponseData.DeviceId := evOutputRequestData.DeviceIdSender;
      evOutputResponseData.MoveId := evOutputRequestData.pMoveData^.MoveId;
      SET_EVENT(evOutputResponse, evOutputResponseData);
   END_IF;
   
   RETURN;  //no entries to coord list -> return
END_IF;

FOR iPump := 1 TO sv_NumberOfDevices[cCompPump] DO
   IF RequiredPumps[iPump] THEN
      
      IF evOutputRequestData.bRelease THEN
         //release pump            
         aReleaseSinglePump(iPump := iPump,
                            DeviceIdSender := evOutputRequestData.DeviceIdSender);      
      ELSE      
         //request pump             
         aIsMaster(iPump := iPump, 
                   pRequiredPumps := evOutputRequestData.pMoveData^.AnaOutData.pRequiredPumps,
                   bMaster => bMaster);
         
         aRequestSinglePump(iPump := iPump,
                            DeviceIdSource := evOutputRequestData.DeviceIdSender,
                            MoveId := evOutputRequestData.pMoveData^.MoveId,
                            AnaOutputMode := evOutputRequestData.AnaOutputMode,
                            prPressureSource := evOutputRequestData.prPressure,
                            prVelocitySource := evOutputRequestData.prVelocity,
                            piCtrlParamSet := evOutputRequestData.pMoveData^.AnaOutData.piCtrlParamSet,
                            bMaster := bMaster);
         
      END_IF;
   END_IF; //end_if pump required
END_FOR;

     
   
      

    


;#END_EDIT_BLOCK END_ALGORITHM

(*
@i   OutputDevice has started:

@i  1. The OutputDevice sends evAnaDevResposne with state nAnaDevStarted.
@i  2. The CoordList is searched for the entry of the responding OutputDevice to get the sourceDevice which has requested the Target.
@i  3. The state of the entry is modified to the state nAnaDevStarted


@i  OutputDevice has stopped:

@i  1. The OutputDevice sends evAnaDevResposne with state nAnaDevStopped.
@i  2. The CoordList is searched for the entry of the responding OutputDevice to get the sourceDevice which has requested the Target.
@i  3. The entry is removed from the CoordList.
@i  4. Checking CoordList if there is another sourceDevice which is waiting for the Target that is now idle again.
@i  5. If Found:
@i     Setting the state to nAnaDevStarted.
@i     Sending a Start-Message to the OutputDevice.
   
   
*)

EVENT_ALGORITHM evaAnaDevResponse ON EV_Task_1(1) WITH evAnaDevResponse


VAR_INPUT
 evAnaDevResponseData : tevAnaDevResponseData;
END_VAR

VAR_TEMP
 TmpDeviceId : tsDeviceId;
 TmpMoveId : tMoveIdent;
 b : BOOL;
END_VAR

VAR
 CoordElement : tsElementCoord;
 evAnaDevCmdData : tevAnaDevCmdData;
 bStartPump : BOOL;
 DeviceIdNone : tsDeviceId := (CompId:=cCompNone,IndexId:=1);
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// get the coordination entry for the responding AnalogDevice
abCoordList.aSearch.SearchData.DeviceIdAnaDev := evAnaDevResponseData.DeviceId;
abCoordList.aSearch();
CoordElement := abCoordList.aSearch.Element;

IF abCoordList.aSearch.bFound THEN
  
    CASE evAnaDevResponseData.State OF
   
       nAnaDevStopped:  //AnalogDevice has stopped
                        IF abCoordList.aSearch.Element.ElementData.AnaDevState = nAnaDevStopping THEN
                           
                            b := WRITE_SV_DIRECT(sv_PumpData[evAnaDevResponseData.DeviceId.IndexId].PumpState, mPumpStateFree);
                            b := WRITE_SV_DIRECT(sv_PumpData[evAnaDevResponseData.DeviceId.IndexId].ActiveDevice, DeviceIdNone);
                            TmpMoveId := cMinMoveIdent;
                            b := WRITE_SV_DIRECT(sv_PumpData[evAnaDevResponseData.DeviceId.IndexId].ActiveMoveId, TmpMoveId);
                             
                            bStartPump := FALSE;
                            IF mStopForInterrupt[evAnaDevResponseData.DeviceId.IndexId] THEN
                               //pump was stopped because of interrupt -> give pump to interrupting movement
                               CoordElement.ElementData := mInterruptPumpForMove[evAnaDevResponseData.DeviceId.IndexId];
                               abCoordList.aModifyAt.Element.SearchData.DeviceIdAnaDev := evAnaDevResponseData.DeviceId;
                               abCoordList.aModifyAt.Element.ElementData := CoordElement.ElementData;
                               abCoordList.aModifyAt(iPos := abCoordList.aSearch.iPos);
                               mInterruptPumpForMove[evAnaDevResponseData.DeviceId.IndexId] := mEmptyCoordElementData;
                               mStopForInterrupt[evAnaDevResponseData.DeviceId.IndexId] := FALSE;
                               bStartPump := TRUE;
                               IF sv_TraceLevel.bAnalog THEN
                                  dummy := Print('give Pump %d to device %d/%d', evAnaDevResponseData.DeviceId.IndexId, 
                                                 CoordElement.ElementData.DeviceIdSource.CompId,
                                                 CoordElement.ElementData.DeviceIdSource.IndexId);
                               END_IF;                                                        
                            ELSIF (mReturnPumpToMove[evAnaDevResponseData.DeviceId.IndexId].DeviceIdSource.CompId <> cCompNone) THEN
                               //return pump to defined device (add previous entry to coord list)
                               CoordElement.ElementData := mReturnPumpToMove[evAnaDevResponseData.DeviceId.IndexId];
                               abCoordList.aModifyAt.Element.SearchData.DeviceIdAnaDev := evAnaDevResponseData.DeviceId;
                               abCoordList.aModifyAt.Element.ElementData := CoordElement.ElementData;
                               abCoordList.aModifyAt(iPos := abCoordList.aSearch.iPos);
                               mReturnPumpToMove[evAnaDevResponseData.DeviceId.IndexId] := mEmptyCoordElementData;
                               bStartPump := TRUE;
                               IF sv_TraceLevel.bAnalog THEN
                                  dummy := Print('return Pump %d to device %d/%d', evAnaDevResponseData.DeviceId.IndexId, 
                                                 CoordElement.ElementData.DeviceIdSource.CompId,
                                                 CoordElement.ElementData.DeviceIdSource.IndexId);
                               END_IF;                               
                            ELSE                             
                               abCoordList.aRemoveAt(abCoordList.aSearch.iPos);    //remove entry
                               //Searching for the next request that is waiting for the AnalogDevice
                               abCoordList.aSearch.SearchData.DeviceIdAnaDev := evAnaDevResponseData.DeviceId;
                               abCoordList.aSearch();
                               IF abCoordList.aSearch.bFound THEN
                                  // found a waiting SourceDevice in CoordList
                                  CoordElement := abCoordList.aSearch.Element;
                                  bStartPump := TRUE;
                               END_IF;
                            END_IF;
                           
                            IF bStartPump THEN                               
                                //modify state
                                CoordElement.ElementData.AnaDevState := nAnaDevStarted;
                                abCoordList.aModifyAt(iPos := abCoordList.aSearch.iPos, Element := CoordElement);
                               
                                // send Start to AnalogDevice
                                evAnaDevCmdData.Cmd            := nAnaDevStart; 
                                evAnaDevCmdData.DeviceId       := CoordElement.SearchData.DeviceIdAnaDev;
                                evAnaDevCmdData.Mode           := CoordElement.ElementData.AnaOutputMode;
                                evAnaDevCmdData.prAnaOutP      := CoordElement.ElementData.prPressureSource;
                                evAnaDevCmdData.prAnaOutV      := CoordElement.ElementData.prVelocitySource;
                                evAnaDevCmdData.MoveId         := CoordElement.ElementData.MoveId;
                                evAnaDevCmdData.piCtrlParamSet := CoordElement.ElementData.piCtrlParamSet;
                                evAnaDevCmdData.bMaster        := CoordElement.ElementData.bMaster;
                                SET_EVENT(evAnaDevCmd, evAnaDevCmdData);
                               
                                b := WRITE_SV_DIRECT(sv_PumpData[evAnaDevResponseData.DeviceId.IndexId].PumpState, mPumpStateBusy);
                                TmpDeviceId := CoordElement.ElementData.DeviceIdSource;
                                b := WRITE_SV_DIRECT(sv_PumpData[evAnaDevResponseData.DeviceId.IndexId].ActiveDevice, TmpDeviceId);
                                TmpMoveId := CoordElement.ElementData.MoveId;
                                b := WRITE_SV_DIRECT(sv_PumpData[evAnaDevResponseData.DeviceId.IndexId].ActiveMoveId, TmpMoveId);
                            END_IF;
                        ELSE
                            //error: wrong State
                            fbDebugTrace(sText := 'ABCoordination.evaAnaDevResponse: Wrong AnalogDevice State');                        
                        END_IF;
       
       nAnaDevStopping, 
       nAnaDevStarted: (* this states will not be reported by analog devices *);
   
    END_CASE;              
ELSE       
    //error: AnalogDevice was never requested but has responded
    fbDebugTrace(sText := 'ABCoordination.evaAnaDevResponse: AnalogDevice has responded without any request');
END_IF;



;#END_EDIT_BLOCK END_ALGORITHM

(*
@i    Requesting an output:
    
@i    1. evaOutputRequest receives the request event sent by the SourceDevice. 
@i    2. check if the TargetDevice is occupied at the moment by searching in abCoordList.
@i    3. if the Target is occupied a new entry is added to the coordList with the state nAnaDevStopped,
@i       -> the Source has to wait for the target until it is idle again.
@i    4. if the target is free, a new entry is added to the coordList with the state nAnaDevStarted, and the 
@i       event evAnaDevCmd is sent to the Target OutputDevice.
     

@i    Releasing an outputDevice:
    
@i    1. evaOutputRequest receives the release event sent by the SourceDevice. 
@i    2. Searching for the target in the coordlist.
@i       If the target has the state nAnaDevStarted (output is active), 
@i       the state will be set to nAnaDevStopping, and the target is signalled that it shoud stop the output (by sending evAnaDevCmd).
@i       If the target has the state nAnaDevStopped (idle) the targetDevice is removed from the coordList.    

*)

EVENT_ALGORITHM evaRequestSinglePump ON EV_Task_1 WITH evRequestSinglePump


VAR_INPUT
 evRequestSinglePumpData : tevRequestSinglePumpData;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (evRequestSinglePumpData.iPump = 0) OR (evRequestSinglePumpData.iPump > cMaxNrOfPumps) THEN
   dummy := Print('evRequestSinglePump with invalid pump number received');
   RETURN;
END_IF;

aRequestSinglePump(iPump := evRequestSinglePumpData.iPump,
                   DeviceIdSource := evRequestSinglePumpData.DeviceIdSender,
                   MoveId := evRequestSinglePumpData.pMoveData^.MoveId,
                   AnaOutputMode := evRequestSinglePumpData.AnaOutputMode,
                   prPressureSource := evRequestSinglePumpData.prPressure,
                   prVelocitySource := evRequestSinglePumpData.prVelocity,
                   piCtrlParamSet := evRequestSinglePumpData.pMoveData^.AnaOutData.piCtrlParamSet,
                   bMaster := TRUE);
 

     
   
      

    


;#END_EDIT_BLOCK END_ALGORITHM

EVENT_ALGORITHM evaReleaseSinglePump ON EV_Task_1 WITH evReleaseSinglePump


VAR_INPUT
 evReleaseSinglePumpData : tevReleaseSinglePumpData;
END_VAR

VAR
 dummy : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bAnalog THEN
   dummy := Print('ABCoordination: evReleaseSinglePump for Pump%d received',evReleaseSinglePumpData.iPump);
   dummy := Print('Pump release was requested by device: %d/%d',evReleaseSinglePumpData.DeviceIdSender.CompId, evReleaseSinglePumpData.DeviceIdSender.IndexId);
END_IF;

aReleaseSinglePump(iPump := evReleaseSinglePumpData.iPump,
                   DeviceIdSender := evReleaseSinglePumpData.DeviceIdSender);


;#END_EDIT_BLOCK END_ALGORITHM

EVENT_ALGORITHM evaInterruptActivePump ON EV_Task_1 WITH evInterruptActivePump


VAR_INPUT
 evInterruptActivePumpData : tevInterruptActivePumpData;
END_VAR

VAR
 dummy : DINT;
END_VAR
#BEGIN_EDIT_BLOCK
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bAnalog THEN
   dummy := Print('ABCoordination: evInterruptActivePump for Pump%d received', evInterruptActivePumpData.iPump);
   dummy := Print('Pump stop was requested by device: %d/%d',evInterruptActivePumpData.DeviceIdSender.CompId, evInterruptActivePumpData.DeviceIdSender.IndexId);
END_IF;

aInterruptActivePump(iPump := evInterruptActivePumpData.iPump,
                     DeviceIdSender := evInterruptActivePumpData.DeviceIdSender,
                     pMoveData := evInterruptActivePumpData.pMoveData,
                     AnaOutputMode := evInterruptActivePumpData.AnaOutputMode,
                     prVelocity := evInterruptActivePumpData.prVelocity,
                     prPressure := evInterruptActivePumpData.prPressure);



;#END_EDIT_BLOCK END_ALGORITHM



END_ALGORITHM_BLOCK



#END_OF_IEC_PART

@Puma @IecEditor 6 97 @Pou 25 
@@@BEG_Comment@@@
@h    ! WARNING !
@h    The Kemro K2 system (including software) only meets category B according to EN 954-1,
@h    thus it is not intended for usage in safety-relevant control applications in the field 
@h    of personal safety (e.g. emergency stop).
@h    To implement potentially necessary safety-relevant control tasks, always use additional 
@h    external safety devices that are intended for the particular purpose, and meet the necessary 
@h    functional safety.
@h    For further information see EN 954-1 (EN ISO 13849-1) and/or the K2-x00 user manual, chapter 
@h    "CE conformity, directives and standards".

This AB coordinates the access to the available pumps
The SourceDevice (eg. Ejector1) requests the access to the pump(s) by the AlgorithmBlock ABOutputRequest (aRequest).
If the requested pump is idle (no other SourceDevice is making outputs) the sourceDevice gets the signal that it is allowed
to make outputs (see ABOutputRequest.aCheck). If the pump is occupied, the SourceDevice has to wait until the pump
is free again (see ABOutputRequest.aRelease).


@@@END_Comment@@@

@BEG_Contents 

@BEG_Func 
@RT(17)FuncTreeContainer 
2 
@Var @RT(9)SET_EVENT @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)SET_ALARM @RT(0) @T @T @DERIVED 0 @F @RT(23)KEBA_STANDARD_PROCEDURE @F 
@T 
@BEG_Attrib 
0 @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Func 

@BEG_Const 
@RT(18)ConstTreeContainer 
2 
@Var @RT(9)cCompNone @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(10)cMinCompId @RT(4)None 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(9)cCompPump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
0 @RT(3)113 @RT(14)Component Pump 
@END_Attrib 
1 1 @F @F @F @F 

@END_Const 

@BEG_Export 

@BEG_Kind 
@ALGORITHM_BLOCK @RT(14)ABCoordination @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) 
@END_Kind 

@BEG_Dcl 
@RT(16)DclTreeContainer 
24 
@Var @RT(11)abCoordList @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(11)ABCoordList @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)evAnaDevCmd @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tevAnaDevCmd @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(16)evAnaDevResponse @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tevAnaDevResponse @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(9)EV_Task_1 @RT(0) @T @F @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(15)evOutputRequest @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)tevOutputRequest @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(16)evOutputResponse @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tevOutputResponse @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(12)fbDebugTrace @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)FBDebugTrace @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(13)sv_TraceLevel @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(12)tsTraceLevel @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(7)TaskMid @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(4)TASK @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(18)erNoPumpDefinition @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(11)sv_PumpData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tyPumpData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(18)sv_NumberOfDevices @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(17)tyNumberOfDevices @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 8 @F @F @F @F 

@Var @RT(19)evReleaseSinglePump @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tevReleaseSinglePump @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(21)evInterruptActivePump @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(22)tevInterruptActivePump @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(17)mReturnPumpToMove @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)tyCoordElementData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(21)mInterruptPumpForMove @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)tyCoordElementData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(22)mEmptyCoordElementData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)tsElementDataCoord @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(17)mStopForInterrupt @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(18)tyStopForInterrupt @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(25)erPumpInterruptNotAllowed @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(19)erInterruptLastPump @RT(0) @T @F @DT @RT(5)ALARM @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(19)evRequestSinglePump @RT(0) @T @T @RENAMED 0 @T @T @DT @RT(20)tevRequestSinglePump @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 7 @F @F @F @F 

@Var @RT(14)mPumpStateFree @RT(0) @T @T @DERIVED 0 @F @RT(11)tnPumpState @F 
@T 
@BEG_Attrib 
3 @RT(14)nPumpStateFree @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)mPumpStateBusy @RT(0) @T @T @DERIVED 0 @F @RT(11)tnPumpState @F 
@T 
@BEG_Attrib 
3 @RT(14)nPumpStateBusy @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 

10 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(9)aIsMaster @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
4 
@Var @RT(5)iPump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)pRequiredPumps @RT(0) @T @T @REFTO 0 @F @DERIVED 0 @T @T @DT @RT(15)tsRequiredPumps @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)bMaster @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 3 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@PROCESS_ALGORITHM @RT(6)paInit @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(10)TaskMid(1) @T @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
0 
@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(18)aReleaseSinglePump @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
8 
@Var @RT(5)iPump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)DeviceIdSender @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)DeviceIdSource @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)DeviceIdTarget @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)CoordElement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)tsElementCoord @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)iCoordPos @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)evAnaDevCmdData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)tevAnaDevCmdData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(1)i @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(18)aRequestSinglePump @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
13 
@Var @RT(15)evAnaDevCmdData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)tevAnaDevCmdData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)DeviceIdTarget @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)iPump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)DeviceIdSource @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(6)MoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)AnaOutputMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnAnaOutputMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)prPressureSource @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(16)prVelocitySource @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)piCtrlParamSet @RT(0) @T @T @REFTO 0 @T @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(7)bMaster @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(11)TmpDeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(9)TmpMoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@ALGORITHM @RT(20)aInterruptActivePump @STRUCTURED_TEXT 
@RT(0) @RT(0) @RT(0) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
14 
@Var @RT(5)iPump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)DeviceIdSender @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(14)DeviceIdTarget @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)CoordElement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)tsElementCoord @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)evAnaDevCmdData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)tevAnaDevCmdData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(9)pMoveData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tpMoveData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)AnaOutputMode @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tnAnaOutputMode @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)prVelocity @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(51)optional parameter; by default sv_rVelocity is used @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)prPressure @RT(0) @T @T @REFTO 0 @T @DT @RT(4)REAL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(51)optional parameter; by default sv_rPressure is used @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(10)iUsedPumps @RT(0) @T @F @DT @RT(3)INT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(12)iListEntries @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(6)iEntry @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(15)TmpCoordElement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)tsElementCoord @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(14)DeviceIdSource @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(16)evaOutputRequest @STRUCTURED_TEXT 
@RT(0) @RT(15)evOutputRequest @RT(9)EV_Task_1 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
6 
@Var @RT(19)evOutputRequestData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(20)tevOutputRequestData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(13)RequiredPumps @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tyRequiredPumps @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(5)iPump @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(7)NoPumps @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(15)tyRequiredPumps @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(20)evOutputResponseData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)tevOutputResponseData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(7)bMaster @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(17)evaAnaDevResponse @STRUCTURED_TEXT 
@RT(0) @RT(16)evAnaDevResponse @RT(12)EV_Task_1(1) @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
8 
@Var @RT(20)evAnaDevResponseData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(21)tevAnaDevResponseData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(12)CoordElement @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(14)tsElementCoord @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(15)evAnaDevCmdData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(16)tevAnaDevCmdData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(10)bStartPump @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@Var @RT(11)TmpDeviceId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tsDeviceId @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(9)TmpMoveId @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(10)tMoveIdent @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(1)b @RT(0) @T @F @DT @RT(4)BOOL @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 4 @F @F @F @F 

@Var @RT(12)DeviceIdNone @RT(0) @T @T @DERIVED 0 @F @RT(10)tsDeviceId @F 
@T 
@BEG_Attrib 
3 @RT(30)(CompId:=cCompNone,IndexId:=1) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(20)evaRequestSinglePump @STRUCTURED_TEXT 
@RT(0) @RT(19)evRequestSinglePump @RT(9)EV_Task_1 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
1 
@Var @RT(23)evRequestSinglePumpData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(24)tevRequestSinglePumpData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(20)evaReleaseSinglePump @STRUCTURED_TEXT 
@RT(0) @RT(19)evReleaseSinglePump @RT(9)EV_Task_1 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(23)evReleaseSinglePumpData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(24)tevReleaseSinglePumpData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Export 

@BEG_Algo 
@EVENT_ALGORITHM @RT(22)evaInterruptActivePump @STRUCTURED_TEXT 
@RT(0) @RT(21)evInterruptActivePump @RT(9)EV_Task_1 @F @F 
@END_Algo 

@BEG_Dcl 
@RT(16)DclTreeContainer 
2 
@Var @RT(25)evInterruptActivePumpData @RT(0) @T @T @DERIVED 0 @T @T @DT @RT(26)tevInterruptActivePumpData @RT(0) @T @T @UNKNOWN 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 1 @F @F @F @F 

@Var @RT(5)dummy @RT(0) @T @F @DT @RT(4)DINT @RT(0) @T @T @BASIC 0 @F 
@F @F 
@T 
@BEG_Attrib 
3 @RT(0) @RT(0) @RT(0) 
@END_Attrib 
1 0 @F @F @F @F 

@END_Dcl 

@END_Export 

@BEG_Body 
@TL(25)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

//the first required pump of a movement is master
//all other pumps are slaves
IF CHECK_REF(pRequiredPumps^) THEN
   FOR i := 1 TO cMaxNrOfPumps DO
      //search for the first required pump
      //if first required pump = given pump: pump is master
      IF pRequiredPumps^.RequiredPumps[i] THEN
         IF (i = iPump) THEN
            bMaster := TRUE;
         ELSE
            bMaster := FALSE;
         END_IF;
         
         EXIT; //exit loop
      END_IF;
   END_FOR;
ELSE
   bMaster := FALSE;
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(20)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

abCoordList.aInit();

STOP_PROCESS_ALGORITHM();












@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(67)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bAnalog THEN
   dummy := Print('ABCoordination.aReleaseSinglePump: Pump %d ', iPump);
END_IF;

DeviceIdTarget.CompId := cCompPump;
DeviceIdTarget.IndexId := iPump; 
abCoordList.aSearch.SearchData.DeviceIdAnaDev := DeviceIdTarget;
abCoordList.aSearch();

IF abCoordList.aSearch.bFound THEN
   iCoordPos := abCoordList.aSearch.iPos; 
   CoordElement := abCoordList.aSearch.Element;
   DeviceIdSource := abCoordList.aSearch.Element.ElementData.DeviceIdSource;
   
   //a movement releases a pump -> check if this movement should get back a pump
   //if yes: delete this return information
   FOR i := 1 TO sv_NumberOfDevices[cCompPump] DO
      IF DeviceIdSender = mReturnPumpToMove[i].DeviceIdSource THEN
         mReturnPumpToMove[i] := mEmptyCoordElementData;
      END_IF;
   END_FOR;
   
   REPEAT
      // search for the SourceDevice in the CoordList
      IF DeviceIdSource = DeviceIdSender THEN
         
         IF CoordElement.ElementData.AnaDevState = nAnaDevStarted THEN
                                  
            // set state to "nAnaDevStopping"
            CoordElement := abCoordList.aSearch.Element;
            CoordElement.ElementData.AnaDevState := nAnaDevStopping;
            abCoordList.aModifyAt(iPos := abCoordList.aSearch.iPos, Element:= CoordElement);
            
            // sending stop command to pump
            evAnaDevCmdData.DeviceId    := DeviceIdTarget;
            evAnaDevCmdData.Cmd         := nAnaDevStop;
            SET_EVENT(evAnaDevCmd, evAnaDevCmdData);
               
         ELSIF CoordElement.ElementData.AnaDevState = nAnaDevStopped THEN
            // state is nAnaDevStopped -> the SourceDevice was waiting for the pump 
            // and has released the pump now -> remove from Coordlist 
            // If the state is nAnaDevStopping the entry will be cleared when the pump
            // sends the response to OutputCoordination with the state nAnaDevStopped
            abCoordList.aRemoveAt(iCoordPos);  
         END_IF;
                                 
         EXIT; // the pump that should be released was found -> exit loop
      END_IF;
      
      // searching for the next CoordEntry in the list
      abCoordList.aSearchNext.SearchData.DeviceIdAnaDev := DeviceIdTarget;
      abCoordList.aSearchNext();
      iCoordPos := abCoordList.aSearchNext.iPos;
      CoordElement := abCoordList.aSearchNext.Element;
      DeviceIdSource := abCoordList.aSearchNext.Element.ElementData.DeviceIdSource;
   UNTIL NOT abCoordList.aSearchNext.bFound
   END_REPEAT;                    
ELSE
   //error: pump was never requested but should be released now
   dummy := Print('ABCoordination.aReleaseSinglePump: Pump %d should be released although it is not used', iPump);             
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(64)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (iPump = 0) OR (iPump > cMaxNrOfPumps) THEN
   dummy := Print('aRequestSinglePump with invalid pump number called');
   RETURN;
END_IF;
                       
DeviceIdTarget.CompId := cCompPump;
DeviceIdTarget.IndexId := iPump; 
abCoordList.aSearch.SearchData.DeviceIdAnaDev := DeviceIdTarget;
abCoordList.aSearch();

// add Entry to CoordList
abCoordList.aAdd.Element.SearchData.DeviceIdAnaDev    := DeviceIdTarget;
abCoordList.aAdd.Element.ElementData.DeviceIdSource   := DeviceIdSource;
abCoordList.aAdd.Element.ElementData.MoveId           := MoveId;
abCoordList.aAdd.Element.ElementData.AnaOutputMode    := AnaOutputMode;
abCoordList.aAdd.Element.ElementData.prPressureSource := prPressureSource;
abCoordList.aAdd.Element.ElementData.prVelocitySource := prVelocitySource;
abCoordList.aAdd.Element.ElementData.piCtrlParamSet   := piCtrlParamSet;         
abCoordList.aAdd.Element.ElementData.bMaster          := bMaster;

IF abCoordList.aSearch.bFound THEN
   // target (pump) found in Coordlist -> target is already requested
   // set state to "Stopped" -> Source is waiting for the target
   abCoordList.aAdd.Element.ElementData.AnaDevState   := nAnaDevStopped;
ELSE
   // Target was not found in Coordlist (Target is ready to be started)
   // -> set State to "Started"
   abCoordList.aAdd.Element.ElementData.AnaDevState   := nAnaDevStarted;
END_IF;

abCoordList.aAdd();
IF NOT abCoordList.aSearch.bFound THEN
   // send Start to pump
   evAnaDevCmdData.DeviceId         := DeviceIdTarget;
   evAnaDevCmdData.Cmd              := nAnaDevStart;
   evAnaDevCmdData.Mode             := AnaOutputMode;
   evAnaDevCmdData.prAnaOutP        := prPressureSource;
   evAnaDevCmdData.prAnaOutV        := prVelocitySource;
   evAnaDevCmdData.MoveId           := MoveId;
   evAnaDevCmdData.piCtrlParamSet   := piCtrlParamSet;
   evAnaDevCmdData.bMaster          := bMaster;
   SET_EVENT(evAnaDevCmd, evAnaDevCmdData);
    
   //write sv_PumpData
   b := WRITE_SV_DIRECT(sv_PumpData[iPump].PumpState, mPumpStateBusy);
   TmpDeviceId := DeviceIdSource;
   b := WRITE_SV_DIRECT(sv_PumpData[iPump].ActiveDevice, TmpDeviceId);
   TmpMoveId := MoveId;
   b := WRITE_SV_DIRECT(sv_PumpData[iPump].ActiveMoveId, TmpMoveId);
 
END_IF;
 

     
   
      

    

@END_Body 

@@@BEG_Comment@@@ 
@TL(18)
@i    Requesting an output:
    
@i    1. evaOutputRequest receives the request event sent by the SourceDevice. 
@i    2. check if the TargetDevice is occupied at the moment by searching in abCoordList.
@i    3. if the Target is occupied a new entry is added to the coordList with the state nAnaDevStopped,
@i       -> the Source has to wait for the target until it is idle again.
@i    4. if the target is free, a new entry is added to the coordList with the state nAnaDevStarted, and the 
@i       event evAnaDevCmd is sent to the Target OutputDevice.
     

@i    Releasing an outputDevice:
    
@i    1. evaOutputRequest receives the release event sent by the SourceDevice. 
@i    2. Searching for the target in the coordlist.
@i       If the target has the state nAnaDevStarted (output is active), 
@i       the state will be set to nAnaDevStopping, and the target is signalled that it shoud stop the output (by sending evAnaDevCmd).
@i       If the target has the state nAnaDevStopped (idle) the targetDevice is removed from the coordList.    

@@@END_Comment@@@ 

@BEG_Body 
@TL(84)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bAnalog THEN
   dummy := Print('ABCoordination.aInterruptActivePump: Pump %d should be interrupted', iPump);
END_IF;

IF (mReturnPumpToMove[iPump].DeviceIdSource.CompId <> cCompNone) THEN
   //pump is already interrupted -> set alarm
   SET_ALARM(Name := erPumpInterruptNotAllowed,
               SubID1 := iPump,
               SubID2 := DeviceIdSender.CompId,
               SubID3 := DeviceIdSender.IndexId,
               SubID4 := pMoveData^.MoveId);
   RETURN;
END_IF;

DeviceIdTarget.CompId := cCompPump;
DeviceIdTarget.IndexId := iPump; 
abCoordList.aSearch.SearchData.DeviceIdAnaDev := DeviceIdTarget;
abCoordList.aSearch();

IF abCoordList.aSearch.bFound THEN 
      
   CoordElement := abCoordList.aSearch.Element;
   IF CoordElement.ElementData.AnaDevState = nAnaDevStarted THEN         
      
      //it is not allowed to interrupt all pumps of a movement
      //check if at least one pump remains for this device after the "interrupted" pump is given away      
      DeviceIdSource := CoordElement.ElementData.DeviceIdSource;
      iListEntries := abCoordList.aGetElementCount();
      iUsedPumps := 0;
      FOR iEntry := 1 TO iListEntries DO
         abCoordList.aElementAt(iPos := iEntry, Element => TmpCoordElement);
         IF (TmpCoordElement.ElementData.DeviceIdSource = DeviceIdSource) AND (TmpCoordElement.ElementData.AnaDevState = nAnaDevStarted) THEN
            iUsedPumps := iUsedPumps + 1;
         END_IF;
      END_FOR;
      
      IF NOT (iUsedPumps > 1) THEN
         //the last pump should be given away -> alarm
         SET_ALARM(Name := erInterruptLastPump,
                   SubID1 := iPump,
                   SubID2 := DeviceIdSender.CompId,
                   SubID3 := DeviceIdSender.IndexId,
                   SubID4 := DeviceIdSource.CompId);
         RETURN;
      END_IF;
      
      //remember which movements actually used the pump (for giving it back later)
      mReturnPumpToMove[iPump] := CoordElement.ElementData;
      mStopForInterrupt[iPump] := TRUE;
      
      //save information about which movement should use the pump
      mInterruptPumpForMove[iPump].DeviceIdSource := DeviceIdSender;
      mInterruptPumpForMove[iPump].MoveId := pMoveData^.MoveId;
      mInterruptPumpForMove[iPump].AnaOutputMode := AnaOutputMode;
      mInterruptPumpForMove[iPump].AnaDevState := nAnaDevStopped;
      mInterruptPumpForMove[iPump].prPressureSource := prPressure;
      mInterruptPumpForMove[iPump].prVelocitySource := prVelocity;
      mInterruptPumpForMove[iPump].piCtrlParamSet := pMoveData^.AnaOutData.piCtrlParamSet;
      
      aIsMaster(iPump := iPump, 
                pRequiredPumps := pMoveData^.AnaOutData.pRequiredPumps);
      
      mInterruptPumpForMove[iPump].bMaster := aIsMaster.bMaster;
      
      //set state to "nAnaDevStopping"
      CoordElement.ElementData.AnaDevState := nAnaDevStopping;
      abCoordList.aModifyAt(iPos := abCoordList.aSearch.iPos, Element:= CoordElement);
      
      // send stop command to pump
      evAnaDevCmdData.DeviceId    := DeviceIdTarget;
      evAnaDevCmdData.Cmd         := nAnaDevStop;
      SET_EVENT(evAnaDevCmd, evAnaDevCmdData);
   END_IF;
                                                     
ELSE
   //error: pump should be stopped but it is not active
   dummy := Print('ABCoordination.aInterruptActivePump: Pump %d should be interrupted but it is not active', iPump);             
END_IF;

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(61)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF CHECK_REF(evOutputRequestData.pMoveData^.AnaOutData.pRequiredPumps^) THEN
   //movement has info about pump assignment
   RequiredPumps := evOutputRequestData.pMoveData^.AnaOutData.pRequiredPumps^.RequiredPumps;   
ELSE
   //output request without a definition of required pumps -> alarm  
   SET_ALARM(Name := erNoPumpDefinition,
             SubID1 := evOutputRequestData.DeviceIdSender.CompId,
             SubID2 := evOutputRequestData.DeviceIdSender.IndexId,
             SubID3 := evOutputRequestData.pMoveData^.MoveId);
   RETURN;
END_IF;

IF RequiredPumps = NoPumps THEN
   //no pump is required 
   IF NOT evOutputRequestData.bRelease THEN
      //-> send response and return
      evOutputResponseData.DeviceId := evOutputRequestData.DeviceIdSender;
      evOutputResponseData.MoveId := evOutputRequestData.pMoveData^.MoveId;
      SET_EVENT(evOutputResponse, evOutputResponseData);
   END_IF;
   
   RETURN;  //no entries to coord list -> return
END_IF;

FOR iPump := 1 TO sv_NumberOfDevices[cCompPump] DO
   IF RequiredPumps[iPump] THEN
      
      IF evOutputRequestData.bRelease THEN
         //release pump            
         aReleaseSinglePump(iPump := iPump,
                            DeviceIdSender := evOutputRequestData.DeviceIdSender);      
      ELSE      
         //request pump             
         aIsMaster(iPump := iPump, 
                   pRequiredPumps := evOutputRequestData.pMoveData^.AnaOutData.pRequiredPumps,
                   bMaster => bMaster);
         
         aRequestSinglePump(iPump := iPump,
                            DeviceIdSource := evOutputRequestData.DeviceIdSender,
                            MoveId := evOutputRequestData.pMoveData^.MoveId,
                            AnaOutputMode := evOutputRequestData.AnaOutputMode,
                            prPressureSource := evOutputRequestData.prPressure,
                            prVelocitySource := evOutputRequestData.prVelocity,
                            piCtrlParamSet := evOutputRequestData.pMoveData^.AnaOutData.piCtrlParamSet,
                            bMaster := bMaster);
         
      END_IF;
   END_IF; //end_if pump required
END_FOR;

     
   
      

    

@END_Body 

@@@BEG_Comment@@@ 
@TL(18)
@i    Requesting an output:
    
@i    1. evaOutputRequest receives the request event sent by the SourceDevice. 
@i    2. check if the TargetDevice is occupied at the moment by searching in abCoordList.
@i    3. if the Target is occupied a new entry is added to the coordList with the state nAnaDevStopped,
@i       -> the Source has to wait for the target until it is idle again.
@i    4. if the target is free, a new entry is added to the coordList with the state nAnaDevStarted, and the 
@i       event evAnaDevCmd is sent to the Target OutputDevice.
     

@i    Releasing an outputDevice:
    
@i    1. evaOutputRequest receives the release event sent by the SourceDevice. 
@i    2. Searching for the target in the coordlist.
@i       If the target has the state nAnaDevStarted (output is active), 
@i       the state will be set to nAnaDevStopping, and the target is signalled that it shoud stop the output (by sending evAnaDevCmd).
@i       If the target has the state nAnaDevStopped (idle) the targetDevice is removed from the coordList.    

@@@END_Comment@@@ 

@BEG_Body 
@TL(99)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

// get the coordination entry for the responding AnalogDevice
abCoordList.aSearch.SearchData.DeviceIdAnaDev := evAnaDevResponseData.DeviceId;
abCoordList.aSearch();
CoordElement := abCoordList.aSearch.Element;

IF abCoordList.aSearch.bFound THEN
  
    CASE evAnaDevResponseData.State OF
   
       nAnaDevStopped:  //AnalogDevice has stopped
                        IF abCoordList.aSearch.Element.ElementData.AnaDevState = nAnaDevStopping THEN
                           
                            b := WRITE_SV_DIRECT(sv_PumpData[evAnaDevResponseData.DeviceId.IndexId].PumpState, mPumpStateFree);
                            b := WRITE_SV_DIRECT(sv_PumpData[evAnaDevResponseData.DeviceId.IndexId].ActiveDevice, DeviceIdNone);
                            TmpMoveId := cMinMoveIdent;
                            b := WRITE_SV_DIRECT(sv_PumpData[evAnaDevResponseData.DeviceId.IndexId].ActiveMoveId, TmpMoveId);
                             
                            bStartPump := FALSE;
                            IF mStopForInterrupt[evAnaDevResponseData.DeviceId.IndexId] THEN
                               //pump was stopped because of interrupt -> give pump to interrupting movement
                               CoordElement.ElementData := mInterruptPumpForMove[evAnaDevResponseData.DeviceId.IndexId];
                               abCoordList.aModifyAt.Element.SearchData.DeviceIdAnaDev := evAnaDevResponseData.DeviceId;
                               abCoordList.aModifyAt.Element.ElementData := CoordElement.ElementData;
                               abCoordList.aModifyAt(iPos := abCoordList.aSearch.iPos);
                               mInterruptPumpForMove[evAnaDevResponseData.DeviceId.IndexId] := mEmptyCoordElementData;
                               mStopForInterrupt[evAnaDevResponseData.DeviceId.IndexId] := FALSE;
                               bStartPump := TRUE;
                               IF sv_TraceLevel.bAnalog THEN
                                  dummy := Print('give Pump %d to device %d/%d', evAnaDevResponseData.DeviceId.IndexId, 
                                                 CoordElement.ElementData.DeviceIdSource.CompId,
                                                 CoordElement.ElementData.DeviceIdSource.IndexId);
                               END_IF;                                                        
                            ELSIF (mReturnPumpToMove[evAnaDevResponseData.DeviceId.IndexId].DeviceIdSource.CompId <> cCompNone) THEN
                               //return pump to defined device (add previous entry to coord list)
                               CoordElement.ElementData := mReturnPumpToMove[evAnaDevResponseData.DeviceId.IndexId];
                               abCoordList.aModifyAt.Element.SearchData.DeviceIdAnaDev := evAnaDevResponseData.DeviceId;
                               abCoordList.aModifyAt.Element.ElementData := CoordElement.ElementData;
                               abCoordList.aModifyAt(iPos := abCoordList.aSearch.iPos);
                               mReturnPumpToMove[evAnaDevResponseData.DeviceId.IndexId] := mEmptyCoordElementData;
                               bStartPump := TRUE;
                               IF sv_TraceLevel.bAnalog THEN
                                  dummy := Print('return Pump %d to device %d/%d', evAnaDevResponseData.DeviceId.IndexId, 
                                                 CoordElement.ElementData.DeviceIdSource.CompId,
                                                 CoordElement.ElementData.DeviceIdSource.IndexId);
                               END_IF;                               
                            ELSE                             
                               abCoordList.aRemoveAt(abCoordList.aSearch.iPos);    //remove entry
                               //Searching for the next request that is waiting for the AnalogDevice
                               abCoordList.aSearch.SearchData.DeviceIdAnaDev := evAnaDevResponseData.DeviceId;
                               abCoordList.aSearch();
                               IF abCoordList.aSearch.bFound THEN
                                  // found a waiting SourceDevice in CoordList
                                  CoordElement := abCoordList.aSearch.Element;
                                  bStartPump := TRUE;
                               END_IF;
                            END_IF;
                           
                            IF bStartPump THEN                               
                                //modify state
                                CoordElement.ElementData.AnaDevState := nAnaDevStarted;
                                abCoordList.aModifyAt(iPos := abCoordList.aSearch.iPos, Element := CoordElement);
                               
                                // send Start to AnalogDevice
                                evAnaDevCmdData.Cmd            := nAnaDevStart; 
                                evAnaDevCmdData.DeviceId       := CoordElement.SearchData.DeviceIdAnaDev;
                                evAnaDevCmdData.Mode           := CoordElement.ElementData.AnaOutputMode;
                                evAnaDevCmdData.prAnaOutP      := CoordElement.ElementData.prPressureSource;
                                evAnaDevCmdData.prAnaOutV      := CoordElement.ElementData.prVelocitySource;
                                evAnaDevCmdData.MoveId         := CoordElement.ElementData.MoveId;
                                evAnaDevCmdData.piCtrlParamSet := CoordElement.ElementData.piCtrlParamSet;
                                evAnaDevCmdData.bMaster        := CoordElement.ElementData.bMaster;
                                SET_EVENT(evAnaDevCmd, evAnaDevCmdData);
                               
                                b := WRITE_SV_DIRECT(sv_PumpData[evAnaDevResponseData.DeviceId.IndexId].PumpState, mPumpStateBusy);
                                TmpDeviceId := CoordElement.ElementData.DeviceIdSource;
                                b := WRITE_SV_DIRECT(sv_PumpData[evAnaDevResponseData.DeviceId.IndexId].ActiveDevice, TmpDeviceId);
                                TmpMoveId := CoordElement.ElementData.MoveId;
                                b := WRITE_SV_DIRECT(sv_PumpData[evAnaDevResponseData.DeviceId.IndexId].ActiveMoveId, TmpMoveId);
                            END_IF;
                        ELSE
                            //error: wrong State
                            fbDebugTrace(sText := 'ABCoordination.evaAnaDevResponse: Wrong AnalogDevice State');                        
                        END_IF;
       
       nAnaDevStopping, 
       nAnaDevStarted: (* this states will not be reported by analog devices *);
   
    END_CASE;              
ELSE       
    //error: AnalogDevice was never requested but has responded
    fbDebugTrace(sText := 'ABCoordination.evaAnaDevResponse: AnalogDevice has responded without any request');
END_IF;


@END_Body 

@@@BEG_Comment@@@ 
@TL(18)
@i   OutputDevice has started:

@i  1. The OutputDevice sends evAnaDevResposne with state nAnaDevStarted.
@i  2. The CoordList is searched for the entry of the responding OutputDevice to get the sourceDevice which has requested the Target.
@i  3. The state of the entry is modified to the state nAnaDevStarted


@i  OutputDevice has stopped:

@i  1. The OutputDevice sends evAnaDevResposne with state nAnaDevStopped.
@i  2. The CoordList is searched for the entry of the responding OutputDevice to get the sourceDevice which has requested the Target.
@i  3. The entry is removed from the CoordList.
@i  4. Checking CoordList if there is another sourceDevice which is waiting for the Target that is now idle again.
@i  5. If Found:
@i     Setting the state to nAnaDevStarted.
@i     Sending a Start-Message to the OutputDevice.
   
   
@@@END_Comment@@@ 

@BEG_Body 
@TL(26)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF (evRequestSinglePumpData.iPump = 0) OR (evRequestSinglePumpData.iPump > cMaxNrOfPumps) THEN
   dummy := Print('evRequestSinglePump with invalid pump number received');
   RETURN;
END_IF;

aRequestSinglePump(iPump := evRequestSinglePumpData.iPump,
                   DeviceIdSource := evRequestSinglePumpData.DeviceIdSender,
                   MoveId := evRequestSinglePumpData.pMoveData^.MoveId,
                   AnaOutputMode := evRequestSinglePumpData.AnaOutputMode,
                   prPressureSource := evRequestSinglePumpData.prPressure,
                   prVelocitySource := evRequestSinglePumpData.prVelocity,
                   piCtrlParamSet := evRequestSinglePumpData.pMoveData^.AnaOutData.piCtrlParamSet,
                   bMaster := TRUE);
 

     
   
      

    

@END_Body 

@@@BEG_Comment@@@ 
@TL(18)
@i    Requesting an output:
    
@i    1. evaOutputRequest receives the request event sent by the SourceDevice. 
@i    2. check if the TargetDevice is occupied at the moment by searching in abCoordList.
@i    3. if the Target is occupied a new entry is added to the coordList with the state nAnaDevStopped,
@i       -> the Source has to wait for the target until it is idle again.
@i    4. if the target is free, a new entry is added to the coordList with the state nAnaDevStarted, and the 
@i       event evAnaDevCmd is sent to the Target OutputDevice.
     

@i    Releasing an outputDevice:
    
@i    1. evaOutputRequest receives the release event sent by the SourceDevice. 
@i    2. Searching for the target in the coordlist.
@i       If the target has the state nAnaDevStarted (output is active), 
@i       the state will be set to nAnaDevStopping, and the target is signalled that it shoud stop the output (by sending evAnaDevCmd).
@i       If the target has the state nAnaDevStopped (idle) the targetDevice is removed from the coordList.    

@@@END_Comment@@@ 

@BEG_Body 
@TL(13)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bAnalog THEN
   dummy := Print('ABCoordination: evReleaseSinglePump for Pump%d received',evReleaseSinglePumpData.iPump);
   dummy := Print('Pump release was requested by device: %d/%d',evReleaseSinglePumpData.DeviceIdSender.CompId, evReleaseSinglePumpData.DeviceIdSender.IndexId);
END_IF;

aReleaseSinglePump(iPump := evReleaseSinglePumpData.iPump,
                   DeviceIdSender := evReleaseSinglePumpData.DeviceIdSender);

@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 

@BEG_Body 
@TL(18)
(**************************************** WARNING ********************************************
 *** The KEBA Kemro K2 System including software is not intended for safety control tasks! ***
 ***                       For further information see Comment tab!                        ***
 *********************************************************************************************)

IF sv_TraceLevel.bAnalog THEN
   dummy := Print('ABCoordination: evInterruptActivePump for Pump%d received', evInterruptActivePumpData.iPump);
   dummy := Print('Pump stop was requested by device: %d/%d',evInterruptActivePumpData.DeviceIdSender.CompId, evInterruptActivePumpData.DeviceIdSender.IndexId);
END_IF;

aInterruptActivePump(iPump := evInterruptActivePumpData.iPump,
                     DeviceIdSender := evInterruptActivePumpData.DeviceIdSender,
                     pMoveData := evInterruptActivePumpData.pMoveData,
                     AnaOutputMode := evInterruptActivePumpData.AnaOutputMode,
                     prVelocity := evInterruptActivePumpData.prVelocity,
                     prPressure := evInterruptActivePumpData.prPressure);


@END_Body 

@@@BEG_Comment@@@ 
@TL(0)

@@@END_Comment@@@ 
@END_Body 

@END_Contents 
